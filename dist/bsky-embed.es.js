function Vy(t) {
  return Object.keys(t).reduce((r, n) => {
    const s = t[n];
    return r[n] = Object.assign({}, s), Zu(s.value) && !Ny(s.value) && !Array.isArray(s.value) && (r[n].value = Object.assign({}, s.value)), Array.isArray(s.value) && (r[n].value = s.value.slice(0)), r;
  }, {});
}
function Iy(t) {
  return t ? Object.keys(t).reduce((r, n) => {
    const s = t[n];
    return r[n] = Zu(s) && "value" in s ? s : {
      value: s
    }, r[n].attribute || (r[n].attribute = My(n)), r[n].parse = "parse" in r[n] ? r[n].parse : typeof r[n].value != "string", r;
  }, {}) : {};
}
function jy(t) {
  return Object.keys(t).reduce((r, n) => (r[n] = t[n].value, r), {});
}
function Oy(t, e) {
  const r = Vy(e);
  return Object.keys(e).forEach((s) => {
    const u = r[s], c = t.getAttribute(u.attribute), a = t[s];
    c && (u.value = u.parse ? Xu(c) : c), a != null && (u.value = Array.isArray(a) ? a.slice(0) : a), u.reflect && Nl(t, u.attribute, u.value, !!u.parse), Object.defineProperty(t, s, {
      get() {
        return u.value;
      },
      set(y) {
        const d = u.value;
        u.value = y, u.reflect && Nl(this, u.attribute, u.value, !!u.parse);
        for (let b = 0, g = this.__propertyChangedCallbacks.length; b < g; b++)
          this.__propertyChangedCallbacks[b](s, y, d);
      },
      enumerable: !0,
      configurable: !0
    });
  }), r;
}
function Xu(t) {
  if (t)
    try {
      return JSON.parse(t);
    } catch {
      return t;
    }
}
function Nl(t, e, r, n) {
  if (r == null || r === !1) return t.removeAttribute(e);
  let s = n ? JSON.stringify(r) : r;
  t.__updating[e] = !0, s === "true" && (s = ""), t.setAttribute(e, s), Promise.resolve().then(() => delete t.__updating[e]);
}
function My(t) {
  return t.replace(/\.?([A-Z]+)/g, (e, r) => "-" + r.toLowerCase()).replace("_", "-").replace(/^-/, "");
}
function Zu(t) {
  return t != null && (typeof t == "object" || typeof t == "function");
}
function Ny(t) {
  return Object.prototype.toString.call(t) === "[object Function]";
}
function $y(t) {
  return typeof t == "function" && t.toString().indexOf("class") === 0;
}
let ja;
function Gy(t, e) {
  const r = Object.keys(e);
  return class extends t {
    static get observedAttributes() {
      return r.map((s) => e[s].attribute);
    }
    constructor() {
      super(), this.__initialized = !1, this.__released = !1, this.__releaseCallbacks = [], this.__propertyChangedCallbacks = [], this.__updating = {}, this.props = {};
    }
    connectedCallback() {
      if (this.__initialized) return;
      this.__releaseCallbacks = [], this.__propertyChangedCallbacks = [], this.__updating = {}, this.props = Oy(this, e);
      const s = jy(this.props), u = this.Component, c = ja;
      try {
        ja = this, this.__initialized = !0, $y(u) ? new u(s, {
          element: this
        }) : u(s, {
          element: this
        });
      } finally {
        ja = c;
      }
    }
    async disconnectedCallback() {
      if (await Promise.resolve(), this.isConnected) return;
      this.__propertyChangedCallbacks.length = 0;
      let s = null;
      for (; s = this.__releaseCallbacks.pop(); ) s(this);
      delete this.__initialized, this.__released = !0;
    }
    attributeChangedCallback(s, u, c) {
      if (this.__initialized && !this.__updating[s] && (s = this.lookupProp(s), s in e)) {
        if (c == null && !this[s]) return;
        this[s] = e[s].parse ? Xu(c) : c;
      }
    }
    lookupProp(s) {
      if (e)
        return r.find((u) => s === u || s === e[u].attribute);
    }
    get renderRoot() {
      return this.shadowRoot || this.attachShadow({
        mode: "open"
      });
    }
    addReleaseCallback(s) {
      this.__releaseCallbacks.push(s);
    }
    addPropertyChangedCallback(s) {
      this.__propertyChangedCallbacks.push(s);
    }
  };
}
function qy(t, e = {}, r = {}) {
  const {
    BaseElement: n = HTMLElement,
    extension: s,
    customElements: u = window.customElements
  } = r;
  return (c) => {
    let a = u.get(t);
    return a ? (a.prototype.Component = c, a) : (a = Gy(n, Iy(e)), a.prototype.Component = c, a.prototype.registeredTag = t, u.define(t, a, s), a);
  };
}
const Fy = (t, e) => t === e, Qa = Symbol("solid-proxy"), Ho = {
  equals: Fy
};
let Hu = Yu;
const _r = 1, Wo = 2, Wu = {
  owned: null,
  cleanups: null,
  context: null,
  owner: null
};
var Ue = null;
let Oa = null, zy = null, de = null, Be = null, zt = null, da = 0;
function Xy(t, e) {
  const r = de, n = Ue, s = t.length === 0, u = e === void 0 ? n : e, c = s ? Wu : {
    owned: null,
    cleanups: null,
    context: u ? u.context : null,
    owner: u
  }, a = s ? t : () => t(() => fa(() => ya(c)));
  Ue = c, de = null;
  try {
    return yn(a, !0);
  } finally {
    de = r, Ue = n;
  }
}
function un(t, e) {
  e = e ? Object.assign({}, Ho, e) : Ho;
  const r = {
    value: t,
    observers: null,
    observerSlots: null,
    comparator: e.equals || void 0
  }, n = (s) => (typeof s == "function" && (s = s(r.value)), Qu(r, s));
  return [Ju.bind(r), n];
}
function ot(t, e, r) {
  const n = ol(t, e, !1, _r);
  fn(n);
}
function Zy(t, e, r) {
  Hu = Jy;
  const n = ol(t, e, !1, _r);
  n.user = !0, zt ? zt.push(n) : fn(n);
}
function Ir(t, e, r) {
  r = r ? Object.assign({}, Ho, r) : Ho;
  const n = ol(t, e, !0, 0);
  return n.observers = null, n.observerSlots = null, n.comparator = r.equals || void 0, fn(n), Ju.bind(n);
}
function fa(t) {
  if (de === null) return t();
  const e = de;
  de = null;
  try {
    return t();
  } finally {
    de = e;
  }
}
function Ju() {
  if (this.sources && this.state)
    if (this.state === _r) fn(this);
    else {
      const t = Be;
      Be = null, yn(() => Qo(this), !1), Be = t;
    }
  if (de) {
    const t = this.observers ? this.observers.length : 0;
    de.sources ? (de.sources.push(this), de.sourceSlots.push(t)) : (de.sources = [this], de.sourceSlots = [t]), this.observers ? (this.observers.push(de), this.observerSlots.push(de.sources.length - 1)) : (this.observers = [de], this.observerSlots = [de.sources.length - 1]);
  }
  return this.value;
}
function Qu(t, e, r) {
  let n = t.value;
  return (!t.comparator || !t.comparator(n, e)) && (t.value = e, t.observers && t.observers.length && yn(() => {
    for (let s = 0; s < t.observers.length; s += 1) {
      const u = t.observers[s], c = Oa && Oa.running;
      c && Oa.disposed.has(u), (c ? !u.tState : !u.state) && (u.pure ? Be.push(u) : zt.push(u), u.observers && ec(u)), c || (u.state = _r);
    }
    if (Be.length > 1e6)
      throw Be = [], new Error();
  }, !1)), e;
}
function fn(t) {
  if (!t.fn) return;
  ya(t);
  const e = da;
  Hy(t, t.value, e);
}
function Hy(t, e, r) {
  let n;
  const s = Ue, u = de;
  de = Ue = t;
  try {
    n = t.fn(e);
  } catch (c) {
    return t.pure && (t.state = _r, t.owned && t.owned.forEach(ya), t.owned = null), t.updatedAt = r + 1, tc(c);
  } finally {
    de = u, Ue = s;
  }
  (!t.updatedAt || t.updatedAt <= r) && (t.updatedAt != null && "observers" in t ? Qu(t, n) : t.value = n, t.updatedAt = r);
}
function ol(t, e, r, n = _r, s) {
  const u = {
    fn: t,
    state: n,
    updatedAt: null,
    owned: null,
    sources: null,
    sourceSlots: null,
    cleanups: null,
    value: e,
    owner: Ue,
    context: Ue ? Ue.context : null,
    pure: r
  };
  return Ue === null || Ue !== Wu && (Ue.owned ? Ue.owned.push(u) : Ue.owned = [u]), u;
}
function Jo(t) {
  if (t.state === 0) return;
  if (t.state === Wo) return Qo(t);
  if (t.suspense && fa(t.suspense.inFallback)) return t.suspense.effects.push(t);
  const e = [t];
  for (; (t = t.owner) && (!t.updatedAt || t.updatedAt < da); )
    t.state && e.push(t);
  for (let r = e.length - 1; r >= 0; r--)
    if (t = e[r], t.state === _r)
      fn(t);
    else if (t.state === Wo) {
      const n = Be;
      Be = null, yn(() => Qo(t, e[0]), !1), Be = n;
    }
}
function yn(t, e) {
  if (Be) return t();
  let r = !1;
  e || (Be = []), zt ? r = !0 : zt = [], da++;
  try {
    const n = t();
    return Wy(r), n;
  } catch (n) {
    r || (zt = null), Be = null, tc(n);
  }
}
function Wy(t) {
  if (Be && (Yu(Be), Be = null), t) return;
  const e = zt;
  zt = null, e.length && yn(() => Hu(e), !1);
}
function Yu(t) {
  for (let e = 0; e < t.length; e++) Jo(t[e]);
}
function Jy(t) {
  let e, r = 0;
  for (e = 0; e < t.length; e++) {
    const n = t[e];
    n.user ? t[r++] = n : Jo(n);
  }
  for (e = 0; e < r; e++) Jo(t[e]);
}
function Qo(t, e) {
  t.state = 0;
  for (let r = 0; r < t.sources.length; r += 1) {
    const n = t.sources[r];
    if (n.sources) {
      const s = n.state;
      s === _r ? n !== e && (!n.updatedAt || n.updatedAt < da) && Jo(n) : s === Wo && Qo(n, e);
    }
  }
}
function ec(t) {
  for (let e = 0; e < t.observers.length; e += 1) {
    const r = t.observers[e];
    r.state || (r.state = Wo, r.pure ? Be.push(r) : zt.push(r), r.observers && ec(r));
  }
}
function ya(t) {
  let e;
  if (t.sources)
    for (; t.sources.length; ) {
      const r = t.sources.pop(), n = t.sourceSlots.pop(), s = r.observers;
      if (s && s.length) {
        const u = s.pop(), c = r.observerSlots.pop();
        n < s.length && (u.sourceSlots[c] = n, s[n] = u, r.observerSlots[n] = c);
      }
    }
  if (t.owned) {
    for (e = t.owned.length - 1; e >= 0; e--) ya(t.owned[e]);
    t.owned = null;
  }
  if (t.cleanups) {
    for (e = t.cleanups.length - 1; e >= 0; e--) t.cleanups[e]();
    t.cleanups = null;
  }
  t.state = 0;
}
function Qy(t) {
  return t instanceof Error ? t : new Error(typeof t == "string" ? t : "Unknown error", {
    cause: t
  });
}
function tc(t, e = Ue) {
  throw Qy(t);
}
function rc(t, e) {
  return fa(() => t(e || {}));
}
function Oo() {
  return !0;
}
const Yy = {
  get(t, e, r) {
    return e === Qa ? r : t.get(e);
  },
  has(t, e) {
    return e === Qa ? !0 : t.has(e);
  },
  set: Oo,
  deleteProperty: Oo,
  getOwnPropertyDescriptor(t, e) {
    return {
      configurable: !0,
      enumerable: !0,
      get() {
        return t.get(e);
      },
      set: Oo,
      deleteProperty: Oo
    };
  },
  ownKeys(t) {
    return t.keys();
  }
};
function Ma(t) {
  return (t = typeof t == "function" ? t() : t) ? t : {};
}
function em() {
  for (let t = 0, e = this.length; t < e; ++t) {
    const r = this[t]();
    if (r !== void 0) return r;
  }
}
function tm(...t) {
  let e = !1;
  for (let c = 0; c < t.length; c++) {
    const a = t[c];
    e = e || !!a && Qa in a, t[c] = typeof a == "function" ? (e = !0, Ir(a)) : a;
  }
  if (e)
    return new Proxy({
      get(c) {
        for (let a = t.length - 1; a >= 0; a--) {
          const y = Ma(t[a])[c];
          if (y !== void 0) return y;
        }
      },
      has(c) {
        for (let a = t.length - 1; a >= 0; a--)
          if (c in Ma(t[a])) return !0;
        return !1;
      },
      keys() {
        const c = [];
        for (let a = 0; a < t.length; a++) c.push(...Object.keys(Ma(t[a])));
        return [...new Set(c)];
      }
    }, Yy);
  const r = {}, n = /* @__PURE__ */ Object.create(null);
  for (let c = t.length - 1; c >= 0; c--) {
    const a = t[c];
    if (!a) continue;
    const y = Object.getOwnPropertyNames(a);
    for (let d = y.length - 1; d >= 0; d--) {
      const b = y[d];
      if (b === "__proto__" || b === "constructor") continue;
      const g = Object.getOwnPropertyDescriptor(a, b);
      if (!n[b])
        n[b] = g.get ? {
          enumerable: !0,
          configurable: !0,
          get: em.bind(r[b] = [g.get.bind(a)])
        } : g.value !== void 0 ? g : void 0;
      else {
        const R = r[b];
        R && (g.get ? R.push(g.get.bind(a)) : g.value !== void 0 && R.push(() => g.value));
      }
    }
  }
  const s = {}, u = Object.keys(n);
  for (let c = u.length - 1; c >= 0; c--) {
    const a = u[c], y = n[a];
    y && y.get ? Object.defineProperty(s, a, y) : s[a] = y ? y.value : void 0;
  }
  return s;
}
function rm(t, e, r) {
  let n = r.length, s = e.length, u = n, c = 0, a = 0, y = e[s - 1].nextSibling, d = null;
  for (; c < s || a < u; ) {
    if (e[c] === r[a]) {
      c++, a++;
      continue;
    }
    for (; e[s - 1] === r[u - 1]; )
      s--, u--;
    if (s === c) {
      const b = u < n ? a ? r[a - 1].nextSibling : r[u - a] : y;
      for (; a < u; ) t.insertBefore(r[a++], b);
    } else if (u === a)
      for (; c < s; )
        (!d || !d.has(e[c])) && e[c].remove(), c++;
    else if (e[c] === r[u - 1] && r[a] === e[s - 1]) {
      const b = e[--s].nextSibling;
      t.insertBefore(r[a++], e[c++].nextSibling), t.insertBefore(r[--u], b), e[s] = r[u];
    } else {
      if (!d) {
        d = /* @__PURE__ */ new Map();
        let g = a;
        for (; g < u; ) d.set(r[g], g++);
      }
      const b = d.get(e[c]);
      if (b != null)
        if (a < b && b < u) {
          let g = c, R = 1, C;
          for (; ++g < s && g < u && !((C = d.get(e[g])) == null || C !== b + R); )
            R++;
          if (R > b - a) {
            const D = e[c];
            for (; a < b; ) t.insertBefore(r[a++], D);
          } else t.replaceChild(r[a++], e[c++]);
        } else c++;
      else e[c++].remove();
    }
  }
}
const $l = "_$DX_DELEGATE";
function Ge(t, e, r) {
  let n;
  const s = () => {
    const c = document.createElement("template");
    return c.innerHTML = t, c.content.firstChild;
  }, u = () => (n || (n = s())).cloneNode(!0);
  return u.cloneNode = u, u;
}
function ic(t, e = window.document) {
  const r = e[$l] || (e[$l] = /* @__PURE__ */ new Set());
  for (let n = 0, s = t.length; n < s; n++) {
    const u = t[n];
    r.has(u) || (r.add(u), e.addEventListener(u, im));
  }
}
function Ae(t, e, r) {
  r == null ? t.removeAttribute(e) : t.setAttribute(e, r);
}
function nc(t, e) {
  e == null ? t.removeAttribute("class") : t.className = e;
}
function Gl(t, e, r) {
  return fa(() => t(e, r));
}
function ie(t, e, r, n) {
  if (r !== void 0 && !n && (n = []), typeof e != "function") return Yo(t, e, n, r);
  ot((s) => Yo(t, e(), s, r), n);
}
function im(t) {
  const e = `$$${t.type}`;
  let r = t.composedPath && t.composedPath()[0] || t.target;
  for (t.target !== r && Object.defineProperty(t, "target", {
    configurable: !0,
    value: r
  }), Object.defineProperty(t, "currentTarget", {
    configurable: !0,
    get() {
      return r || document;
    }
  }); r; ) {
    const n = r[e];
    if (n && !r.disabled) {
      const s = r[`${e}Data`];
      if (s !== void 0 ? n.call(r, s, t) : n.call(r, t), t.cancelBubble) return;
    }
    r = r._$host || r.parentNode || r.host;
  }
}
function Yo(t, e, r, n, s) {
  for (; typeof r == "function"; ) r = r();
  if (e === r) return r;
  const u = typeof e, c = n !== void 0;
  if (t = c && r[0] && r[0].parentNode || t, u === "string" || u === "number") {
    if (u === "number" && (e = e.toString(), e === r))
      return r;
    if (c) {
      let a = r[0];
      a && a.nodeType === 3 ? a.data !== e && (a.data = e) : a = document.createTextNode(e), r = di(t, r, n, a);
    } else
      r !== "" && typeof r == "string" ? r = t.firstChild.data = e : r = t.textContent = e;
  } else if (e == null || u === "boolean")
    r = di(t, r, n);
  else {
    if (u === "function")
      return ot(() => {
        let a = e();
        for (; typeof a == "function"; ) a = a();
        r = Yo(t, a, r, n);
      }), () => r;
    if (Array.isArray(e)) {
      const a = [], y = r && Array.isArray(r);
      if (Ya(a, e, r, s))
        return ot(() => r = Yo(t, a, r, n, !0)), () => r;
      if (a.length === 0) {
        if (r = di(t, r, n), c) return r;
      } else y ? r.length === 0 ? ql(t, a, n) : rm(t, r, a) : (r && di(t), ql(t, a));
      r = a;
    } else if (e.nodeType) {
      if (Array.isArray(r)) {
        if (c) return r = di(t, r, n, e);
        di(t, r, null, e);
      } else r == null || r === "" || !t.firstChild ? t.appendChild(e) : t.replaceChild(e, t.firstChild);
      r = e;
    }
  }
  return r;
}
function Ya(t, e, r, n) {
  let s = !1;
  for (let u = 0, c = e.length; u < c; u++) {
    let a = e[u], y = r && r[t.length], d;
    if (!(a == null || a === !0 || a === !1)) if ((d = typeof a) == "object" && a.nodeType)
      t.push(a);
    else if (Array.isArray(a))
      s = Ya(t, a, y) || s;
    else if (d === "function")
      if (n) {
        for (; typeof a == "function"; ) a = a();
        s = Ya(t, Array.isArray(a) ? a : [a], Array.isArray(y) ? y : [y]) || s;
      } else
        t.push(a), s = !0;
    else {
      const b = String(a);
      y && y.nodeType === 3 && y.data === b ? t.push(y) : t.push(document.createTextNode(b));
    }
  }
  return s;
}
function ql(t, e, r = null) {
  for (let n = 0, s = e.length; n < s; n++) t.insertBefore(e[n], r);
}
function di(t, e, r, n) {
  if (r === void 0) return t.textContent = "";
  const s = n || document.createTextNode("");
  if (e.length) {
    let u = !1;
    for (let c = e.length - 1; c >= 0; c--) {
      const a = e[c];
      if (s !== a) {
        const y = a.parentNode === t;
        !u && !c ? y ? t.replaceChild(s, a) : t.insertBefore(s, r) : y && a.remove();
      } else u = !0;
    }
  } else t.insertBefore(s, r);
  return [s];
}
function nm(t) {
  const e = Object.keys(t), r = {};
  for (let n = 0; n < e.length; n++) {
    const [s, u] = un(t[e[n]]);
    Object.defineProperty(r, e[n], {
      get: s,
      set(c) {
        u(() => c);
      }
    });
  }
  return r;
}
function sm(t) {
  if (t.assignedSlot && t.assignedSlot._$owner) return t.assignedSlot._$owner;
  let e = t.parentNode;
  for (; e && !e._$owner && !(e.assignedSlot && e.assignedSlot._$owner); )
    e = e.parentNode;
  return e && e.assignedSlot ? e.assignedSlot._$owner : t._$owner;
}
function om(t) {
  return (e, r) => {
    const { element: n } = r;
    return Xy((s) => {
      const u = nm(e);
      n.addPropertyChangedCallback((a, y) => u[a] = y), n.addReleaseCallback(() => {
        n.renderRoot.textContent = "", s();
      });
      const c = t(u, r);
      return ie(n.renderRoot, c);
    }, sm(n));
  };
}
function am(t, e, r) {
  return arguments.length === 2 && (r = e, e = {}), qy(t, e)(om(r));
}
const lm = '*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}:before,:after{--tw-content: ""}html,:host{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}.fixed{position:fixed}.right-5{right:1.25rem}.top-5{top:1.25rem}.col-span-2{grid-column:span 2 / span 2}.mx-1{margin-left:.25rem;margin-right:.25rem}.mx-auto{margin-left:auto;margin-right:auto}.mb-1{margin-bottom:.25rem}.mb-16{margin-bottom:4rem}.ml-10{margin-left:2.5rem}.mr-1{margin-right:.25rem}.mt-4{margin-top:1rem}.mt-8{margin-top:2rem}.block{display:block}.inline{display:inline}.flex{display:flex}.grid{display:grid}.h-10{height:2.5rem}.h-14{height:3.5rem}.h-2{height:.5rem}.h-4{height:1rem}.max-h-\\[90vh\\]{max-height:90vh}.w-10{width:2.5rem}.w-14{width:3.5rem}.w-4{width:1rem}.w-full{width:100%}.max-w-\\[calc\\(100vw-96px\\)\\]{max-width:calc(100vw - 96px)}.max-w-screen-sm{max-width:640px}.flex-1{flex:1 1 0%}@keyframes pulse{50%{opacity:.5}}.animate-pulse{animation:pulse 2s cubic-bezier(.4,0,.6,1) infinite}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.grid-cols-4{grid-template-columns:repeat(4,minmax(0,1fr))}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-center{justify-content:center}.gap-1{gap:.25rem}.gap-2{gap:.5rem}.gap-4{gap:1rem}.space-y-2>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.5rem * var(--tw-space-y-reverse))}.overflow-hidden{overflow:hidden}.text-ellipsis{text-overflow:ellipsis}.whitespace-nowrap{white-space:nowrap}.whitespace-pre-wrap{white-space:pre-wrap}.rounded{border-radius:.25rem}.rounded-full{border-radius:9999px}.rounded-md{border-radius:.375rem}.rounded-t-md{border-top-left-radius:.375rem;border-top-right-radius:.375rem}.border{border-width:1px}.border-b{border-bottom-width:1px}.border-slate-300{--tw-border-opacity: 1;border-color:rgb(203 213 225 / var(--tw-border-opacity))}.bg-blue-500{--tw-bg-opacity: 1;background-color:rgb(59 130 246 / var(--tw-bg-opacity))}.bg-gray-900{--tw-bg-opacity: 1;background-color:rgb(17 24 39 / var(--tw-bg-opacity))}.bg-slate-100{--tw-bg-opacity: 1;background-color:rgb(241 245 249 / var(--tw-bg-opacity))}.bg-slate-200{--tw-bg-opacity: 1;background-color:rgb(226 232 240 / var(--tw-bg-opacity))}.bg-slate-900{--tw-bg-opacity: 1;background-color:rgb(15 23 42 / var(--tw-bg-opacity))}.p-3{padding:.75rem}.p-4{padding:1rem}.px-4{padding-left:1rem;padding-right:1rem}.py-1{padding-top:.25rem;padding-bottom:.25rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.text-sm{font-size:.875rem;line-height:1.25rem}.font-bold{font-weight:700}.font-semibold{font-weight:600}.text-blue-500{--tw-text-opacity: 1;color:rgb(59 130 246 / var(--tw-text-opacity))}.text-slate-500{--tw-text-opacity: 1;color:rgb(100 116 139 / var(--tw-text-opacity))}.text-slate-600{--tw-text-opacity: 1;color:rgb(71 85 105 / var(--tw-text-opacity))}.text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}.underline{text-decoration-line:underline}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.backdrop\\:bg-gray-800::backdrop{--tw-bg-opacity: 1;background-color:rgb(31 41 55 / var(--tw-bg-opacity))}.backdrop\\:opacity-90::backdrop{opacity:.9}.hover\\:bg-blue-700:hover{--tw-bg-opacity: 1;background-color:rgb(29 78 216 / var(--tw-bg-opacity))}.hover\\:underline:hover{text-decoration-line:underline}.dark\\:border-slate-800:where(.dark,.dark *){--tw-border-opacity: 1;border-color:rgb(30 41 59 / var(--tw-border-opacity))}.dark\\:bg-slate-800:where(.dark,.dark *){--tw-bg-opacity: 1;background-color:rgb(30 41 59 / var(--tw-bg-opacity))}.dark\\:text-slate-400:where(.dark,.dark *){--tw-text-opacity: 1;color:rgb(148 163 184 / var(--tw-text-opacity))}.dark\\:text-white:where(.dark,.dark *){--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}';
var S = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function sc(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    r.prototype = e.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(t).forEach(function(n) {
    var s = Object.getOwnPropertyDescriptor(t, n);
    Object.defineProperty(r, n, s.get ? s : {
      enumerable: !0,
      get: function() {
        return t[n];
      }
    });
  }), r;
}
var al = {}, oi = {}, ll = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.DisallowedDomainError = t.UnsupportedDomainError = t.ReservedHandleError = t.InvalidHandleError = t.isValidTld = t.isValidHandle = t.normalizeAndEnsureValidHandle = t.normalizeHandle = t.ensureValidHandleRegex = t.ensureValidHandle = t.DISALLOWED_TLDS = t.INVALID_HANDLE = void 0, t.INVALID_HANDLE = "handle.invalid", t.DISALLOWED_TLDS = [
    ".local",
    ".arpa",
    ".invalid",
    ".localhost",
    ".internal",
    ".example",
    ".alt",
    // policy could concievably change on ".onion" some day
    ".onion"
    // NOTE: .test is allowed in testing and devopment. In practical terms
    // "should" "never" actually resolve and get registered in production
  ];
  const e = (g) => {
    if (!/^[a-zA-Z0-9.-]*$/.test(g))
      throw new a("Disallowed characters in handle (ASCII letters, digits, dashes, periods only)");
    if (g.length > 253)
      throw new a("Handle is too long (253 chars max)");
    const R = g.split(".");
    if (R.length < 2)
      throw new a("Handle domain needs at least two parts");
    for (let C = 0; C < R.length; C++) {
      const D = R[C];
      if (D.length < 1)
        throw new a("Handle parts can not be empty");
      if (D.length > 63)
        throw new a("Handle part too long (max 63 chars)");
      if (D.endsWith("-") || D.startsWith("-"))
        throw new a("Handle parts can not start or end with hyphens");
      if (C + 1 == R.length && !/^[a-zA-Z]/.test(D))
        throw new a("Handle final component (TLD) must start with ASCII letter");
    }
  };
  t.ensureValidHandle = e;
  const r = (g) => {
    if (!/^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$/.test(g))
      throw new a("Handle didn't validate via regex");
    if (g.length > 253)
      throw new a("Handle is too long (253 chars max)");
  };
  t.ensureValidHandleRegex = r;
  const n = (g) => g.toLowerCase();
  t.normalizeHandle = n;
  const s = (g) => {
    const R = (0, t.normalizeHandle)(g);
    return (0, t.ensureValidHandle)(R), R;
  };
  t.normalizeAndEnsureValidHandle = s;
  const u = (g) => {
    try {
      (0, t.ensureValidHandle)(g);
    } catch (R) {
      if (R instanceof a)
        return !1;
      throw R;
    }
    return !0;
  };
  t.isValidHandle = u;
  const c = (g) => !t.DISALLOWED_TLDS.some((R) => g.endsWith(R));
  t.isValidTld = c;
  class a extends Error {
  }
  t.InvalidHandleError = a;
  class y extends Error {
  }
  t.ReservedHandleError = y;
  class d extends Error {
  }
  t.UnsupportedDomainError = d;
  class b extends Error {
  }
  t.DisallowedDomainError = b;
})(ll);
var Xt = {};
Object.defineProperty(Xt, "__esModule", { value: !0 });
Xt.InvalidDidError = Xt.ensureValidDidRegex = Xt.ensureValidDid = void 0;
const um = (t) => {
  if (!/^[a-zA-Z0-9._:%-]*$/.test(t))
    throw new Gt("Disallowed characters in DID (ASCII letters, digits, and a couple other characters only)");
  const e = t.split(":");
  if (e.length < 3)
    throw new Gt("DID requires prefix, method, and method-specific content");
  if (e[0] != "did")
    throw new Gt('DID requires "did:" prefix');
  if (!/^[a-z]+$/.test(e[1]))
    throw new Gt("DID method must be lower-case letters");
  if (t.endsWith(":") || t.endsWith("%"))
    throw new Gt('DID can not end with ":" or "%"');
  if (t.length > 2 * 1024)
    throw new Gt("DID is too long (2048 chars max)");
};
Xt.ensureValidDid = um;
const cm = (t) => {
  if (!/^did:[a-z]+:[a-zA-Z0-9._:%-]*[a-zA-Z0-9._-]$/.test(t))
    throw new Gt("DID didn't validate via regex");
  if (t.length > 2 * 1024)
    throw new Gt("DID is too long (2048 chars max)");
};
Xt.ensureValidDidRegex = cm;
class Gt extends Error {
}
Xt.InvalidDidError = Gt;
var ul = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.InvalidNsidError = t.ensureValidNsidRegex = t.ensureValidNsid = t.NSID = void 0;
  class e {
    static parse(c) {
      return new e(c);
    }
    static create(c, a) {
      const y = [...c.split(".").reverse(), a].join(".");
      return new e(y);
    }
    static isValid(c) {
      try {
        return e.parse(c), !0;
      } catch {
        return !1;
      }
    }
    constructor(c) {
      Object.defineProperty(this, "segments", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: []
      }), (0, t.ensureValidNsid)(c), this.segments = c.split(".");
    }
    get authority() {
      return this.segments.slice(0, this.segments.length - 1).reverse().join(".");
    }
    get name() {
      return this.segments.at(this.segments.length - 1);
    }
    toString() {
      return this.segments.join(".");
    }
  }
  t.NSID = e;
  const r = (u) => {
    const c = u;
    if (!/^[a-zA-Z0-9.-]*$/.test(c))
      throw new s("Disallowed characters in NSID (ASCII letters, digits, dashes, periods only)");
    if (c.length > 317)
      throw new s("NSID is too long (317 chars max)");
    const a = c.split(".");
    if (a.length < 3)
      throw new s("NSID needs at least three parts");
    for (let y = 0; y < a.length; y++) {
      const d = a[y];
      if (d.length < 1)
        throw new s("NSID parts can not be empty");
      if (d.length > 63)
        throw new s("NSID part too long (max 63 chars)");
      if (d.endsWith("-") || d.startsWith("-"))
        throw new s("NSID parts can not start or end with hyphen");
      if (/^[0-9]/.test(d) && y == 0)
        throw new s("NSID first part may not start with a digit");
      if (!/^[a-zA-Z]+$/.test(d) && y + 1 == a.length)
        throw new s("NSID name part must be only letters");
    }
  };
  t.ensureValidNsid = r;
  const n = (u) => {
    if (!/^[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(\.[a-zA-Z]([a-zA-Z]{0,61}[a-zA-Z])?)$/.test(u))
      throw new s("NSID didn't validate via regex");
    if (u.length > 317)
      throw new s("NSID is too long (317 chars max)");
  };
  t.ensureValidNsidRegex = n;
  class s extends Error {
  }
  t.InvalidNsidError = s;
})(ul);
var oc = {}, hi = {};
Object.defineProperty(hi, "__esModule", { value: !0 });
hi.ensureValidAtUriRegex = hi.ensureValidAtUri = void 0;
const ac = ll, lc = Xt, uc = ul, pm = (t) => {
  const e = t.split("#");
  if (e.length > 2)
    throw new Error('ATURI can have at most one "#", separating fragment out');
  const r = e[1] || null;
  if (t = e[0], !/^[a-zA-Z0-9._~:@!$&')(*+,;=%/-]*$/.test(t))
    throw new Error("Disallowed characters in ATURI (ASCII)");
  const n = t.split("/");
  if (n.length >= 3 && (n[0] != "at:" || n[1].length != 0))
    throw new Error('ATURI must start with "at://"');
  if (n.length < 3)
    throw new Error("ATURI requires at least method and authority sections");
  try {
    n[2].startsWith("did:") ? (0, lc.ensureValidDid)(n[2]) : (0, ac.ensureValidHandle)(n[2]);
  } catch {
    throw new Error("ATURI authority must be a valid handle or DID");
  }
  if (n.length >= 4) {
    if (n[3].length == 0)
      throw new Error("ATURI can not have a slash after authority without a path segment");
    try {
      (0, uc.ensureValidNsid)(n[3]);
    } catch {
      throw new Error("ATURI requires first path segment (if supplied) to be valid NSID");
    }
  }
  if (n.length >= 5 && n[4].length == 0)
    throw new Error("ATURI can not have a slash after collection, unless record key is provided");
  if (n.length >= 6)
    throw new Error("ATURI path can have at most two parts, and no trailing slash");
  if (e.length >= 2 && r == null)
    throw new Error("ATURI fragment must be non-empty and start with slash");
  if (r != null) {
    if (r.length == 0 || r[0] != "/")
      throw new Error("ATURI fragment must be non-empty and start with slash");
    if (!/^\/[a-zA-Z0-9._~:@!$&')(*+,;=%[\]/-]*$/.test(r))
      throw new Error("Disallowed characters in ATURI fragment (ASCII)");
  }
  if (t.length > 8 * 1024)
    throw new Error("ATURI is far too long");
};
hi.ensureValidAtUri = pm;
const dm = (t) => {
  const e = /^at:\/\/(?<authority>[a-zA-Z0-9._:%-]+)(\/(?<collection>[a-zA-Z0-9-.]+)(\/(?<rkey>[a-zA-Z0-9._~:@!$&%')(*+,;=-]+))?)?(#(?<fragment>\/[a-zA-Z0-9._~:@!$&%')(*+,;=\-[\]/\\]*))?$/, r = t.match(e);
  if (!r || !r.groups)
    throw new Error("ATURI didn't validate via regex");
  const n = r.groups;
  try {
    (0, ac.ensureValidHandleRegex)(n.authority);
  } catch {
    try {
      (0, lc.ensureValidDidRegex)(n.authority);
    } catch {
      throw new Error("ATURI authority must be a valid handle or DID");
    }
  }
  if (n.collection)
    try {
      (0, uc.ensureValidNsidRegex)(n.collection);
    } catch {
      throw new Error("ATURI collection path segment must be a valid NSID");
    }
  if (t.length > 8 * 1024)
    throw new Error("ATURI is far too long");
};
hi.ensureValidAtUriRegex = dm;
(function(t) {
  var e = S && S.__createBinding || (Object.create ? function(a, y, d, b) {
    b === void 0 && (b = d);
    var g = Object.getOwnPropertyDescriptor(y, d);
    (!g || ("get" in g ? !y.__esModule : g.writable || g.configurable)) && (g = { enumerable: !0, get: function() {
      return y[d];
    } }), Object.defineProperty(a, b, g);
  } : function(a, y, d, b) {
    b === void 0 && (b = d), a[b] = y[d];
  }), r = S && S.__exportStar || function(a, y) {
    for (var d in a) d !== "default" && !Object.prototype.hasOwnProperty.call(y, d) && e(y, a, d);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.AtUri = t.ATP_URI_REGEX = void 0, r(hi, t), t.ATP_URI_REGEX = // proto-    --did--------------   --name----------------   --path----   --query--   --hash--
  /^(at:\/\/)?((?:did:[a-z0-9:%-]+)|(?:[a-z0-9][a-z0-9.:-]*))(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
  const n = /^(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
  class s {
    constructor(y, d) {
      Object.defineProperty(this, "hash", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "host", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "pathname", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "searchParams", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      });
      let b;
      if (d) {
        if (b = u(d), !b)
          throw new Error(`Invalid at uri: ${d}`);
        const g = c(y);
        if (!g)
          throw new Error(`Invalid path: ${y}`);
        Object.assign(b, g);
      } else if (b = u(y), !b)
        throw new Error(`Invalid at uri: ${y}`);
      this.hash = b.hash, this.host = b.host, this.pathname = b.pathname, this.searchParams = b.searchParams;
    }
    static make(y, d, b) {
      let g = y;
      return d && (g += "/" + d), b && (g += "/" + b), new s(g);
    }
    get protocol() {
      return "at:";
    }
    get origin() {
      return `at://${this.host}`;
    }
    get hostname() {
      return this.host;
    }
    set hostname(y) {
      this.host = y;
    }
    get search() {
      return this.searchParams.toString();
    }
    set search(y) {
      this.searchParams = new URLSearchParams(y);
    }
    get collection() {
      return this.pathname.split("/").filter(Boolean)[0] || "";
    }
    set collection(y) {
      const d = this.pathname.split("/").filter(Boolean);
      d[0] = y, this.pathname = d.join("/");
    }
    get rkey() {
      return this.pathname.split("/").filter(Boolean)[1] || "";
    }
    set rkey(y) {
      const d = this.pathname.split("/").filter(Boolean);
      d[0] || (d[0] = "undefined"), d[1] = y, this.pathname = d.join("/");
    }
    get href() {
      return this.toString();
    }
    toString() {
      let y = this.pathname || "/";
      y.startsWith("/") || (y = `/${y}`);
      let d = this.searchParams.toString();
      d && !d.startsWith("?") && (d = `?${d}`);
      let b = this.hash;
      return b && !b.startsWith("#") && (b = `#${b}`), `at://${this.host}${y}${d}${b}`;
    }
  }
  t.AtUri = s;
  function u(a) {
    const y = t.ATP_URI_REGEX.exec(a);
    if (y)
      return {
        hash: y[5] || "",
        host: y[2] || "",
        pathname: y[3] || "",
        searchParams: new URLSearchParams(y[4] || "")
      };
  }
  function c(a) {
    const y = n.exec(a);
    if (y)
      return {
        hash: y[3] || "",
        pathname: y[1] || "",
        searchParams: new URLSearchParams(y[2] || "")
      };
  }
})(oc);
var cc = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.InvalidTidError = t.isValidTid = t.ensureValidTid = void 0;
  const e = (s) => {
    if (s.length != 13)
      throw new n("TID must be 13 characters");
    if (!/^[234567abcdefghij][234567abcdefghijklmnopqrstuvwxyz]{12}$/.test(s))
      throw new n("TID syntax not valid (regex)");
  };
  t.ensureValidTid = e;
  const r = (s) => {
    try {
      (0, t.ensureValidTid)(s);
    } catch (u) {
      if (u instanceof n)
        return !1;
      throw u;
    }
    return !0;
  };
  t.isValidTid = r;
  class n extends Error {
  }
  t.InvalidTidError = n;
})(cc);
var pc = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.InvalidRecordKeyError = t.isValidRecordKey = t.ensureValidRecordKey = void 0;
  const e = (s) => {
    if (s.length > 512 || s.length < 1)
      throw new n("record key must be 1 to 512 characters");
    if (!/^[a-zA-Z0-9_~.:-]{1,512}$/.test(s))
      throw new n("record key syntax not valid (regex)");
    if (s == "." || s == "..")
      throw new n('record key can not be "." or ".."');
  };
  t.ensureValidRecordKey = e;
  const r = (s) => {
    try {
      (0, t.ensureValidRecordKey)(s);
    } catch (u) {
      if (u instanceof n)
        return !1;
      throw u;
    }
    return !0;
  };
  t.isValidRecordKey = r;
  class n extends Error {
  }
  t.InvalidRecordKeyError = n;
})(pc);
var dc = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.InvalidDatetimeError = t.normalizeDatetimeAlways = t.normalizeDatetime = t.isValidDatetime = t.ensureValidDatetime = void 0;
  const e = (c) => {
    const a = new Date(c);
    if (isNaN(a.getTime()))
      throw new u("datetime did not parse as ISO 8601");
    if (a.toISOString().startsWith("-"))
      throw new u("datetime normalized to a negative time");
    if (!/^[0-9]{4}-[01][0-9]-[0-3][0-9]T[0-2][0-9]:[0-6][0-9]:[0-6][0-9](.[0-9]{1,20})?(Z|([+-][0-2][0-9]:[0-5][0-9]))$/.test(c))
      throw new u("datetime didn't validate via regex");
    if (c.length > 64)
      throw new u("datetime is too long (64 chars max)");
    if (c.endsWith("-00:00"))
      throw new u('datetime can not use "-00:00" for UTC timezone');
    if (c.startsWith("000"))
      throw new u("datetime so close to year zero not allowed");
  };
  t.ensureValidDatetime = e;
  const r = (c) => {
    try {
      (0, t.ensureValidDatetime)(c);
    } catch (a) {
      if (a instanceof u)
        return !1;
      throw a;
    }
    return !0;
  };
  t.isValidDatetime = r;
  const n = (c) => {
    if ((0, t.isValidDatetime)(c)) {
      const d = new Date(c).toISOString();
      if ((0, t.isValidDatetime)(d))
        return d;
    }
    if (!/.*(([+-]\d\d:?\d\d)|[a-zA-Z])$/.test(c)) {
      const d = /* @__PURE__ */ new Date(c + "Z");
      if (!isNaN(d.getTime())) {
        const b = d.toISOString();
        if ((0, t.isValidDatetime)(b))
          return b;
      }
    }
    const a = new Date(c);
    if (isNaN(a.getTime()))
      throw new u("datetime did not parse as any timestamp format");
    const y = a.toISOString();
    if ((0, t.isValidDatetime)(y))
      return y;
    throw new u("datetime normalized to invalid timestamp string");
  };
  t.normalizeDatetime = n;
  const s = (c) => {
    try {
      return (0, t.normalizeDatetime)(c);
    } catch (a) {
      if (a instanceof u)
        return (/* @__PURE__ */ new Date(0)).toISOString();
      throw a;
    }
  };
  t.normalizeDatetimeAlways = s;
  class u extends Error {
  }
  t.InvalidDatetimeError = u;
})(dc);
(function(t) {
  var e = S && S.__createBinding || (Object.create ? function(n, s, u, c) {
    c === void 0 && (c = u);
    var a = Object.getOwnPropertyDescriptor(s, u);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
      return s[u];
    } }), Object.defineProperty(n, c, a);
  } : function(n, s, u, c) {
    c === void 0 && (c = u), n[c] = s[u];
  }), r = S && S.__exportStar || function(n, s) {
    for (var u in n) u !== "default" && !Object.prototype.hasOwnProperty.call(s, u) && e(s, n, u);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), r(ll, t), r(Xt, t), r(ul, t), r(oc, t), r(cc, t), r(pc, t), r(dc, t);
})(oi);
var mn = {}, Tr = {}, ai = {}, el = {}, Tt = {}, ma = {}, bn = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.getParsedType = t.ZodParsedType = t.objectUtil = t.util = void 0;
  var e;
  (function(n) {
    n.assertEqual = (a) => a;
    function s(a) {
    }
    n.assertIs = s;
    function u(a) {
      throw new Error();
    }
    n.assertNever = u, n.arrayToEnum = (a) => {
      const y = {};
      for (const d of a)
        y[d] = d;
      return y;
    }, n.getValidEnumValues = (a) => {
      const y = n.objectKeys(a).filter((b) => typeof a[a[b]] != "number"), d = {};
      for (const b of y)
        d[b] = a[b];
      return n.objectValues(d);
    }, n.objectValues = (a) => n.objectKeys(a).map(function(y) {
      return a[y];
    }), n.objectKeys = typeof Object.keys == "function" ? (a) => Object.keys(a) : (a) => {
      const y = [];
      for (const d in a)
        Object.prototype.hasOwnProperty.call(a, d) && y.push(d);
      return y;
    }, n.find = (a, y) => {
      for (const d of a)
        if (y(d))
          return d;
    }, n.isInteger = typeof Number.isInteger == "function" ? (a) => Number.isInteger(a) : (a) => typeof a == "number" && isFinite(a) && Math.floor(a) === a;
    function c(a, y = " | ") {
      return a.map((d) => typeof d == "string" ? `'${d}'` : d).join(y);
    }
    n.joinValues = c, n.jsonStringifyReplacer = (a, y) => typeof y == "bigint" ? y.toString() : y;
  })(e = t.util || (t.util = {})), function(n) {
    n.mergeShapes = (s, u) => ({
      ...s,
      ...u
      // second overwrites first
    });
  }(t.objectUtil || (t.objectUtil = {})), t.ZodParsedType = e.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  const r = (n) => {
    switch (typeof n) {
      case "undefined":
        return t.ZodParsedType.undefined;
      case "string":
        return t.ZodParsedType.string;
      case "number":
        return isNaN(n) ? t.ZodParsedType.nan : t.ZodParsedType.number;
      case "boolean":
        return t.ZodParsedType.boolean;
      case "function":
        return t.ZodParsedType.function;
      case "bigint":
        return t.ZodParsedType.bigint;
      case "symbol":
        return t.ZodParsedType.symbol;
      case "object":
        return Array.isArray(n) ? t.ZodParsedType.array : n === null ? t.ZodParsedType.null : n.then && typeof n.then == "function" && n.catch && typeof n.catch == "function" ? t.ZodParsedType.promise : typeof Map < "u" && n instanceof Map ? t.ZodParsedType.map : typeof Set < "u" && n instanceof Set ? t.ZodParsedType.set : typeof Date < "u" && n instanceof Date ? t.ZodParsedType.date : t.ZodParsedType.object;
      default:
        return t.ZodParsedType.unknown;
    }
  };
  t.getParsedType = r;
})(bn);
var St = {};
Object.defineProperty(St, "__esModule", { value: !0 });
St.ZodError = St.quotelessJson = St.ZodIssueCode = void 0;
const fc = bn;
St.ZodIssueCode = fc.util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const fm = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
St.quotelessJson = fm;
class pn extends Error {
  constructor(e) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = e;
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    const r = e || function(u) {
      return u.message;
    }, n = { _errors: [] }, s = (u) => {
      for (const c of u.issues)
        if (c.code === "invalid_union")
          c.unionErrors.map(s);
        else if (c.code === "invalid_return_type")
          s(c.returnTypeError);
        else if (c.code === "invalid_arguments")
          s(c.argumentsError);
        else if (c.path.length === 0)
          n._errors.push(r(c));
        else {
          let a = n, y = 0;
          for (; y < c.path.length; ) {
            const d = c.path[y];
            y === c.path.length - 1 ? (a[d] = a[d] || { _errors: [] }, a[d]._errors.push(r(c))) : a[d] = a[d] || { _errors: [] }, a = a[d], y++;
          }
        }
    };
    return s(this), n;
  }
  static assert(e) {
    if (!(e instanceof pn))
      throw new Error(`Not a ZodError: ${e}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, fc.util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (r) => r.message) {
    const r = {}, n = [];
    for (const s of this.issues)
      s.path.length > 0 ? (r[s.path[0]] = r[s.path[0]] || [], r[s.path[0]].push(e(s))) : n.push(e(s));
    return { formErrors: n, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
}
St.ZodError = pn;
pn.create = (t) => new pn(t);
Object.defineProperty(ma, "__esModule", { value: !0 });
const Ur = bn, Te = St, ym = (t, e) => {
  let r;
  switch (t.code) {
    case Te.ZodIssueCode.invalid_type:
      t.received === Ur.ZodParsedType.undefined ? r = "Required" : r = `Expected ${t.expected}, received ${t.received}`;
      break;
    case Te.ZodIssueCode.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(t.expected, Ur.util.jsonStringifyReplacer)}`;
      break;
    case Te.ZodIssueCode.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${Ur.util.joinValues(t.keys, ", ")}`;
      break;
    case Te.ZodIssueCode.invalid_union:
      r = "Invalid input";
      break;
    case Te.ZodIssueCode.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${Ur.util.joinValues(t.options)}`;
      break;
    case Te.ZodIssueCode.invalid_enum_value:
      r = `Invalid enum value. Expected ${Ur.util.joinValues(t.options)}, received '${t.received}'`;
      break;
    case Te.ZodIssueCode.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case Te.ZodIssueCode.invalid_return_type:
      r = "Invalid function return type";
      break;
    case Te.ZodIssueCode.invalid_date:
      r = "Invalid date";
      break;
    case Te.ZodIssueCode.invalid_string:
      typeof t.validation == "object" ? "includes" in t.validation ? (r = `Invalid input: must include "${t.validation.includes}"`, typeof t.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? r = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? r = `Invalid input: must end with "${t.validation.endsWith}"` : Ur.util.assertNever(t.validation) : t.validation !== "regex" ? r = `Invalid ${t.validation}` : r = "Invalid";
      break;
    case Te.ZodIssueCode.too_small:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : r = "Invalid input";
      break;
    case Te.ZodIssueCode.too_big:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? r = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : r = "Invalid input";
      break;
    case Te.ZodIssueCode.custom:
      r = "Invalid input";
      break;
    case Te.ZodIssueCode.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case Te.ZodIssueCode.not_multiple_of:
      r = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case Te.ZodIssueCode.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = e.defaultError, Ur.util.assertNever(t);
  }
  return { message: r };
};
ma.default = ym;
var mm = S && S.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(Tt, "__esModule", { value: !0 });
Tt.getErrorMap = Tt.setErrorMap = Tt.defaultErrorMap = void 0;
const yc = mm(ma);
Tt.defaultErrorMap = yc.default;
let mc = yc.default;
function bm(t) {
  mc = t;
}
Tt.setErrorMap = bm;
function hm() {
  return mc;
}
Tt.getErrorMap = hm;
var cl = {};
(function(t) {
  var e = S && S.__importDefault || function(C) {
    return C && C.__esModule ? C : { default: C };
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.isAsync = t.isValid = t.isDirty = t.isAborted = t.OK = t.DIRTY = t.INVALID = t.ParseStatus = t.addIssueToContext = t.EMPTY_PATH = t.makeIssue = void 0;
  const r = Tt, n = e(ma), s = (C) => {
    const { data: D, path: U, errorMaps: K, issueData: A } = C, T = [...U, ...A.path || []], V = {
      ...A,
      path: T
    };
    if (A.message !== void 0)
      return {
        ...A,
        path: T,
        message: A.message
      };
    let I = "";
    const X = K.filter((q) => !!q).slice().reverse();
    for (const q of X)
      I = q(V, { data: D, defaultError: I }).message;
    return {
      ...A,
      path: T,
      message: I
    };
  };
  t.makeIssue = s, t.EMPTY_PATH = [];
  function u(C, D) {
    const U = (0, r.getErrorMap)(), K = (0, t.makeIssue)({
      issueData: D,
      data: C.data,
      path: C.path,
      errorMaps: [
        C.common.contextualErrorMap,
        C.schemaErrorMap,
        U,
        U === n.default ? void 0 : n.default
        // then global default map
      ].filter((A) => !!A)
    });
    C.common.issues.push(K);
  }
  t.addIssueToContext = u;
  class c {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      this.value === "valid" && (this.value = "dirty");
    }
    abort() {
      this.value !== "aborted" && (this.value = "aborted");
    }
    static mergeArray(D, U) {
      const K = [];
      for (const A of U) {
        if (A.status === "aborted")
          return t.INVALID;
        A.status === "dirty" && D.dirty(), K.push(A.value);
      }
      return { status: D.value, value: K };
    }
    static async mergeObjectAsync(D, U) {
      const K = [];
      for (const A of U) {
        const T = await A.key, V = await A.value;
        K.push({
          key: T,
          value: V
        });
      }
      return c.mergeObjectSync(D, K);
    }
    static mergeObjectSync(D, U) {
      const K = {};
      for (const A of U) {
        const { key: T, value: V } = A;
        if (T.status === "aborted" || V.status === "aborted")
          return t.INVALID;
        T.status === "dirty" && D.dirty(), V.status === "dirty" && D.dirty(), T.value !== "__proto__" && (typeof V.value < "u" || A.alwaysSet) && (K[T.value] = V.value);
      }
      return { status: D.value, value: K };
    }
  }
  t.ParseStatus = c, t.INVALID = Object.freeze({
    status: "aborted"
  });
  const a = (C) => ({ status: "dirty", value: C });
  t.DIRTY = a;
  const y = (C) => ({ status: "valid", value: C });
  t.OK = y;
  const d = (C) => C.status === "aborted";
  t.isAborted = d;
  const b = (C) => C.status === "dirty";
  t.isDirty = b;
  const g = (C) => C.status === "valid";
  t.isValid = g;
  const R = (C) => typeof Promise < "u" && C instanceof Promise;
  t.isAsync = R;
})(cl);
var bc = {};
Object.defineProperty(bc, "__esModule", { value: !0 });
var hc = {}, Ec = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.errorUtil = void 0, function(e) {
    e.errToObj = (r) => typeof r == "string" ? { message: r } : r || {}, e.toString = (r) => typeof r == "string" ? r : r?.message;
  }(t.errorUtil || (t.errorUtil = {}));
})(Ec);
(function(t) {
  var e = S && S.__classPrivateFieldGet || function(h, o, p, m) {
    if (p === "a" && !m) throw new TypeError("Private accessor was defined without a getter");
    if (typeof o == "function" ? h !== o || !m : !o.has(h)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return p === "m" ? m : p === "a" ? m.call(h) : m ? m.value : o.get(h);
  }, r = S && S.__classPrivateFieldSet || function(h, o, p, m, E) {
    if (m === "m") throw new TypeError("Private method is not writable");
    if (m === "a" && !E) throw new TypeError("Private accessor was defined without a setter");
    if (typeof o == "function" ? h !== o || !E : !o.has(h)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return m === "a" ? E.call(h, p) : E ? E.value = p : o.set(h, p), p;
  }, n, s;
  Object.defineProperty(t, "__esModule", { value: !0 }), t.boolean = t.bigint = t.array = t.any = t.coerce = t.ZodFirstPartyTypeKind = t.late = t.ZodSchema = t.Schema = t.custom = t.ZodReadonly = t.ZodPipeline = t.ZodBranded = t.BRAND = t.ZodNaN = t.ZodCatch = t.ZodDefault = t.ZodNullable = t.ZodOptional = t.ZodTransformer = t.ZodEffects = t.ZodPromise = t.ZodNativeEnum = t.ZodEnum = t.ZodLiteral = t.ZodLazy = t.ZodFunction = t.ZodSet = t.ZodMap = t.ZodRecord = t.ZodTuple = t.ZodIntersection = t.ZodDiscriminatedUnion = t.ZodUnion = t.ZodObject = t.ZodArray = t.ZodVoid = t.ZodNever = t.ZodUnknown = t.ZodAny = t.ZodNull = t.ZodUndefined = t.ZodSymbol = t.ZodDate = t.ZodBoolean = t.ZodBigInt = t.ZodNumber = t.ZodString = t.datetimeRegex = t.ZodType = void 0, t.NEVER = t.void = t.unknown = t.union = t.undefined = t.tuple = t.transformer = t.symbol = t.string = t.strictObject = t.set = t.record = t.promise = t.preprocess = t.pipeline = t.ostring = t.optional = t.onumber = t.oboolean = t.object = t.number = t.nullable = t.null = t.never = t.nativeEnum = t.nan = t.map = t.literal = t.lazy = t.intersection = t.instanceof = t.function = t.enum = t.effect = t.discriminatedUnion = t.date = void 0;
  const u = Tt, c = Ec, a = cl, y = bn, d = St;
  class b {
    constructor(o, p, m, E) {
      this._cachedPath = [], this.parent = o, this.data = p, this._path = m, this._key = E;
    }
    get path() {
      return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
    }
  }
  const g = (h, o) => {
    if ((0, a.isValid)(o))
      return { success: !0, data: o.value };
    if (!h.common.issues.length)
      throw new Error("Validation failed but no issues detected.");
    return {
      success: !1,
      get error() {
        if (this._error)
          return this._error;
        const p = new d.ZodError(h.common.issues);
        return this._error = p, this._error;
      }
    };
  };
  function R(h) {
    if (!h)
      return {};
    const { errorMap: o, invalid_type_error: p, required_error: m, description: E } = h;
    if (o && (p || m))
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return o ? { errorMap: o, description: E } : { errorMap: (L, _) => {
      var j, O;
      const { message: z } = h;
      return L.code === "invalid_enum_value" ? { message: z ?? _.defaultError } : typeof _.data > "u" ? { message: (j = z ?? m) !== null && j !== void 0 ? j : _.defaultError } : L.code !== "invalid_type" ? { message: _.defaultError } : { message: (O = z ?? p) !== null && O !== void 0 ? O : _.defaultError };
    }, description: E };
  }
  class C {
    constructor(o) {
      this.spa = this.safeParseAsync, this._def = o, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
    }
    get description() {
      return this._def.description;
    }
    _getType(o) {
      return (0, y.getParsedType)(o.data);
    }
    _getOrReturnCtx(o, p) {
      return p || {
        common: o.parent.common,
        data: o.data,
        parsedType: (0, y.getParsedType)(o.data),
        schemaErrorMap: this._def.errorMap,
        path: o.path,
        parent: o.parent
      };
    }
    _processInputParams(o) {
      return {
        status: new a.ParseStatus(),
        ctx: {
          common: o.parent.common,
          data: o.data,
          parsedType: (0, y.getParsedType)(o.data),
          schemaErrorMap: this._def.errorMap,
          path: o.path,
          parent: o.parent
        }
      };
    }
    _parseSync(o) {
      const p = this._parse(o);
      if ((0, a.isAsync)(p))
        throw new Error("Synchronous parse encountered promise.");
      return p;
    }
    _parseAsync(o) {
      const p = this._parse(o);
      return Promise.resolve(p);
    }
    parse(o, p) {
      const m = this.safeParse(o, p);
      if (m.success)
        return m.data;
      throw m.error;
    }
    safeParse(o, p) {
      var m;
      const E = {
        common: {
          issues: [],
          async: (m = p?.async) !== null && m !== void 0 ? m : !1,
          contextualErrorMap: p?.errorMap
        },
        path: p?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: o,
        parsedType: (0, y.getParsedType)(o)
      }, x = this._parseSync({ data: o, path: E.path, parent: E });
      return g(E, x);
    }
    async parseAsync(o, p) {
      const m = await this.safeParseAsync(o, p);
      if (m.success)
        return m.data;
      throw m.error;
    }
    async safeParseAsync(o, p) {
      const m = {
        common: {
          issues: [],
          contextualErrorMap: p?.errorMap,
          async: !0
        },
        path: p?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: o,
        parsedType: (0, y.getParsedType)(o)
      }, E = this._parse({ data: o, path: m.path, parent: m }), x = await ((0, a.isAsync)(E) ? E : Promise.resolve(E));
      return g(m, x);
    }
    refine(o, p) {
      const m = (E) => typeof p == "string" || typeof p > "u" ? { message: p } : typeof p == "function" ? p(E) : p;
      return this._refinement((E, x) => {
        const L = o(E), _ = () => x.addIssue({
          code: d.ZodIssueCode.custom,
          ...m(E)
        });
        return typeof Promise < "u" && L instanceof Promise ? L.then((j) => j ? !0 : (_(), !1)) : L ? !0 : (_(), !1);
      });
    }
    refinement(o, p) {
      return this._refinement((m, E) => o(m) ? !0 : (E.addIssue(typeof p == "function" ? p(m, E) : p), !1));
    }
    _refinement(o) {
      return new nt({
        schema: this,
        typeName: G.ZodEffects,
        effect: { type: "refinement", refinement: o }
      });
    }
    superRefine(o) {
      return this._refinement(o);
    }
    optional() {
      return mt.create(this, this._def);
    }
    nullable() {
      return fr.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return it.create(this, this._def);
    }
    promise() {
      return pi.create(this, this._def);
    }
    or(o) {
      return Zi.create([this, o], this._def);
    }
    and(o) {
      return Hi.create(this, o, this._def);
    }
    transform(o) {
      return new nt({
        ...R(this._def),
        schema: this,
        typeName: G.ZodEffects,
        effect: { type: "transform", transform: o }
      });
    }
    default(o) {
      const p = typeof o == "function" ? o : () => o;
      return new en({
        ...R(this._def),
        innerType: this,
        defaultValue: p,
        typeName: G.ZodDefault
      });
    }
    brand() {
      return new Va({
        typeName: G.ZodBranded,
        type: this,
        ...R(this._def)
      });
    }
    catch(o) {
      const p = typeof o == "function" ? o : () => o;
      return new tn({
        ...R(this._def),
        innerType: this,
        catchValue: p,
        typeName: G.ZodCatch
      });
    }
    describe(o) {
      const p = this.constructor;
      return new p({
        ...this._def,
        description: o
      });
    }
    pipe(o) {
      return rn.create(this, o);
    }
    readonly() {
      return nn.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  t.ZodType = C, t.Schema = C, t.ZodSchema = C;
  const D = /^c[^\s-]{8,}$/i, U = /^[0-9a-z]+$/, K = /^[0-9A-HJKMNP-TV-Z]{26}$/, A = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, T = /^[a-z0-9_-]{21}$/i, V = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, I = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, X = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
  let q;
  const W = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, ee = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, ve = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, Ke = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", Br = new RegExp(`^${Ke}$`);
  function Do(h) {
    let o = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
    return h.precision ? o = `${o}\\.\\d{${h.precision}}` : h.precision == null && (o = `${o}(\\.\\d+)?`), o;
  }
  function qi(h) {
    return new RegExp(`^${Do(h)}$`);
  }
  function Dl(h) {
    let o = `${Ke}T${Do(h)}`;
    const p = [];
    return p.push(h.local ? "Z?" : "Z"), h.offset && p.push("([+-]\\d{2}:?\\d{2})"), o = `${o}(${p.join("|")})`, new RegExp(`^${o}$`);
  }
  t.datetimeRegex = Dl;
  function ey(h, o) {
    return !!((o === "v4" || !o) && W.test(h) || (o === "v6" || !o) && ee.test(h));
  }
  class rt extends C {
    _parse(o) {
      if (this._def.coerce && (o.data = String(o.data)), this._getType(o) !== y.ZodParsedType.string) {
        const x = this._getOrReturnCtx(o);
        return (0, a.addIssueToContext)(x, {
          code: d.ZodIssueCode.invalid_type,
          expected: y.ZodParsedType.string,
          received: x.parsedType
        }), a.INVALID;
      }
      const m = new a.ParseStatus();
      let E;
      for (const x of this._def.checks)
        if (x.kind === "min")
          o.data.length < x.value && (E = this._getOrReturnCtx(o, E), (0, a.addIssueToContext)(E, {
            code: d.ZodIssueCode.too_small,
            minimum: x.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: x.message
          }), m.dirty());
        else if (x.kind === "max")
          o.data.length > x.value && (E = this._getOrReturnCtx(o, E), (0, a.addIssueToContext)(E, {
            code: d.ZodIssueCode.too_big,
            maximum: x.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: x.message
          }), m.dirty());
        else if (x.kind === "length") {
          const L = o.data.length > x.value, _ = o.data.length < x.value;
          (L || _) && (E = this._getOrReturnCtx(o, E), L ? (0, a.addIssueToContext)(E, {
            code: d.ZodIssueCode.too_big,
            maximum: x.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: x.message
          }) : _ && (0, a.addIssueToContext)(E, {
            code: d.ZodIssueCode.too_small,
            minimum: x.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: x.message
          }), m.dirty());
        } else if (x.kind === "email")
          I.test(o.data) || (E = this._getOrReturnCtx(o, E), (0, a.addIssueToContext)(E, {
            validation: "email",
            code: d.ZodIssueCode.invalid_string,
            message: x.message
          }), m.dirty());
        else if (x.kind === "emoji")
          q || (q = new RegExp(X, "u")), q.test(o.data) || (E = this._getOrReturnCtx(o, E), (0, a.addIssueToContext)(E, {
            validation: "emoji",
            code: d.ZodIssueCode.invalid_string,
            message: x.message
          }), m.dirty());
        else if (x.kind === "uuid")
          A.test(o.data) || (E = this._getOrReturnCtx(o, E), (0, a.addIssueToContext)(E, {
            validation: "uuid",
            code: d.ZodIssueCode.invalid_string,
            message: x.message
          }), m.dirty());
        else if (x.kind === "nanoid")
          T.test(o.data) || (E = this._getOrReturnCtx(o, E), (0, a.addIssueToContext)(E, {
            validation: "nanoid",
            code: d.ZodIssueCode.invalid_string,
            message: x.message
          }), m.dirty());
        else if (x.kind === "cuid")
          D.test(o.data) || (E = this._getOrReturnCtx(o, E), (0, a.addIssueToContext)(E, {
            validation: "cuid",
            code: d.ZodIssueCode.invalid_string,
            message: x.message
          }), m.dirty());
        else if (x.kind === "cuid2")
          U.test(o.data) || (E = this._getOrReturnCtx(o, E), (0, a.addIssueToContext)(E, {
            validation: "cuid2",
            code: d.ZodIssueCode.invalid_string,
            message: x.message
          }), m.dirty());
        else if (x.kind === "ulid")
          K.test(o.data) || (E = this._getOrReturnCtx(o, E), (0, a.addIssueToContext)(E, {
            validation: "ulid",
            code: d.ZodIssueCode.invalid_string,
            message: x.message
          }), m.dirty());
        else if (x.kind === "url")
          try {
            new URL(o.data);
          } catch {
            E = this._getOrReturnCtx(o, E), (0, a.addIssueToContext)(E, {
              validation: "url",
              code: d.ZodIssueCode.invalid_string,
              message: x.message
            }), m.dirty();
          }
        else x.kind === "regex" ? (x.regex.lastIndex = 0, x.regex.test(o.data) || (E = this._getOrReturnCtx(o, E), (0, a.addIssueToContext)(E, {
          validation: "regex",
          code: d.ZodIssueCode.invalid_string,
          message: x.message
        }), m.dirty())) : x.kind === "trim" ? o.data = o.data.trim() : x.kind === "includes" ? o.data.includes(x.value, x.position) || (E = this._getOrReturnCtx(o, E), (0, a.addIssueToContext)(E, {
          code: d.ZodIssueCode.invalid_string,
          validation: { includes: x.value, position: x.position },
          message: x.message
        }), m.dirty()) : x.kind === "toLowerCase" ? o.data = o.data.toLowerCase() : x.kind === "toUpperCase" ? o.data = o.data.toUpperCase() : x.kind === "startsWith" ? o.data.startsWith(x.value) || (E = this._getOrReturnCtx(o, E), (0, a.addIssueToContext)(E, {
          code: d.ZodIssueCode.invalid_string,
          validation: { startsWith: x.value },
          message: x.message
        }), m.dirty()) : x.kind === "endsWith" ? o.data.endsWith(x.value) || (E = this._getOrReturnCtx(o, E), (0, a.addIssueToContext)(E, {
          code: d.ZodIssueCode.invalid_string,
          validation: { endsWith: x.value },
          message: x.message
        }), m.dirty()) : x.kind === "datetime" ? Dl(x).test(o.data) || (E = this._getOrReturnCtx(o, E), (0, a.addIssueToContext)(E, {
          code: d.ZodIssueCode.invalid_string,
          validation: "datetime",
          message: x.message
        }), m.dirty()) : x.kind === "date" ? Br.test(o.data) || (E = this._getOrReturnCtx(o, E), (0, a.addIssueToContext)(E, {
          code: d.ZodIssueCode.invalid_string,
          validation: "date",
          message: x.message
        }), m.dirty()) : x.kind === "time" ? qi(x).test(o.data) || (E = this._getOrReturnCtx(o, E), (0, a.addIssueToContext)(E, {
          code: d.ZodIssueCode.invalid_string,
          validation: "time",
          message: x.message
        }), m.dirty()) : x.kind === "duration" ? V.test(o.data) || (E = this._getOrReturnCtx(o, E), (0, a.addIssueToContext)(E, {
          validation: "duration",
          code: d.ZodIssueCode.invalid_string,
          message: x.message
        }), m.dirty()) : x.kind === "ip" ? ey(o.data, x.version) || (E = this._getOrReturnCtx(o, E), (0, a.addIssueToContext)(E, {
          validation: "ip",
          code: d.ZodIssueCode.invalid_string,
          message: x.message
        }), m.dirty()) : x.kind === "base64" ? ve.test(o.data) || (E = this._getOrReturnCtx(o, E), (0, a.addIssueToContext)(E, {
          validation: "base64",
          code: d.ZodIssueCode.invalid_string,
          message: x.message
        }), m.dirty()) : y.util.assertNever(x);
      return { status: m.value, value: o.data };
    }
    _regex(o, p, m) {
      return this.refinement((E) => o.test(E), {
        validation: p,
        code: d.ZodIssueCode.invalid_string,
        ...c.errorUtil.errToObj(m)
      });
    }
    _addCheck(o) {
      return new rt({
        ...this._def,
        checks: [...this._def.checks, o]
      });
    }
    email(o) {
      return this._addCheck({ kind: "email", ...c.errorUtil.errToObj(o) });
    }
    url(o) {
      return this._addCheck({ kind: "url", ...c.errorUtil.errToObj(o) });
    }
    emoji(o) {
      return this._addCheck({ kind: "emoji", ...c.errorUtil.errToObj(o) });
    }
    uuid(o) {
      return this._addCheck({ kind: "uuid", ...c.errorUtil.errToObj(o) });
    }
    nanoid(o) {
      return this._addCheck({ kind: "nanoid", ...c.errorUtil.errToObj(o) });
    }
    cuid(o) {
      return this._addCheck({ kind: "cuid", ...c.errorUtil.errToObj(o) });
    }
    cuid2(o) {
      return this._addCheck({ kind: "cuid2", ...c.errorUtil.errToObj(o) });
    }
    ulid(o) {
      return this._addCheck({ kind: "ulid", ...c.errorUtil.errToObj(o) });
    }
    base64(o) {
      return this._addCheck({ kind: "base64", ...c.errorUtil.errToObj(o) });
    }
    ip(o) {
      return this._addCheck({ kind: "ip", ...c.errorUtil.errToObj(o) });
    }
    datetime(o) {
      var p, m;
      return typeof o == "string" ? this._addCheck({
        kind: "datetime",
        precision: null,
        offset: !1,
        local: !1,
        message: o
      }) : this._addCheck({
        kind: "datetime",
        precision: typeof o?.precision > "u" ? null : o?.precision,
        offset: (p = o?.offset) !== null && p !== void 0 ? p : !1,
        local: (m = o?.local) !== null && m !== void 0 ? m : !1,
        ...c.errorUtil.errToObj(o?.message)
      });
    }
    date(o) {
      return this._addCheck({ kind: "date", message: o });
    }
    time(o) {
      return typeof o == "string" ? this._addCheck({
        kind: "time",
        precision: null,
        message: o
      }) : this._addCheck({
        kind: "time",
        precision: typeof o?.precision > "u" ? null : o?.precision,
        ...c.errorUtil.errToObj(o?.message)
      });
    }
    duration(o) {
      return this._addCheck({ kind: "duration", ...c.errorUtil.errToObj(o) });
    }
    regex(o, p) {
      return this._addCheck({
        kind: "regex",
        regex: o,
        ...c.errorUtil.errToObj(p)
      });
    }
    includes(o, p) {
      return this._addCheck({
        kind: "includes",
        value: o,
        position: p?.position,
        ...c.errorUtil.errToObj(p?.message)
      });
    }
    startsWith(o, p) {
      return this._addCheck({
        kind: "startsWith",
        value: o,
        ...c.errorUtil.errToObj(p)
      });
    }
    endsWith(o, p) {
      return this._addCheck({
        kind: "endsWith",
        value: o,
        ...c.errorUtil.errToObj(p)
      });
    }
    min(o, p) {
      return this._addCheck({
        kind: "min",
        value: o,
        ...c.errorUtil.errToObj(p)
      });
    }
    max(o, p) {
      return this._addCheck({
        kind: "max",
        value: o,
        ...c.errorUtil.errToObj(p)
      });
    }
    length(o, p) {
      return this._addCheck({
        kind: "length",
        value: o,
        ...c.errorUtil.errToObj(p)
      });
    }
    /**
     * @deprecated Use z.string().min(1) instead.
     * @see {@link ZodString.min}
     */
    nonempty(o) {
      return this.min(1, c.errorUtil.errToObj(o));
    }
    trim() {
      return new rt({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new rt({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new rt({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((o) => o.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((o) => o.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((o) => o.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((o) => o.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((o) => o.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((o) => o.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((o) => o.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((o) => o.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((o) => o.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((o) => o.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((o) => o.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((o) => o.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((o) => o.kind === "ip");
    }
    get isBase64() {
      return !!this._def.checks.find((o) => o.kind === "base64");
    }
    get minLength() {
      let o = null;
      for (const p of this._def.checks)
        p.kind === "min" && (o === null || p.value > o) && (o = p.value);
      return o;
    }
    get maxLength() {
      let o = null;
      for (const p of this._def.checks)
        p.kind === "max" && (o === null || p.value < o) && (o = p.value);
      return o;
    }
  }
  t.ZodString = rt, rt.create = (h) => {
    var o;
    return new rt({
      checks: [],
      typeName: G.ZodString,
      coerce: (o = h?.coerce) !== null && o !== void 0 ? o : !1,
      ...R(h)
    });
  };
  function ty(h, o) {
    const p = (h.toString().split(".")[1] || "").length, m = (o.toString().split(".")[1] || "").length, E = p > m ? p : m, x = parseInt(h.toFixed(E).replace(".", "")), L = parseInt(o.toFixed(E).replace(".", ""));
    return x % L / Math.pow(10, E);
  }
  class cr extends C {
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
    }
    _parse(o) {
      if (this._def.coerce && (o.data = Number(o.data)), this._getType(o) !== y.ZodParsedType.number) {
        const x = this._getOrReturnCtx(o);
        return (0, a.addIssueToContext)(x, {
          code: d.ZodIssueCode.invalid_type,
          expected: y.ZodParsedType.number,
          received: x.parsedType
        }), a.INVALID;
      }
      let m;
      const E = new a.ParseStatus();
      for (const x of this._def.checks)
        x.kind === "int" ? y.util.isInteger(o.data) || (m = this._getOrReturnCtx(o, m), (0, a.addIssueToContext)(m, {
          code: d.ZodIssueCode.invalid_type,
          expected: "integer",
          received: "float",
          message: x.message
        }), E.dirty()) : x.kind === "min" ? (x.inclusive ? o.data < x.value : o.data <= x.value) && (m = this._getOrReturnCtx(o, m), (0, a.addIssueToContext)(m, {
          code: d.ZodIssueCode.too_small,
          minimum: x.value,
          type: "number",
          inclusive: x.inclusive,
          exact: !1,
          message: x.message
        }), E.dirty()) : x.kind === "max" ? (x.inclusive ? o.data > x.value : o.data >= x.value) && (m = this._getOrReturnCtx(o, m), (0, a.addIssueToContext)(m, {
          code: d.ZodIssueCode.too_big,
          maximum: x.value,
          type: "number",
          inclusive: x.inclusive,
          exact: !1,
          message: x.message
        }), E.dirty()) : x.kind === "multipleOf" ? ty(o.data, x.value) !== 0 && (m = this._getOrReturnCtx(o, m), (0, a.addIssueToContext)(m, {
          code: d.ZodIssueCode.not_multiple_of,
          multipleOf: x.value,
          message: x.message
        }), E.dirty()) : x.kind === "finite" ? Number.isFinite(o.data) || (m = this._getOrReturnCtx(o, m), (0, a.addIssueToContext)(m, {
          code: d.ZodIssueCode.not_finite,
          message: x.message
        }), E.dirty()) : y.util.assertNever(x);
      return { status: E.value, value: o.data };
    }
    gte(o, p) {
      return this.setLimit("min", o, !0, c.errorUtil.toString(p));
    }
    gt(o, p) {
      return this.setLimit("min", o, !1, c.errorUtil.toString(p));
    }
    lte(o, p) {
      return this.setLimit("max", o, !0, c.errorUtil.toString(p));
    }
    lt(o, p) {
      return this.setLimit("max", o, !1, c.errorUtil.toString(p));
    }
    setLimit(o, p, m, E) {
      return new cr({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: o,
            value: p,
            inclusive: m,
            message: c.errorUtil.toString(E)
          }
        ]
      });
    }
    _addCheck(o) {
      return new cr({
        ...this._def,
        checks: [...this._def.checks, o]
      });
    }
    int(o) {
      return this._addCheck({
        kind: "int",
        message: c.errorUtil.toString(o)
      });
    }
    positive(o) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !1,
        message: c.errorUtil.toString(o)
      });
    }
    negative(o) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !1,
        message: c.errorUtil.toString(o)
      });
    }
    nonpositive(o) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !0,
        message: c.errorUtil.toString(o)
      });
    }
    nonnegative(o) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !0,
        message: c.errorUtil.toString(o)
      });
    }
    multipleOf(o, p) {
      return this._addCheck({
        kind: "multipleOf",
        value: o,
        message: c.errorUtil.toString(p)
      });
    }
    finite(o) {
      return this._addCheck({
        kind: "finite",
        message: c.errorUtil.toString(o)
      });
    }
    safe(o) {
      return this._addCheck({
        kind: "min",
        inclusive: !0,
        value: Number.MIN_SAFE_INTEGER,
        message: c.errorUtil.toString(o)
      })._addCheck({
        kind: "max",
        inclusive: !0,
        value: Number.MAX_SAFE_INTEGER,
        message: c.errorUtil.toString(o)
      });
    }
    get minValue() {
      let o = null;
      for (const p of this._def.checks)
        p.kind === "min" && (o === null || p.value > o) && (o = p.value);
      return o;
    }
    get maxValue() {
      let o = null;
      for (const p of this._def.checks)
        p.kind === "max" && (o === null || p.value < o) && (o = p.value);
      return o;
    }
    get isInt() {
      return !!this._def.checks.find((o) => o.kind === "int" || o.kind === "multipleOf" && y.util.isInteger(o.value));
    }
    get isFinite() {
      let o = null, p = null;
      for (const m of this._def.checks) {
        if (m.kind === "finite" || m.kind === "int" || m.kind === "multipleOf")
          return !0;
        m.kind === "min" ? (p === null || m.value > p) && (p = m.value) : m.kind === "max" && (o === null || m.value < o) && (o = m.value);
      }
      return Number.isFinite(p) && Number.isFinite(o);
    }
  }
  t.ZodNumber = cr, cr.create = (h) => new cr({
    checks: [],
    typeName: G.ZodNumber,
    coerce: h?.coerce || !1,
    ...R(h)
  });
  class pr extends C {
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte;
    }
    _parse(o) {
      if (this._def.coerce && (o.data = BigInt(o.data)), this._getType(o) !== y.ZodParsedType.bigint) {
        const x = this._getOrReturnCtx(o);
        return (0, a.addIssueToContext)(x, {
          code: d.ZodIssueCode.invalid_type,
          expected: y.ZodParsedType.bigint,
          received: x.parsedType
        }), a.INVALID;
      }
      let m;
      const E = new a.ParseStatus();
      for (const x of this._def.checks)
        x.kind === "min" ? (x.inclusive ? o.data < x.value : o.data <= x.value) && (m = this._getOrReturnCtx(o, m), (0, a.addIssueToContext)(m, {
          code: d.ZodIssueCode.too_small,
          type: "bigint",
          minimum: x.value,
          inclusive: x.inclusive,
          message: x.message
        }), E.dirty()) : x.kind === "max" ? (x.inclusive ? o.data > x.value : o.data >= x.value) && (m = this._getOrReturnCtx(o, m), (0, a.addIssueToContext)(m, {
          code: d.ZodIssueCode.too_big,
          type: "bigint",
          maximum: x.value,
          inclusive: x.inclusive,
          message: x.message
        }), E.dirty()) : x.kind === "multipleOf" ? o.data % x.value !== BigInt(0) && (m = this._getOrReturnCtx(o, m), (0, a.addIssueToContext)(m, {
          code: d.ZodIssueCode.not_multiple_of,
          multipleOf: x.value,
          message: x.message
        }), E.dirty()) : y.util.assertNever(x);
      return { status: E.value, value: o.data };
    }
    gte(o, p) {
      return this.setLimit("min", o, !0, c.errorUtil.toString(p));
    }
    gt(o, p) {
      return this.setLimit("min", o, !1, c.errorUtil.toString(p));
    }
    lte(o, p) {
      return this.setLimit("max", o, !0, c.errorUtil.toString(p));
    }
    lt(o, p) {
      return this.setLimit("max", o, !1, c.errorUtil.toString(p));
    }
    setLimit(o, p, m, E) {
      return new pr({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: o,
            value: p,
            inclusive: m,
            message: c.errorUtil.toString(E)
          }
        ]
      });
    }
    _addCheck(o) {
      return new pr({
        ...this._def,
        checks: [...this._def.checks, o]
      });
    }
    positive(o) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !1,
        message: c.errorUtil.toString(o)
      });
    }
    negative(o) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !1,
        message: c.errorUtil.toString(o)
      });
    }
    nonpositive(o) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !0,
        message: c.errorUtil.toString(o)
      });
    }
    nonnegative(o) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !0,
        message: c.errorUtil.toString(o)
      });
    }
    multipleOf(o, p) {
      return this._addCheck({
        kind: "multipleOf",
        value: o,
        message: c.errorUtil.toString(p)
      });
    }
    get minValue() {
      let o = null;
      for (const p of this._def.checks)
        p.kind === "min" && (o === null || p.value > o) && (o = p.value);
      return o;
    }
    get maxValue() {
      let o = null;
      for (const p of this._def.checks)
        p.kind === "max" && (o === null || p.value < o) && (o = p.value);
      return o;
    }
  }
  t.ZodBigInt = pr, pr.create = (h) => {
    var o;
    return new pr({
      checks: [],
      typeName: G.ZodBigInt,
      coerce: (o = h?.coerce) !== null && o !== void 0 ? o : !1,
      ...R(h)
    });
  };
  class Fi extends C {
    _parse(o) {
      if (this._def.coerce && (o.data = !!o.data), this._getType(o) !== y.ZodParsedType.boolean) {
        const m = this._getOrReturnCtx(o);
        return (0, a.addIssueToContext)(m, {
          code: d.ZodIssueCode.invalid_type,
          expected: y.ZodParsedType.boolean,
          received: m.parsedType
        }), a.INVALID;
      }
      return (0, a.OK)(o.data);
    }
  }
  t.ZodBoolean = Fi, Fi.create = (h) => new Fi({
    typeName: G.ZodBoolean,
    coerce: h?.coerce || !1,
    ...R(h)
  });
  class Pr extends C {
    _parse(o) {
      if (this._def.coerce && (o.data = new Date(o.data)), this._getType(o) !== y.ZodParsedType.date) {
        const x = this._getOrReturnCtx(o);
        return (0, a.addIssueToContext)(x, {
          code: d.ZodIssueCode.invalid_type,
          expected: y.ZodParsedType.date,
          received: x.parsedType
        }), a.INVALID;
      }
      if (isNaN(o.data.getTime())) {
        const x = this._getOrReturnCtx(o);
        return (0, a.addIssueToContext)(x, {
          code: d.ZodIssueCode.invalid_date
        }), a.INVALID;
      }
      const m = new a.ParseStatus();
      let E;
      for (const x of this._def.checks)
        x.kind === "min" ? o.data.getTime() < x.value && (E = this._getOrReturnCtx(o, E), (0, a.addIssueToContext)(E, {
          code: d.ZodIssueCode.too_small,
          message: x.message,
          inclusive: !0,
          exact: !1,
          minimum: x.value,
          type: "date"
        }), m.dirty()) : x.kind === "max" ? o.data.getTime() > x.value && (E = this._getOrReturnCtx(o, E), (0, a.addIssueToContext)(E, {
          code: d.ZodIssueCode.too_big,
          message: x.message,
          inclusive: !0,
          exact: !1,
          maximum: x.value,
          type: "date"
        }), m.dirty()) : y.util.assertNever(x);
      return {
        status: m.value,
        value: new Date(o.data.getTime())
      };
    }
    _addCheck(o) {
      return new Pr({
        ...this._def,
        checks: [...this._def.checks, o]
      });
    }
    min(o, p) {
      return this._addCheck({
        kind: "min",
        value: o.getTime(),
        message: c.errorUtil.toString(p)
      });
    }
    max(o, p) {
      return this._addCheck({
        kind: "max",
        value: o.getTime(),
        message: c.errorUtil.toString(p)
      });
    }
    get minDate() {
      let o = null;
      for (const p of this._def.checks)
        p.kind === "min" && (o === null || p.value > o) && (o = p.value);
      return o != null ? new Date(o) : null;
    }
    get maxDate() {
      let o = null;
      for (const p of this._def.checks)
        p.kind === "max" && (o === null || p.value < o) && (o = p.value);
      return o != null ? new Date(o) : null;
    }
  }
  t.ZodDate = Pr, Pr.create = (h) => new Pr({
    checks: [],
    coerce: h?.coerce || !1,
    typeName: G.ZodDate,
    ...R(h)
  });
  class Ko extends C {
    _parse(o) {
      if (this._getType(o) !== y.ZodParsedType.symbol) {
        const m = this._getOrReturnCtx(o);
        return (0, a.addIssueToContext)(m, {
          code: d.ZodIssueCode.invalid_type,
          expected: y.ZodParsedType.symbol,
          received: m.parsedType
        }), a.INVALID;
      }
      return (0, a.OK)(o.data);
    }
  }
  t.ZodSymbol = Ko, Ko.create = (h) => new Ko({
    typeName: G.ZodSymbol,
    ...R(h)
  });
  class zi extends C {
    _parse(o) {
      if (this._getType(o) !== y.ZodParsedType.undefined) {
        const m = this._getOrReturnCtx(o);
        return (0, a.addIssueToContext)(m, {
          code: d.ZodIssueCode.invalid_type,
          expected: y.ZodParsedType.undefined,
          received: m.parsedType
        }), a.INVALID;
      }
      return (0, a.OK)(o.data);
    }
  }
  t.ZodUndefined = zi, zi.create = (h) => new zi({
    typeName: G.ZodUndefined,
    ...R(h)
  });
  class Xi extends C {
    _parse(o) {
      if (this._getType(o) !== y.ZodParsedType.null) {
        const m = this._getOrReturnCtx(o);
        return (0, a.addIssueToContext)(m, {
          code: d.ZodIssueCode.invalid_type,
          expected: y.ZodParsedType.null,
          received: m.parsedType
        }), a.INVALID;
      }
      return (0, a.OK)(o.data);
    }
  }
  t.ZodNull = Xi, Xi.create = (h) => new Xi({
    typeName: G.ZodNull,
    ...R(h)
  });
  class li extends C {
    constructor() {
      super(...arguments), this._any = !0;
    }
    _parse(o) {
      return (0, a.OK)(o.data);
    }
  }
  t.ZodAny = li, li.create = (h) => new li({
    typeName: G.ZodAny,
    ...R(h)
  });
  class Dr extends C {
    constructor() {
      super(...arguments), this._unknown = !0;
    }
    _parse(o) {
      return (0, a.OK)(o.data);
    }
  }
  t.ZodUnknown = Dr, Dr.create = (h) => new Dr({
    typeName: G.ZodUnknown,
    ...R(h)
  });
  class jt extends C {
    _parse(o) {
      const p = this._getOrReturnCtx(o);
      return (0, a.addIssueToContext)(p, {
        code: d.ZodIssueCode.invalid_type,
        expected: y.ZodParsedType.never,
        received: p.parsedType
      }), a.INVALID;
    }
  }
  t.ZodNever = jt, jt.create = (h) => new jt({
    typeName: G.ZodNever,
    ...R(h)
  });
  class Uo extends C {
    _parse(o) {
      if (this._getType(o) !== y.ZodParsedType.undefined) {
        const m = this._getOrReturnCtx(o);
        return (0, a.addIssueToContext)(m, {
          code: d.ZodIssueCode.invalid_type,
          expected: y.ZodParsedType.void,
          received: m.parsedType
        }), a.INVALID;
      }
      return (0, a.OK)(o.data);
    }
  }
  t.ZodVoid = Uo, Uo.create = (h) => new Uo({
    typeName: G.ZodVoid,
    ...R(h)
  });
  class it extends C {
    _parse(o) {
      const { ctx: p, status: m } = this._processInputParams(o), E = this._def;
      if (p.parsedType !== y.ZodParsedType.array)
        return (0, a.addIssueToContext)(p, {
          code: d.ZodIssueCode.invalid_type,
          expected: y.ZodParsedType.array,
          received: p.parsedType
        }), a.INVALID;
      if (E.exactLength !== null) {
        const L = p.data.length > E.exactLength.value, _ = p.data.length < E.exactLength.value;
        (L || _) && ((0, a.addIssueToContext)(p, {
          code: L ? d.ZodIssueCode.too_big : d.ZodIssueCode.too_small,
          minimum: _ ? E.exactLength.value : void 0,
          maximum: L ? E.exactLength.value : void 0,
          type: "array",
          inclusive: !0,
          exact: !0,
          message: E.exactLength.message
        }), m.dirty());
      }
      if (E.minLength !== null && p.data.length < E.minLength.value && ((0, a.addIssueToContext)(p, {
        code: d.ZodIssueCode.too_small,
        minimum: E.minLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: E.minLength.message
      }), m.dirty()), E.maxLength !== null && p.data.length > E.maxLength.value && ((0, a.addIssueToContext)(p, {
        code: d.ZodIssueCode.too_big,
        maximum: E.maxLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: E.maxLength.message
      }), m.dirty()), p.common.async)
        return Promise.all([...p.data].map((L, _) => E.type._parseAsync(new b(p, L, p.path, _)))).then((L) => a.ParseStatus.mergeArray(m, L));
      const x = [...p.data].map((L, _) => E.type._parseSync(new b(p, L, p.path, _)));
      return a.ParseStatus.mergeArray(m, x);
    }
    get element() {
      return this._def.type;
    }
    min(o, p) {
      return new it({
        ...this._def,
        minLength: { value: o, message: c.errorUtil.toString(p) }
      });
    }
    max(o, p) {
      return new it({
        ...this._def,
        maxLength: { value: o, message: c.errorUtil.toString(p) }
      });
    }
    length(o, p) {
      return new it({
        ...this._def,
        exactLength: { value: o, message: c.errorUtil.toString(p) }
      });
    }
    nonempty(o) {
      return this.min(1, o);
    }
  }
  t.ZodArray = it, it.create = (h, o) => new it({
    type: h,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: G.ZodArray,
    ...R(o)
  });
  function ui(h) {
    if (h instanceof se) {
      const o = {};
      for (const p in h.shape) {
        const m = h.shape[p];
        o[p] = mt.create(ui(m));
      }
      return new se({
        ...h._def,
        shape: () => o
      });
    } else return h instanceof it ? new it({
      ...h._def,
      type: ui(h.element)
    }) : h instanceof mt ? mt.create(ui(h.unwrap())) : h instanceof fr ? fr.create(ui(h.unwrap())) : h instanceof yt ? yt.create(h.items.map((o) => ui(o))) : h;
  }
  class se extends C {
    constructor() {
      super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const o = this._def.shape(), p = y.util.objectKeys(o);
      return this._cached = { shape: o, keys: p };
    }
    _parse(o) {
      if (this._getType(o) !== y.ZodParsedType.object) {
        const O = this._getOrReturnCtx(o);
        return (0, a.addIssueToContext)(O, {
          code: d.ZodIssueCode.invalid_type,
          expected: y.ZodParsedType.object,
          received: O.parsedType
        }), a.INVALID;
      }
      const { status: m, ctx: E } = this._processInputParams(o), { shape: x, keys: L } = this._getCached(), _ = [];
      if (!(this._def.catchall instanceof jt && this._def.unknownKeys === "strip"))
        for (const O in E.data)
          L.includes(O) || _.push(O);
      const j = [];
      for (const O of L) {
        const z = x[O], Qe = E.data[O];
        j.push({
          key: { status: "valid", value: O },
          value: z._parse(new b(E, Qe, E.path, O)),
          alwaysSet: O in E.data
        });
      }
      if (this._def.catchall instanceof jt) {
        const O = this._def.unknownKeys;
        if (O === "passthrough")
          for (const z of _)
            j.push({
              key: { status: "valid", value: z },
              value: { status: "valid", value: E.data[z] }
            });
        else if (O === "strict")
          _.length > 0 && ((0, a.addIssueToContext)(E, {
            code: d.ZodIssueCode.unrecognized_keys,
            keys: _
          }), m.dirty());
        else if (O !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
      } else {
        const O = this._def.catchall;
        for (const z of _) {
          const Qe = E.data[z];
          j.push({
            key: { status: "valid", value: z },
            value: O._parse(
              new b(E, Qe, E.path, z)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: z in E.data
          });
        }
      }
      return E.common.async ? Promise.resolve().then(async () => {
        const O = [];
        for (const z of j) {
          const Qe = await z.key, Ml = await z.value;
          O.push({
            key: Qe,
            value: Ml,
            alwaysSet: z.alwaysSet
          });
        }
        return O;
      }).then((O) => a.ParseStatus.mergeObjectSync(m, O)) : a.ParseStatus.mergeObjectSync(m, j);
    }
    get shape() {
      return this._def.shape();
    }
    strict(o) {
      return c.errorUtil.errToObj, new se({
        ...this._def,
        unknownKeys: "strict",
        ...o !== void 0 ? {
          errorMap: (p, m) => {
            var E, x, L, _;
            const j = (L = (x = (E = this._def).errorMap) === null || x === void 0 ? void 0 : x.call(E, p, m).message) !== null && L !== void 0 ? L : m.defaultError;
            return p.code === "unrecognized_keys" ? {
              message: (_ = c.errorUtil.errToObj(o).message) !== null && _ !== void 0 ? _ : j
            } : {
              message: j
            };
          }
        } : {}
      });
    }
    strip() {
      return new se({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new se({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(o) {
      return new se({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...o
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(o) {
      return new se({
        unknownKeys: o._def.unknownKeys,
        catchall: o._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...o._def.shape()
        }),
        typeName: G.ZodObject
      });
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(o, p) {
      return this.augment({ [o]: p });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(o) {
      return new se({
        ...this._def,
        catchall: o
      });
    }
    pick(o) {
      const p = {};
      return y.util.objectKeys(o).forEach((m) => {
        o[m] && this.shape[m] && (p[m] = this.shape[m]);
      }), new se({
        ...this._def,
        shape: () => p
      });
    }
    omit(o) {
      const p = {};
      return y.util.objectKeys(this.shape).forEach((m) => {
        o[m] || (p[m] = this.shape[m]);
      }), new se({
        ...this._def,
        shape: () => p
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return ui(this);
    }
    partial(o) {
      const p = {};
      return y.util.objectKeys(this.shape).forEach((m) => {
        const E = this.shape[m];
        o && !o[m] ? p[m] = E : p[m] = E.optional();
      }), new se({
        ...this._def,
        shape: () => p
      });
    }
    required(o) {
      const p = {};
      return y.util.objectKeys(this.shape).forEach((m) => {
        if (o && !o[m])
          p[m] = this.shape[m];
        else {
          let x = this.shape[m];
          for (; x instanceof mt; )
            x = x._def.innerType;
          p[m] = x;
        }
      }), new se({
        ...this._def,
        shape: () => p
      });
    }
    keyof() {
      return Kl(y.util.objectKeys(this.shape));
    }
  }
  t.ZodObject = se, se.create = (h, o) => new se({
    shape: () => h,
    unknownKeys: "strip",
    catchall: jt.create(),
    typeName: G.ZodObject,
    ...R(o)
  }), se.strictCreate = (h, o) => new se({
    shape: () => h,
    unknownKeys: "strict",
    catchall: jt.create(),
    typeName: G.ZodObject,
    ...R(o)
  }), se.lazycreate = (h, o) => new se({
    shape: h,
    unknownKeys: "strip",
    catchall: jt.create(),
    typeName: G.ZodObject,
    ...R(o)
  });
  class Zi extends C {
    _parse(o) {
      const { ctx: p } = this._processInputParams(o), m = this._def.options;
      function E(x) {
        for (const _ of x)
          if (_.result.status === "valid")
            return _.result;
        for (const _ of x)
          if (_.result.status === "dirty")
            return p.common.issues.push(..._.ctx.common.issues), _.result;
        const L = x.map((_) => new d.ZodError(_.ctx.common.issues));
        return (0, a.addIssueToContext)(p, {
          code: d.ZodIssueCode.invalid_union,
          unionErrors: L
        }), a.INVALID;
      }
      if (p.common.async)
        return Promise.all(m.map(async (x) => {
          const L = {
            ...p,
            common: {
              ...p.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await x._parseAsync({
              data: p.data,
              path: p.path,
              parent: L
            }),
            ctx: L
          };
        })).then(E);
      {
        let x;
        const L = [];
        for (const j of m) {
          const O = {
            ...p,
            common: {
              ...p.common,
              issues: []
            },
            parent: null
          }, z = j._parseSync({
            data: p.data,
            path: p.path,
            parent: O
          });
          if (z.status === "valid")
            return z;
          z.status === "dirty" && !x && (x = { result: z, ctx: O }), O.common.issues.length && L.push(O.common.issues);
        }
        if (x)
          return p.common.issues.push(...x.ctx.common.issues), x.result;
        const _ = L.map((j) => new d.ZodError(j));
        return (0, a.addIssueToContext)(p, {
          code: d.ZodIssueCode.invalid_union,
          unionErrors: _
        }), a.INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  t.ZodUnion = Zi, Zi.create = (h, o) => new Zi({
    options: h,
    typeName: G.ZodUnion,
    ...R(o)
  });
  const Ot = (h) => h instanceof Ji ? Ot(h.schema) : h instanceof nt ? Ot(h.innerType()) : h instanceof Qi ? [h.value] : h instanceof dr ? h.options : h instanceof Yi ? y.util.objectValues(h.enum) : h instanceof en ? Ot(h._def.innerType) : h instanceof zi ? [void 0] : h instanceof Xi ? [null] : h instanceof mt ? [void 0, ...Ot(h.unwrap())] : h instanceof fr ? [null, ...Ot(h.unwrap())] : h instanceof Va || h instanceof nn ? Ot(h.unwrap()) : h instanceof tn ? Ot(h._def.innerType) : [];
  class Vo extends C {
    _parse(o) {
      const { ctx: p } = this._processInputParams(o);
      if (p.parsedType !== y.ZodParsedType.object)
        return (0, a.addIssueToContext)(p, {
          code: d.ZodIssueCode.invalid_type,
          expected: y.ZodParsedType.object,
          received: p.parsedType
        }), a.INVALID;
      const m = this.discriminator, E = p.data[m], x = this.optionsMap.get(E);
      return x ? p.common.async ? x._parseAsync({
        data: p.data,
        path: p.path,
        parent: p
      }) : x._parseSync({
        data: p.data,
        path: p.path,
        parent: p
      }) : ((0, a.addIssueToContext)(p, {
        code: d.ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [m]
      }), a.INVALID);
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(o, p, m) {
      const E = /* @__PURE__ */ new Map();
      for (const x of p) {
        const L = Ot(x.shape[o]);
        if (!L.length)
          throw new Error(`A discriminator value for key \`${o}\` could not be extracted from all schema options`);
        for (const _ of L) {
          if (E.has(_))
            throw new Error(`Discriminator property ${String(o)} has duplicate value ${String(_)}`);
          E.set(_, x);
        }
      }
      return new Vo({
        typeName: G.ZodDiscriminatedUnion,
        discriminator: o,
        options: p,
        optionsMap: E,
        ...R(m)
      });
    }
  }
  t.ZodDiscriminatedUnion = Vo;
  function Ua(h, o) {
    const p = (0, y.getParsedType)(h), m = (0, y.getParsedType)(o);
    if (h === o)
      return { valid: !0, data: h };
    if (p === y.ZodParsedType.object && m === y.ZodParsedType.object) {
      const E = y.util.objectKeys(o), x = y.util.objectKeys(h).filter((_) => E.indexOf(_) !== -1), L = { ...h, ...o };
      for (const _ of x) {
        const j = Ua(h[_], o[_]);
        if (!j.valid)
          return { valid: !1 };
        L[_] = j.data;
      }
      return { valid: !0, data: L };
    } else if (p === y.ZodParsedType.array && m === y.ZodParsedType.array) {
      if (h.length !== o.length)
        return { valid: !1 };
      const E = [];
      for (let x = 0; x < h.length; x++) {
        const L = h[x], _ = o[x], j = Ua(L, _);
        if (!j.valid)
          return { valid: !1 };
        E.push(j.data);
      }
      return { valid: !0, data: E };
    } else return p === y.ZodParsedType.date && m === y.ZodParsedType.date && +h == +o ? { valid: !0, data: h } : { valid: !1 };
  }
  class Hi extends C {
    _parse(o) {
      const { status: p, ctx: m } = this._processInputParams(o), E = (x, L) => {
        if ((0, a.isAborted)(x) || (0, a.isAborted)(L))
          return a.INVALID;
        const _ = Ua(x.value, L.value);
        return _.valid ? (((0, a.isDirty)(x) || (0, a.isDirty)(L)) && p.dirty(), { status: p.value, value: _.data }) : ((0, a.addIssueToContext)(m, {
          code: d.ZodIssueCode.invalid_intersection_types
        }), a.INVALID);
      };
      return m.common.async ? Promise.all([
        this._def.left._parseAsync({
          data: m.data,
          path: m.path,
          parent: m
        }),
        this._def.right._parseAsync({
          data: m.data,
          path: m.path,
          parent: m
        })
      ]).then(([x, L]) => E(x, L)) : E(this._def.left._parseSync({
        data: m.data,
        path: m.path,
        parent: m
      }), this._def.right._parseSync({
        data: m.data,
        path: m.path,
        parent: m
      }));
    }
  }
  t.ZodIntersection = Hi, Hi.create = (h, o, p) => new Hi({
    left: h,
    right: o,
    typeName: G.ZodIntersection,
    ...R(p)
  });
  class yt extends C {
    _parse(o) {
      const { status: p, ctx: m } = this._processInputParams(o);
      if (m.parsedType !== y.ZodParsedType.array)
        return (0, a.addIssueToContext)(m, {
          code: d.ZodIssueCode.invalid_type,
          expected: y.ZodParsedType.array,
          received: m.parsedType
        }), a.INVALID;
      if (m.data.length < this._def.items.length)
        return (0, a.addIssueToContext)(m, {
          code: d.ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array"
        }), a.INVALID;
      !this._def.rest && m.data.length > this._def.items.length && ((0, a.addIssueToContext)(m, {
        code: d.ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), p.dirty());
      const x = [...m.data].map((L, _) => {
        const j = this._def.items[_] || this._def.rest;
        return j ? j._parse(new b(m, L, m.path, _)) : null;
      }).filter((L) => !!L);
      return m.common.async ? Promise.all(x).then((L) => a.ParseStatus.mergeArray(p, L)) : a.ParseStatus.mergeArray(p, x);
    }
    get items() {
      return this._def.items;
    }
    rest(o) {
      return new yt({
        ...this._def,
        rest: o
      });
    }
  }
  t.ZodTuple = yt, yt.create = (h, o) => {
    if (!Array.isArray(h))
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new yt({
      items: h,
      typeName: G.ZodTuple,
      rest: null,
      ...R(o)
    });
  };
  class Wi extends C {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(o) {
      const { status: p, ctx: m } = this._processInputParams(o);
      if (m.parsedType !== y.ZodParsedType.object)
        return (0, a.addIssueToContext)(m, {
          code: d.ZodIssueCode.invalid_type,
          expected: y.ZodParsedType.object,
          received: m.parsedType
        }), a.INVALID;
      const E = [], x = this._def.keyType, L = this._def.valueType;
      for (const _ in m.data)
        E.push({
          key: x._parse(new b(m, _, m.path, _)),
          value: L._parse(new b(m, m.data[_], m.path, _)),
          alwaysSet: _ in m.data
        });
      return m.common.async ? a.ParseStatus.mergeObjectAsync(p, E) : a.ParseStatus.mergeObjectSync(p, E);
    }
    get element() {
      return this._def.valueType;
    }
    static create(o, p, m) {
      return p instanceof C ? new Wi({
        keyType: o,
        valueType: p,
        typeName: G.ZodRecord,
        ...R(m)
      }) : new Wi({
        keyType: rt.create(),
        valueType: o,
        typeName: G.ZodRecord,
        ...R(p)
      });
    }
  }
  t.ZodRecord = Wi;
  class Io extends C {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(o) {
      const { status: p, ctx: m } = this._processInputParams(o);
      if (m.parsedType !== y.ZodParsedType.map)
        return (0, a.addIssueToContext)(m, {
          code: d.ZodIssueCode.invalid_type,
          expected: y.ZodParsedType.map,
          received: m.parsedType
        }), a.INVALID;
      const E = this._def.keyType, x = this._def.valueType, L = [...m.data.entries()].map(([_, j], O) => ({
        key: E._parse(new b(m, _, m.path, [O, "key"])),
        value: x._parse(new b(m, j, m.path, [O, "value"]))
      }));
      if (m.common.async) {
        const _ = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const j of L) {
            const O = await j.key, z = await j.value;
            if (O.status === "aborted" || z.status === "aborted")
              return a.INVALID;
            (O.status === "dirty" || z.status === "dirty") && p.dirty(), _.set(O.value, z.value);
          }
          return { status: p.value, value: _ };
        });
      } else {
        const _ = /* @__PURE__ */ new Map();
        for (const j of L) {
          const O = j.key, z = j.value;
          if (O.status === "aborted" || z.status === "aborted")
            return a.INVALID;
          (O.status === "dirty" || z.status === "dirty") && p.dirty(), _.set(O.value, z.value);
        }
        return { status: p.value, value: _ };
      }
    }
  }
  t.ZodMap = Io, Io.create = (h, o, p) => new Io({
    valueType: o,
    keyType: h,
    typeName: G.ZodMap,
    ...R(p)
  });
  class Kr extends C {
    _parse(o) {
      const { status: p, ctx: m } = this._processInputParams(o);
      if (m.parsedType !== y.ZodParsedType.set)
        return (0, a.addIssueToContext)(m, {
          code: d.ZodIssueCode.invalid_type,
          expected: y.ZodParsedType.set,
          received: m.parsedType
        }), a.INVALID;
      const E = this._def;
      E.minSize !== null && m.data.size < E.minSize.value && ((0, a.addIssueToContext)(m, {
        code: d.ZodIssueCode.too_small,
        minimum: E.minSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: E.minSize.message
      }), p.dirty()), E.maxSize !== null && m.data.size > E.maxSize.value && ((0, a.addIssueToContext)(m, {
        code: d.ZodIssueCode.too_big,
        maximum: E.maxSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: E.maxSize.message
      }), p.dirty());
      const x = this._def.valueType;
      function L(j) {
        const O = /* @__PURE__ */ new Set();
        for (const z of j) {
          if (z.status === "aborted")
            return a.INVALID;
          z.status === "dirty" && p.dirty(), O.add(z.value);
        }
        return { status: p.value, value: O };
      }
      const _ = [...m.data.values()].map((j, O) => x._parse(new b(m, j, m.path, O)));
      return m.common.async ? Promise.all(_).then((j) => L(j)) : L(_);
    }
    min(o, p) {
      return new Kr({
        ...this._def,
        minSize: { value: o, message: c.errorUtil.toString(p) }
      });
    }
    max(o, p) {
      return new Kr({
        ...this._def,
        maxSize: { value: o, message: c.errorUtil.toString(p) }
      });
    }
    size(o, p) {
      return this.min(o, p).max(o, p);
    }
    nonempty(o) {
      return this.min(1, o);
    }
  }
  t.ZodSet = Kr, Kr.create = (h, o) => new Kr({
    valueType: h,
    minSize: null,
    maxSize: null,
    typeName: G.ZodSet,
    ...R(o)
  });
  class ci extends C {
    constructor() {
      super(...arguments), this.validate = this.implement;
    }
    _parse(o) {
      const { ctx: p } = this._processInputParams(o);
      if (p.parsedType !== y.ZodParsedType.function)
        return (0, a.addIssueToContext)(p, {
          code: d.ZodIssueCode.invalid_type,
          expected: y.ZodParsedType.function,
          received: p.parsedType
        }), a.INVALID;
      function m(_, j) {
        return (0, a.makeIssue)({
          data: _,
          path: p.path,
          errorMaps: [
            p.common.contextualErrorMap,
            p.schemaErrorMap,
            (0, u.getErrorMap)(),
            u.defaultErrorMap
          ].filter((O) => !!O),
          issueData: {
            code: d.ZodIssueCode.invalid_arguments,
            argumentsError: j
          }
        });
      }
      function E(_, j) {
        return (0, a.makeIssue)({
          data: _,
          path: p.path,
          errorMaps: [
            p.common.contextualErrorMap,
            p.schemaErrorMap,
            (0, u.getErrorMap)(),
            u.defaultErrorMap
          ].filter((O) => !!O),
          issueData: {
            code: d.ZodIssueCode.invalid_return_type,
            returnTypeError: j
          }
        });
      }
      const x = { errorMap: p.common.contextualErrorMap }, L = p.data;
      if (this._def.returns instanceof pi) {
        const _ = this;
        return (0, a.OK)(async function(...j) {
          const O = new d.ZodError([]), z = await _._def.args.parseAsync(j, x).catch((Ia) => {
            throw O.addIssue(m(j, Ia)), O;
          }), Qe = await Reflect.apply(L, this, z);
          return await _._def.returns._def.type.parseAsync(Qe, x).catch((Ia) => {
            throw O.addIssue(E(Qe, Ia)), O;
          });
        });
      } else {
        const _ = this;
        return (0, a.OK)(function(...j) {
          const O = _._def.args.safeParse(j, x);
          if (!O.success)
            throw new d.ZodError([m(j, O.error)]);
          const z = Reflect.apply(L, this, O.data), Qe = _._def.returns.safeParse(z, x);
          if (!Qe.success)
            throw new d.ZodError([E(z, Qe.error)]);
          return Qe.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...o) {
      return new ci({
        ...this._def,
        args: yt.create(o).rest(Dr.create())
      });
    }
    returns(o) {
      return new ci({
        ...this._def,
        returns: o
      });
    }
    implement(o) {
      return this.parse(o);
    }
    strictImplement(o) {
      return this.parse(o);
    }
    static create(o, p, m) {
      return new ci({
        args: o || yt.create([]).rest(Dr.create()),
        returns: p || Dr.create(),
        typeName: G.ZodFunction,
        ...R(m)
      });
    }
  }
  t.ZodFunction = ci;
  class Ji extends C {
    get schema() {
      return this._def.getter();
    }
    _parse(o) {
      const { ctx: p } = this._processInputParams(o);
      return this._def.getter()._parse({ data: p.data, path: p.path, parent: p });
    }
  }
  t.ZodLazy = Ji, Ji.create = (h, o) => new Ji({
    getter: h,
    typeName: G.ZodLazy,
    ...R(o)
  });
  class Qi extends C {
    _parse(o) {
      if (o.data !== this._def.value) {
        const p = this._getOrReturnCtx(o);
        return (0, a.addIssueToContext)(p, {
          received: p.data,
          code: d.ZodIssueCode.invalid_literal,
          expected: this._def.value
        }), a.INVALID;
      }
      return { status: "valid", value: o.data };
    }
    get value() {
      return this._def.value;
    }
  }
  t.ZodLiteral = Qi, Qi.create = (h, o) => new Qi({
    value: h,
    typeName: G.ZodLiteral,
    ...R(o)
  });
  function Kl(h, o) {
    return new dr({
      values: h,
      typeName: G.ZodEnum,
      ...R(o)
    });
  }
  class dr extends C {
    constructor() {
      super(...arguments), n.set(this, void 0);
    }
    _parse(o) {
      if (typeof o.data != "string") {
        const p = this._getOrReturnCtx(o), m = this._def.values;
        return (0, a.addIssueToContext)(p, {
          expected: y.util.joinValues(m),
          received: p.parsedType,
          code: d.ZodIssueCode.invalid_type
        }), a.INVALID;
      }
      if (e(this, n, "f") || r(this, n, new Set(this._def.values), "f"), !e(this, n, "f").has(o.data)) {
        const p = this._getOrReturnCtx(o), m = this._def.values;
        return (0, a.addIssueToContext)(p, {
          received: p.data,
          code: d.ZodIssueCode.invalid_enum_value,
          options: m
        }), a.INVALID;
      }
      return (0, a.OK)(o.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const o = {};
      for (const p of this._def.values)
        o[p] = p;
      return o;
    }
    get Values() {
      const o = {};
      for (const p of this._def.values)
        o[p] = p;
      return o;
    }
    get Enum() {
      const o = {};
      for (const p of this._def.values)
        o[p] = p;
      return o;
    }
    extract(o, p = this._def) {
      return dr.create(o, {
        ...this._def,
        ...p
      });
    }
    exclude(o, p = this._def) {
      return dr.create(this.options.filter((m) => !o.includes(m)), {
        ...this._def,
        ...p
      });
    }
  }
  t.ZodEnum = dr, n = /* @__PURE__ */ new WeakMap(), dr.create = Kl;
  class Yi extends C {
    constructor() {
      super(...arguments), s.set(this, void 0);
    }
    _parse(o) {
      const p = y.util.getValidEnumValues(this._def.values), m = this._getOrReturnCtx(o);
      if (m.parsedType !== y.ZodParsedType.string && m.parsedType !== y.ZodParsedType.number) {
        const E = y.util.objectValues(p);
        return (0, a.addIssueToContext)(m, {
          expected: y.util.joinValues(E),
          received: m.parsedType,
          code: d.ZodIssueCode.invalid_type
        }), a.INVALID;
      }
      if (e(this, s, "f") || r(this, s, new Set(y.util.getValidEnumValues(this._def.values)), "f"), !e(this, s, "f").has(o.data)) {
        const E = y.util.objectValues(p);
        return (0, a.addIssueToContext)(m, {
          received: m.data,
          code: d.ZodIssueCode.invalid_enum_value,
          options: E
        }), a.INVALID;
      }
      return (0, a.OK)(o.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  t.ZodNativeEnum = Yi, s = /* @__PURE__ */ new WeakMap(), Yi.create = (h, o) => new Yi({
    values: h,
    typeName: G.ZodNativeEnum,
    ...R(o)
  });
  class pi extends C {
    unwrap() {
      return this._def.type;
    }
    _parse(o) {
      const { ctx: p } = this._processInputParams(o);
      if (p.parsedType !== y.ZodParsedType.promise && p.common.async === !1)
        return (0, a.addIssueToContext)(p, {
          code: d.ZodIssueCode.invalid_type,
          expected: y.ZodParsedType.promise,
          received: p.parsedType
        }), a.INVALID;
      const m = p.parsedType === y.ZodParsedType.promise ? p.data : Promise.resolve(p.data);
      return (0, a.OK)(m.then((E) => this._def.type.parseAsync(E, {
        path: p.path,
        errorMap: p.common.contextualErrorMap
      })));
    }
  }
  t.ZodPromise = pi, pi.create = (h, o) => new pi({
    type: h,
    typeName: G.ZodPromise,
    ...R(o)
  });
  class nt extends C {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === G.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(o) {
      const { status: p, ctx: m } = this._processInputParams(o), E = this._def.effect || null, x = {
        addIssue: (L) => {
          (0, a.addIssueToContext)(m, L), L.fatal ? p.abort() : p.dirty();
        },
        get path() {
          return m.path;
        }
      };
      if (x.addIssue = x.addIssue.bind(x), E.type === "preprocess") {
        const L = E.transform(m.data, x);
        if (m.common.async)
          return Promise.resolve(L).then(async (_) => {
            if (p.value === "aborted")
              return a.INVALID;
            const j = await this._def.schema._parseAsync({
              data: _,
              path: m.path,
              parent: m
            });
            return j.status === "aborted" ? a.INVALID : j.status === "dirty" || p.value === "dirty" ? (0, a.DIRTY)(j.value) : j;
          });
        {
          if (p.value === "aborted")
            return a.INVALID;
          const _ = this._def.schema._parseSync({
            data: L,
            path: m.path,
            parent: m
          });
          return _.status === "aborted" ? a.INVALID : _.status === "dirty" || p.value === "dirty" ? (0, a.DIRTY)(_.value) : _;
        }
      }
      if (E.type === "refinement") {
        const L = (_) => {
          const j = E.refinement(_, x);
          if (m.common.async)
            return Promise.resolve(j);
          if (j instanceof Promise)
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          return _;
        };
        if (m.common.async === !1) {
          const _ = this._def.schema._parseSync({
            data: m.data,
            path: m.path,
            parent: m
          });
          return _.status === "aborted" ? a.INVALID : (_.status === "dirty" && p.dirty(), L(_.value), { status: p.value, value: _.value });
        } else
          return this._def.schema._parseAsync({ data: m.data, path: m.path, parent: m }).then((_) => _.status === "aborted" ? a.INVALID : (_.status === "dirty" && p.dirty(), L(_.value).then(() => ({ status: p.value, value: _.value }))));
      }
      if (E.type === "transform")
        if (m.common.async === !1) {
          const L = this._def.schema._parseSync({
            data: m.data,
            path: m.path,
            parent: m
          });
          if (!(0, a.isValid)(L))
            return L;
          const _ = E.transform(L.value, x);
          if (_ instanceof Promise)
            throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
          return { status: p.value, value: _ };
        } else
          return this._def.schema._parseAsync({ data: m.data, path: m.path, parent: m }).then((L) => (0, a.isValid)(L) ? Promise.resolve(E.transform(L.value, x)).then((_) => ({ status: p.value, value: _ })) : L);
      y.util.assertNever(E);
    }
  }
  t.ZodEffects = nt, t.ZodTransformer = nt, nt.create = (h, o, p) => new nt({
    schema: h,
    typeName: G.ZodEffects,
    effect: o,
    ...R(p)
  }), nt.createWithPreprocess = (h, o, p) => new nt({
    schema: o,
    effect: { type: "preprocess", transform: h },
    typeName: G.ZodEffects,
    ...R(p)
  });
  class mt extends C {
    _parse(o) {
      return this._getType(o) === y.ZodParsedType.undefined ? (0, a.OK)(void 0) : this._def.innerType._parse(o);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  t.ZodOptional = mt, mt.create = (h, o) => new mt({
    innerType: h,
    typeName: G.ZodOptional,
    ...R(o)
  });
  class fr extends C {
    _parse(o) {
      return this._getType(o) === y.ZodParsedType.null ? (0, a.OK)(null) : this._def.innerType._parse(o);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  t.ZodNullable = fr, fr.create = (h, o) => new fr({
    innerType: h,
    typeName: G.ZodNullable,
    ...R(o)
  });
  class en extends C {
    _parse(o) {
      const { ctx: p } = this._processInputParams(o);
      let m = p.data;
      return p.parsedType === y.ZodParsedType.undefined && (m = this._def.defaultValue()), this._def.innerType._parse({
        data: m,
        path: p.path,
        parent: p
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  t.ZodDefault = en, en.create = (h, o) => new en({
    innerType: h,
    typeName: G.ZodDefault,
    defaultValue: typeof o.default == "function" ? o.default : () => o.default,
    ...R(o)
  });
  class tn extends C {
    _parse(o) {
      const { ctx: p } = this._processInputParams(o), m = {
        ...p,
        common: {
          ...p.common,
          issues: []
        }
      }, E = this._def.innerType._parse({
        data: m.data,
        path: m.path,
        parent: {
          ...m
        }
      });
      return (0, a.isAsync)(E) ? E.then((x) => ({
        status: "valid",
        value: x.status === "valid" ? x.value : this._def.catchValue({
          get error() {
            return new d.ZodError(m.common.issues);
          },
          input: m.data
        })
      })) : {
        status: "valid",
        value: E.status === "valid" ? E.value : this._def.catchValue({
          get error() {
            return new d.ZodError(m.common.issues);
          },
          input: m.data
        })
      };
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  t.ZodCatch = tn, tn.create = (h, o) => new tn({
    innerType: h,
    typeName: G.ZodCatch,
    catchValue: typeof o.catch == "function" ? o.catch : () => o.catch,
    ...R(o)
  });
  class jo extends C {
    _parse(o) {
      if (this._getType(o) !== y.ZodParsedType.nan) {
        const m = this._getOrReturnCtx(o);
        return (0, a.addIssueToContext)(m, {
          code: d.ZodIssueCode.invalid_type,
          expected: y.ZodParsedType.nan,
          received: m.parsedType
        }), a.INVALID;
      }
      return { status: "valid", value: o.data };
    }
  }
  t.ZodNaN = jo, jo.create = (h) => new jo({
    typeName: G.ZodNaN,
    ...R(h)
  }), t.BRAND = Symbol("zod_brand");
  class Va extends C {
    _parse(o) {
      const { ctx: p } = this._processInputParams(o), m = p.data;
      return this._def.type._parse({
        data: m,
        path: p.path,
        parent: p
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  t.ZodBranded = Va;
  class rn extends C {
    _parse(o) {
      const { status: p, ctx: m } = this._processInputParams(o);
      if (m.common.async)
        return (async () => {
          const x = await this._def.in._parseAsync({
            data: m.data,
            path: m.path,
            parent: m
          });
          return x.status === "aborted" ? a.INVALID : x.status === "dirty" ? (p.dirty(), (0, a.DIRTY)(x.value)) : this._def.out._parseAsync({
            data: x.value,
            path: m.path,
            parent: m
          });
        })();
      {
        const E = this._def.in._parseSync({
          data: m.data,
          path: m.path,
          parent: m
        });
        return E.status === "aborted" ? a.INVALID : E.status === "dirty" ? (p.dirty(), {
          status: "dirty",
          value: E.value
        }) : this._def.out._parseSync({
          data: E.value,
          path: m.path,
          parent: m
        });
      }
    }
    static create(o, p) {
      return new rn({
        in: o,
        out: p,
        typeName: G.ZodPipeline
      });
    }
  }
  t.ZodPipeline = rn;
  class nn extends C {
    _parse(o) {
      const p = this._def.innerType._parse(o), m = (E) => ((0, a.isValid)(E) && (E.value = Object.freeze(E.value)), E);
      return (0, a.isAsync)(p) ? p.then((E) => m(E)) : m(p);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  t.ZodReadonly = nn, nn.create = (h, o) => new nn({
    innerType: h,
    typeName: G.ZodReadonly,
    ...R(o)
  });
  function Ul(h, o = {}, p) {
    return h ? li.create().superRefine((m, E) => {
      var x, L;
      if (!h(m)) {
        const _ = typeof o == "function" ? o(m) : typeof o == "string" ? { message: o } : o, j = (L = (x = _.fatal) !== null && x !== void 0 ? x : p) !== null && L !== void 0 ? L : !0, O = typeof _ == "string" ? { message: _ } : _;
        E.addIssue({ code: "custom", ...O, fatal: j });
      }
    }) : li.create();
  }
  t.custom = Ul, t.late = {
    object: se.lazycreate
  };
  var G;
  (function(h) {
    h.ZodString = "ZodString", h.ZodNumber = "ZodNumber", h.ZodNaN = "ZodNaN", h.ZodBigInt = "ZodBigInt", h.ZodBoolean = "ZodBoolean", h.ZodDate = "ZodDate", h.ZodSymbol = "ZodSymbol", h.ZodUndefined = "ZodUndefined", h.ZodNull = "ZodNull", h.ZodAny = "ZodAny", h.ZodUnknown = "ZodUnknown", h.ZodNever = "ZodNever", h.ZodVoid = "ZodVoid", h.ZodArray = "ZodArray", h.ZodObject = "ZodObject", h.ZodUnion = "ZodUnion", h.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", h.ZodIntersection = "ZodIntersection", h.ZodTuple = "ZodTuple", h.ZodRecord = "ZodRecord", h.ZodMap = "ZodMap", h.ZodSet = "ZodSet", h.ZodFunction = "ZodFunction", h.ZodLazy = "ZodLazy", h.ZodLiteral = "ZodLiteral", h.ZodEnum = "ZodEnum", h.ZodEffects = "ZodEffects", h.ZodNativeEnum = "ZodNativeEnum", h.ZodOptional = "ZodOptional", h.ZodNullable = "ZodNullable", h.ZodDefault = "ZodDefault", h.ZodCatch = "ZodCatch", h.ZodPromise = "ZodPromise", h.ZodBranded = "ZodBranded", h.ZodPipeline = "ZodPipeline", h.ZodReadonly = "ZodReadonly";
  })(G = t.ZodFirstPartyTypeKind || (t.ZodFirstPartyTypeKind = {}));
  const ry = (h, o = {
    message: `Input not instance of ${h.name}`
  }) => Ul((p) => p instanceof h, o);
  t.instanceof = ry;
  const Vl = rt.create;
  t.string = Vl;
  const Il = cr.create;
  t.number = Il;
  const iy = jo.create;
  t.nan = iy;
  const ny = pr.create;
  t.bigint = ny;
  const jl = Fi.create;
  t.boolean = jl;
  const sy = Pr.create;
  t.date = sy;
  const oy = Ko.create;
  t.symbol = oy;
  const ay = zi.create;
  t.undefined = ay;
  const ly = Xi.create;
  t.null = ly;
  const uy = li.create;
  t.any = uy;
  const cy = Dr.create;
  t.unknown = cy;
  const py = jt.create;
  t.never = py;
  const dy = Uo.create;
  t.void = dy;
  const fy = it.create;
  t.array = fy;
  const yy = se.create;
  t.object = yy;
  const my = se.strictCreate;
  t.strictObject = my;
  const by = Zi.create;
  t.union = by;
  const hy = Vo.create;
  t.discriminatedUnion = hy;
  const Ey = Hi.create;
  t.intersection = Ey;
  const xy = yt.create;
  t.tuple = xy;
  const gy = Wi.create;
  t.record = gy;
  const Ry = Io.create;
  t.map = Ry;
  const vy = Kr.create;
  t.set = vy;
  const Ay = ci.create;
  t.function = Ay;
  const wy = Ji.create;
  t.lazy = wy;
  const Cy = Qi.create;
  t.literal = Cy;
  const _y = dr.create;
  t.enum = _y;
  const Ty = Yi.create;
  t.nativeEnum = Ty;
  const Sy = pi.create;
  t.promise = Sy;
  const Ol = nt.create;
  t.effect = Ol, t.transformer = Ol;
  const Ly = mt.create;
  t.optional = Ly;
  const ky = fr.create;
  t.nullable = ky;
  const By = nt.createWithPreprocess;
  t.preprocess = By;
  const Py = rn.create;
  t.pipeline = Py;
  const Dy = () => Vl().optional();
  t.ostring = Dy;
  const Ky = () => Il().optional();
  t.onumber = Ky;
  const Uy = () => jl().optional();
  t.oboolean = Uy, t.coerce = {
    string: (h) => rt.create({ ...h, coerce: !0 }),
    number: (h) => cr.create({ ...h, coerce: !0 }),
    boolean: (h) => Fi.create({
      ...h,
      coerce: !0
    }),
    bigint: (h) => pr.create({ ...h, coerce: !0 }),
    date: (h) => Pr.create({ ...h, coerce: !0 })
  }, t.NEVER = a.INVALID;
})(hc);
(function(t) {
  var e = S && S.__createBinding || (Object.create ? function(n, s, u, c) {
    c === void 0 && (c = u), Object.defineProperty(n, c, { enumerable: !0, get: function() {
      return s[u];
    } });
  } : function(n, s, u, c) {
    c === void 0 && (c = u), n[c] = s[u];
  }), r = S && S.__exportStar || function(n, s) {
    for (var u in n) u !== "default" && !Object.prototype.hasOwnProperty.call(s, u) && e(s, n, u);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), r(Tt, t), r(cl, t), r(bc, t), r(bn, t), r(hc, t), r(St, t);
})(el);
(function(t) {
  var e = S && S.__createBinding || (Object.create ? function(c, a, y, d) {
    d === void 0 && (d = y), Object.defineProperty(c, d, { enumerable: !0, get: function() {
      return a[y];
    } });
  } : function(c, a, y, d) {
    d === void 0 && (d = y), c[d] = a[y];
  }), r = S && S.__setModuleDefault || (Object.create ? function(c, a) {
    Object.defineProperty(c, "default", { enumerable: !0, value: a });
  } : function(c, a) {
    c.default = a;
  }), n = S && S.__importStar || function(c) {
    if (c && c.__esModule) return c;
    var a = {};
    if (c != null) for (var y in c) y !== "default" && Object.prototype.hasOwnProperty.call(c, y) && e(a, c, y);
    return r(a, c), a;
  }, s = S && S.__exportStar || function(c, a) {
    for (var y in c) y !== "default" && !Object.prototype.hasOwnProperty.call(a, y) && e(a, c, y);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.z = void 0;
  const u = n(el);
  t.z = u, s(el, t), t.default = u;
})(ai);
var Lt = {};
Object.defineProperty(Lt, "__esModule", { value: !0 });
Lt.requiredPropertiesRefinement = Lt.toConcreteTypes = Lt.toLexUri = void 0;
const Na = ai;
function Em(t, e) {
  if (t.split("#").length > 2)
    throw new Error("Uri can only have one hash segment");
  if (t.startsWith("lex:"))
    return t;
  if (t.startsWith("#")) {
    if (!e)
      throw new Error(`Unable to resolve uri without anchor: ${t}`);
    return `${e}${t}`;
  }
  return `lex:${t}`;
}
Lt.toLexUri = Em;
function xm(t, e) {
  return e.type === "ref" ? [t.getDefOrThrow(e.ref)] : e.type === "union" ? e.refs.map((r) => t.getDefOrThrow(r)).flat() : [e];
}
Lt.toConcreteTypes = xm;
function gm(t, e) {
  if (t.required !== void 0) {
    if (!Array.isArray(t.required)) {
      e.addIssue({
        code: Na.z.ZodIssueCode.invalid_type,
        received: typeof t.required,
        expected: "array"
      });
      return;
    }
    if (t.properties === void 0) {
      t.required.length > 0 && e.addIssue({
        code: Na.z.ZodIssueCode.custom,
        message: "Required fields defined but no properties defined"
      });
      return;
    }
    for (const r of t.required)
      t.properties[r] === void 0 && e.addIssue({
        code: Na.z.ZodIssueCode.custom,
        message: `Required field "${r}" not defined`
      });
  }
}
Lt.requiredPropertiesRefinement = gm;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.LexiconDefNotFoundError = t.InvalidLexiconError = t.ValidationError = t.parseLexiconDoc = t.isDiscriminatedObject = t.discriminatedObject = t.hasProp = t.isObj = t.isValidLexiconDoc = t.lexiconDoc = t.lexUserType = t.lexRecord = t.lexXrpcSubscription = t.lexXrpcProcedure = t.lexXrpcQuery = t.lexXrpcError = t.lexXrpcSubscriptionMessage = t.lexXrpcBody = t.lexXrpcParameters = t.lexObject = t.lexToken = t.lexPrimitiveArray = t.lexArray = t.lexBlob = t.lexRefVariant = t.lexRefUnion = t.lexRef = t.lexIpldType = t.lexCidLink = t.lexBytes = t.lexPrimitive = t.lexUnknown = t.lexString = t.lexStringFormat = t.lexInteger = t.lexBoolean = void 0;
  const e = ai, r = oi, n = Lt;
  t.lexBoolean = e.z.object({
    type: e.z.literal("boolean"),
    description: e.z.string().optional(),
    default: e.z.boolean().optional(),
    const: e.z.boolean().optional()
  }).strict(), t.lexInteger = e.z.object({
    type: e.z.literal("integer"),
    description: e.z.string().optional(),
    default: e.z.number().int().optional(),
    minimum: e.z.number().int().optional(),
    maximum: e.z.number().int().optional(),
    enum: e.z.number().int().array().optional(),
    const: e.z.number().int().optional()
  }).strict(), t.lexStringFormat = e.z.enum([
    "datetime",
    "uri",
    "at-uri",
    "did",
    "handle",
    "at-identifier",
    "nsid",
    "cid",
    "language",
    "tid",
    "record-key"
  ]), t.lexString = e.z.object({
    type: e.z.literal("string"),
    format: t.lexStringFormat.optional(),
    description: e.z.string().optional(),
    default: e.z.string().optional(),
    minLength: e.z.number().int().optional(),
    maxLength: e.z.number().int().optional(),
    minGraphemes: e.z.number().int().optional(),
    maxGraphemes: e.z.number().int().optional(),
    enum: e.z.string().array().optional(),
    const: e.z.string().optional(),
    knownValues: e.z.string().array().optional()
  }).strict(), t.lexUnknown = e.z.object({
    type: e.z.literal("unknown"),
    description: e.z.string().optional()
  }).strict(), t.lexPrimitive = e.z.discriminatedUnion("type", [
    t.lexBoolean,
    t.lexInteger,
    t.lexString,
    t.lexUnknown
  ]), t.lexBytes = e.z.object({
    type: e.z.literal("bytes"),
    description: e.z.string().optional(),
    maxLength: e.z.number().optional(),
    minLength: e.z.number().optional()
  }).strict(), t.lexCidLink = e.z.object({
    type: e.z.literal("cid-link"),
    description: e.z.string().optional()
  }).strict(), t.lexIpldType = e.z.discriminatedUnion("type", [t.lexBytes, t.lexCidLink]), t.lexRef = e.z.object({
    type: e.z.literal("ref"),
    description: e.z.string().optional(),
    ref: e.z.string()
  }).strict(), t.lexRefUnion = e.z.object({
    type: e.z.literal("union"),
    description: e.z.string().optional(),
    refs: e.z.string().array(),
    closed: e.z.boolean().optional()
  }).strict(), t.lexRefVariant = e.z.discriminatedUnion("type", [t.lexRef, t.lexRefUnion]), t.lexBlob = e.z.object({
    type: e.z.literal("blob"),
    description: e.z.string().optional(),
    accept: e.z.string().array().optional(),
    maxSize: e.z.number().optional()
  }).strict(), t.lexArray = e.z.object({
    type: e.z.literal("array"),
    description: e.z.string().optional(),
    items: e.z.union([t.lexPrimitive, t.lexIpldType, t.lexBlob, t.lexRefVariant]),
    minLength: e.z.number().int().optional(),
    maxLength: e.z.number().int().optional()
  }).strict(), t.lexPrimitiveArray = t.lexArray.merge(e.z.object({
    items: t.lexPrimitive
  }).strict()), t.lexToken = e.z.object({
    type: e.z.literal("token"),
    description: e.z.string().optional()
  }).strict(), t.lexObject = e.z.object({
    type: e.z.literal("object"),
    description: e.z.string().optional(),
    required: e.z.string().array().optional(),
    nullable: e.z.string().array().optional(),
    properties: e.z.record(e.z.union([t.lexRefVariant, t.lexIpldType, t.lexArray, t.lexBlob, t.lexPrimitive]))
  }).strict().superRefine(n.requiredPropertiesRefinement), t.lexXrpcParameters = e.z.object({
    type: e.z.literal("params"),
    description: e.z.string().optional(),
    required: e.z.string().array().optional(),
    properties: e.z.record(e.z.union([t.lexPrimitive, t.lexPrimitiveArray]))
  }).strict().superRefine(n.requiredPropertiesRefinement), t.lexXrpcBody = e.z.object({
    description: e.z.string().optional(),
    encoding: e.z.string(),
    schema: e.z.union([t.lexRefVariant, t.lexObject]).optional()
  }).strict(), t.lexXrpcSubscriptionMessage = e.z.object({
    description: e.z.string().optional(),
    schema: e.z.union([t.lexRefVariant, t.lexObject]).optional()
  }).strict(), t.lexXrpcError = e.z.object({
    name: e.z.string(),
    description: e.z.string().optional()
  }).strict(), t.lexXrpcQuery = e.z.object({
    type: e.z.literal("query"),
    description: e.z.string().optional(),
    parameters: t.lexXrpcParameters.optional(),
    output: t.lexXrpcBody.optional(),
    errors: t.lexXrpcError.array().optional()
  }).strict(), t.lexXrpcProcedure = e.z.object({
    type: e.z.literal("procedure"),
    description: e.z.string().optional(),
    parameters: t.lexXrpcParameters.optional(),
    input: t.lexXrpcBody.optional(),
    output: t.lexXrpcBody.optional(),
    errors: t.lexXrpcError.array().optional()
  }).strict(), t.lexXrpcSubscription = e.z.object({
    type: e.z.literal("subscription"),
    description: e.z.string().optional(),
    parameters: t.lexXrpcParameters.optional(),
    message: t.lexXrpcSubscriptionMessage.optional(),
    errors: t.lexXrpcError.array().optional()
  }).strict(), t.lexRecord = e.z.object({
    type: e.z.literal("record"),
    description: e.z.string().optional(),
    key: e.z.string().optional(),
    record: t.lexObject
  }).strict(), t.lexUserType = e.z.custom((R) => {
    if (!(!R || typeof R != "object") && R.type !== void 0)
      switch (R.type) {
        case "record":
          return t.lexRecord.parse(R);
        case "query":
          return t.lexXrpcQuery.parse(R);
        case "procedure":
          return t.lexXrpcProcedure.parse(R);
        case "subscription":
          return t.lexXrpcSubscription.parse(R);
        case "blob":
          return t.lexBlob.parse(R);
        case "array":
          return t.lexArray.parse(R);
        case "token":
          return t.lexToken.parse(R);
        case "object":
          return t.lexObject.parse(R);
        case "boolean":
          return t.lexBoolean.parse(R);
        case "integer":
          return t.lexInteger.parse(R);
        case "string":
          return t.lexString.parse(R);
        case "bytes":
          return t.lexBytes.parse(R);
        case "cid-link":
          return t.lexCidLink.parse(R);
        case "unknown":
          return t.lexUnknown.parse(R);
      }
  }, (R) => !R || typeof R != "object" ? {
    message: "Must be an object",
    fatal: !0
  } : R.type === void 0 ? {
    message: "Must have a type",
    fatal: !0
  } : {
    message: `Invalid type: ${R.type} must be one of: record, query, procedure, subscription, blob, array, token, object, boolean, integer, string, bytes, cid-link, unknown`,
    fatal: !0
  }), t.lexiconDoc = e.z.object({
    lexicon: e.z.literal(1),
    id: e.z.string().refine((R) => r.NSID.isValid(R), {
      message: "Must be a valid NSID"
    }),
    revision: e.z.number().optional(),
    description: e.z.string().optional(),
    defs: e.z.record(t.lexUserType)
  }).strict().superRefine((R, C) => {
    for (const D in R.defs) {
      const U = R.defs[D];
      D !== "main" && (U.type === "record" || U.type === "procedure" || U.type === "query" || U.type === "subscription") && C.addIssue({
        code: e.z.ZodIssueCode.custom,
        message: "Records, procedures, queries, and subscriptions must be the main definition."
      });
    }
  });
  function s(R) {
    return t.lexiconDoc.safeParse(R).success;
  }
  t.isValidLexiconDoc = s;
  function u(R) {
    return R !== null && typeof R == "object";
  }
  t.isObj = u;
  function c(R, C) {
    return C in R;
  }
  t.hasProp = c, t.discriminatedObject = e.z.object({ $type: e.z.string() });
  function a(R) {
    return t.discriminatedObject.safeParse(R).success;
  }
  t.isDiscriminatedObject = a;
  function y(R) {
    return t.lexiconDoc.parse(R), R;
  }
  t.parseLexiconDoc = y;
  class d extends Error {
  }
  t.ValidationError = d;
  class b extends Error {
  }
  t.InvalidLexiconError = b;
  class g extends Error {
  }
  t.LexiconDefNotFoundError = g;
})(Tr);
var ba = {}, Ye = {}, tt = {}, ha = {}, Ea = {}, Vt = {}, xr = {};
Object.defineProperty(xr, "__esModule", { value: !0 });
xr.isObject = xr.assure = xr.is = void 0;
const Rm = (t, e) => e.safeParse(t).success;
xr.is = Rm;
const vm = (t, e) => t.parse(e);
xr.assure = vm;
const Am = (t) => typeof t == "object" && t !== null;
xr.isObject = Am;
var Ei = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.parseIntWithFallback = t.dedupeStrs = t.range = t.chunkArray = t.errHasMsg = t.isErrnoException = t.asyncFilter = t.s32decode = t.s32encode = t.streamToBuffer = t.flattenUint8Arrays = t.bailableWait = t.wait = t.jitter = t.noUndefinedVals = void 0;
  const e = (A) => (Object.keys(A).forEach((T) => {
    A[T] === void 0 && delete A[T];
  }), A);
  t.noUndefinedVals = e;
  const r = (A) => Math.round((Math.random() - 0.5) * A * 2);
  t.jitter = r;
  const n = (A) => new Promise((T) => setTimeout(T, A));
  t.wait = n;
  const s = (A) => {
    let T;
    const V = new Promise((I) => {
      const X = setTimeout(I, A);
      T = () => {
        clearTimeout(X), I();
      };
    });
    return { bail: T, wait: () => V };
  };
  t.bailableWait = s;
  const u = (A) => {
    const T = A.reduce((X, q) => X + q.length, 0), V = new Uint8Array(T);
    let I = 0;
    return A.forEach((X) => {
      V.set(X, I), I += X.length;
    }), V;
  };
  t.flattenUint8Arrays = u;
  const c = async (A) => {
    const T = [];
    for await (const V of A)
      T.push(V);
    return (0, t.flattenUint8Arrays)(T);
  };
  t.streamToBuffer = c;
  const a = "234567abcdefghijklmnopqrstuvwxyz", y = (A) => {
    let T = "";
    for (; A; ) {
      const V = A % 32;
      A = Math.floor(A / 32), T = a.charAt(V) + T;
    }
    return T;
  };
  t.s32encode = y;
  const d = (A) => {
    let T = 0;
    for (const V of A)
      T = T * 32 + a.indexOf(V);
    return T;
  };
  t.s32decode = d;
  const b = async (A, T) => {
    const V = await Promise.all(A.map((I) => T(I)));
    return A.filter((I, X) => V[X]);
  };
  t.asyncFilter = b;
  const g = (A) => !!A && A.code;
  t.isErrnoException = g;
  const R = (A, T) => !!A && typeof A == "object" && A.message === T;
  t.errHasMsg = R;
  const C = (A, T) => A.reduce((V, I, X) => {
    const q = Math.floor(X / T);
    return V[q] || (V[q] = []), V[q].push(I), V;
  }, []);
  t.chunkArray = C;
  const D = (A) => {
    const T = [];
    for (let V = 0; V < A; V++)
      T.push(V);
    return T;
  };
  t.range = D;
  const U = (A) => [...new Set(A)];
  t.dedupeStrs = U;
  const K = (A, T) => {
    const V = parseInt(A || "", 10);
    return isNaN(V) ? T : V;
  };
  t.parseIntWithFallback = K;
})(Ei);
var xi = {};
Object.defineProperty(xi, "__esModule", { value: !0 });
xi.mapDefined = xi.keyBy = void 0;
const wm = (t, e) => t.reduce((r, n) => (r[n[e]] = n, r), {});
xi.keyBy = wm;
const Cm = (t, e) => {
  const r = [];
  for (const n of t) {
    const s = e(n);
    s !== void 0 && r.push(s);
  }
  return r;
};
xi.mapDefined = Cm;
var xc = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.handleAllSettledErrors = t.AsyncBufferFullError = t.AsyncBuffer = t.allComplete = t.createDeferrables = t.createDeferrable = t.readFromGenerator = void 0;
  const e = Ei, r = async (b, g, R = Promise.resolve(), C = Number.MAX_SAFE_INTEGER) => {
    const D = [];
    let U, K = !1;
    const A = async () => {
      if (await g(D.at(-1)))
        return !0;
      const V = (0, e.bailableWait)(20);
      return await V.wait(), U = V.bail, K ? !1 : await A();
    }, T = new Promise((V) => {
      R.then(() => {
        A().then(() => V());
      });
    });
    try {
      for (; D.length < C; ) {
        const V = await Promise.race([b.next(), T]);
        if (!V)
          break;
        const I = V;
        if (I.done)
          break;
        D.push(I.value);
      }
    } finally {
      K = !0, U && U();
    }
    return D;
  };
  t.readFromGenerator = r;
  const n = () => {
    let b;
    const g = new Promise((R) => {
      b = () => R();
    });
    return { resolve: b, complete: g };
  };
  t.createDeferrable = n;
  const s = (b) => {
    const g = [];
    for (let R = 0; R < b; R++)
      g.push((0, t.createDeferrable)());
    return g;
  };
  t.createDeferrables = s;
  const u = async (b) => {
    await Promise.all(b.map((g) => g.complete));
  };
  t.allComplete = u;
  class c {
    constructor(g) {
      Object.defineProperty(this, "maxSize", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: g
      }), Object.defineProperty(this, "buffer", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: []
      }), Object.defineProperty(this, "promise", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "resolve", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "closed", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: !1
      }), Object.defineProperty(this, "toThrow", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), this.promise = Promise.resolve(), this.resolve = () => null, this.resetPromise();
    }
    get curr() {
      return this.buffer;
    }
    get size() {
      return this.buffer.length;
    }
    get isClosed() {
      return this.closed;
    }
    resetPromise() {
      this.promise = new Promise((g) => this.resolve = g);
    }
    push(g) {
      this.buffer.push(g), this.resolve();
    }
    pushMany(g) {
      g.forEach((R) => this.buffer.push(R)), this.resolve();
    }
    async *events() {
      for (; ; ) {
        if (this.closed && this.buffer.length === 0) {
          if (this.toThrow)
            throw this.toThrow;
          return;
        }
        if (await this.promise, this.toThrow)
          throw this.toThrow;
        if (this.maxSize && this.size > this.maxSize)
          throw new a(this.maxSize);
        const [g, ...R] = this.buffer;
        g ? (this.buffer = R, yield g) : this.resetPromise();
      }
    }
    throw(g) {
      this.toThrow = g, this.closed = !0, this.resolve();
    }
    close() {
      this.closed = !0, this.resolve();
    }
  }
  t.AsyncBuffer = c;
  class a extends Error {
    constructor(g) {
      super(`ReachedMaxBufferSize: ${g}`);
    }
  }
  t.AsyncBufferFullError = a;
  const y = (b) => {
    const g = b.filter(d).map((R) => R.reason);
    if (g.length !== 0)
      throw g.length === 1 ? g[0] : new AggregateError(g, "Multiple errors: " + g.map((R) => R?.message).join(`
`));
  };
  t.handleAllSettledErrors = y;
  const d = (b) => b.status === "rejected";
})(xc);
var hn = {};
Object.defineProperty(hn, "__esModule", { value: !0 });
hn.TID = void 0;
const Mo = Ei, Fl = 13;
let $a = 0, zl = 0, No = null;
function Xl(t) {
  return t.replaceAll("-", "");
}
class qt {
  constructor(e) {
    Object.defineProperty(this, "str", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const r = Xl(e);
    if (r.length !== Fl)
      throw new Error(`Poorly formatted TID: ${r.length} length`);
    this.str = r;
  }
  static next(e) {
    const r = Math.max(Date.now(), $a);
    r === $a && zl++, $a = r;
    const n = r * 1e3 + zl;
    No === null && (No = Math.floor(Math.random() * 32));
    const s = qt.fromTime(n, No);
    return !e || s.newerThan(e) ? s : qt.fromTime(e.timestamp() + 1, No);
  }
  static nextStr(e) {
    return qt.next(e ? new qt(e) : void 0).toString();
  }
  static fromTime(e, r) {
    const n = `${(0, Mo.s32encode)(e)}${(0, Mo.s32encode)(r).padStart(2, "2")}`;
    return new qt(n);
  }
  static fromStr(e) {
    return new qt(e);
  }
  static oldestFirst(e, r) {
    return e.compareTo(r);
  }
  static newestFirst(e, r) {
    return r.compareTo(e);
  }
  static is(e) {
    return Xl(e).length === Fl;
  }
  timestamp() {
    return (0, Mo.s32decode)(this.str.slice(0, 11));
  }
  clockid() {
    return (0, Mo.s32decode)(this.str.slice(11, 13));
  }
  formatted() {
    const e = this.toString();
    return `${e.slice(0, 4)}-${e.slice(4, 7)}-${e.slice(7, 11)}-${e.slice(11, 13)}`;
  }
  toString() {
    return this.str;
  }
  // newer > older
  compareTo(e) {
    return this.str > e.str ? 1 : this.str < e.str ? -1 : 0;
  }
  equals(e) {
    return this.str === e.str;
  }
  newerThan(e) {
    return this.compareTo(e) > 0;
  }
  olderThan(e) {
    return this.compareTo(e) < 0;
  }
}
hn.TID = qt;
hn.default = qt;
var gc = {}, _m = Rc, Zl = 128, Tm = 127, Sm = ~Tm, Lm = Math.pow(2, 31);
function Rc(t, e, r) {
  e = e || [], r = r || 0;
  for (var n = r; t >= Lm; )
    e[r++] = t & 255 | Zl, t /= 128;
  for (; t & Sm; )
    e[r++] = t & 255 | Zl, t >>>= 7;
  return e[r] = t | 0, Rc.bytes = r - n + 1, e;
}
var km = tl, Bm = 128, Hl = 127;
function tl(t, n) {
  var r = 0, n = n || 0, s = 0, u = n, c, a = t.length;
  do {
    if (u >= a)
      throw tl.bytes = 0, new RangeError("Could not decode varint");
    c = t[u++], r += s < 28 ? (c & Hl) << s : (c & Hl) * Math.pow(2, s), s += 7;
  } while (c >= Bm);
  return tl.bytes = u - n, r;
}
var Pm = Math.pow(2, 7), Dm = Math.pow(2, 14), Km = Math.pow(2, 21), Um = Math.pow(2, 28), Vm = Math.pow(2, 35), Im = Math.pow(2, 42), jm = Math.pow(2, 49), Om = Math.pow(2, 56), Mm = Math.pow(2, 63), Nm = function(t) {
  return t < Pm ? 1 : t < Dm ? 2 : t < Km ? 3 : t < Um ? 4 : t < Vm ? 5 : t < Im ? 6 : t < jm ? 7 : t < Om ? 8 : t < Mm ? 9 : 10;
}, $m = {
  encode: _m,
  decode: km,
  encodingLength: Nm
}, ea = $m;
const rl = (t, e = 0) => [
  ea.decode(t, e),
  ea.decode.bytes
], ta = (t, e, r = 0) => (ea.encode(t, e, r), e), ra = (t) => ea.encodingLength(t), Gm = (t, e) => {
  if (t === e)
    return !0;
  if (t.byteLength !== e.byteLength)
    return !1;
  for (let r = 0; r < t.byteLength; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}, pl = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
    return t;
  if (t instanceof ArrayBuffer)
    return new Uint8Array(t);
  if (ArrayBuffer.isView(t))
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, qm = (t) => new TextEncoder().encode(t), Fm = (t) => new TextDecoder().decode(t), zm = (t, e) => {
  const r = e.byteLength, n = ra(t), s = n + ra(r), u = new Uint8Array(s + r);
  return ta(t, u, 0), ta(r, u, n), u.set(e, s), new dl(t, r, e, u);
}, Xm = (t) => {
  const e = pl(t), [r, n] = rl(e), [s, u] = rl(e.subarray(n)), c = e.subarray(n + u);
  if (c.byteLength !== s)
    throw new Error("Incorrect length");
  return new dl(r, s, c, e);
}, Zm = (t, e) => t === e ? !0 : t.code === e.code && t.size === e.size && Gm(t.bytes, e.bytes);
class dl {
  constructor(e, r, n, s) {
    this.code = e, this.size = r, this.digest = n, this.bytes = s;
  }
}
function Hm(t, e) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), n = 0; n < r.length; n++)
    r[n] = 255;
  for (var s = 0; s < t.length; s++) {
    var u = t.charAt(s), c = u.charCodeAt(0);
    if (r[c] !== 255)
      throw new TypeError(u + " is ambiguous");
    r[c] = s;
  }
  var a = t.length, y = t.charAt(0), d = Math.log(a) / Math.log(256), b = Math.log(256) / Math.log(a);
  function g(D) {
    if (D instanceof Uint8Array || (ArrayBuffer.isView(D) ? D = new Uint8Array(D.buffer, D.byteOffset, D.byteLength) : Array.isArray(D) && (D = Uint8Array.from(D))), !(D instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (D.length === 0)
      return "";
    for (var U = 0, K = 0, A = 0, T = D.length; A !== T && D[A] === 0; )
      A++, U++;
    for (var V = (T - A) * b + 1 >>> 0, I = new Uint8Array(V); A !== T; ) {
      for (var X = D[A], q = 0, W = V - 1; (X !== 0 || q < K) && W !== -1; W--, q++)
        X += 256 * I[W] >>> 0, I[W] = X % a >>> 0, X = X / a >>> 0;
      if (X !== 0)
        throw new Error("Non-zero carry");
      K = q, A++;
    }
    for (var ee = V - K; ee !== V && I[ee] === 0; )
      ee++;
    for (var ve = y.repeat(U); ee < V; ++ee)
      ve += t.charAt(I[ee]);
    return ve;
  }
  function R(D) {
    if (typeof D != "string")
      throw new TypeError("Expected String");
    if (D.length === 0)
      return new Uint8Array();
    var U = 0;
    if (D[U] !== " ") {
      for (var K = 0, A = 0; D[U] === y; )
        K++, U++;
      for (var T = (D.length - U) * d + 1 >>> 0, V = new Uint8Array(T); D[U]; ) {
        var I = r[D.charCodeAt(U)];
        if (I === 255)
          return;
        for (var X = 0, q = T - 1; (I !== 0 || X < A) && q !== -1; q--, X++)
          I += a * V[q] >>> 0, V[q] = I % 256 >>> 0, I = I / 256 >>> 0;
        if (I !== 0)
          throw new Error("Non-zero carry");
        A = X, U++;
      }
      if (D[U] !== " ") {
        for (var W = T - A; W !== T && V[W] === 0; )
          W++;
        for (var ee = new Uint8Array(K + (T - W)), ve = K; W !== T; )
          ee[ve++] = V[W++];
        return ee;
      }
    }
  }
  function C(D) {
    var U = R(D);
    if (U)
      return U;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: g,
    decodeUnsafe: R,
    decode: C
  };
}
var Wm = Hm, Jm = Wm;
class Qm {
  constructor(e, r, n) {
    this.name = e, this.prefix = r, this.baseEncode = n;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Ym {
  constructor(e, r, n) {
    if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = r.codePointAt(0), this.baseDecode = n;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return vc(this, e);
  }
}
class eb {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return vc(this, e);
  }
  decode(e) {
    const r = e[0], n = this.decoders[r];
    if (n)
      return n.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const vc = (t, e) => new eb({
  ...t.decoders || { [t.prefix]: t },
  ...e.decoders || { [e.prefix]: e }
});
class tb {
  constructor(e, r, n, s) {
    this.name = e, this.prefix = r, this.baseEncode = n, this.baseDecode = s, this.encoder = new Qm(e, r, n), this.decoder = new Ym(e, r, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const xa = ({ name: t, prefix: e, encode: r, decode: n }) => new tb(t, e, r, n), En = ({ prefix: t, name: e, alphabet: r }) => {
  const { encode: n, decode: s } = Jm(r, e);
  return xa({
    prefix: t,
    name: e,
    encode: n,
    decode: (u) => pl(s(u))
  });
}, rb = (t, e, r, n) => {
  const s = {};
  for (let b = 0; b < e.length; ++b)
    s[e[b]] = b;
  let u = t.length;
  for (; t[u - 1] === "="; )
    --u;
  const c = new Uint8Array(u * r / 8 | 0);
  let a = 0, y = 0, d = 0;
  for (let b = 0; b < u; ++b) {
    const g = s[t[b]];
    if (g === void 0)
      throw new SyntaxError(`Non-${n} character`);
    y = y << r | g, a += r, a >= 8 && (a -= 8, c[d++] = 255 & y >> a);
  }
  if (a >= r || 255 & y << 8 - a)
    throw new SyntaxError("Unexpected end of data");
  return c;
}, ib = (t, e, r) => {
  const n = e[e.length - 1] === "=", s = (1 << r) - 1;
  let u = "", c = 0, a = 0;
  for (let y = 0; y < t.length; ++y)
    for (a = a << 8 | t[y], c += 8; c > r; )
      c -= r, u += e[s & a >> c];
  if (c && (u += e[s & a << r - c]), n)
    for (; u.length * r & 7; )
      u += "=";
  return u;
}, _e = ({ name: t, prefix: e, bitsPerChar: r, alphabet: n }) => xa({
  prefix: e,
  name: t,
  encode(s) {
    return ib(s, n, r);
  },
  decode(s) {
    return rb(s, n, r, t);
  }
}), Ft = En({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), nb = En({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), sb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: Ft,
  base58flickr: nb
}, Symbol.toStringTag, { value: "Module" })), cn = _e({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), ob = _e({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), ab = _e({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), lb = _e({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), ub = _e({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), cb = _e({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), pb = _e({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), db = _e({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), fb = _e({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), yb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: cn,
  base32hex: ub,
  base32hexpad: pb,
  base32hexpadupper: db,
  base32hexupper: cb,
  base32pad: ab,
  base32padupper: lb,
  base32upper: ob,
  base32z: fb
}, Symbol.toStringTag, { value: "Module" }));
class Se {
  constructor(e, r, n, s) {
    this.code = r, this.version = e, this.multihash = n, this.bytes = s, this.byteOffset = s.byteOffset, this.byteLength = s.byteLength, this.asCID = this, this._baseCache = /* @__PURE__ */ new Map(), Object.defineProperties(this, {
      byteOffset: Go,
      byteLength: Go,
      code: $o,
      version: $o,
      multihash: $o,
      bytes: $o,
      _baseCache: Go,
      asCID: Go
    });
  }
  toV0() {
    switch (this.version) {
      case 0:
        return this;
      default: {
        const { code: e, multihash: r } = this;
        if (e !== sn)
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        if (r.code !== Eb)
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        return Se.createV0(r);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: e, digest: r } = this.multihash, n = zm(e, r);
        return Se.createV1(this.code, n);
      }
      case 1:
        return this;
      default:
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
    }
  }
  equals(e) {
    return e && this.code === e.code && this.version === e.version && Zm(this.multihash, e.multihash);
  }
  toString(e) {
    const { bytes: r, version: n, _baseCache: s } = this;
    switch (n) {
      case 0:
        return bb(r, s, e || Ft.encoder);
      default:
        return hb(r, s, e || cn.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(e) {
    return gb(/^0\.0/, Rb), !!(e && (e[Jl] || e.asCID === e));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(e) {
    if (e instanceof Se)
      return e;
    if (e != null && e.asCID === e) {
      const { version: r, code: n, multihash: s, bytes: u } = e;
      return new Se(r, n, s, u || Wl(r, n, s.bytes));
    } else if (e != null && e[Jl] === !0) {
      const { version: r, multihash: n, code: s } = e, u = Xm(n);
      return Se.create(r, s, u);
    } else
      return null;
  }
  static create(e, r, n) {
    if (typeof r != "number")
      throw new Error("String codecs are no longer supported");
    switch (e) {
      case 0: {
        if (r !== sn)
          throw new Error(`Version 0 CID must use dag-pb (code: ${sn}) block encoding`);
        return new Se(e, r, n, n.bytes);
      }
      case 1: {
        const s = Wl(e, r, n.bytes);
        return new Se(e, r, n, s);
      }
      default:
        throw new Error("Invalid version");
    }
  }
  static createV0(e) {
    return Se.create(0, sn, e);
  }
  static createV1(e, r) {
    return Se.create(1, e, r);
  }
  static decode(e) {
    const [r, n] = Se.decodeFirst(e);
    if (n.length)
      throw new Error("Incorrect length");
    return r;
  }
  static decodeFirst(e) {
    const r = Se.inspectBytes(e), n = r.size - r.multihashSize, s = pl(e.subarray(n, n + r.multihashSize));
    if (s.byteLength !== r.multihashSize)
      throw new Error("Incorrect length");
    const u = s.subarray(r.multihashSize - r.digestSize), c = new dl(r.multihashCode, r.digestSize, u, s);
    return [
      r.version === 0 ? Se.createV0(c) : Se.createV1(r.codec, c),
      e.subarray(r.size)
    ];
  }
  static inspectBytes(e) {
    let r = 0;
    const n = () => {
      const [g, R] = rl(e.subarray(r));
      return r += R, g;
    };
    let s = n(), u = sn;
    if (s === 18 ? (s = 0, r = 0) : s === 1 && (u = n()), s !== 0 && s !== 1)
      throw new RangeError(`Invalid CID version ${s}`);
    const c = r, a = n(), y = n(), d = r + y, b = d - c;
    return {
      version: s,
      codec: u,
      multihashCode: a,
      digestSize: y,
      multihashSize: b,
      size: d
    };
  }
  static parse(e, r) {
    const [n, s] = mb(e, r), u = Se.decode(s);
    return u._baseCache.set(n, e), u;
  }
}
const mb = (t, e) => {
  switch (t[0]) {
    case "Q": {
      const r = e || Ft;
      return [
        Ft.prefix,
        r.decode(`${Ft.prefix}${t}`)
      ];
    }
    case Ft.prefix: {
      const r = e || Ft;
      return [
        Ft.prefix,
        r.decode(t)
      ];
    }
    case cn.prefix: {
      const r = e || cn;
      return [
        cn.prefix,
        r.decode(t)
      ];
    }
    default: {
      if (e == null)
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      return [
        t[0],
        e.decode(t)
      ];
    }
  }
}, bb = (t, e, r) => {
  const { prefix: n } = r;
  if (n !== Ft.prefix)
    throw Error(`Cannot string encode V0 in ${r.name} encoding`);
  const s = e.get(n);
  if (s == null) {
    const u = r.encode(t).slice(1);
    return e.set(n, u), u;
  } else
    return s;
}, hb = (t, e, r) => {
  const { prefix: n } = r, s = e.get(n);
  if (s == null) {
    const u = r.encode(t);
    return e.set(n, u), u;
  } else
    return s;
}, sn = 112, Eb = 18, Wl = (t, e, r) => {
  const n = ra(t), s = n + ra(e), u = new Uint8Array(s + r.byteLength);
  return ta(t, u, 0), ta(e, u, n), u.set(r, s), u;
}, Jl = Symbol.for("@ipld/js-cid/CID"), $o = {
  writable: !1,
  configurable: !1,
  enumerable: !0
}, Go = {
  writable: !1,
  enumerable: !1,
  configurable: !1
}, xb = "0.0.0-dev", gb = (t, e) => {
  if (t.test(xb))
    console.warn(e);
  else
    throw new Error(e);
}, Rb = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`, vb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CID: Se
}, Symbol.toStringTag, { value: "Module" })), ji = /* @__PURE__ */ sc(vb);
function Ab(t, e) {
  for (let r = 0; r < t.byteLength; r++) {
    if (t[r] < e[r])
      return -1;
    if (t[r] > e[r])
      return 1;
  }
  return t.byteLength > e.byteLength ? 1 : t.byteLength < e.byteLength ? -1 : 0;
}
function wb(t, e) {
  e || (e = t.reduce((s, u) => s + u.length, 0));
  const r = new Uint8Array(e);
  let n = 0;
  for (const s of t)
    r.set(s, n), n += s.length;
  return r;
}
function Cb(t, e) {
  if (t === e)
    return !0;
  if (t.byteLength !== e.byteLength)
    return !1;
  for (let r = 0; r < t.byteLength; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
const _b = xa({
  prefix: "\0",
  name: "identity",
  encode: (t) => Fm(t),
  decode: (t) => qm(t)
}), Tb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: _b
}, Symbol.toStringTag, { value: "Module" })), Sb = _e({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), Lb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: Sb
}, Symbol.toStringTag, { value: "Module" })), kb = _e({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), Bb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: kb
}, Symbol.toStringTag, { value: "Module" })), Pb = En({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), Db = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: Pb
}, Symbol.toStringTag, { value: "Module" })), Kb = _e({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), Ub = _e({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), Vb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: Kb,
  base16upper: Ub
}, Symbol.toStringTag, { value: "Module" })), Ib = En({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), jb = En({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), Ob = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: Ib,
  base36upper: jb
}, Symbol.toStringTag, { value: "Module" })), Mb = _e({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), Nb = _e({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), $b = _e({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), Gb = _e({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), qb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: Mb,
  base64pad: Nb,
  base64url: $b,
  base64urlpad: Gb
}, Symbol.toStringTag, { value: "Module" })), Ac = Array.from(""), Fb = Ac.reduce((t, e, r) => (t[r] = e, t), []), zb = Ac.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);
function Xb(t) {
  return t.reduce((e, r) => (e += Fb[r], e), "");
}
function Zb(t) {
  const e = [];
  for (const r of t) {
    const n = zb[r.codePointAt(0)];
    if (n === void 0)
      throw new Error(`Non-base256emoji character: ${r}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
const Hb = xa({
  prefix: "",
  name: "base256emoji",
  encode: Xb,
  decode: Zb
}), Wb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: Hb
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const Ql = {
  ...Tb,
  ...Lb,
  ...Bb,
  ...Db,
  ...Vb,
  ...yb,
  ...Ob,
  ...sb,
  ...qb,
  ...Wb
};
function wc(t, e, r, n) {
  return {
    name: t,
    prefix: e,
    encoder: {
      name: t,
      prefix: e,
      encode: r
    },
    decoder: { decode: n }
  };
}
const Yl = wc("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), Ga = wc("ascii", "a", (t) => {
  let e = "a";
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = new Uint8Array(t.length);
  for (let r = 0; r < t.length; r++)
    e[r] = t.charCodeAt(r);
  return e;
}), Cc = {
  utf8: Yl,
  "utf-8": Yl,
  hex: Ql.base16,
  latin1: Ga,
  ascii: Ga,
  binary: Ga,
  ...Ql
};
function Jb(t, e = "utf8") {
  const r = Cc[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return r.decoder.decode(`${r.prefix}${t}`);
}
function Qb(t, e = "utf8") {
  const r = Cc[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return r.encoder.encode(t).substring(1);
}
function Yb(t, e) {
  if (t.length !== e.length)
    throw new Error("Inputs should have the same length");
  const r = new Uint8Array(t.length);
  for (let n = 0; n < t.length; n++)
    r[n] = t[n] ^ e[n];
  return r;
}
const eh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  compare: Ab,
  concat: wb,
  equals: Cb,
  fromString: Jb,
  toString: Qb,
  xor: Yb
}, Symbol.toStringTag, { value: "Module" })), _c = /* @__PURE__ */ sc(eh);
(function(t) {
  var e = S && S.__createBinding || (Object.create ? function(d, b, g, R) {
    R === void 0 && (R = g);
    var C = Object.getOwnPropertyDescriptor(b, g);
    (!C || ("get" in C ? !b.__esModule : C.writable || C.configurable)) && (C = { enumerable: !0, get: function() {
      return b[g];
    } }), Object.defineProperty(d, R, C);
  } : function(d, b, g, R) {
    R === void 0 && (R = g), d[R] = b[g];
  }), r = S && S.__setModuleDefault || (Object.create ? function(d, b) {
    Object.defineProperty(d, "default", { enumerable: !0, value: b });
  } : function(d, b) {
    d.default = b;
  }), n = S && S.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var b = {};
    if (d != null) for (var g in d) g !== "default" && Object.prototype.hasOwnProperty.call(d, g) && e(b, d, g);
    return r(b, d), b;
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ipldEquals = t.ipldToJson = t.jsonToIpld = void 0;
  const s = ji, u = n(_c), c = (d) => {
    if (Array.isArray(d))
      return d.map((b) => (0, t.jsonToIpld)(b));
    if (d && typeof d == "object") {
      if (typeof d.$link == "string" && Object.keys(d).length === 1)
        return s.CID.parse(d.$link);
      if (typeof d.$bytes == "string" && Object.keys(d).length === 1)
        return u.fromString(d.$bytes, "base64");
      const b = {};
      for (const g of Object.keys(d))
        b[g] = (0, t.jsonToIpld)(d[g]);
      return b;
    }
    return d;
  };
  t.jsonToIpld = c;
  const a = (d) => {
    if (Array.isArray(d))
      return d.map((b) => (0, t.ipldToJson)(b));
    if (d && typeof d == "object") {
      if (d instanceof Uint8Array)
        return {
          $bytes: u.toString(d, "base64")
        };
      if (s.CID.asCID(d))
        return {
          $link: d.toString()
        };
      const b = {};
      for (const g of Object.keys(d))
        b[g] = (0, t.ipldToJson)(d[g]);
      return b;
    }
    return d;
  };
  t.ipldToJson = a;
  const y = (d, b) => {
    if (Array.isArray(d) && Array.isArray(b)) {
      if (d.length !== b.length)
        return !1;
      for (let g = 0; g < d.length; g++)
        if (!(0, t.ipldEquals)(d[g], b[g]))
          return !1;
      return !0;
    }
    if (d && b && typeof d == "object" && typeof b == "object") {
      if (d instanceof Uint8Array && b instanceof Uint8Array)
        return u.equals(d, b);
      if (s.CID.asCID(d) && s.CID.asCID(b))
        return s.CID.asCID(d)?.equals(s.CID.asCID(b));
      if (Object.keys(d).length !== Object.keys(b).length)
        return !1;
      for (const g of Object.keys(d))
        if (!(0, t.ipldEquals)(d[g], b[g]))
          return !1;
      return !0;
    }
    return d === b;
  };
  t.ipldEquals = y;
})(gc);
var gi = {};
Object.defineProperty(gi, "__esModule", { value: !0 });
gi.backoffMs = gi.retry = void 0;
const th = Ei;
async function rh(t, e = {}) {
  const { maxRetries: r = 3, retryable: n = () => !0, getWaitMs: s = Tc } = e;
  let u = 0, c;
  for (; !c; )
    try {
      return await t();
    } catch (a) {
      const y = s(u);
      u < r && y !== null && n(a) ? (u += 1, y !== 0 && await (0, th.wait)(y)) : c = a;
    }
  throw c;
}
gi.retry = rh;
function Tc(t, e = 100, r = 1e3) {
  const n = Math.pow(2, t) * e, s = Math.min(n, r);
  return ih(s);
}
gi.backoffMs = Tc;
function ih(t) {
  const e = t * 0.15;
  return t + nh(-e, e);
}
function nh(t, e) {
  return Math.random() * (e - t) + t;
}
var Sc = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.def = t.schema = void 0;
  const e = ji, r = ai, n = r.z.any().refine((s) => e.CID.asCID(s) !== null, {
    message: "Not a CID"
  }).transform((s) => e.CID.asCID(s));
  t.schema = {
    cid: n,
    bytes: r.z.instanceof(Uint8Array),
    string: r.z.string(),
    array: r.z.array(r.z.unknown()),
    map: r.z.record(r.z.string(), r.z.unknown()),
    unknown: r.z.unknown()
  }, t.def = {
    cid: {
      name: "cid",
      schema: t.schema.cid
    },
    bytes: {
      name: "bytes",
      schema: t.schema.bytes
    },
    string: {
      name: "string",
      schema: t.schema.string
    },
    map: {
      name: "map",
      schema: t.schema.map
    },
    unknown: {
      name: "unknown",
      schema: t.schema.unknown
    }
  };
})(Sc);
var Lc = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.addHoursToDate = t.lessThanAgoMs = t.DAY = t.HOUR = t.MINUTE = t.SECOND = void 0, t.SECOND = 1e3, t.MINUTE = t.SECOND * 60, t.HOUR = t.MINUTE * 60, t.DAY = t.HOUR * 24;
  const e = (n, s) => Date.now() < n.getTime() + s;
  t.lessThanAgoMs = e;
  const r = (n, s) => {
    const u = s ? new Date(s) : /* @__PURE__ */ new Date();
    return u.setHours(u.getHours() + n), u;
  };
  t.addHoursToDate = r;
})(Lc);
var $e = {}, fl = {}, yl = {}, ml = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.EXTENDED_PICTOGRAPHIC = t.CLUSTER_BREAK = void 0, function(e) {
    e[e.CR = 0] = "CR", e[e.LF = 1] = "LF", e[e.CONTROL = 2] = "CONTROL", e[e.EXTEND = 3] = "EXTEND", e[e.REGIONAL_INDICATOR = 4] = "REGIONAL_INDICATOR", e[e.SPACINGMARK = 5] = "SPACINGMARK", e[e.L = 6] = "L", e[e.V = 7] = "V", e[e.T = 8] = "T", e[e.LV = 9] = "LV", e[e.LVT = 10] = "LVT", e[e.OTHER = 11] = "OTHER", e[e.PREPEND = 12] = "PREPEND", e[e.E_BASE = 13] = "E_BASE", e[e.E_MODIFIER = 14] = "E_MODIFIER", e[e.ZWJ = 15] = "ZWJ", e[e.GLUE_AFTER_ZWJ = 16] = "GLUE_AFTER_ZWJ", e[e.E_BASE_GAZ = 17] = "E_BASE_GAZ";
  }(t.CLUSTER_BREAK || (t.CLUSTER_BREAK = {})), t.EXTENDED_PICTOGRAPHIC = 101;
})(ml);
var bl = {};
Object.defineProperty(bl, "__esModule", { value: !0 });
const J = ml, Mt = 0, qa = 1, sh = 2, oh = 3, ah = 4;
class lh {
  /**
   * Check if the the character at the position {pos} of the string is surrogate
   * @param str {string}
   * @param pos {number}
   * @returns {boolean}
   */
  static isSurrogate(e, r) {
    return 55296 <= e.charCodeAt(r) && e.charCodeAt(r) <= 56319 && 56320 <= e.charCodeAt(r + 1) && e.charCodeAt(r + 1) <= 57343;
  }
  /**
   * The String.prototype.codePointAt polyfill
   * Private function, gets a Unicode code point from a JavaScript UTF-16 string
   * handling surrogate pairs appropriately
   * @param str {string}
   * @param idx {number}
   * @returns {number}
   */
  static codePointAt(e, r) {
    r === void 0 && (r = 0);
    const n = e.charCodeAt(r);
    if (55296 <= n && n <= 56319 && r < e.length - 1) {
      const s = n, u = e.charCodeAt(r + 1);
      return 56320 <= u && u <= 57343 ? (s - 55296) * 1024 + (u - 56320) + 65536 : s;
    }
    if (56320 <= n && n <= 57343 && r >= 1) {
      const s = e.charCodeAt(r - 1), u = n;
      return 55296 <= s && s <= 56319 ? (s - 55296) * 1024 + (u - 56320) + 65536 : u;
    }
    return n;
  }
  //
  /**
   * Private function, returns whether a break is allowed between the two given grapheme breaking classes
   * Implemented the UAX #29 3.1.1 Grapheme Cluster Boundary Rules on extended grapheme clusters
   * @param start {number}
   * @param mid {Array<number>}
   * @param end {number}
   * @param startEmoji {number}
   * @param midEmoji {Array<number>}
   * @param endEmoji {number}
   * @returns {number}
   */
  static shouldBreak(e, r, n, s, u, c) {
    const a = [e].concat(r).concat([n]), y = [s].concat(u).concat([c]), d = a[a.length - 2], b = n, g = c, R = a.lastIndexOf(J.CLUSTER_BREAK.REGIONAL_INDICATOR);
    if (R > 0 && a.slice(1, R).every(function(D) {
      return D === J.CLUSTER_BREAK.REGIONAL_INDICATOR;
    }) && [J.CLUSTER_BREAK.PREPEND, J.CLUSTER_BREAK.REGIONAL_INDICATOR].indexOf(d) === -1)
      return a.filter(function(D) {
        return D === J.CLUSTER_BREAK.REGIONAL_INDICATOR;
      }).length % 2 === 1 ? oh : ah;
    if (d === J.CLUSTER_BREAK.CR && b === J.CLUSTER_BREAK.LF)
      return Mt;
    if (d === J.CLUSTER_BREAK.CONTROL || d === J.CLUSTER_BREAK.CR || d === J.CLUSTER_BREAK.LF)
      return qa;
    if (b === J.CLUSTER_BREAK.CONTROL || b === J.CLUSTER_BREAK.CR || b === J.CLUSTER_BREAK.LF)
      return qa;
    if (d === J.CLUSTER_BREAK.L && (b === J.CLUSTER_BREAK.L || b === J.CLUSTER_BREAK.V || b === J.CLUSTER_BREAK.LV || b === J.CLUSTER_BREAK.LVT))
      return Mt;
    if ((d === J.CLUSTER_BREAK.LV || d === J.CLUSTER_BREAK.V) && (b === J.CLUSTER_BREAK.V || b === J.CLUSTER_BREAK.T))
      return Mt;
    if ((d === J.CLUSTER_BREAK.LVT || d === J.CLUSTER_BREAK.T) && b === J.CLUSTER_BREAK.T)
      return Mt;
    if (b === J.CLUSTER_BREAK.EXTEND || b === J.CLUSTER_BREAK.ZWJ)
      return Mt;
    if (b === J.CLUSTER_BREAK.SPACINGMARK)
      return Mt;
    if (d === J.CLUSTER_BREAK.PREPEND)
      return Mt;
    const C = y.slice(0, -1).lastIndexOf(J.EXTENDED_PICTOGRAPHIC);
    return C !== -1 && y[C] === J.EXTENDED_PICTOGRAPHIC && a.slice(C + 1, -2).every(function(D) {
      return D === J.CLUSTER_BREAK.EXTEND;
    }) && d === J.CLUSTER_BREAK.ZWJ && g === J.EXTENDED_PICTOGRAPHIC ? Mt : r.indexOf(J.CLUSTER_BREAK.REGIONAL_INDICATOR) !== -1 ? sh : d === J.CLUSTER_BREAK.REGIONAL_INDICATOR && b === J.CLUSTER_BREAK.REGIONAL_INDICATOR ? Mt : qa;
  }
}
bl.default = lh;
var hl = {};
Object.defineProperty(hl, "__esModule", { value: !0 });
class uh {
  constructor(e, r) {
    this._index = 0, this._str = e, this._nextBreak = r;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    let e;
    if ((e = this._nextBreak(this._str, this._index)) < this._str.length) {
      const r = this._str.slice(this._index, e);
      return this._index = e, { value: r, done: !1 };
    }
    if (this._index < this._str.length) {
      const r = this._str.slice(this._index);
      return this._index = this._str.length, { value: r, done: !1 };
    }
    return { value: void 0, done: !0 };
  }
}
hl.default = uh;
var kc = S && S.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(yl, "__esModule", { value: !0 });
const i = ml, qo = kc(bl), ch = kc(hl);
class $t {
  /**
   * Returns the next grapheme break in the string after the given index
   * @param string {string}
   * @param index {number}
   * @returns {number}
   */
  static nextBreak(e, r) {
    if (r === void 0 && (r = 0), r < 0)
      return 0;
    if (r >= e.length - 1)
      return e.length;
    const n = qo.default.codePointAt(e, r), s = $t.getGraphemeBreakProperty(n), u = $t.getEmojiProperty(n), c = [], a = [];
    for (let y = r + 1; y < e.length; y++) {
      if (qo.default.isSurrogate(e, y - 1))
        continue;
      const d = qo.default.codePointAt(e, y), b = $t.getGraphemeBreakProperty(d), g = $t.getEmojiProperty(d);
      if (qo.default.shouldBreak(s, c, b, u, a, g))
        return y;
      c.push(b), a.push(g);
    }
    return e.length;
  }
  /**
   * Breaks the given string into an array of grapheme clusters
   * @param str {string}
   * @returns {string[]}
   */
  splitGraphemes(e) {
    const r = [];
    let n = 0, s;
    for (; (s = $t.nextBreak(e, n)) < e.length; )
      r.push(e.slice(n, s)), n = s;
    return n < e.length && r.push(e.slice(n)), r;
  }
  /**
   * Returns an iterator of grapheme clusters in the given string
   * @param str {string}
   * @returns {GraphemerIterator}
   */
  iterateGraphemes(e) {
    return new ch.default(e, $t.nextBreak);
  }
  /**
   * Returns the number of grapheme clusters in the given string
   * @param str {string}
   * @returns {number}
   */
  countGraphemes(e) {
    let r = 0, n = 0, s;
    for (; (s = $t.nextBreak(e, n)) < e.length; )
      n = s, r++;
    return n < e.length && r++, r;
  }
  /**
   * Given a Unicode code point, determines this symbol's grapheme break property
   * @param code {number} Unicode code point
   * @returns {number}
   */
  static getGraphemeBreakProperty(e) {
    if (e < 48905) {
      if (e < 44116) {
        if (e < 4141) {
          if (e < 2818) {
            if (e < 2363)
              if (e < 1759) {
                if (e < 1471) {
                  if (e < 127) {
                    if (e < 11) {
                      if (e < 10) {
                        if (0 <= e && e <= 9)
                          return i.CLUSTER_BREAK.CONTROL;
                      } else if (e === 10)
                        return i.CLUSTER_BREAK.LF;
                    } else if (e < 13) {
                      if (11 <= e && e <= 12)
                        return i.CLUSTER_BREAK.CONTROL;
                    } else if (e < 14) {
                      if (e === 13)
                        return i.CLUSTER_BREAK.CR;
                    } else if (14 <= e && e <= 31)
                      return i.CLUSTER_BREAK.CONTROL;
                  } else if (e < 768) {
                    if (e < 173) {
                      if (127 <= e && e <= 159)
                        return i.CLUSTER_BREAK.CONTROL;
                    } else if (e === 173)
                      return i.CLUSTER_BREAK.CONTROL;
                  } else if (e < 1155) {
                    if (768 <= e && e <= 879)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1425) {
                    if (1155 <= e && e <= 1161)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (1425 <= e && e <= 1469)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 1552) {
                  if (e < 1476) {
                    if (e < 1473) {
                      if (e === 1471)
                        return i.CLUSTER_BREAK.EXTEND;
                    } else if (1473 <= e && e <= 1474)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1479) {
                    if (1476 <= e && e <= 1477)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1536) {
                    if (e === 1479)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (1536 <= e && e <= 1541)
                    return i.CLUSTER_BREAK.PREPEND;
                } else if (e < 1648) {
                  if (e < 1564) {
                    if (1552 <= e && e <= 1562)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1611) {
                    if (e === 1564)
                      return i.CLUSTER_BREAK.CONTROL;
                  } else if (1611 <= e && e <= 1631)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 1750) {
                  if (e === 1648)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 1757) {
                  if (1750 <= e && e <= 1756)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 1757)
                  return i.CLUSTER_BREAK.PREPEND;
              } else if (e < 2075) {
                if (e < 1840)
                  if (e < 1770) {
                    if (e < 1767) {
                      if (1759 <= e && e <= 1764)
                        return i.CLUSTER_BREAK.EXTEND;
                    } else if (1767 <= e && e <= 1768)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1807) {
                    if (1770 <= e && e <= 1773)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else {
                    if (e === 1807)
                      return i.CLUSTER_BREAK.PREPEND;
                    if (e === 1809)
                      return i.CLUSTER_BREAK.EXTEND;
                  }
                else if (e < 2027) {
                  if (e < 1958) {
                    if (1840 <= e && e <= 1866)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (1958 <= e && e <= 1968)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2045) {
                  if (2027 <= e && e <= 2035)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2070) {
                  if (e === 2045)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (2070 <= e && e <= 2073)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2200) {
                if (e < 2089) {
                  if (e < 2085) {
                    if (2075 <= e && e <= 2083)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (2085 <= e && e <= 2087)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2137) {
                  if (2089 <= e && e <= 2093)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2192) {
                  if (2137 <= e && e <= 2139)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (2192 <= e && e <= 2193)
                  return i.CLUSTER_BREAK.PREPEND;
              } else if (e < 2275) {
                if (e < 2250) {
                  if (2200 <= e && e <= 2207)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2274) {
                  if (2250 <= e && e <= 2273)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 2274)
                  return i.CLUSTER_BREAK.PREPEND;
              } else if (e < 2307) {
                if (2275 <= e && e <= 2306)
                  return i.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 2307)
                  return i.CLUSTER_BREAK.SPACINGMARK;
                if (e === 2362)
                  return i.CLUSTER_BREAK.EXTEND;
              }
            else if (e < 2561) {
              if (e < 2434) {
                if (e < 2381) {
                  if (e < 2366) {
                    if (e === 2363)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                    if (e === 2364)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2369) {
                    if (2366 <= e && e <= 2368)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 2377) {
                    if (2369 <= e && e <= 2376)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (2377 <= e && e <= 2380)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2385) {
                  if (e < 2382) {
                    if (e === 2381)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (2382 <= e && e <= 2383)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2402) {
                  if (2385 <= e && e <= 2391)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2433) {
                  if (2402 <= e && e <= 2403)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 2433)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2503) {
                if (e < 2494) {
                  if (e < 2492) {
                    if (2434 <= e && e <= 2435)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e === 2492)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2495) {
                  if (e === 2494)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2497) {
                  if (2495 <= e && e <= 2496)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (2497 <= e && e <= 2500)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2519) {
                if (e < 2507) {
                  if (2503 <= e && e <= 2504)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2509) {
                  if (2507 <= e && e <= 2508)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e === 2509)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2530) {
                if (e === 2519)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2558) {
                if (2530 <= e && e <= 2531)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e === 2558)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 2691) {
              if (e < 2631) {
                if (e < 2620) {
                  if (e < 2563) {
                    if (2561 <= e && e <= 2562)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e === 2563)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2622) {
                  if (e === 2620)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2625) {
                  if (2622 <= e && e <= 2624)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (2625 <= e && e <= 2626)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2672) {
                if (e < 2635) {
                  if (2631 <= e && e <= 2632)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2641) {
                  if (2635 <= e && e <= 2637)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 2641)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2677) {
                if (2672 <= e && e <= 2673)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2689) {
                if (e === 2677)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (2689 <= e && e <= 2690)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 2761) {
              if (e < 2750) {
                if (e === 2691)
                  return i.CLUSTER_BREAK.SPACINGMARK;
                if (e === 2748)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2753) {
                if (2750 <= e && e <= 2752)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 2759) {
                if (2753 <= e && e <= 2757)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (2759 <= e && e <= 2760)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 2786) {
              if (e < 2763) {
                if (e === 2761)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 2765) {
                if (2763 <= e && e <= 2764)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e === 2765)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 2810) {
              if (2786 <= e && e <= 2787)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 2817) {
              if (2810 <= e && e <= 2815)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e === 2817)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 3315) {
            if (e < 3076) {
              if (e < 2946) {
                if (e < 2887) {
                  if (e < 2878) {
                    if (e < 2876) {
                      if (2818 <= e && e <= 2819)
                        return i.CLUSTER_BREAK.SPACINGMARK;
                    } else if (e === 2876)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2880) {
                    if (2878 <= e && e <= 2879)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2881) {
                    if (e === 2880)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                  } else if (2881 <= e && e <= 2884)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2893) {
                  if (e < 2891) {
                    if (2887 <= e && e <= 2888)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                  } else if (2891 <= e && e <= 2892)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2901) {
                  if (e === 2893)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2914) {
                  if (2901 <= e && e <= 2903)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (2914 <= e && e <= 2915)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3014) {
                if (e < 3007) {
                  if (e === 2946 || e === 3006)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 3008) {
                  if (e === 3007)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 3009) {
                  if (e === 3008)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (3009 <= e && e <= 3010)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3031) {
                if (e < 3018) {
                  if (3014 <= e && e <= 3016)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 3021) {
                  if (3018 <= e && e <= 3020)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e === 3021)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3072) {
                if (e === 3031)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3073) {
                if (e === 3072)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (3073 <= e && e <= 3075)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3262) {
              if (e < 3146) {
                if (e < 3134) {
                  if (e === 3076 || e === 3132)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 3137) {
                  if (3134 <= e && e <= 3136)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 3142) {
                  if (3137 <= e && e <= 3140)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (3142 <= e && e <= 3144)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3201) {
                if (e < 3157) {
                  if (3146 <= e && e <= 3149)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 3170) {
                  if (3157 <= e && e <= 3158)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (3170 <= e && e <= 3171)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3202) {
                if (e === 3201)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3260) {
                if (3202 <= e && e <= 3203)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e === 3260)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 3270) {
              if (e < 3264) {
                if (e === 3262)
                  return i.CLUSTER_BREAK.SPACINGMARK;
                if (e === 3263)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3266) {
                if (3264 <= e && e <= 3265)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3267) {
                if (e === 3266)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (3267 <= e && e <= 3268)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3276) {
              if (e < 3271) {
                if (e === 3270)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3274) {
                if (3271 <= e && e <= 3272)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (3274 <= e && e <= 3275)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3285) {
              if (3276 <= e && e <= 3277)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 3298) {
              if (3285 <= e && e <= 3286)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (3298 <= e && e <= 3299)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 3551) {
            if (e < 3406) {
              if (e < 3391) {
                if (e < 3330) {
                  if (e < 3328) {
                    if (e === 3315)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                  } else if (3328 <= e && e <= 3329)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 3387) {
                  if (3330 <= e && e <= 3331)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 3390) {
                  if (3387 <= e && e <= 3388)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 3390)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3398) {
                if (e < 3393) {
                  if (3391 <= e && e <= 3392)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (3393 <= e && e <= 3396)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3402) {
                if (3398 <= e && e <= 3400)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3405) {
                if (3402 <= e && e <= 3404)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e === 3405)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 3530) {
              if (e < 3426) {
                if (e === 3406)
                  return i.CLUSTER_BREAK.PREPEND;
                if (e === 3415)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3457) {
                if (3426 <= e && e <= 3427)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3458) {
                if (e === 3457)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (3458 <= e && e <= 3459)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3538) {
              if (e < 3535) {
                if (e === 3530)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3536) {
                if (e === 3535)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (3536 <= e && e <= 3537)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3542) {
              if (3538 <= e && e <= 3540)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 3544) {
              if (e === 3542)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (3544 <= e && e <= 3550)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 3893) {
            if (e < 3655) {
              if (e < 3633) {
                if (e < 3570) {
                  if (e === 3551)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (3570 <= e && e <= 3571)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3635) {
                if (e === 3633)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3636) {
                if (e === 3635)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (3636 <= e && e <= 3642)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 3764)
              if (e < 3761) {
                if (3655 <= e && e <= 3662)
                  return i.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 3761)
                  return i.CLUSTER_BREAK.EXTEND;
                if (e === 3763)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              }
            else if (e < 3784) {
              if (3764 <= e && e <= 3772)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 3864) {
              if (3784 <= e && e <= 3790)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (3864 <= e && e <= 3865)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 3967) {
            if (e < 3897) {
              if (e === 3893 || e === 3895)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 3902) {
              if (e === 3897)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 3953) {
              if (3902 <= e && e <= 3903)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (3953 <= e && e <= 3966)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 3981) {
            if (e < 3968) {
              if (e === 3967)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3974) {
              if (3968 <= e && e <= 3972)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (3974 <= e && e <= 3975)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 3993) {
            if (3981 <= e && e <= 3991)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 4038) {
            if (3993 <= e && e <= 4028)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e === 4038)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 7204) {
          if (e < 6448) {
            if (e < 5938) {
              if (e < 4226) {
                if (e < 4157) {
                  if (e < 4146) {
                    if (e < 4145) {
                      if (4141 <= e && e <= 4144)
                        return i.CLUSTER_BREAK.EXTEND;
                    } else if (e === 4145)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 4153) {
                    if (4146 <= e && e <= 4151)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 4155) {
                    if (4153 <= e && e <= 4154)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (4155 <= e && e <= 4156)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 4184) {
                  if (e < 4182) {
                    if (4157 <= e && e <= 4158)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (4182 <= e && e <= 4183)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 4190) {
                  if (4184 <= e && e <= 4185)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 4209) {
                  if (4190 <= e && e <= 4192)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (4209 <= e && e <= 4212)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 4352) {
                if (e < 4229) {
                  if (e === 4226)
                    return i.CLUSTER_BREAK.EXTEND;
                  if (e === 4228)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 4237) {
                  if (4229 <= e && e <= 4230)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 4237 || e === 4253)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 4957) {
                if (e < 4448) {
                  if (4352 <= e && e <= 4447)
                    return i.CLUSTER_BREAK.L;
                } else if (e < 4520) {
                  if (4448 <= e && e <= 4519)
                    return i.CLUSTER_BREAK.V;
                } else if (4520 <= e && e <= 4607)
                  return i.CLUSTER_BREAK.T;
              } else if (e < 5906) {
                if (4957 <= e && e <= 4959)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 5909) {
                if (5906 <= e && e <= 5908)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e === 5909)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 6089) {
              if (e < 6070) {
                if (e < 5970) {
                  if (e < 5940) {
                    if (5938 <= e && e <= 5939)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e === 5940)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 6002) {
                  if (5970 <= e && e <= 5971)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 6068) {
                  if (6002 <= e && e <= 6003)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (6068 <= e && e <= 6069)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6078) {
                if (e < 6071) {
                  if (e === 6070)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (6071 <= e && e <= 6077)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6086) {
                if (6078 <= e && e <= 6085)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 6087) {
                if (e === 6086)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (6087 <= e && e <= 6088)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 6277)
              if (e < 6155) {
                if (e < 6109) {
                  if (6089 <= e && e <= 6099)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 6109)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6158) {
                if (6155 <= e && e <= 6157)
                  return i.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 6158)
                  return i.CLUSTER_BREAK.CONTROL;
                if (e === 6159)
                  return i.CLUSTER_BREAK.EXTEND;
              }
            else if (e < 6435) {
              if (e < 6313) {
                if (6277 <= e && e <= 6278)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6432) {
                if (e === 6313)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (6432 <= e && e <= 6434)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 6439) {
              if (6435 <= e && e <= 6438)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 6441) {
              if (6439 <= e && e <= 6440)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (6441 <= e && e <= 6443)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 6971) {
            if (e < 6744)
              if (e < 6681) {
                if (e < 6451) {
                  if (e < 6450) {
                    if (6448 <= e && e <= 6449)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e === 6450)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 6457) {
                  if (6451 <= e && e <= 6456)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 6679) {
                  if (6457 <= e && e <= 6459)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (6679 <= e && e <= 6680)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6741) {
                if (e < 6683) {
                  if (6681 <= e && e <= 6682)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e === 6683)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6742) {
                if (e === 6741)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else {
                if (e === 6742)
                  return i.CLUSTER_BREAK.EXTEND;
                if (e === 6743)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              }
            else if (e < 6771) {
              if (e < 6754) {
                if (e < 6752) {
                  if (6744 <= e && e <= 6750)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 6752)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6757) {
                if (e === 6754)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6765) {
                if (6757 <= e && e <= 6764)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (6765 <= e && e <= 6770)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 6912) {
              if (e < 6783) {
                if (6771 <= e && e <= 6780)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6832) {
                if (e === 6783)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (6832 <= e && e <= 6862)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 6916) {
              if (6912 <= e && e <= 6915)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 6964) {
              if (e === 6916)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (6964 <= e && e <= 6970)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 7080) {
            if (e < 7019) {
              if (e < 6973) {
                if (e === 6971)
                  return i.CLUSTER_BREAK.SPACINGMARK;
                if (e === 6972)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6978) {
                if (6973 <= e && e <= 6977)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 6979) {
                if (e === 6978)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (6979 <= e && e <= 6980)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 7073) {
              if (e < 7040) {
                if (7019 <= e && e <= 7027)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 7042) {
                if (7040 <= e && e <= 7041)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e === 7042)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 7074) {
              if (e === 7073)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 7078) {
              if (7074 <= e && e <= 7077)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (7078 <= e && e <= 7079)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 7144)
            if (e < 7083) {
              if (e < 7082) {
                if (7080 <= e && e <= 7081)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e === 7082)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 7142) {
              if (7083 <= e && e <= 7085)
                return i.CLUSTER_BREAK.EXTEND;
            } else {
              if (e === 7142)
                return i.CLUSTER_BREAK.EXTEND;
              if (e === 7143)
                return i.CLUSTER_BREAK.SPACINGMARK;
            }
          else if (e < 7150) {
            if (e < 7146) {
              if (7144 <= e && e <= 7145)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 7149) {
              if (7146 <= e && e <= 7148)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 7149)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 7151) {
            if (e === 7150)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 7154) {
            if (7151 <= e && e <= 7153)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (7154 <= e && e <= 7155)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 43346) {
          if (e < 11647) {
            if (e < 7415) {
              if (e < 7380) {
                if (e < 7220) {
                  if (e < 7212) {
                    if (7204 <= e && e <= 7211)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                  } else if (7212 <= e && e <= 7219)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 7222) {
                  if (7220 <= e && e <= 7221)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 7376) {
                  if (7222 <= e && e <= 7223)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (7376 <= e && e <= 7378)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 7394) {
                if (e < 7393) {
                  if (7380 <= e && e <= 7392)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 7393)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 7405) {
                if (7394 <= e && e <= 7400)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e === 7405 || e === 7412)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 8205)
              if (e < 7616) {
                if (e < 7416) {
                  if (e === 7415)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (7416 <= e && e <= 7417)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 8203) {
                if (7616 <= e && e <= 7679)
                  return i.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 8203)
                  return i.CLUSTER_BREAK.CONTROL;
                if (e === 8204)
                  return i.CLUSTER_BREAK.EXTEND;
              }
            else if (e < 8288) {
              if (e < 8206) {
                if (e === 8205)
                  return i.CLUSTER_BREAK.ZWJ;
              } else if (e < 8232) {
                if (8206 <= e && e <= 8207)
                  return i.CLUSTER_BREAK.CONTROL;
              } else if (8232 <= e && e <= 8238)
                return i.CLUSTER_BREAK.CONTROL;
            } else if (e < 8400) {
              if (8288 <= e && e <= 8303)
                return i.CLUSTER_BREAK.CONTROL;
            } else if (e < 11503) {
              if (8400 <= e && e <= 8432)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (11503 <= e && e <= 11505)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 43043) {
            if (e < 42612) {
              if (e < 12330) {
                if (e < 11744) {
                  if (e === 11647)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (11744 <= e && e <= 11775)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 12441) {
                if (12330 <= e && e <= 12335)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 42607) {
                if (12441 <= e && e <= 12442)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (42607 <= e && e <= 42610)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 43010) {
              if (e < 42654) {
                if (42612 <= e && e <= 42621)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 42736) {
                if (42654 <= e && e <= 42655)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (42736 <= e && e <= 42737)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 43014) {
              if (e === 43010)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e === 43014 || e === 43019)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 43188) {
            if (e < 43047) {
              if (e < 43045) {
                if (43043 <= e && e <= 43044)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (43045 <= e && e <= 43046)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 43052) {
              if (e === 43047)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43136) {
              if (e === 43052)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (43136 <= e && e <= 43137)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 43263) {
            if (e < 43204) {
              if (43188 <= e && e <= 43203)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43232) {
              if (43204 <= e && e <= 43205)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (43232 <= e && e <= 43249)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 43302) {
            if (e === 43263)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 43335) {
            if (43302 <= e && e <= 43309)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (43335 <= e && e <= 43345)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 43698) {
          if (e < 43493) {
            if (e < 43444)
              if (e < 43392) {
                if (e < 43360) {
                  if (43346 <= e && e <= 43347)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (43360 <= e && e <= 43388)
                  return i.CLUSTER_BREAK.L;
              } else if (e < 43395) {
                if (43392 <= e && e <= 43394)
                  return i.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 43395)
                  return i.CLUSTER_BREAK.SPACINGMARK;
                if (e === 43443)
                  return i.CLUSTER_BREAK.EXTEND;
              }
            else if (e < 43450) {
              if (e < 43446) {
                if (43444 <= e && e <= 43445)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (43446 <= e && e <= 43449)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 43452) {
              if (43450 <= e && e <= 43451)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43454) {
              if (43452 <= e && e <= 43453)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (43454 <= e && e <= 43456)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 43573) {
            if (e < 43567) {
              if (e < 43561) {
                if (e === 43493)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (43561 <= e && e <= 43566)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 43569) {
              if (43567 <= e && e <= 43568)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43571) {
              if (43569 <= e && e <= 43570)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (43571 <= e && e <= 43572)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 43597) {
            if (e < 43587) {
              if (43573 <= e && e <= 43574)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e === 43587 || e === 43596)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 43644) {
            if (e === 43597)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e === 43644 || e === 43696)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 44006) {
          if (e < 43756)
            if (e < 43710) {
              if (e < 43703) {
                if (43698 <= e && e <= 43700)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (43703 <= e && e <= 43704)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 43713) {
              if (43710 <= e && e <= 43711)
                return i.CLUSTER_BREAK.EXTEND;
            } else {
              if (e === 43713)
                return i.CLUSTER_BREAK.EXTEND;
              if (e === 43755)
                return i.CLUSTER_BREAK.SPACINGMARK;
            }
          else if (e < 43766) {
            if (e < 43758) {
              if (43756 <= e && e <= 43757)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 43765) {
              if (43758 <= e && e <= 43759)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 43765)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 44003) {
            if (e === 43766)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 44005) {
            if (44003 <= e && e <= 44004)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e === 44005)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 44032)
          if (e < 44009) {
            if (e < 44008) {
              if (44006 <= e && e <= 44007)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 44008)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 44012) {
            if (44009 <= e && e <= 44010)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else {
            if (e === 44012)
              return i.CLUSTER_BREAK.SPACINGMARK;
            if (e === 44013)
              return i.CLUSTER_BREAK.EXTEND;
          }
        else if (e < 44061) {
          if (e < 44033) {
            if (e === 44032)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 44060) {
            if (44033 <= e && e <= 44059)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 44060)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 44088) {
          if (44061 <= e && e <= 44087)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 44089) {
          if (e === 44088)
            return i.CLUSTER_BREAK.LV;
        } else if (44089 <= e && e <= 44115)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 46497) {
        if (e < 45293) {
          if (e < 44704) {
            if (e < 44397) {
              if (e < 44256) {
                if (e < 44173) {
                  if (e < 44144) {
                    if (e < 44117) {
                      if (e === 44116)
                        return i.CLUSTER_BREAK.LV;
                    } else if (44117 <= e && e <= 44143)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e < 44145) {
                    if (e === 44144)
                      return i.CLUSTER_BREAK.LV;
                  } else if (e < 44172) {
                    if (44145 <= e && e <= 44171)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e === 44172)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 44201) {
                  if (e < 44200) {
                    if (44173 <= e && e <= 44199)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e === 44200)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 44228) {
                  if (44201 <= e && e <= 44227)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 44229) {
                  if (e === 44228)
                    return i.CLUSTER_BREAK.LV;
                } else if (44229 <= e && e <= 44255)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 44313) {
                if (e < 44284) {
                  if (e < 44257) {
                    if (e === 44256)
                      return i.CLUSTER_BREAK.LV;
                  } else if (44257 <= e && e <= 44283)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 44285) {
                  if (e === 44284)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 44312) {
                  if (44285 <= e && e <= 44311)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 44312)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 44368) {
                if (e < 44340) {
                  if (44313 <= e && e <= 44339)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 44341) {
                  if (e === 44340)
                    return i.CLUSTER_BREAK.LV;
                } else if (44341 <= e && e <= 44367)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 44369) {
                if (e === 44368)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 44396) {
                if (44369 <= e && e <= 44395)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 44396)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 44537) {
              if (e < 44480) {
                if (e < 44425) {
                  if (e < 44424) {
                    if (44397 <= e && e <= 44423)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e === 44424)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 44452) {
                  if (44425 <= e && e <= 44451)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 44453) {
                  if (e === 44452)
                    return i.CLUSTER_BREAK.LV;
                } else if (44453 <= e && e <= 44479)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 44508) {
                if (e < 44481) {
                  if (e === 44480)
                    return i.CLUSTER_BREAK.LV;
                } else if (44481 <= e && e <= 44507)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 44509) {
                if (e === 44508)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 44536) {
                if (44509 <= e && e <= 44535)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 44536)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 44620) {
              if (e < 44565) {
                if (e < 44564) {
                  if (44537 <= e && e <= 44563)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 44564)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 44592) {
                if (44565 <= e && e <= 44591)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 44593) {
                if (e === 44592)
                  return i.CLUSTER_BREAK.LV;
              } else if (44593 <= e && e <= 44619)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 44649) {
              if (e < 44621) {
                if (e === 44620)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 44648) {
                if (44621 <= e && e <= 44647)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 44648)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 44676) {
              if (44649 <= e && e <= 44675)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 44677) {
              if (e === 44676)
                return i.CLUSTER_BREAK.LV;
            } else if (44677 <= e && e <= 44703)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 44985) {
            if (e < 44844) {
              if (e < 44761) {
                if (e < 44732) {
                  if (e < 44705) {
                    if (e === 44704)
                      return i.CLUSTER_BREAK.LV;
                  } else if (44705 <= e && e <= 44731)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 44733) {
                  if (e === 44732)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 44760) {
                  if (44733 <= e && e <= 44759)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 44760)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 44789) {
                if (e < 44788) {
                  if (44761 <= e && e <= 44787)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 44788)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 44816) {
                if (44789 <= e && e <= 44815)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 44817) {
                if (e === 44816)
                  return i.CLUSTER_BREAK.LV;
              } else if (44817 <= e && e <= 44843)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 44901) {
              if (e < 44872) {
                if (e < 44845) {
                  if (e === 44844)
                    return i.CLUSTER_BREAK.LV;
                } else if (44845 <= e && e <= 44871)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 44873) {
                if (e === 44872)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 44900) {
                if (44873 <= e && e <= 44899)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 44900)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 44956) {
              if (e < 44928) {
                if (44901 <= e && e <= 44927)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 44929) {
                if (e === 44928)
                  return i.CLUSTER_BREAK.LV;
              } else if (44929 <= e && e <= 44955)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 44957) {
              if (e === 44956)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 44984) {
              if (44957 <= e && e <= 44983)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 44984)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 45152) {
            if (e < 45068) {
              if (e < 45013) {
                if (e < 45012) {
                  if (44985 <= e && e <= 45011)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 45012)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 45040) {
                if (45013 <= e && e <= 45039)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 45041) {
                if (e === 45040)
                  return i.CLUSTER_BREAK.LV;
              } else if (45041 <= e && e <= 45067)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 45097) {
              if (e < 45069) {
                if (e === 45068)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 45096) {
                if (45069 <= e && e <= 45095)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 45096)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45124) {
              if (45097 <= e && e <= 45123)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 45125) {
              if (e === 45124)
                return i.CLUSTER_BREAK.LV;
            } else if (45125 <= e && e <= 45151)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 45209) {
            if (e < 45180) {
              if (e < 45153) {
                if (e === 45152)
                  return i.CLUSTER_BREAK.LV;
              } else if (45153 <= e && e <= 45179)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 45181) {
              if (e === 45180)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45208) {
              if (45181 <= e && e <= 45207)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 45208)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 45264) {
            if (e < 45236) {
              if (45209 <= e && e <= 45235)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 45237) {
              if (e === 45236)
                return i.CLUSTER_BREAK.LV;
            } else if (45237 <= e && e <= 45263)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 45265) {
            if (e === 45264)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 45292) {
            if (45265 <= e && e <= 45291)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 45292)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 45908) {
          if (e < 45600) {
            if (e < 45433) {
              if (e < 45376) {
                if (e < 45321) {
                  if (e < 45320) {
                    if (45293 <= e && e <= 45319)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e === 45320)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 45348) {
                  if (45321 <= e && e <= 45347)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 45349) {
                  if (e === 45348)
                    return i.CLUSTER_BREAK.LV;
                } else if (45349 <= e && e <= 45375)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 45404) {
                if (e < 45377) {
                  if (e === 45376)
                    return i.CLUSTER_BREAK.LV;
                } else if (45377 <= e && e <= 45403)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 45405) {
                if (e === 45404)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 45432) {
                if (45405 <= e && e <= 45431)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 45432)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45516) {
              if (e < 45461) {
                if (e < 45460) {
                  if (45433 <= e && e <= 45459)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 45460)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 45488) {
                if (45461 <= e && e <= 45487)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 45489) {
                if (e === 45488)
                  return i.CLUSTER_BREAK.LV;
              } else if (45489 <= e && e <= 45515)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 45545) {
              if (e < 45517) {
                if (e === 45516)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 45544) {
                if (45517 <= e && e <= 45543)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 45544)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45572) {
              if (45545 <= e && e <= 45571)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 45573) {
              if (e === 45572)
                return i.CLUSTER_BREAK.LV;
            } else if (45573 <= e && e <= 45599)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 45741) {
            if (e < 45657) {
              if (e < 45628) {
                if (e < 45601) {
                  if (e === 45600)
                    return i.CLUSTER_BREAK.LV;
                } else if (45601 <= e && e <= 45627)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 45629) {
                if (e === 45628)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 45656) {
                if (45629 <= e && e <= 45655)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 45656)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45712) {
              if (e < 45684) {
                if (45657 <= e && e <= 45683)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 45685) {
                if (e === 45684)
                  return i.CLUSTER_BREAK.LV;
              } else if (45685 <= e && e <= 45711)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 45713) {
              if (e === 45712)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45740) {
              if (45713 <= e && e <= 45739)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 45740)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 45824) {
            if (e < 45769) {
              if (e < 45768) {
                if (45741 <= e && e <= 45767)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 45768)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45796) {
              if (45769 <= e && e <= 45795)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 45797) {
              if (e === 45796)
                return i.CLUSTER_BREAK.LV;
            } else if (45797 <= e && e <= 45823)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 45853) {
            if (e < 45825) {
              if (e === 45824)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45852) {
              if (45825 <= e && e <= 45851)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 45852)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 45880) {
            if (45853 <= e && e <= 45879)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 45881) {
            if (e === 45880)
              return i.CLUSTER_BREAK.LV;
          } else if (45881 <= e && e <= 45907)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 46189) {
          if (e < 46048) {
            if (e < 45965) {
              if (e < 45936) {
                if (e < 45909) {
                  if (e === 45908)
                    return i.CLUSTER_BREAK.LV;
                } else if (45909 <= e && e <= 45935)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 45937) {
                if (e === 45936)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 45964) {
                if (45937 <= e && e <= 45963)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 45964)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45993) {
              if (e < 45992) {
                if (45965 <= e && e <= 45991)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 45992)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 46020) {
              if (45993 <= e && e <= 46019)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 46021) {
              if (e === 46020)
                return i.CLUSTER_BREAK.LV;
            } else if (46021 <= e && e <= 46047)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 46105) {
            if (e < 46076) {
              if (e < 46049) {
                if (e === 46048)
                  return i.CLUSTER_BREAK.LV;
              } else if (46049 <= e && e <= 46075)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 46077) {
              if (e === 46076)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 46104) {
              if (46077 <= e && e <= 46103)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 46104)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 46160) {
            if (e < 46132) {
              if (46105 <= e && e <= 46131)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 46133) {
              if (e === 46132)
                return i.CLUSTER_BREAK.LV;
            } else if (46133 <= e && e <= 46159)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 46161) {
            if (e === 46160)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 46188) {
            if (46161 <= e && e <= 46187)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 46188)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 46356) {
          if (e < 46272) {
            if (e < 46217) {
              if (e < 46216) {
                if (46189 <= e && e <= 46215)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 46216)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 46244) {
              if (46217 <= e && e <= 46243)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 46245) {
              if (e === 46244)
                return i.CLUSTER_BREAK.LV;
            } else if (46245 <= e && e <= 46271)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 46301) {
            if (e < 46273) {
              if (e === 46272)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 46300) {
              if (46273 <= e && e <= 46299)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 46300)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 46328) {
            if (46301 <= e && e <= 46327)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 46329) {
            if (e === 46328)
              return i.CLUSTER_BREAK.LV;
          } else if (46329 <= e && e <= 46355)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 46413) {
          if (e < 46384) {
            if (e < 46357) {
              if (e === 46356)
                return i.CLUSTER_BREAK.LV;
            } else if (46357 <= e && e <= 46383)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 46385) {
            if (e === 46384)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 46412) {
            if (46385 <= e && e <= 46411)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 46412)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 46468) {
          if (e < 46440) {
            if (46413 <= e && e <= 46439)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 46441) {
            if (e === 46440)
              return i.CLUSTER_BREAK.LV;
          } else if (46441 <= e && e <= 46467)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 46469) {
          if (e === 46468)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 46496) {
          if (46469 <= e && e <= 46495)
            return i.CLUSTER_BREAK.LVT;
        } else if (e === 46496)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 47701) {
        if (e < 47112) {
          if (e < 46804) {
            if (e < 46637) {
              if (e < 46580) {
                if (e < 46525) {
                  if (e < 46524) {
                    if (46497 <= e && e <= 46523)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e === 46524)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 46552) {
                  if (46525 <= e && e <= 46551)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 46553) {
                  if (e === 46552)
                    return i.CLUSTER_BREAK.LV;
                } else if (46553 <= e && e <= 46579)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 46608) {
                if (e < 46581) {
                  if (e === 46580)
                    return i.CLUSTER_BREAK.LV;
                } else if (46581 <= e && e <= 46607)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 46609) {
                if (e === 46608)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 46636) {
                if (46609 <= e && e <= 46635)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 46636)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 46720) {
              if (e < 46665) {
                if (e < 46664) {
                  if (46637 <= e && e <= 46663)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 46664)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 46692) {
                if (46665 <= e && e <= 46691)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 46693) {
                if (e === 46692)
                  return i.CLUSTER_BREAK.LV;
              } else if (46693 <= e && e <= 46719)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 46749) {
              if (e < 46721) {
                if (e === 46720)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 46748) {
                if (46721 <= e && e <= 46747)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 46748)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 46776) {
              if (46749 <= e && e <= 46775)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 46777) {
              if (e === 46776)
                return i.CLUSTER_BREAK.LV;
            } else if (46777 <= e && e <= 46803)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 46945) {
            if (e < 46861) {
              if (e < 46832) {
                if (e < 46805) {
                  if (e === 46804)
                    return i.CLUSTER_BREAK.LV;
                } else if (46805 <= e && e <= 46831)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 46833) {
                if (e === 46832)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 46860) {
                if (46833 <= e && e <= 46859)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 46860)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 46916) {
              if (e < 46888) {
                if (46861 <= e && e <= 46887)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 46889) {
                if (e === 46888)
                  return i.CLUSTER_BREAK.LV;
              } else if (46889 <= e && e <= 46915)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 46917) {
              if (e === 46916)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 46944) {
              if (46917 <= e && e <= 46943)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 46944)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 47028) {
            if (e < 46973) {
              if (e < 46972) {
                if (46945 <= e && e <= 46971)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 46972)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47e3) {
              if (46973 <= e && e <= 46999)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 47001) {
              if (e === 47e3)
                return i.CLUSTER_BREAK.LV;
            } else if (47001 <= e && e <= 47027)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47057) {
            if (e < 47029) {
              if (e === 47028)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47056) {
              if (47029 <= e && e <= 47055)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 47056)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 47084) {
            if (47057 <= e && e <= 47083)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47085) {
            if (e === 47084)
              return i.CLUSTER_BREAK.LV;
          } else if (47085 <= e && e <= 47111)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 47393) {
          if (e < 47252) {
            if (e < 47169) {
              if (e < 47140) {
                if (e < 47113) {
                  if (e === 47112)
                    return i.CLUSTER_BREAK.LV;
                } else if (47113 <= e && e <= 47139)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 47141) {
                if (e === 47140)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 47168) {
                if (47141 <= e && e <= 47167)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 47168)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47197) {
              if (e < 47196) {
                if (47169 <= e && e <= 47195)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 47196)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47224) {
              if (47197 <= e && e <= 47223)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 47225) {
              if (e === 47224)
                return i.CLUSTER_BREAK.LV;
            } else if (47225 <= e && e <= 47251)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47309) {
            if (e < 47280) {
              if (e < 47253) {
                if (e === 47252)
                  return i.CLUSTER_BREAK.LV;
              } else if (47253 <= e && e <= 47279)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 47281) {
              if (e === 47280)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47308) {
              if (47281 <= e && e <= 47307)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 47308)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 47364) {
            if (e < 47336) {
              if (47309 <= e && e <= 47335)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 47337) {
              if (e === 47336)
                return i.CLUSTER_BREAK.LV;
            } else if (47337 <= e && e <= 47363)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47365) {
            if (e === 47364)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 47392) {
            if (47365 <= e && e <= 47391)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 47392)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 47560) {
          if (e < 47476) {
            if (e < 47421) {
              if (e < 47420) {
                if (47393 <= e && e <= 47419)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 47420)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47448) {
              if (47421 <= e && e <= 47447)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 47449) {
              if (e === 47448)
                return i.CLUSTER_BREAK.LV;
            } else if (47449 <= e && e <= 47475)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47505) {
            if (e < 47477) {
              if (e === 47476)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47504) {
              if (47477 <= e && e <= 47503)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 47504)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 47532) {
            if (47505 <= e && e <= 47531)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47533) {
            if (e === 47532)
              return i.CLUSTER_BREAK.LV;
          } else if (47533 <= e && e <= 47559)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 47617) {
          if (e < 47588) {
            if (e < 47561) {
              if (e === 47560)
                return i.CLUSTER_BREAK.LV;
            } else if (47561 <= e && e <= 47587)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47589) {
            if (e === 47588)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 47616) {
            if (47589 <= e && e <= 47615)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 47616)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 47672) {
          if (e < 47644) {
            if (47617 <= e && e <= 47643)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47645) {
            if (e === 47644)
              return i.CLUSTER_BREAK.LV;
          } else if (47645 <= e && e <= 47671)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 47673) {
          if (e === 47672)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 47700) {
          if (47673 <= e && e <= 47699)
            return i.CLUSTER_BREAK.LVT;
        } else if (e === 47700)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 48316) {
        if (e < 48008) {
          if (e < 47841) {
            if (e < 47784) {
              if (e < 47729) {
                if (e < 47728) {
                  if (47701 <= e && e <= 47727)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 47728)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 47756) {
                if (47729 <= e && e <= 47755)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 47757) {
                if (e === 47756)
                  return i.CLUSTER_BREAK.LV;
              } else if (47757 <= e && e <= 47783)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 47812) {
              if (e < 47785) {
                if (e === 47784)
                  return i.CLUSTER_BREAK.LV;
              } else if (47785 <= e && e <= 47811)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 47813) {
              if (e === 47812)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47840) {
              if (47813 <= e && e <= 47839)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 47840)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 47924) {
            if (e < 47869) {
              if (e < 47868) {
                if (47841 <= e && e <= 47867)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 47868)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47896) {
              if (47869 <= e && e <= 47895)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 47897) {
              if (e === 47896)
                return i.CLUSTER_BREAK.LV;
            } else if (47897 <= e && e <= 47923)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47953) {
            if (e < 47925) {
              if (e === 47924)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47952) {
              if (47925 <= e && e <= 47951)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 47952)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 47980) {
            if (47953 <= e && e <= 47979)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47981) {
            if (e === 47980)
              return i.CLUSTER_BREAK.LV;
          } else if (47981 <= e && e <= 48007)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48149) {
          if (e < 48065) {
            if (e < 48036) {
              if (e < 48009) {
                if (e === 48008)
                  return i.CLUSTER_BREAK.LV;
              } else if (48009 <= e && e <= 48035)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 48037) {
              if (e === 48036)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 48064) {
              if (48037 <= e && e <= 48063)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 48064)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48120) {
            if (e < 48092) {
              if (48065 <= e && e <= 48091)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 48093) {
              if (e === 48092)
                return i.CLUSTER_BREAK.LV;
            } else if (48093 <= e && e <= 48119)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 48121) {
            if (e === 48120)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48148) {
            if (48121 <= e && e <= 48147)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 48148)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 48232) {
          if (e < 48177) {
            if (e < 48176) {
              if (48149 <= e && e <= 48175)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 48176)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48204) {
            if (48177 <= e && e <= 48203)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 48205) {
            if (e === 48204)
              return i.CLUSTER_BREAK.LV;
          } else if (48205 <= e && e <= 48231)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48261) {
          if (e < 48233) {
            if (e === 48232)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48260) {
            if (48233 <= e && e <= 48259)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 48260)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 48288) {
          if (48261 <= e && e <= 48287)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48289) {
          if (e === 48288)
            return i.CLUSTER_BREAK.LV;
        } else if (48289 <= e && e <= 48315)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 48597) {
        if (e < 48456) {
          if (e < 48373) {
            if (e < 48344) {
              if (e < 48317) {
                if (e === 48316)
                  return i.CLUSTER_BREAK.LV;
              } else if (48317 <= e && e <= 48343)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 48345) {
              if (e === 48344)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 48372) {
              if (48345 <= e && e <= 48371)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 48372)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48401) {
            if (e < 48400) {
              if (48373 <= e && e <= 48399)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 48400)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48428) {
            if (48401 <= e && e <= 48427)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 48429) {
            if (e === 48428)
              return i.CLUSTER_BREAK.LV;
          } else if (48429 <= e && e <= 48455)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48513) {
          if (e < 48484) {
            if (e < 48457) {
              if (e === 48456)
                return i.CLUSTER_BREAK.LV;
            } else if (48457 <= e && e <= 48483)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 48485) {
            if (e === 48484)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48512) {
            if (48485 <= e && e <= 48511)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 48512)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 48568) {
          if (e < 48540) {
            if (48513 <= e && e <= 48539)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 48541) {
            if (e === 48540)
              return i.CLUSTER_BREAK.LV;
          } else if (48541 <= e && e <= 48567)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48569) {
          if (e === 48568)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 48596) {
          if (48569 <= e && e <= 48595)
            return i.CLUSTER_BREAK.LVT;
        } else if (e === 48596)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 48764) {
        if (e < 48680) {
          if (e < 48625) {
            if (e < 48624) {
              if (48597 <= e && e <= 48623)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 48624)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48652) {
            if (48625 <= e && e <= 48651)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 48653) {
            if (e === 48652)
              return i.CLUSTER_BREAK.LV;
          } else if (48653 <= e && e <= 48679)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48709) {
          if (e < 48681) {
            if (e === 48680)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48708) {
            if (48681 <= e && e <= 48707)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 48708)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 48736) {
          if (48709 <= e && e <= 48735)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48737) {
          if (e === 48736)
            return i.CLUSTER_BREAK.LV;
        } else if (48737 <= e && e <= 48763)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 48821) {
        if (e < 48792) {
          if (e < 48765) {
            if (e === 48764)
              return i.CLUSTER_BREAK.LV;
          } else if (48765 <= e && e <= 48791)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48793) {
          if (e === 48792)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 48820) {
          if (48793 <= e && e <= 48819)
            return i.CLUSTER_BREAK.LVT;
        } else if (e === 48820)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 48876) {
        if (e < 48848) {
          if (48821 <= e && e <= 48847)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48849) {
          if (e === 48848)
            return i.CLUSTER_BREAK.LV;
        } else if (48849 <= e && e <= 48875)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 48877) {
        if (e === 48876)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 48904) {
        if (48877 <= e && e <= 48903)
          return i.CLUSTER_BREAK.LVT;
      } else if (e === 48904)
        return i.CLUSTER_BREAK.LV;
    } else if (e < 53720) {
      if (e < 51312) {
        if (e < 50108) {
          if (e < 49493) {
            if (e < 49212) {
              if (e < 49045) {
                if (e < 48988) {
                  if (e < 48933) {
                    if (e < 48932) {
                      if (48905 <= e && e <= 48931)
                        return i.CLUSTER_BREAK.LVT;
                    } else if (e === 48932)
                      return i.CLUSTER_BREAK.LV;
                  } else if (e < 48960) {
                    if (48933 <= e && e <= 48959)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e < 48961) {
                    if (e === 48960)
                      return i.CLUSTER_BREAK.LV;
                  } else if (48961 <= e && e <= 48987)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 49016) {
                  if (e < 48989) {
                    if (e === 48988)
                      return i.CLUSTER_BREAK.LV;
                  } else if (48989 <= e && e <= 49015)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 49017) {
                  if (e === 49016)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 49044) {
                  if (49017 <= e && e <= 49043)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 49044)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49128) {
                if (e < 49073) {
                  if (e < 49072) {
                    if (49045 <= e && e <= 49071)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e === 49072)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 49100) {
                  if (49073 <= e && e <= 49099)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 49101) {
                  if (e === 49100)
                    return i.CLUSTER_BREAK.LV;
                } else if (49101 <= e && e <= 49127)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49157) {
                if (e < 49129) {
                  if (e === 49128)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 49156) {
                  if (49129 <= e && e <= 49155)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 49156)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49184) {
                if (49157 <= e && e <= 49183)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49185) {
                if (e === 49184)
                  return i.CLUSTER_BREAK.LV;
              } else if (49185 <= e && e <= 49211)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 49352) {
              if (e < 49269) {
                if (e < 49240) {
                  if (e < 49213) {
                    if (e === 49212)
                      return i.CLUSTER_BREAK.LV;
                  } else if (49213 <= e && e <= 49239)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 49241) {
                  if (e === 49240)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 49268) {
                  if (49241 <= e && e <= 49267)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 49268)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49297) {
                if (e < 49296) {
                  if (49269 <= e && e <= 49295)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 49296)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49324) {
                if (49297 <= e && e <= 49323)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49325) {
                if (e === 49324)
                  return i.CLUSTER_BREAK.LV;
              } else if (49325 <= e && e <= 49351)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 49409) {
              if (e < 49380) {
                if (e < 49353) {
                  if (e === 49352)
                    return i.CLUSTER_BREAK.LV;
                } else if (49353 <= e && e <= 49379)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49381) {
                if (e === 49380)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49408) {
                if (49381 <= e && e <= 49407)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 49408)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 49464) {
              if (e < 49436) {
                if (49409 <= e && e <= 49435)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49437) {
                if (e === 49436)
                  return i.CLUSTER_BREAK.LV;
              } else if (49437 <= e && e <= 49463)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 49465) {
              if (e === 49464)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 49492) {
              if (49465 <= e && e <= 49491)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 49492)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 49800) {
            if (e < 49633) {
              if (e < 49576) {
                if (e < 49521) {
                  if (e < 49520) {
                    if (49493 <= e && e <= 49519)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e === 49520)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 49548) {
                  if (49521 <= e && e <= 49547)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 49549) {
                  if (e === 49548)
                    return i.CLUSTER_BREAK.LV;
                } else if (49549 <= e && e <= 49575)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49604) {
                if (e < 49577) {
                  if (e === 49576)
                    return i.CLUSTER_BREAK.LV;
                } else if (49577 <= e && e <= 49603)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49605) {
                if (e === 49604)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49632) {
                if (49605 <= e && e <= 49631)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 49632)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 49716) {
              if (e < 49661) {
                if (e < 49660) {
                  if (49633 <= e && e <= 49659)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 49660)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49688) {
                if (49661 <= e && e <= 49687)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49689) {
                if (e === 49688)
                  return i.CLUSTER_BREAK.LV;
              } else if (49689 <= e && e <= 49715)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 49745) {
              if (e < 49717) {
                if (e === 49716)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49744) {
                if (49717 <= e && e <= 49743)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 49744)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 49772) {
              if (49745 <= e && e <= 49771)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 49773) {
              if (e === 49772)
                return i.CLUSTER_BREAK.LV;
            } else if (49773 <= e && e <= 49799)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 49941) {
            if (e < 49857) {
              if (e < 49828) {
                if (e < 49801) {
                  if (e === 49800)
                    return i.CLUSTER_BREAK.LV;
                } else if (49801 <= e && e <= 49827)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49829) {
                if (e === 49828)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49856) {
                if (49829 <= e && e <= 49855)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 49856)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 49912) {
              if (e < 49884) {
                if (49857 <= e && e <= 49883)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49885) {
                if (e === 49884)
                  return i.CLUSTER_BREAK.LV;
              } else if (49885 <= e && e <= 49911)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 49913) {
              if (e === 49912)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 49940) {
              if (49913 <= e && e <= 49939)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 49940)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 50024) {
            if (e < 49969) {
              if (e < 49968) {
                if (49941 <= e && e <= 49967)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 49968)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 49996) {
              if (49969 <= e && e <= 49995)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 49997) {
              if (e === 49996)
                return i.CLUSTER_BREAK.LV;
            } else if (49997 <= e && e <= 50023)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 50053) {
            if (e < 50025) {
              if (e === 50024)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 50052) {
              if (50025 <= e && e <= 50051)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 50052)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 50080) {
            if (50053 <= e && e <= 50079)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 50081) {
            if (e === 50080)
              return i.CLUSTER_BREAK.LV;
          } else if (50081 <= e && e <= 50107)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 50697) {
          if (e < 50389) {
            if (e < 50248) {
              if (e < 50165) {
                if (e < 50136) {
                  if (e < 50109) {
                    if (e === 50108)
                      return i.CLUSTER_BREAK.LV;
                  } else if (50109 <= e && e <= 50135)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 50137) {
                  if (e === 50136)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 50164) {
                  if (50137 <= e && e <= 50163)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 50164)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 50193) {
                if (e < 50192) {
                  if (50165 <= e && e <= 50191)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 50192)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 50220) {
                if (50193 <= e && e <= 50219)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 50221) {
                if (e === 50220)
                  return i.CLUSTER_BREAK.LV;
              } else if (50221 <= e && e <= 50247)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50305) {
              if (e < 50276) {
                if (e < 50249) {
                  if (e === 50248)
                    return i.CLUSTER_BREAK.LV;
                } else if (50249 <= e && e <= 50275)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 50277) {
                if (e === 50276)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 50304) {
                if (50277 <= e && e <= 50303)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 50304)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 50360) {
              if (e < 50332) {
                if (50305 <= e && e <= 50331)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 50333) {
                if (e === 50332)
                  return i.CLUSTER_BREAK.LV;
              } else if (50333 <= e && e <= 50359)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50361) {
              if (e === 50360)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 50388) {
              if (50361 <= e && e <= 50387)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 50388)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 50556) {
            if (e < 50472) {
              if (e < 50417) {
                if (e < 50416) {
                  if (50389 <= e && e <= 50415)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 50416)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 50444) {
                if (50417 <= e && e <= 50443)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 50445) {
                if (e === 50444)
                  return i.CLUSTER_BREAK.LV;
              } else if (50445 <= e && e <= 50471)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50501) {
              if (e < 50473) {
                if (e === 50472)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 50500) {
                if (50473 <= e && e <= 50499)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 50500)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 50528) {
              if (50501 <= e && e <= 50527)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50529) {
              if (e === 50528)
                return i.CLUSTER_BREAK.LV;
            } else if (50529 <= e && e <= 50555)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 50613) {
            if (e < 50584) {
              if (e < 50557) {
                if (e === 50556)
                  return i.CLUSTER_BREAK.LV;
              } else if (50557 <= e && e <= 50583)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50585) {
              if (e === 50584)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 50612) {
              if (50585 <= e && e <= 50611)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 50612)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 50668) {
            if (e < 50640) {
              if (50613 <= e && e <= 50639)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50641) {
              if (e === 50640)
                return i.CLUSTER_BREAK.LV;
            } else if (50641 <= e && e <= 50667)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 50669) {
            if (e === 50668)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 50696) {
            if (50669 <= e && e <= 50695)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 50696)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 51004) {
          if (e < 50837) {
            if (e < 50780) {
              if (e < 50725) {
                if (e < 50724) {
                  if (50697 <= e && e <= 50723)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 50724)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 50752) {
                if (50725 <= e && e <= 50751)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 50753) {
                if (e === 50752)
                  return i.CLUSTER_BREAK.LV;
              } else if (50753 <= e && e <= 50779)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50808) {
              if (e < 50781) {
                if (e === 50780)
                  return i.CLUSTER_BREAK.LV;
              } else if (50781 <= e && e <= 50807)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50809) {
              if (e === 50808)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 50836) {
              if (50809 <= e && e <= 50835)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 50836)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 50920) {
            if (e < 50865) {
              if (e < 50864) {
                if (50837 <= e && e <= 50863)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 50864)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 50892) {
              if (50865 <= e && e <= 50891)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50893) {
              if (e === 50892)
                return i.CLUSTER_BREAK.LV;
            } else if (50893 <= e && e <= 50919)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 50949) {
            if (e < 50921) {
              if (e === 50920)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 50948) {
              if (50921 <= e && e <= 50947)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 50948)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 50976) {
            if (50949 <= e && e <= 50975)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 50977) {
            if (e === 50976)
              return i.CLUSTER_BREAK.LV;
          } else if (50977 <= e && e <= 51003)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 51145) {
          if (e < 51061) {
            if (e < 51032) {
              if (e < 51005) {
                if (e === 51004)
                  return i.CLUSTER_BREAK.LV;
              } else if (51005 <= e && e <= 51031)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 51033) {
              if (e === 51032)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 51060) {
              if (51033 <= e && e <= 51059)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 51060)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 51116) {
            if (e < 51088) {
              if (51061 <= e && e <= 51087)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 51089) {
              if (e === 51088)
                return i.CLUSTER_BREAK.LV;
            } else if (51089 <= e && e <= 51115)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 51117) {
            if (e === 51116)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 51144) {
            if (51117 <= e && e <= 51143)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 51144)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 51228) {
          if (e < 51173) {
            if (e < 51172) {
              if (51145 <= e && e <= 51171)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 51172)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 51200) {
            if (51173 <= e && e <= 51199)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 51201) {
            if (e === 51200)
              return i.CLUSTER_BREAK.LV;
          } else if (51201 <= e && e <= 51227)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 51257) {
          if (e < 51229) {
            if (e === 51228)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 51256) {
            if (51229 <= e && e <= 51255)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 51256)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 51284) {
          if (51257 <= e && e <= 51283)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 51285) {
          if (e === 51284)
            return i.CLUSTER_BREAK.LV;
        } else if (51285 <= e && e <= 51311)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 52516) {
        if (e < 51901) {
          if (e < 51593) {
            if (e < 51452) {
              if (e < 51369) {
                if (e < 51340) {
                  if (e < 51313) {
                    if (e === 51312)
                      return i.CLUSTER_BREAK.LV;
                  } else if (51313 <= e && e <= 51339)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 51341) {
                  if (e === 51340)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 51368) {
                  if (51341 <= e && e <= 51367)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 51368)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 51397) {
                if (e < 51396) {
                  if (51369 <= e && e <= 51395)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 51396)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 51424) {
                if (51397 <= e && e <= 51423)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 51425) {
                if (e === 51424)
                  return i.CLUSTER_BREAK.LV;
              } else if (51425 <= e && e <= 51451)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 51509) {
              if (e < 51480) {
                if (e < 51453) {
                  if (e === 51452)
                    return i.CLUSTER_BREAK.LV;
                } else if (51453 <= e && e <= 51479)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 51481) {
                if (e === 51480)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 51508) {
                if (51481 <= e && e <= 51507)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 51508)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 51564) {
              if (e < 51536) {
                if (51509 <= e && e <= 51535)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 51537) {
                if (e === 51536)
                  return i.CLUSTER_BREAK.LV;
              } else if (51537 <= e && e <= 51563)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 51565) {
              if (e === 51564)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 51592) {
              if (51565 <= e && e <= 51591)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 51592)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 51760) {
            if (e < 51676) {
              if (e < 51621) {
                if (e < 51620) {
                  if (51593 <= e && e <= 51619)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 51620)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 51648) {
                if (51621 <= e && e <= 51647)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 51649) {
                if (e === 51648)
                  return i.CLUSTER_BREAK.LV;
              } else if (51649 <= e && e <= 51675)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 51705) {
              if (e < 51677) {
                if (e === 51676)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 51704) {
                if (51677 <= e && e <= 51703)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 51704)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 51732) {
              if (51705 <= e && e <= 51731)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 51733) {
              if (e === 51732)
                return i.CLUSTER_BREAK.LV;
            } else if (51733 <= e && e <= 51759)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 51817) {
            if (e < 51788) {
              if (e < 51761) {
                if (e === 51760)
                  return i.CLUSTER_BREAK.LV;
              } else if (51761 <= e && e <= 51787)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 51789) {
              if (e === 51788)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 51816) {
              if (51789 <= e && e <= 51815)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 51816)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 51872) {
            if (e < 51844) {
              if (51817 <= e && e <= 51843)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 51845) {
              if (e === 51844)
                return i.CLUSTER_BREAK.LV;
            } else if (51845 <= e && e <= 51871)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 51873) {
            if (e === 51872)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 51900) {
            if (51873 <= e && e <= 51899)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 51900)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 52208) {
          if (e < 52041) {
            if (e < 51984) {
              if (e < 51929) {
                if (e < 51928) {
                  if (51901 <= e && e <= 51927)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 51928)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 51956) {
                if (51929 <= e && e <= 51955)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 51957) {
                if (e === 51956)
                  return i.CLUSTER_BREAK.LV;
              } else if (51957 <= e && e <= 51983)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52012) {
              if (e < 51985) {
                if (e === 51984)
                  return i.CLUSTER_BREAK.LV;
              } else if (51985 <= e && e <= 52011)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52013) {
              if (e === 52012)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52040) {
              if (52013 <= e && e <= 52039)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 52040)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52124) {
            if (e < 52069) {
              if (e < 52068) {
                if (52041 <= e && e <= 52067)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 52068)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52096) {
              if (52069 <= e && e <= 52095)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52097) {
              if (e === 52096)
                return i.CLUSTER_BREAK.LV;
            } else if (52097 <= e && e <= 52123)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52153) {
            if (e < 52125) {
              if (e === 52124)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52152) {
              if (52125 <= e && e <= 52151)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 52152)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52180) {
            if (52153 <= e && e <= 52179)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52181) {
            if (e === 52180)
              return i.CLUSTER_BREAK.LV;
          } else if (52181 <= e && e <= 52207)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 52349) {
          if (e < 52265) {
            if (e < 52236) {
              if (e < 52209) {
                if (e === 52208)
                  return i.CLUSTER_BREAK.LV;
              } else if (52209 <= e && e <= 52235)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52237) {
              if (e === 52236)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52264) {
              if (52237 <= e && e <= 52263)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 52264)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52320) {
            if (e < 52292) {
              if (52265 <= e && e <= 52291)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52293) {
              if (e === 52292)
                return i.CLUSTER_BREAK.LV;
            } else if (52293 <= e && e <= 52319)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52321) {
            if (e === 52320)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52348) {
            if (52321 <= e && e <= 52347)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 52348)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 52432) {
          if (e < 52377) {
            if (e < 52376) {
              if (52349 <= e && e <= 52375)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 52376)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52404) {
            if (52377 <= e && e <= 52403)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52405) {
            if (e === 52404)
              return i.CLUSTER_BREAK.LV;
          } else if (52405 <= e && e <= 52431)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 52461) {
          if (e < 52433) {
            if (e === 52432)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52460) {
            if (52433 <= e && e <= 52459)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 52460)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 52488) {
          if (52461 <= e && e <= 52487)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 52489) {
          if (e === 52488)
            return i.CLUSTER_BREAK.LV;
        } else if (52489 <= e && e <= 52515)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 53105) {
        if (e < 52797) {
          if (e < 52656) {
            if (e < 52573) {
              if (e < 52544) {
                if (e < 52517) {
                  if (e === 52516)
                    return i.CLUSTER_BREAK.LV;
                } else if (52517 <= e && e <= 52543)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 52545) {
                if (e === 52544)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 52572) {
                if (52545 <= e && e <= 52571)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 52572)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52601) {
              if (e < 52600) {
                if (52573 <= e && e <= 52599)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 52600)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52628) {
              if (52601 <= e && e <= 52627)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52629) {
              if (e === 52628)
                return i.CLUSTER_BREAK.LV;
            } else if (52629 <= e && e <= 52655)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52713) {
            if (e < 52684) {
              if (e < 52657) {
                if (e === 52656)
                  return i.CLUSTER_BREAK.LV;
              } else if (52657 <= e && e <= 52683)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52685) {
              if (e === 52684)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52712) {
              if (52685 <= e && e <= 52711)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 52712)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52768) {
            if (e < 52740) {
              if (52713 <= e && e <= 52739)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52741) {
              if (e === 52740)
                return i.CLUSTER_BREAK.LV;
            } else if (52741 <= e && e <= 52767)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52769) {
            if (e === 52768)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52796) {
            if (52769 <= e && e <= 52795)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 52796)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 52964) {
          if (e < 52880) {
            if (e < 52825) {
              if (e < 52824) {
                if (52797 <= e && e <= 52823)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 52824)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52852) {
              if (52825 <= e && e <= 52851)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52853) {
              if (e === 52852)
                return i.CLUSTER_BREAK.LV;
            } else if (52853 <= e && e <= 52879)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52909) {
            if (e < 52881) {
              if (e === 52880)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52908) {
              if (52881 <= e && e <= 52907)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 52908)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52936) {
            if (52909 <= e && e <= 52935)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52937) {
            if (e === 52936)
              return i.CLUSTER_BREAK.LV;
          } else if (52937 <= e && e <= 52963)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 53021) {
          if (e < 52992) {
            if (e < 52965) {
              if (e === 52964)
                return i.CLUSTER_BREAK.LV;
            } else if (52965 <= e && e <= 52991)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52993) {
            if (e === 52992)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 53020) {
            if (52993 <= e && e <= 53019)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 53020)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 53076) {
          if (e < 53048) {
            if (53021 <= e && e <= 53047)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 53049) {
            if (e === 53048)
              return i.CLUSTER_BREAK.LV;
          } else if (53049 <= e && e <= 53075)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 53077) {
          if (e === 53076)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 53104) {
          if (53077 <= e && e <= 53103)
            return i.CLUSTER_BREAK.LVT;
        } else if (e === 53104)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 53412) {
        if (e < 53245) {
          if (e < 53188) {
            if (e < 53133) {
              if (e < 53132) {
                if (53105 <= e && e <= 53131)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 53132)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 53160) {
              if (53133 <= e && e <= 53159)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 53161) {
              if (e === 53160)
                return i.CLUSTER_BREAK.LV;
            } else if (53161 <= e && e <= 53187)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 53216) {
            if (e < 53189) {
              if (e === 53188)
                return i.CLUSTER_BREAK.LV;
            } else if (53189 <= e && e <= 53215)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 53217) {
            if (e === 53216)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 53244) {
            if (53217 <= e && e <= 53243)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 53244)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 53328) {
          if (e < 53273) {
            if (e < 53272) {
              if (53245 <= e && e <= 53271)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 53272)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 53300) {
            if (53273 <= e && e <= 53299)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 53301) {
            if (e === 53300)
              return i.CLUSTER_BREAK.LV;
          } else if (53301 <= e && e <= 53327)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 53357) {
          if (e < 53329) {
            if (e === 53328)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 53356) {
            if (53329 <= e && e <= 53355)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 53356)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 53384) {
          if (53357 <= e && e <= 53383)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 53385) {
          if (e === 53384)
            return i.CLUSTER_BREAK.LV;
        } else if (53385 <= e && e <= 53411)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 53553) {
        if (e < 53469) {
          if (e < 53440) {
            if (e < 53413) {
              if (e === 53412)
                return i.CLUSTER_BREAK.LV;
            } else if (53413 <= e && e <= 53439)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 53441) {
            if (e === 53440)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 53468) {
            if (53441 <= e && e <= 53467)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 53468)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 53524) {
          if (e < 53496) {
            if (53469 <= e && e <= 53495)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 53497) {
            if (e === 53496)
              return i.CLUSTER_BREAK.LV;
          } else if (53497 <= e && e <= 53523)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 53525) {
          if (e === 53524)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 53552) {
          if (53525 <= e && e <= 53551)
            return i.CLUSTER_BREAK.LVT;
        } else if (e === 53552)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 53636) {
        if (e < 53581) {
          if (e < 53580) {
            if (53553 <= e && e <= 53579)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 53580)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 53608) {
          if (53581 <= e && e <= 53607)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 53609) {
          if (e === 53608)
            return i.CLUSTER_BREAK.LV;
        } else if (53609 <= e && e <= 53635)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 53665) {
        if (e < 53637) {
          if (e === 53636)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 53664) {
          if (53637 <= e && e <= 53663)
            return i.CLUSTER_BREAK.LVT;
        } else if (e === 53664)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 53692) {
        if (53665 <= e && e <= 53691)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 53693) {
        if (e === 53692)
          return i.CLUSTER_BREAK.LV;
      } else if (53693 <= e && e <= 53719)
        return i.CLUSTER_BREAK.LVT;
    } else if (e < 70459) {
      if (e < 54897) {
        if (e < 54308) {
          if (e < 54001) {
            if (e < 53860) {
              if (e < 53777) {
                if (e < 53748) {
                  if (e < 53721) {
                    if (e === 53720)
                      return i.CLUSTER_BREAK.LV;
                  } else if (53721 <= e && e <= 53747)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 53749) {
                  if (e === 53748)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 53776) {
                  if (53749 <= e && e <= 53775)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 53776)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 53805) {
                if (e < 53804) {
                  if (53777 <= e && e <= 53803)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 53804)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 53832) {
                if (53805 <= e && e <= 53831)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 53833) {
                if (e === 53832)
                  return i.CLUSTER_BREAK.LV;
              } else if (53833 <= e && e <= 53859)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 53917) {
              if (e < 53888) {
                if (e < 53861) {
                  if (e === 53860)
                    return i.CLUSTER_BREAK.LV;
                } else if (53861 <= e && e <= 53887)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 53889) {
                if (e === 53888)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 53916) {
                if (53889 <= e && e <= 53915)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 53916)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 53972) {
              if (e < 53944) {
                if (53917 <= e && e <= 53943)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 53945) {
                if (e === 53944)
                  return i.CLUSTER_BREAK.LV;
              } else if (53945 <= e && e <= 53971)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 53973) {
              if (e === 53972)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54e3) {
              if (53973 <= e && e <= 53999)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 54e3)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 54141) {
            if (e < 54084) {
              if (e < 54029) {
                if (e < 54028) {
                  if (54001 <= e && e <= 54027)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 54028)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 54056) {
                if (54029 <= e && e <= 54055)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 54057) {
                if (e === 54056)
                  return i.CLUSTER_BREAK.LV;
              } else if (54057 <= e && e <= 54083)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 54112) {
              if (e < 54085) {
                if (e === 54084)
                  return i.CLUSTER_BREAK.LV;
              } else if (54085 <= e && e <= 54111)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 54113) {
              if (e === 54112)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54140) {
              if (54113 <= e && e <= 54139)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 54140)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 54224) {
            if (e < 54169) {
              if (e < 54168) {
                if (54141 <= e && e <= 54167)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 54168)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54196) {
              if (54169 <= e && e <= 54195)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 54197) {
              if (e === 54196)
                return i.CLUSTER_BREAK.LV;
            } else if (54197 <= e && e <= 54223)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 54253) {
            if (e < 54225) {
              if (e === 54224)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54252) {
              if (54225 <= e && e <= 54251)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 54252)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 54280) {
            if (54253 <= e && e <= 54279)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 54281) {
            if (e === 54280)
              return i.CLUSTER_BREAK.LV;
          } else if (54281 <= e && e <= 54307)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 54589) {
          if (e < 54448) {
            if (e < 54365) {
              if (e < 54336) {
                if (e < 54309) {
                  if (e === 54308)
                    return i.CLUSTER_BREAK.LV;
                } else if (54309 <= e && e <= 54335)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 54337) {
                if (e === 54336)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 54364) {
                if (54337 <= e && e <= 54363)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 54364)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54393) {
              if (e < 54392) {
                if (54365 <= e && e <= 54391)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 54392)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54420) {
              if (54393 <= e && e <= 54419)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 54421) {
              if (e === 54420)
                return i.CLUSTER_BREAK.LV;
            } else if (54421 <= e && e <= 54447)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 54505) {
            if (e < 54476) {
              if (e < 54449) {
                if (e === 54448)
                  return i.CLUSTER_BREAK.LV;
              } else if (54449 <= e && e <= 54475)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 54477) {
              if (e === 54476)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54504) {
              if (54477 <= e && e <= 54503)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 54504)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 54560) {
            if (e < 54532) {
              if (54505 <= e && e <= 54531)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 54533) {
              if (e === 54532)
                return i.CLUSTER_BREAK.LV;
            } else if (54533 <= e && e <= 54559)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 54561) {
            if (e === 54560)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 54588) {
            if (54561 <= e && e <= 54587)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 54588)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 54756) {
          if (e < 54672) {
            if (e < 54617) {
              if (e < 54616) {
                if (54589 <= e && e <= 54615)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 54616)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54644) {
              if (54617 <= e && e <= 54643)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 54645) {
              if (e === 54644)
                return i.CLUSTER_BREAK.LV;
            } else if (54645 <= e && e <= 54671)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 54701) {
            if (e < 54673) {
              if (e === 54672)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54700) {
              if (54673 <= e && e <= 54699)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 54700)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 54728) {
            if (54701 <= e && e <= 54727)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 54729) {
            if (e === 54728)
              return i.CLUSTER_BREAK.LV;
          } else if (54729 <= e && e <= 54755)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 54813) {
          if (e < 54784) {
            if (e < 54757) {
              if (e === 54756)
                return i.CLUSTER_BREAK.LV;
            } else if (54757 <= e && e <= 54783)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 54785) {
            if (e === 54784)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 54812) {
            if (54785 <= e && e <= 54811)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 54812)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 54868) {
          if (e < 54840) {
            if (54813 <= e && e <= 54839)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 54841) {
            if (e === 54840)
              return i.CLUSTER_BREAK.LV;
          } else if (54841 <= e && e <= 54867)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 54869) {
          if (e === 54868)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 54896) {
          if (54869 <= e && e <= 54895)
            return i.CLUSTER_BREAK.LVT;
        } else if (e === 54896)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 69632) {
        if (e < 55216) {
          if (e < 55037) {
            if (e < 54980) {
              if (e < 54925) {
                if (e < 54924) {
                  if (54897 <= e && e <= 54923)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 54924)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 54952) {
                if (54925 <= e && e <= 54951)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 54953) {
                if (e === 54952)
                  return i.CLUSTER_BREAK.LV;
              } else if (54953 <= e && e <= 54979)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 55008) {
              if (e < 54981) {
                if (e === 54980)
                  return i.CLUSTER_BREAK.LV;
              } else if (54981 <= e && e <= 55007)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 55009) {
              if (e === 55008)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 55036) {
              if (55009 <= e && e <= 55035)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 55036)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 55120) {
            if (e < 55065) {
              if (e < 55064) {
                if (55037 <= e && e <= 55063)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 55064)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 55092) {
              if (55065 <= e && e <= 55091)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 55093) {
              if (e === 55092)
                return i.CLUSTER_BREAK.LV;
            } else if (55093 <= e && e <= 55119)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 55149) {
            if (e < 55121) {
              if (e === 55120)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 55148) {
              if (55121 <= e && e <= 55147)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 55148)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 55176) {
            if (55149 <= e && e <= 55175)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 55177) {
            if (e === 55176)
              return i.CLUSTER_BREAK.LV;
          } else if (55177 <= e && e <= 55203)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 68097) {
          if (e < 65279) {
            if (e < 64286) {
              if (e < 55243) {
                if (55216 <= e && e <= 55238)
                  return i.CLUSTER_BREAK.V;
              } else if (55243 <= e && e <= 55291)
                return i.CLUSTER_BREAK.T;
            } else if (e < 65024) {
              if (e === 64286)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 65056) {
              if (65024 <= e && e <= 65039)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (65056 <= e && e <= 65071)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 66045) {
            if (e < 65438) {
              if (e === 65279)
                return i.CLUSTER_BREAK.CONTROL;
            } else if (e < 65520) {
              if (65438 <= e && e <= 65439)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (65520 <= e && e <= 65531)
              return i.CLUSTER_BREAK.CONTROL;
          } else if (e < 66272) {
            if (e === 66045)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 66422) {
            if (e === 66272)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (66422 <= e && e <= 66426)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 68325) {
          if (e < 68108) {
            if (e < 68101) {
              if (68097 <= e && e <= 68099)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (68101 <= e && e <= 68102)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 68152) {
            if (68108 <= e && e <= 68111)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 68159) {
            if (68152 <= e && e <= 68154)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e === 68159)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 69373) {
          if (e < 68900) {
            if (68325 <= e && e <= 68326)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 69291) {
            if (68900 <= e && e <= 68903)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (69291 <= e && e <= 69292)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 69446) {
          if (69373 <= e && e <= 69375)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 69506) {
          if (69446 <= e && e <= 69456)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (69506 <= e && e <= 69509)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 70016) {
        if (e < 69815) {
          if (e < 69747) {
            if (e < 69634) {
              if (e === 69632)
                return i.CLUSTER_BREAK.SPACINGMARK;
              if (e === 69633)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 69688) {
              if (e === 69634)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 69744) {
              if (69688 <= e && e <= 69702)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e === 69744)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 69762) {
            if (e < 69759) {
              if (69747 <= e && e <= 69748)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (69759 <= e && e <= 69761)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 69808) {
            if (e === 69762)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 69811) {
            if (69808 <= e && e <= 69810)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (69811 <= e && e <= 69814)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 69888)
          if (e < 69821) {
            if (e < 69817) {
              if (69815 <= e && e <= 69816)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (69817 <= e && e <= 69818)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 69826) {
            if (e === 69821)
              return i.CLUSTER_BREAK.PREPEND;
          } else {
            if (e === 69826)
              return i.CLUSTER_BREAK.EXTEND;
            if (e === 69837)
              return i.CLUSTER_BREAK.PREPEND;
          }
        else if (e < 69933) {
          if (e < 69927) {
            if (69888 <= e && e <= 69890)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 69932) {
            if (69927 <= e && e <= 69931)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e === 69932)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 69957) {
          if (69933 <= e && e <= 69940)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 70003) {
          if (69957 <= e && e <= 69958)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e === 70003)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 70194) {
        if (e < 70082) {
          if (e < 70067) {
            if (e < 70018) {
              if (70016 <= e && e <= 70017)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e === 70018)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 70070) {
            if (70067 <= e && e <= 70069)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 70079) {
            if (70070 <= e && e <= 70078)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (70079 <= e && e <= 70080)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 70095) {
          if (e < 70089) {
            if (70082 <= e && e <= 70083)
              return i.CLUSTER_BREAK.PREPEND;
          } else if (e < 70094) {
            if (70089 <= e && e <= 70092)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e === 70094)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 70188) {
          if (e === 70095)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 70191) {
          if (70188 <= e && e <= 70190)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (70191 <= e && e <= 70193)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 70209) {
        if (e < 70197) {
          if (e < 70196) {
            if (70194 <= e && e <= 70195)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e === 70196)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 70198) {
          if (e === 70197)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 70206) {
          if (70198 <= e && e <= 70199)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e === 70206)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 70371) {
        if (e < 70367) {
          if (e === 70209)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 70368) {
          if (e === 70367)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (70368 <= e && e <= 70370)
          return i.CLUSTER_BREAK.SPACINGMARK;
      } else if (e < 70400) {
        if (70371 <= e && e <= 70378)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 70402) {
        if (70400 <= e && e <= 70401)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (70402 <= e && e <= 70403)
        return i.CLUSTER_BREAK.SPACINGMARK;
    } else if (e < 72343) {
      if (e < 71339) {
        if (e < 70841) {
          if (e < 70512) {
            if (e < 70471) {
              if (e < 70463) {
                if (e < 70462) {
                  if (70459 <= e && e <= 70460)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 70462)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 70464) {
                if (e === 70463)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 70465) {
                if (e === 70464)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (70465 <= e && e <= 70468)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 70487) {
              if (e < 70475) {
                if (70471 <= e && e <= 70472)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (70475 <= e && e <= 70477)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 70498) {
              if (e === 70487)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 70502) {
              if (70498 <= e && e <= 70499)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (70502 <= e && e <= 70508)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 70725) {
            if (e < 70712) {
              if (e < 70709) {
                if (70512 <= e && e <= 70516)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (70709 <= e && e <= 70711)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 70720) {
              if (70712 <= e && e <= 70719)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 70722) {
              if (70720 <= e && e <= 70721)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (70722 <= e && e <= 70724)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 70832) {
            if (e < 70726) {
              if (e === 70725)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 70726 || e === 70750)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 70833) {
            if (e === 70832)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 70835) {
            if (70833 <= e && e <= 70834)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (70835 <= e && e <= 70840)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 71096) {
          if (e < 70847)
            if (e < 70843) {
              if (e === 70841)
                return i.CLUSTER_BREAK.SPACINGMARK;
              if (e === 70842)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 70845) {
              if (70843 <= e && e <= 70844)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else {
              if (e === 70845)
                return i.CLUSTER_BREAK.EXTEND;
              if (e === 70846)
                return i.CLUSTER_BREAK.SPACINGMARK;
            }
          else if (e < 71087) {
            if (e < 70849) {
              if (70847 <= e && e <= 70848)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 70850) {
              if (e === 70849)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (70850 <= e && e <= 70851)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 71088) {
            if (e === 71087)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 71090) {
            if (71088 <= e && e <= 71089)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (71090 <= e && e <= 71093)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 71216) {
          if (e < 71102) {
            if (e < 71100) {
              if (71096 <= e && e <= 71099)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (71100 <= e && e <= 71101)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 71103) {
            if (e === 71102)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 71132) {
            if (71103 <= e && e <= 71104)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (71132 <= e && e <= 71133)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 71229) {
          if (e < 71219) {
            if (71216 <= e && e <= 71218)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 71227) {
            if (71219 <= e && e <= 71226)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (71227 <= e && e <= 71228)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 71230) {
          if (e === 71229)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 71231) {
          if (e === 71230)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (71231 <= e && e <= 71232)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 71999)
        if (e < 71463) {
          if (e < 71350) {
            if (e < 71341) {
              if (e === 71339)
                return i.CLUSTER_BREAK.EXTEND;
              if (e === 71340)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 71342) {
              if (e === 71341)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 71344) {
              if (71342 <= e && e <= 71343)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (71344 <= e && e <= 71349)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 71453) {
            if (e === 71350)
              return i.CLUSTER_BREAK.SPACINGMARK;
            if (e === 71351)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 71458) {
            if (71453 <= e && e <= 71455)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 71462) {
            if (71458 <= e && e <= 71461)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e === 71462)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 71984) {
          if (e < 71727) {
            if (e < 71724) {
              if (71463 <= e && e <= 71467)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (71724 <= e && e <= 71726)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 71736) {
            if (71727 <= e && e <= 71735)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 71737) {
            if (e === 71736)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (71737 <= e && e <= 71738)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 71995) {
          if (e < 71985) {
            if (e === 71984)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 71991) {
            if (71985 <= e && e <= 71989)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (71991 <= e && e <= 71992)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 71997) {
          if (71995 <= e && e <= 71996)
            return i.CLUSTER_BREAK.EXTEND;
        } else {
          if (e === 71997)
            return i.CLUSTER_BREAK.SPACINGMARK;
          if (e === 71998)
            return i.CLUSTER_BREAK.EXTEND;
        }
      else if (e < 72193)
        if (e < 72145)
          if (e < 72001) {
            if (e === 71999)
              return i.CLUSTER_BREAK.PREPEND;
            if (e === 72e3)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 72002) {
            if (e === 72001)
              return i.CLUSTER_BREAK.PREPEND;
          } else {
            if (e === 72002)
              return i.CLUSTER_BREAK.SPACINGMARK;
            if (e === 72003)
              return i.CLUSTER_BREAK.EXTEND;
          }
        else if (e < 72156) {
          if (e < 72148) {
            if (72145 <= e && e <= 72147)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 72154) {
            if (72148 <= e && e <= 72151)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (72154 <= e && e <= 72155)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 72160) {
          if (72156 <= e && e <= 72159)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else {
          if (e === 72160)
            return i.CLUSTER_BREAK.EXTEND;
          if (e === 72164)
            return i.CLUSTER_BREAK.SPACINGMARK;
        }
      else if (e < 72263) {
        if (e < 72249) {
          if (e < 72243) {
            if (72193 <= e && e <= 72202)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (72243 <= e && e <= 72248)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 72250) {
          if (e === 72249)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 72251) {
          if (e === 72250)
            return i.CLUSTER_BREAK.PREPEND;
        } else if (72251 <= e && e <= 72254)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 72281) {
        if (e < 72273) {
          if (e === 72263)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 72279) {
          if (72273 <= e && e <= 72278)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (72279 <= e && e <= 72280)
          return i.CLUSTER_BREAK.SPACINGMARK;
      } else if (e < 72324) {
        if (72281 <= e && e <= 72283)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 72330) {
        if (72324 <= e && e <= 72329)
          return i.CLUSTER_BREAK.PREPEND;
      } else if (72330 <= e && e <= 72342)
        return i.CLUSTER_BREAK.EXTEND;
    } else if (e < 94033) {
      if (e < 73104) {
        if (e < 72881) {
          if (e < 72766) {
            if (e < 72751) {
              if (e < 72344) {
                if (e === 72343)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (72344 <= e && e <= 72345)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 72752) {
              if (e === 72751)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 72760) {
              if (72752 <= e && e <= 72758)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (72760 <= e && e <= 72765)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 72850) {
            if (e === 72766)
              return i.CLUSTER_BREAK.SPACINGMARK;
            if (e === 72767)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 72873) {
            if (72850 <= e && e <= 72871)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 72874) {
            if (e === 72873)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (72874 <= e && e <= 72880)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 73018) {
          if (e < 72884) {
            if (e < 72882) {
              if (e === 72881)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (72882 <= e && e <= 72883)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 72885) {
            if (e === 72884)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 73009) {
            if (72885 <= e && e <= 72886)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (73009 <= e && e <= 73014)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 73030) {
          if (e < 73020) {
            if (e === 73018)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 73023) {
            if (73020 <= e && e <= 73021)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (73023 <= e && e <= 73029)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 73031) {
          if (e === 73030)
            return i.CLUSTER_BREAK.PREPEND;
        } else if (e < 73098) {
          if (e === 73031)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (73098 <= e && e <= 73102)
          return i.CLUSTER_BREAK.SPACINGMARK;
      } else if (e < 73526) {
        if (e < 73459)
          if (e < 73109) {
            if (e < 73107) {
              if (73104 <= e && e <= 73105)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (73107 <= e && e <= 73108)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 73110) {
            if (e === 73109)
              return i.CLUSTER_BREAK.EXTEND;
          } else {
            if (e === 73110)
              return i.CLUSTER_BREAK.SPACINGMARK;
            if (e === 73111)
              return i.CLUSTER_BREAK.EXTEND;
          }
        else if (e < 73474) {
          if (e < 73461) {
            if (73459 <= e && e <= 73460)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 73472) {
            if (73461 <= e && e <= 73462)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (73472 <= e && e <= 73473)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 73475) {
          if (e === 73474)
            return i.CLUSTER_BREAK.PREPEND;
        } else if (e < 73524) {
          if (e === 73475)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (73524 <= e && e <= 73525)
          return i.CLUSTER_BREAK.SPACINGMARK;
      } else if (e < 78896)
        if (e < 73536) {
          if (e < 73534) {
            if (73526 <= e && e <= 73530)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (73534 <= e && e <= 73535)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 73537) {
          if (e === 73536)
            return i.CLUSTER_BREAK.EXTEND;
        } else {
          if (e === 73537)
            return i.CLUSTER_BREAK.SPACINGMARK;
          if (e === 73538)
            return i.CLUSTER_BREAK.EXTEND;
        }
      else if (e < 92912) {
        if (e < 78912) {
          if (78896 <= e && e <= 78911)
            return i.CLUSTER_BREAK.CONTROL;
        } else if (e < 78919) {
          if (e === 78912)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (78919 <= e && e <= 78933)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 92976) {
        if (92912 <= e && e <= 92916)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 94031) {
        if (92976 <= e && e <= 92982)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e === 94031)
        return i.CLUSTER_BREAK.EXTEND;
    } else if (e < 121476) {
      if (e < 119143)
        if (e < 113824) {
          if (e < 94180) {
            if (e < 94095) {
              if (94033 <= e && e <= 94087)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (94095 <= e && e <= 94098)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 94192) {
            if (e === 94180)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 113821) {
            if (94192 <= e && e <= 94193)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (113821 <= e && e <= 113822)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 118576) {
          if (e < 118528) {
            if (113824 <= e && e <= 113827)
              return i.CLUSTER_BREAK.CONTROL;
          } else if (118528 <= e && e <= 118573)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 119141) {
          if (118576 <= e && e <= 118598)
            return i.CLUSTER_BREAK.EXTEND;
        } else {
          if (e === 119141)
            return i.CLUSTER_BREAK.EXTEND;
          if (e === 119142)
            return i.CLUSTER_BREAK.SPACINGMARK;
        }
      else if (e < 119173) {
        if (e < 119150) {
          if (e < 119149) {
            if (119143 <= e && e <= 119145)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e === 119149)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 119155) {
          if (119150 <= e && e <= 119154)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 119163) {
          if (119155 <= e && e <= 119162)
            return i.CLUSTER_BREAK.CONTROL;
        } else if (119163 <= e && e <= 119170)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 121344) {
        if (e < 119210) {
          if (119173 <= e && e <= 119179)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 119362) {
          if (119210 <= e && e <= 119213)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (119362 <= e && e <= 119364)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 121403) {
        if (121344 <= e && e <= 121398)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 121461) {
        if (121403 <= e && e <= 121452)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e === 121461)
        return i.CLUSTER_BREAK.EXTEND;
    } else if (e < 123628) {
      if (e < 122907) {
        if (e < 121505) {
          if (e < 121499) {
            if (e === 121476)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (121499 <= e && e <= 121503)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 122880) {
          if (121505 <= e && e <= 121519)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 122888) {
          if (122880 <= e && e <= 122886)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (122888 <= e && e <= 122904)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 123023) {
        if (e < 122915) {
          if (122907 <= e && e <= 122913)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 122918) {
          if (122915 <= e && e <= 122916)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (122918 <= e && e <= 122922)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 123184) {
        if (e === 123023)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 123566) {
        if (123184 <= e && e <= 123190)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e === 123566)
        return i.CLUSTER_BREAK.EXTEND;
    } else if (e < 127995) {
      if (e < 125136) {
        if (e < 124140) {
          if (123628 <= e && e <= 123631)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (124140 <= e && e <= 124143)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 125252) {
        if (125136 <= e && e <= 125142)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 127462) {
        if (125252 <= e && e <= 125258)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (127462 <= e && e <= 127487)
        return i.CLUSTER_BREAK.REGIONAL_INDICATOR;
    } else if (e < 917632) {
      if (e < 917504) {
        if (127995 <= e && e <= 127999)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 917536) {
        if (917504 <= e && e <= 917535)
          return i.CLUSTER_BREAK.CONTROL;
      } else if (917536 <= e && e <= 917631)
        return i.CLUSTER_BREAK.EXTEND;
    } else if (e < 917760) {
      if (917632 <= e && e <= 917759)
        return i.CLUSTER_BREAK.CONTROL;
    } else if (e < 918e3) {
      if (917760 <= e && e <= 917999)
        return i.CLUSTER_BREAK.EXTEND;
    } else if (918e3 <= e && e <= 921599)
      return i.CLUSTER_BREAK.CONTROL;
    return i.CLUSTER_BREAK.OTHER;
  }
  /**
   * Given a Unicode code point, returns if symbol is an extended pictographic or some other break
   * @param code {number} Unicode code point
   * @returns {number}
   */
  static getEmojiProperty(e) {
    if (e < 10160) {
      if (e < 9728) {
        if (e < 9e3) {
          if (e < 8482) {
            if (e < 8252) {
              if (e === 169 || e === 174)
                return i.EXTENDED_PICTOGRAPHIC;
            } else if (e === 8252 || e === 8265)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e < 8596) {
            if (e === 8482 || e === 8505)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e < 8617) {
            if (8596 <= e && e <= 8601)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e < 8986) {
            if (8617 <= e && e <= 8618)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (8986 <= e && e <= 8987)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 9410) {
          if (e < 9167) {
            if (e === 9e3 || e === 9096)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9193) {
            if (e === 9167)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9208) {
            if (9193 <= e && e <= 9203)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (9208 <= e && e <= 9210)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 9654) {
          if (e < 9642) {
            if (e === 9410)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (9642 <= e && e <= 9643)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 9664) {
          if (e === 9654)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 9723) {
          if (e === 9664)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (9723 <= e && e <= 9726)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 10035) {
        if (e < 10004) {
          if (e < 9748) {
            if (e < 9735) {
              if (9728 <= e && e <= 9733)
                return i.EXTENDED_PICTOGRAPHIC;
            } else if (9735 <= e && e <= 9746)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9872) {
            if (9748 <= e && e <= 9861)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9992) {
            if (9872 <= e && e <= 9989)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (9992 <= e && e <= 10002)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 10013) {
          if (e === 10004 || e === 10006)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 10017) {
          if (e === 10013)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e === 10017 || e === 10024)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 10067) {
        if (e < 10055) {
          if (e < 10052) {
            if (10035 <= e && e <= 10036)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e === 10052)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 10060) {
          if (e === 10055)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e === 10060 || e === 10062)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 10083) {
        if (e < 10071) {
          if (10067 <= e && e <= 10069)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e === 10071)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 10133) {
        if (10083 <= e && e <= 10087)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 10145) {
        if (10133 <= e && e <= 10135)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e === 10145)
        return i.EXTENDED_PICTOGRAPHIC;
    } else if (e < 127489) {
      if (e < 12951) {
        if (e < 11035) {
          if (e < 10548) {
            if (e === 10160 || e === 10175)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e < 11013) {
            if (10548 <= e && e <= 10549)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (11013 <= e && e <= 11015)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 11093) {
          if (e < 11088) {
            if (11035 <= e && e <= 11036)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e === 11088)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 12336) {
          if (e === 11093)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e === 12336 || e === 12349)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 127340) {
        if (e < 126976) {
          if (e === 12951 || e === 12953)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127245) {
          if (126976 <= e && e <= 127231)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127279) {
          if (127245 <= e && e <= 127247)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e === 127279)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 127374) {
        if (e < 127358) {
          if (127340 <= e && e <= 127345)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (127358 <= e && e <= 127359)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 127377) {
        if (e === 127374)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 127405) {
        if (127377 <= e && e <= 127386)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (127405 <= e && e <= 127461)
        return i.EXTENDED_PICTOGRAPHIC;
    } else if (e < 128981) {
      if (e < 127561) {
        if (e < 127535) {
          if (e < 127514) {
            if (127489 <= e && e <= 127503)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e === 127514)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127538) {
          if (e === 127535)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127548) {
          if (127538 <= e && e <= 127546)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (127548 <= e && e <= 127551)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 128326) {
        if (e < 128e3) {
          if (127561 <= e && e <= 127994)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (128e3 <= e && e <= 128317)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 128640) {
        if (128326 <= e && e <= 128591)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 128884) {
        if (128640 <= e && e <= 128767)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (128884 <= e && e <= 128895)
        return i.EXTENDED_PICTOGRAPHIC;
    } else if (e < 129198) {
      if (e < 129096) {
        if (e < 129036) {
          if (128981 <= e && e <= 129023)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (129036 <= e && e <= 129039)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 129114) {
        if (129096 <= e && e <= 129103)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 129160) {
        if (129114 <= e && e <= 129119)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (129160 <= e && e <= 129167)
        return i.EXTENDED_PICTOGRAPHIC;
    } else if (e < 129340) {
      if (e < 129292) {
        if (129198 <= e && e <= 129279)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (129292 <= e && e <= 129338)
        return i.EXTENDED_PICTOGRAPHIC;
    } else if (e < 129351) {
      if (129340 <= e && e <= 129349)
        return i.EXTENDED_PICTOGRAPHIC;
    } else if (e < 130048) {
      if (129351 <= e && e <= 129791)
        return i.EXTENDED_PICTOGRAPHIC;
    } else if (130048 <= e && e <= 131069)
      return i.EXTENDED_PICTOGRAPHIC;
    return i.CLUSTER_BREAK.OTHER;
  }
}
yl.default = $t;
var ph = S && S.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(fl, "__esModule", { value: !0 });
const dh = ph(yl);
fl.default = dh.default;
var fh = S && S.__createBinding || (Object.create ? function(t, e, r, n) {
  n === void 0 && (n = r);
  var s = Object.getOwnPropertyDescriptor(e, r);
  (!s || ("get" in s ? !e.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, n, s);
} : function(t, e, r, n) {
  n === void 0 && (n = r), t[n] = e[r];
}), yh = S && S.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), mh = S && S.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && fh(e, t, r);
  return yh(e, t), e;
}, bh = S && S.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty($e, "__esModule", { value: !0 });
$e.validateLanguage = $e.parseLanguage = $e.b64UrlToUtf8 = $e.utf8ToB64Url = $e.graphemeLen = $e.utf8Len = void 0;
const hh = bh(fl), ia = mh(_c), Eh = (t) => new TextEncoder().encode(t).byteLength;
$e.utf8Len = Eh;
const xh = (t) => new hh.default().countGraphemes(t);
$e.graphemeLen = xh;
const gh = (t) => ia.toString(ia.fromString(t, "utf8"), "base64url");
$e.utf8ToB64Url = gh;
const Rh = (t) => ia.toString(ia.fromString(t, "base64url"), "utf8");
$e.b64UrlToUtf8 = Rh;
const vh = (t) => {
  const e = t.match(Bc);
  if (!e?.groups)
    return null;
  const r = e.groups;
  return {
    grandfathered: r.grandfathered,
    language: r.language,
    extlang: r.extlang,
    script: r.script,
    region: r.region,
    variant: r.variant,
    extension: r.extension,
    privateUse: r.privateUseA || r.privateUseB
  };
};
$e.parseLanguage = vh;
const Ah = (t) => Bc.test(t);
$e.validateLanguage = Ah;
const Bc = /^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-(?<extension>[0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8})+))*(-(?<privateUseA>x(-[A-Za-z0-9]{1,8})+))?)|(?<privateUseB>x(-[A-Za-z0-9]{1,8})+))$/;
var Pc = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.didDocument = t.getServiceEndpoint = t.getNotifEndpoint = t.getFeedGenEndpoint = t.getPdsEndpoint = t.getSigningDidKey = t.getVerificationMaterial = t.getSigningKey = t.getHandle = t.getDid = t.isValidDidDoc = void 0;
  const e = ai, r = (U) => t.didDocument.safeParse(U).success;
  t.isValidDidDoc = r;
  const n = (U) => {
    const K = U.id;
    if (typeof K != "string")
      throw new Error("No `id` on document");
    return K;
  };
  t.getDid = n;
  const s = (U) => {
    const K = U.alsoKnownAs;
    if (!K)
      return;
    const A = K.find((T) => T.startsWith("at://"));
    if (A)
      return A.slice(5);
  };
  t.getHandle = s;
  const u = (U) => (0, t.getVerificationMaterial)(U, "atproto");
  t.getSigningKey = u;
  const c = (U, K) => {
    const A = (0, t.getDid)(U);
    let T = U.verificationMethod;
    if (!T || typeof T != "object")
      return;
    Array.isArray(T) || (T = [T]);
    const V = T.find((I) => I.id === `#${K}` || I.id === `${A}#${K}`);
    if (V?.publicKeyMultibase)
      return {
        type: V.type,
        publicKeyMultibase: V.publicKeyMultibase
      };
  };
  t.getVerificationMaterial = c;
  const a = (U) => {
    const K = (0, t.getSigningKey)(U);
    if (K)
      return `did:key:${K.publicKeyMultibase}`;
  };
  t.getSigningDidKey = a;
  const y = (U) => (0, t.getServiceEndpoint)(U, {
    id: "#atproto_pds",
    type: "AtprotoPersonalDataServer"
  });
  t.getPdsEndpoint = y;
  const d = (U) => (0, t.getServiceEndpoint)(U, {
    id: "#bsky_fg",
    type: "BskyFeedGenerator"
  });
  t.getFeedGenEndpoint = d;
  const b = (U) => (0, t.getServiceEndpoint)(U, {
    id: "#bsky_notif",
    type: "BskyNotificationService"
  });
  t.getNotifEndpoint = b;
  const g = (U, K) => {
    const A = (0, t.getDid)(U);
    let T = U.service;
    if (!T || typeof T != "object")
      return;
    Array.isArray(T) || (T = [T]);
    const V = T.find((I) => I.id === K.id || I.id === `${A}${K.id}`);
    if (V && !(K.type && V.type !== K.type) && typeof V.serviceEndpoint == "string")
      return R(V.serviceEndpoint);
  };
  t.getServiceEndpoint = g;
  const R = (U) => {
    let K;
    try {
      K = new URL(U);
    } catch {
      return;
    }
    if (["http:", "https:"].includes(K.protocol))
      return K.hostname ? U : void 0;
  }, C = e.z.object({
    id: e.z.string(),
    type: e.z.string(),
    controller: e.z.string(),
    publicKeyMultibase: e.z.string().optional()
  }), D = e.z.object({
    id: e.z.string(),
    type: e.z.string(),
    serviceEndpoint: e.z.union([e.z.string(), e.z.record(e.z.unknown())])
  });
  t.didDocument = e.z.object({
    id: e.z.string(),
    alsoKnownAs: e.z.array(e.z.string()).optional(),
    verificationMethod: e.z.array(C).optional(),
    service: e.z.array(D).optional()
  });
})(Pc);
(function(t) {
  var e = S && S.__createBinding || (Object.create ? function(u, c, a, y) {
    y === void 0 && (y = a);
    var d = Object.getOwnPropertyDescriptor(c, a);
    (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return c[a];
    } }), Object.defineProperty(u, y, d);
  } : function(u, c, a, y) {
    y === void 0 && (y = a), u[y] = c[a];
  }), r = S && S.__setModuleDefault || (Object.create ? function(u, c) {
    Object.defineProperty(u, "default", { enumerable: !0, value: c });
  } : function(u, c) {
    u.default = c;
  }), n = S && S.__importStar || function(u) {
    if (u && u.__esModule) return u;
    var c = {};
    if (u != null) for (var a in u) a !== "default" && Object.prototype.hasOwnProperty.call(u, a) && e(c, u, a);
    return r(c, u), c;
  }, s = S && S.__exportStar || function(u, c) {
    for (var a in u) a !== "default" && !Object.prototype.hasOwnProperty.call(c, a) && e(c, u, a);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.util = t.check = void 0, t.check = n(xr), t.util = n(Ei), s(xi, t), s(xc, t), s(Ei, t), s(hn, t), s(gc, t), s(gi, t), s(Sc, t), s(Lc, t), s($e, t), s(Pc, t);
})(Vt);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.BlobRef = t.jsonBlobRef = t.untypedJsonBlobRef = t.typedJsonBlobRef = void 0;
  const e = Vt, r = ji, n = ai;
  t.typedJsonBlobRef = n.z.object({
    $type: n.z.literal("blob"),
    ref: e.schema.cid,
    mimeType: n.z.string(),
    size: n.z.number()
  }).strict(), t.untypedJsonBlobRef = n.z.object({
    cid: n.z.string(),
    mimeType: n.z.string()
  }).strict(), t.jsonBlobRef = n.z.union([t.typedJsonBlobRef, t.untypedJsonBlobRef]);
  class s {
    constructor(c, a, y, d) {
      Object.defineProperty(this, "ref", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: c
      }), Object.defineProperty(this, "mimeType", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: a
      }), Object.defineProperty(this, "size", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: y
      }), Object.defineProperty(this, "original", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), this.original = d ?? {
        $type: "blob",
        ref: c,
        mimeType: a,
        size: y
      };
    }
    static asBlobRef(c) {
      return e.check.is(c, t.jsonBlobRef) ? s.fromJsonRef(c) : null;
    }
    static fromJsonRef(c) {
      return e.check.is(c, t.typedJsonBlobRef) ? new s(c.ref, c.mimeType, c.size) : new s(r.CID.parse(c.cid), c.mimeType, -1, c);
    }
    ipld() {
      return {
        $type: "blob",
        ref: this.ref,
        mimeType: this.mimeType,
        size: this.size
      };
    }
    toJSON() {
      return (0, e.ipldToJson)(this.ipld());
    }
  }
  t.BlobRef = s;
})(Ea);
Object.defineProperty(ha, "__esModule", { value: !0 });
ha.blob = void 0;
const wh = Ea, Ch = Tr;
function _h(t, e, r, n) {
  return !n || !(n instanceof wh.BlobRef) ? {
    success: !1,
    error: new Ch.ValidationError(`${e} should be a blob ref`)
  } : { success: !0, value: n };
}
ha.blob = _h;
var Ce = {}, ne = {}, Dc = {};
(function(t) {
  (() => {
    var e = { d: (b, g) => {
      for (var R in g) e.o(g, R) && !e.o(b, R) && Object.defineProperty(b, R, { enumerable: !0, get: g[R] });
    }, o: (b, g) => Object.prototype.hasOwnProperty.call(b, g), r: (b) => {
      typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(b, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(b, "__esModule", { value: !0 });
    } }, r = {};
    function n(b, g) {
      return g === void 0 && (g = "-"), new RegExp("^(?!0{4}" + g + "0{2}" + g + "0{2})((?=[0-9]{4}" + g + "(((0[^2])|1[0-2])|02(?=" + g + "(([0-1][0-9])|2[0-8])))" + g + "[0-9]{2})|(?=((([13579][26])|([2468][048])|(0[48]))0{2})|([0-9]{2}((((0|[2468])[48])|[2468][048])|([13579][26])))" + g + "02" + g + "29))([0-9]{4})" + g + "(?!((0[469])|11)" + g + "31)((0[1,3-9]|1[0-2])|(02(?!" + g + "3)))" + g + "(0[1-9]|[1-2][0-9]|3[0-1])$").test(b);
    }
    function s(b) {
      var g = /\D/.exec(b);
      return g ? g[0] : "";
    }
    function u(b, g, R) {
      g === void 0 && (g = ":"), R === void 0 && (R = !1);
      var C = new RegExp("^([0-1]|2(?=([0-3])|4" + g + "00))[0-9]" + g + "[0-5][0-9](" + g + "([0-5]|6(?=0))[0-9])?(.[0-9]{1,9})?$");
      if (!R || !/[Z+\-]/.test(b)) return C.test(b);
      if (/Z$/.test(b)) return C.test(b.replace("Z", ""));
      var D = b.includes("+"), U = b.split(/[+-]/), K = U[0], A = U[1];
      return C.test(K) && function(T, V, I) {
        return I === void 0 && (I = ":"), new RegExp(V ? "^(0(?!(2" + I + "4)|0" + I + "3)|1(?=([0-1]|2(?=" + I + "[04])|[34](?=" + I + "0))))([03469](?=" + I + "[03])|[17](?=" + I + "0)|2(?=" + I + "[04])|5(?=" + I + "[034])|8(?=" + I + "[04]))" + I + "([03](?=0)|4(?=5))[05]$" : "^(0(?=[^0])|1(?=[0-2]))([39](?=" + I + "[03])|[0-24-8](?=" + I + "00))" + I + "[03]0$").test(T);
      }(A, D, s(A));
    }
    function c(b) {
      var g = b.split("T"), R = g[0], C = g[1], D = n(R, s(R));
      if (!C) return !1;
      var U, K = (U = C.match(/([^Z+\-\d])(?=\d+\1)/), Array.isArray(U) ? U[0] : "");
      return D && u(C, K, !0);
    }
    function a(b, g) {
      return g === void 0 && (g = "-"), new RegExp("^[0-9]{4}" + g + "(0(?=[^0])|1(?=[0-2]))[0-9]$").test(b);
    }
    e.r(r), e.d(r, { isValidDate: () => n, isValidISODateString: () => c, isValidTime: () => u, isValidYearMonth: () => a });
    var y = t;
    for (var d in r) y[d] = r[d];
    r.__esModule && Object.defineProperty(y, "__esModule", { value: !0 });
  })();
})(Dc);
Object.defineProperty(ne, "__esModule", { value: !0 });
ne.recordKey = ne.tid = ne.language = ne.cid = ne.nsid = ne.atIdentifier = ne.handle = ne.did = ne.atUri = ne.uri = ne.datetime = void 0;
const Th = Dc, Sh = ji, ft = Tr, Oi = oi, Lh = Vt;
function kh(t, e) {
  try {
    if (!(0, Th.isValidISODateString)(e))
      throw new Error();
  } catch {
    return {
      success: !1,
      error: new ft.ValidationError(`${t} must be an valid atproto datetime (both RFC-3339 and ISO-8601)`)
    };
  }
  return { success: !0, value: e };
}
ne.datetime = kh;
function Bh(t, e) {
  return e.match(/^\w+:(?:\/\/)?[^\s/][^\s]*$/) !== null ? { success: !0, value: e } : {
    success: !1,
    error: new ft.ValidationError(`${t} must be a uri`)
  };
}
ne.uri = Bh;
function Ph(t, e) {
  try {
    (0, Oi.ensureValidAtUri)(e);
  } catch {
    return {
      success: !1,
      error: new ft.ValidationError(`${t} must be a valid at-uri`)
    };
  }
  return { success: !0, value: e };
}
ne.atUri = Ph;
function Kc(t, e) {
  try {
    (0, Oi.ensureValidDid)(e);
  } catch {
    return {
      success: !1,
      error: new ft.ValidationError(`${t} must be a valid did`)
    };
  }
  return { success: !0, value: e };
}
ne.did = Kc;
function Uc(t, e) {
  try {
    (0, Oi.ensureValidHandle)(e);
  } catch {
    return {
      success: !1,
      error: new ft.ValidationError(`${t} must be a valid handle`)
    };
  }
  return { success: !0, value: e };
}
ne.handle = Uc;
function Dh(t, e) {
  return !Kc(t, e).success && !Uc(t, e).success ? {
    success: !1,
    error: new ft.ValidationError(`${t} must be a valid did or a handle`)
  } : { success: !0, value: e };
}
ne.atIdentifier = Dh;
function Kh(t, e) {
  try {
    (0, Oi.ensureValidNsid)(e);
  } catch {
    return {
      success: !1,
      error: new ft.ValidationError(`${t} must be a valid nsid`)
    };
  }
  return { success: !0, value: e };
}
ne.nsid = Kh;
function Uh(t, e) {
  try {
    Sh.CID.parse(e);
  } catch {
    return {
      success: !1,
      error: new ft.ValidationError(`${t} must be a cid string`)
    };
  }
  return { success: !0, value: e };
}
ne.cid = Uh;
function Vh(t, e) {
  return (0, Lh.validateLanguage)(e) ? { success: !0, value: e } : {
    success: !1,
    error: new ft.ValidationError(`${t} must be a well-formed BCP 47 language tag`)
  };
}
ne.language = Vh;
function Ih(t, e) {
  try {
    (0, Oi.ensureValidTid)(e);
  } catch {
    return {
      success: !1,
      error: new ft.ValidationError(`${t} must be a valid TID (timestamp identifier)`)
    };
  }
  return { success: !0, value: e };
}
ne.tid = Ih;
function jh(t, e) {
  try {
    (0, Oi.ensureValidRecordKey)(e);
  } catch {
    return {
      success: !1,
      error: new ft.ValidationError(`${t} must be a valid Record Key`)
    };
  }
  return { success: !0, value: e };
}
ne.recordKey = jh;
var Oh = S && S.__createBinding || (Object.create ? function(t, e, r, n) {
  n === void 0 && (n = r);
  var s = Object.getOwnPropertyDescriptor(e, r);
  (!s || ("get" in s ? !e.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, n, s);
} : function(t, e, r, n) {
  n === void 0 && (n = r), t[n] = e[r];
}), Mh = S && S.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), Nh = S && S.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && Oh(e, t, r);
  return Mh(e, t), e;
};
Object.defineProperty(Ce, "__esModule", { value: !0 });
Ce.unknown = Ce.cidLink = Ce.bytes = Ce.string = Ce.integer = Ce.boolean = Ce.validate = void 0;
const Fo = Vt, $h = ji, st = Nh(ne), oe = Tr;
function Gh(t, e, r, n) {
  switch (r.type) {
    case "boolean":
      return Vc(t, e, r, n);
    case "integer":
      return Ic(t, e, r, n);
    case "string":
      return jc(t, e, r, n);
    case "bytes":
      return Oc(t, e, r, n);
    case "cid-link":
      return Mc(t, e, r, n);
    case "unknown":
      return Nc(t, e, r, n);
    default:
      return {
        success: !1,
        error: new oe.ValidationError(`Unexpected lexicon type: ${r.type}`)
      };
  }
}
Ce.validate = Gh;
function Vc(t, e, r, n) {
  r = r;
  const s = typeof n;
  return s === "undefined" ? typeof r.default == "boolean" ? { success: !0, value: r.default } : {
    success: !1,
    error: new oe.ValidationError(`${e} must be a boolean`)
  } : s !== "boolean" ? {
    success: !1,
    error: new oe.ValidationError(`${e} must be a boolean`)
  } : typeof r.const == "boolean" && n !== r.const ? {
    success: !1,
    error: new oe.ValidationError(`${e} must be ${r.const}`)
  } : { success: !0, value: n };
}
Ce.boolean = Vc;
function Ic(t, e, r, n) {
  return r = r, typeof n === "undefined" ? typeof r.default == "number" ? { success: !0, value: r.default } : {
    success: !1,
    error: new oe.ValidationError(`${e} must be an integer`)
  } : Number.isInteger(n) ? typeof r.const == "number" && n !== r.const ? {
    success: !1,
    error: new oe.ValidationError(`${e} must be ${r.const}`)
  } : Array.isArray(r.enum) && !r.enum.includes(n) ? {
    success: !1,
    error: new oe.ValidationError(`${e} must be one of (${r.enum.join("|")})`)
  } : typeof r.maximum == "number" && n > r.maximum ? {
    success: !1,
    error: new oe.ValidationError(`${e} can not be greater than ${r.maximum}`)
  } : typeof r.minimum == "number" && n < r.minimum ? {
    success: !1,
    error: new oe.ValidationError(`${e} can not be less than ${r.minimum}`)
  } : { success: !0, value: n } : {
    success: !1,
    error: new oe.ValidationError(`${e} must be an integer`)
  };
}
Ce.integer = Ic;
function jc(t, e, r, n) {
  if (r = r, typeof n > "u")
    return typeof r.default == "string" ? { success: !0, value: r.default } : {
      success: !1,
      error: new oe.ValidationError(`${e} must be a string`)
    };
  if (typeof n != "string")
    return {
      success: !1,
      error: new oe.ValidationError(`${e} must be a string`)
    };
  if (typeof r.const == "string" && n !== r.const)
    return {
      success: !1,
      error: new oe.ValidationError(`${e} must be ${r.const}`)
    };
  if (Array.isArray(r.enum) && !r.enum.includes(n))
    return {
      success: !1,
      error: new oe.ValidationError(`${e} must be one of (${r.enum.join("|")})`)
    };
  if (typeof r.maxLength == "number" && (0, Fo.utf8Len)(n) > r.maxLength)
    return {
      success: !1,
      error: new oe.ValidationError(`${e} must not be longer than ${r.maxLength} characters`)
    };
  if (typeof r.minLength == "number" && (0, Fo.utf8Len)(n) < r.minLength)
    return {
      success: !1,
      error: new oe.ValidationError(`${e} must not be shorter than ${r.minLength} characters`)
    };
  if (typeof r.maxGraphemes == "number" && (0, Fo.graphemeLen)(n) > r.maxGraphemes)
    return {
      success: !1,
      error: new oe.ValidationError(`${e} must not be longer than ${r.maxGraphemes} graphemes`)
    };
  if (typeof r.minGraphemes == "number" && (0, Fo.graphemeLen)(n) < r.minGraphemes)
    return {
      success: !1,
      error: new oe.ValidationError(`${e} must not be shorter than ${r.minGraphemes} graphemes`)
    };
  if (typeof r.format == "string")
    switch (r.format) {
      case "datetime":
        return st.datetime(e, n);
      case "uri":
        return st.uri(e, n);
      case "at-uri":
        return st.atUri(e, n);
      case "did":
        return st.did(e, n);
      case "handle":
        return st.handle(e, n);
      case "at-identifier":
        return st.atIdentifier(e, n);
      case "nsid":
        return st.nsid(e, n);
      case "cid":
        return st.cid(e, n);
      case "language":
        return st.language(e, n);
      case "tid":
        return st.tid(e, n);
      case "record-key":
        return st.recordKey(e, n);
    }
  return { success: !0, value: n };
}
Ce.string = jc;
function Oc(t, e, r, n) {
  return r = r, !n || !(n instanceof Uint8Array) ? {
    success: !1,
    error: new oe.ValidationError(`${e} must be a byte array`)
  } : typeof r.maxLength == "number" && n.byteLength > r.maxLength ? {
    success: !1,
    error: new oe.ValidationError(`${e} must not be larger than ${r.maxLength} bytes`)
  } : typeof r.minLength == "number" && n.byteLength < r.minLength ? {
    success: !1,
    error: new oe.ValidationError(`${e} must not be smaller than ${r.minLength} bytes`)
  } : { success: !0, value: n };
}
Ce.bytes = Oc;
function Mc(t, e, r, n) {
  return $h.CID.asCID(n) === null ? {
    success: !1,
    error: new oe.ValidationError(`${e} must be a CID`)
  } : { success: !0, value: n };
}
Ce.cidLink = Mc;
function Nc(t, e, r, n) {
  return !n || typeof n != "object" ? {
    success: !1,
    error: new oe.ValidationError(`${e} must be an object`)
  } : { success: !0, value: n };
}
Ce.unknown = Nc;
Object.defineProperty(tt, "__esModule", { value: !0 });
tt.validateOneOf = tt.object = tt.array = tt.validate = void 0;
const gt = Tr, il = Lt, qh = ha, fi = Ce;
function $c(t, e, r, n) {
  switch (r.type) {
    case "boolean":
      return (0, fi.boolean)(t, e, r, n);
    case "integer":
      return (0, fi.integer)(t, e, r, n);
    case "string":
      return (0, fi.string)(t, e, r, n);
    case "bytes":
      return (0, fi.bytes)(t, e, r, n);
    case "cid-link":
      return (0, fi.cidLink)(t, e, r, n);
    case "unknown":
      return (0, fi.unknown)(t, e, r, n);
    case "object":
      return El(t, e, r, n);
    case "array":
      return Gc(t, e, r, n);
    case "blob":
      return (0, qh.blob)(t, e, r, n);
    default:
      return {
        success: !1,
        error: new gt.ValidationError(`Unexpected lexicon type: ${r.type}`)
      };
  }
}
tt.validate = $c;
function Gc(t, e, r, n) {
  if (!Array.isArray(n))
    return {
      success: !1,
      error: new gt.ValidationError(`${e} must be an array`)
    };
  if (typeof r.maxLength == "number" && n.length > r.maxLength)
    return {
      success: !1,
      error: new gt.ValidationError(`${e} must not have more than ${r.maxLength} elements`)
    };
  if (typeof r.minLength == "number" && n.length < r.minLength)
    return {
      success: !1,
      error: new gt.ValidationError(`${e} must not have fewer than ${r.minLength} elements`)
    };
  const s = r.items;
  for (let u = 0; u < n.length; u++) {
    const c = n[u], a = `${e}/${u}`, y = xl(t, a, s, c);
    if (!y.success)
      return y;
  }
  return { success: !0, value: n };
}
tt.array = Gc;
function El(t, e, r, n) {
  if (r = r, !n || typeof n != "object")
    return {
      success: !1,
      error: new gt.ValidationError(`${e} must be an object`)
    };
  const s = new Set(r.required), u = new Set(r.nullable);
  let c = n;
  if (typeof r.properties == "object")
    for (const a in r.properties) {
      if (n[a] === null && u.has(a))
        continue;
      const y = r.properties[a];
      if (typeof n[a] > "u" && !s.has(a))
        if (y.type === "integer" || y.type === "boolean" || y.type === "string") {
          if (typeof y.default > "u")
            continue;
        } else
          continue;
      const d = `${e}/${a}`, b = xl(t, d, y, n[a]), g = b.success ? b.value : n[a], R = typeof g > "u";
      if (R && s.has(a))
        return {
          success: !1,
          error: new gt.ValidationError(`${e} must have the property "${a}"`)
        };
      if (!R && !b.success)
        return b;
      g !== n[a] && (c === n && (c = { ...n }), c[a] = g);
    }
  return { success: !0, value: c };
}
tt.object = El;
function xl(t, e, r, n, s = !1) {
  let u, c;
  if (r.type === "union") {
    if (!(0, gt.isDiscriminatedObject)(n))
      return {
        success: !1,
        error: new gt.ValidationError(`${e} must be an object which includes the "$type" property`)
      };
    if (Fh(r.refs, n.$type))
      c = (0, il.toConcreteTypes)(t, {
        type: "ref",
        ref: n.$type
      });
    else
      return r.closed ? {
        success: !1,
        error: new gt.ValidationError(`${e} $type must be one of ${r.refs.join(", ")}`)
      } : { success: !0, value: n };
  } else
    c = (0, il.toConcreteTypes)(t, r);
  for (const a of c) {
    const y = s ? El(t, e, a, n) : $c(t, e, a, n);
    if (y.success)
      return y;
    u ?? (u = y.error);
  }
  return c.length > 1 ? {
    success: !1,
    error: new gt.ValidationError(`${e} did not match any of the expected definitions`)
  } : { success: !1, error: u };
}
tt.validateOneOf = xl;
const Fh = (t, e) => {
  const r = (0, il.toLexUri)(e);
  return t.includes(r) ? !0 : r.endsWith("#main") ? t.includes(r.replace("#main", "")) : t.includes(r + "#main");
};
var ga = {}, zh = S && S.__createBinding || (Object.create ? function(t, e, r, n) {
  n === void 0 && (n = r);
  var s = Object.getOwnPropertyDescriptor(e, r);
  (!s || ("get" in s ? !e.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, n, s);
} : function(t, e, r, n) {
  n === void 0 && (n = r), t[n] = e[r];
}), Xh = S && S.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), Zh = S && S.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && zh(e, t, r);
  return Xh(e, t), e;
};
Object.defineProperty(ga, "__esModule", { value: !0 });
ga.params = void 0;
const Hh = Tr, Wh = Zh(Ce), Jh = tt;
function Qh(t, e, r, n) {
  const s = n && typeof n == "object" ? n : {}, u = new Set(r.required ?? []);
  let c = s;
  if (typeof r.properties == "object")
    for (const a in r.properties) {
      const y = r.properties[a], d = y.type === "array" ? (0, Jh.array)(t, a, y, s[a]) : Wh.validate(t, a, y, s[a]), b = d.success ? d.value : s[a], g = typeof b > "u";
      if (g && u.has(a))
        return {
          success: !1,
          error: new Hh.ValidationError(`${e} must have the property "${a}"`)
        };
      if (!g && !d.success)
        return d;
      b !== s[a] && (c === s && (c = { ...s }), c[a] = b);
    }
  return { success: !0, value: c };
}
ga.params = Qh;
Object.defineProperty(Ye, "__esModule", { value: !0 });
Ye.assertValidXrpcMessage = Ye.assertValidXrpcOutput = Ye.assertValidXrpcInput = Ye.assertValidXrpcParams = Ye.assertValidRecord = void 0;
const qc = tt, Yh = ga;
function e0(t, e, r) {
  const n = (0, qc.object)(t, "Record", e.record, r);
  if (!n.success)
    throw n.error;
  return n.value;
}
Ye.assertValidRecord = e0;
function t0(t, e, r) {
  if (e.parameters) {
    const n = (0, Yh.params)(t, "Params", e.parameters, r);
    if (!n.success)
      throw n.error;
    return n.value;
  }
}
Ye.assertValidXrpcParams = t0;
function r0(t, e, r) {
  if (e.input?.schema)
    return gl(t, "Input", e.input.schema, r, !0);
}
Ye.assertValidXrpcInput = r0;
function i0(t, e, r) {
  if (e.output?.schema)
    return gl(t, "Output", e.output.schema, r, !0);
}
Ye.assertValidXrpcOutput = i0;
function n0(t, e, r) {
  if (e.message?.schema)
    return gl(t, "Message", e.message.schema, r, !0);
}
Ye.assertValidXrpcMessage = n0;
function gl(t, e, r, n, s = !1) {
  const u = (0, qc.validateOneOf)(t, e, r, n, s);
  if (!u.success)
    throw u.error;
  return u.value;
}
var s0 = S && S.__createBinding || (Object.create ? function(t, e, r, n) {
  n === void 0 && (n = r);
  var s = Object.getOwnPropertyDescriptor(e, r);
  (!s || ("get" in s ? !e.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, n, s);
} : function(t, e, r, n) {
  n === void 0 && (n = r), t[n] = e[r];
}), o0 = S && S.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), a0 = S && S.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && s0(e, t, r);
  return o0(e, t), e;
};
Object.defineProperty(ba, "__esModule", { value: !0 });
ba.Lexicons = void 0;
const bt = Tr, on = Ye, Le = Lt, eu = a0(tt);
class l0 {
  constructor(e) {
    if (Object.defineProperty(this, "docs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "defs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), e)
      for (const r of e)
        this.add(r);
  }
  /**
   * @example clone a lexicon:
   * ```ts
   * const clone = new Lexicons(originalLexicon)
   * ```
   *
   * @example get docs array:
   * ```ts
   * const docs = Array.from(lexicons)
   * ```
   */
  [Symbol.iterator]() {
    return this.docs.values();
  }
  /**
   * Add a lexicon doc.
   */
  add(e) {
    const r = (0, Le.toLexUri)(e.id);
    if (this.docs.has(r))
      throw new Error(`${r} has already been registered`);
    nl(e, r), this.docs.set(r, e);
    for (const [n, s] of tu(e))
      this.defs.set(n, s);
  }
  /**
   * Remove a lexicon doc.
   */
  remove(e) {
    e = (0, Le.toLexUri)(e);
    const r = this.docs.get(e);
    if (!r)
      throw new Error(`Unable to remove "${e}": does not exist`);
    for (const [n, s] of tu(r))
      this.defs.delete(n);
    this.docs.delete(e);
  }
  /**
   * Get a lexicon doc.
   */
  get(e) {
    return e = (0, Le.toLexUri)(e), this.docs.get(e);
  }
  /**
   * Get a definition.
   */
  getDef(e) {
    return e = (0, Le.toLexUri)(e), this.defs.get(e);
  }
  getDefOrThrow(e, r) {
    const n = this.getDef(e);
    if (!n)
      throw new bt.LexiconDefNotFoundError(`Lexicon not found: ${e}`);
    if (r && !r.includes(n.type))
      throw new bt.InvalidLexiconError(`Not a ${r.join(" or ")} lexicon: ${e}`);
    return n;
  }
  /**
   * Validate a record or object.
   */
  validate(e, r) {
    e = (0, Le.toLexUri)(e);
    const n = this.getDefOrThrow(e, ["record", "object"]);
    if (!(0, bt.isObj)(r))
      throw new bt.ValidationError("Value must be an object");
    if (n.type === "record")
      return eu.object(this, "Record", n.record, r);
    if (n.type === "object")
      return eu.object(this, "Object", n, r);
    throw new bt.InvalidLexiconError("Definition must be a record or object");
  }
  /**
   * Validate a record and throw on any error.
   */
  assertValidRecord(e, r) {
    e = (0, Le.toLexUri)(e);
    const n = this.getDefOrThrow(e, ["record"]);
    if (!(0, bt.isObj)(r))
      throw new bt.ValidationError("Record must be an object");
    if (!(0, bt.hasProp)(r, "$type") || typeof r.$type != "string")
      throw new bt.ValidationError("Record/$type must be a string");
    const s = r.$type || "";
    if ((0, Le.toLexUri)(s) !== e)
      throw new bt.ValidationError(`Invalid $type: must be ${e}, got ${s}`);
    return (0, on.assertValidRecord)(this, n, r);
  }
  /**
   * Validate xrpc query params and throw on any error.
   */
  assertValidXrpcParams(e, r) {
    e = (0, Le.toLexUri)(e);
    const n = this.getDefOrThrow(e, [
      "query",
      "procedure",
      "subscription"
    ]);
    return (0, on.assertValidXrpcParams)(this, n, r);
  }
  /**
   * Validate xrpc input body and throw on any error.
   */
  assertValidXrpcInput(e, r) {
    e = (0, Le.toLexUri)(e);
    const n = this.getDefOrThrow(e, ["procedure"]);
    return (0, on.assertValidXrpcInput)(this, n, r);
  }
  /**
   * Validate xrpc output body and throw on any error.
   */
  assertValidXrpcOutput(e, r) {
    e = (0, Le.toLexUri)(e);
    const n = this.getDefOrThrow(e, ["query", "procedure"]);
    return (0, on.assertValidXrpcOutput)(this, n, r);
  }
  /**
   * Validate xrpc subscription message and throw on any error.
   */
  assertValidXrpcMessage(e, r) {
    e = (0, Le.toLexUri)(e);
    const n = this.getDefOrThrow(e, ["subscription"]);
    return (0, on.assertValidXrpcMessage)(this, n, r);
  }
  /**
   * Resolve a lex uri given a ref
   */
  resolveLexUri(e, r) {
    return e = (0, Le.toLexUri)(e), (0, Le.toLexUri)(r, e);
  }
}
ba.Lexicons = l0;
function* tu(t) {
  for (const e in t.defs)
    yield [`lex:${t.id}#${e}`, t.defs[e]], e === "main" && (yield [`lex:${t.id}`, t.defs[e]]);
}
function nl(t, e) {
  for (const r in t)
    t.type === "ref" ? t.ref = (0, Le.toLexUri)(t.ref, e) : t.type === "union" ? t.refs = t.refs.map((n) => (0, Le.toLexUri)(n, e)) : Array.isArray(t[r]) ? t[r] = t[r].map((n) => typeof n == "string" ? n.startsWith("#") ? (0, Le.toLexUri)(n, e) : n : n && typeof n == "object" ? nl(n, e) : n) : t[r] && typeof t[r] == "object" && (t[r] = nl(t[r], e));
  return t;
}
var Fc = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.jsonStringToLex = t.jsonToLex = t.stringifyLex = t.lexToJson = t.ipldToLex = t.lexToIpld = void 0;
  const e = Vt, r = ji, n = Ea, s = (b) => {
    if (Array.isArray(b))
      return b.map((g) => (0, t.lexToIpld)(g));
    if (b && typeof b == "object") {
      if (b instanceof n.BlobRef)
        return b.original;
      if (r.CID.asCID(b) || b instanceof Uint8Array)
        return b;
      const g = {};
      for (const R of Object.keys(b))
        g[R] = (0, t.lexToIpld)(b[R]);
      return g;
    }
    return b;
  };
  t.lexToIpld = s;
  const u = (b) => {
    if (Array.isArray(b))
      return b.map((g) => (0, t.ipldToLex)(g));
    if (b && typeof b == "object") {
      if ((b.$type === "blob" || typeof b.cid == "string" && typeof b.mimeType == "string") && e.check.is(b, n.jsonBlobRef))
        return n.BlobRef.fromJsonRef(b);
      if (r.CID.asCID(b) || b instanceof Uint8Array)
        return b;
      const g = {};
      for (const R of Object.keys(b))
        g[R] = (0, t.ipldToLex)(b[R]);
      return g;
    }
    return b;
  };
  t.ipldToLex = u;
  const c = (b) => (0, e.ipldToJson)((0, t.lexToIpld)(b));
  t.lexToJson = c;
  const a = (b) => JSON.stringify((0, t.lexToJson)(b));
  t.stringifyLex = a;
  const y = (b) => (0, t.ipldToLex)((0, e.jsonToIpld)(b));
  t.jsonToLex = y;
  const d = (b) => (0, t.jsonToLex)(JSON.parse(b));
  t.jsonStringToLex = d;
})(Fc);
(function(t) {
  var e = S && S.__createBinding || (Object.create ? function(n, s, u, c) {
    c === void 0 && (c = u);
    var a = Object.getOwnPropertyDescriptor(s, u);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
      return s[u];
    } }), Object.defineProperty(n, c, a);
  } : function(n, s, u, c) {
    c === void 0 && (c = u), n[c] = s[u];
  }), r = S && S.__exportStar || function(n, s) {
    for (var u in n) u !== "default" && !Object.prototype.hasOwnProperty.call(s, u) && e(s, n, u);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), r(Tr, t), r(ba, t), r(Ea, t), r(Fc, t);
})(mn);
var zc = {};
Object.defineProperty(zc, "__esModule", { value: !0 });
var xn = {};
Object.defineProperty(xn, "__esModule", { value: !0 });
xn.BSKY_LABELER_DID = void 0;
xn.BSKY_LABELER_DID = "did:plc:ar7c4by46qjdydhdevvrndac";
var at = {};
Object.defineProperty(at, "__esModule", { value: !0 });
at.validateSavedFeed = at.getSavedFeedType = at.savedFeedsToUriArrays = at.sanitizeMutedWordValue = void 0;
const Xc = oi, u0 = Vt;
function c0(t) {
  return t.trim().replace(/^#(?!\ufe0f)/, "").replace(/[\r\n\u00AD\u2060\u200D\u200C\u200B]+/, "");
}
at.sanitizeMutedWordValue = c0;
function p0(t) {
  const e = [], r = [];
  for (const n of t)
    n.pinned && e.push(n.value), r.push(n.value);
  return {
    pinned: e,
    saved: r
  };
}
at.savedFeedsToUriArrays = p0;
function d0(t) {
  switch (new Xc.AtUri(t).collection) {
    case "app.bsky.feed.generator":
      return "feed";
    case "app.bsky.graph.list":
      return "list";
    default:
      return "unknown";
  }
}
at.getSavedFeedType = d0;
function f0(t) {
  if (new u0.TID(t.id), ["feed", "list"].includes(t.type)) {
    const e = new Xc.AtUri(t.value), r = e.collection === "app.bsky.feed.generator", n = e.collection === "app.bsky.graph.list";
    if (t.type === "feed" && !r)
      throw new Error(`Saved feed of type 'feed' must be a feed, got ${e.collection}`);
    if (t.type === "list" && !n)
      throw new Error(`Saved feed of type 'list' must be a list, got ${e.collection}`);
  }
}
at.validateSavedFeed = f0;
var l = {}, v = {}, Ra = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.XRPCInvalidResponseError = t.XRPCError = t.XRPCResponse = t.ResponseTypeStrings = t.ResponseTypeNames = t.ResponseType = t.errorResponseBody = void 0;
  const e = ai;
  t.errorResponseBody = e.z.object({
    error: e.z.string().optional(),
    message: e.z.string().optional()
  });
  var r;
  (function(c) {
    c[c.Unknown = 1] = "Unknown", c[c.InvalidResponse = 2] = "InvalidResponse", c[c.Success = 200] = "Success", c[c.InvalidRequest = 400] = "InvalidRequest", c[c.AuthRequired = 401] = "AuthRequired", c[c.Forbidden = 403] = "Forbidden", c[c.XRPCNotSupported = 404] = "XRPCNotSupported", c[c.PayloadTooLarge = 413] = "PayloadTooLarge", c[c.RateLimitExceeded = 429] = "RateLimitExceeded", c[c.InternalServerError = 500] = "InternalServerError", c[c.MethodNotImplemented = 501] = "MethodNotImplemented", c[c.UpstreamFailure = 502] = "UpstreamFailure", c[c.NotEnoughResources = 503] = "NotEnoughResources", c[c.UpstreamTimeout = 504] = "UpstreamTimeout";
  })(r || (t.ResponseType = r = {})), t.ResponseTypeNames = {
    [r.InvalidResponse]: "InvalidResponse",
    [r.Success]: "Success",
    [r.InvalidRequest]: "InvalidRequest",
    [r.AuthRequired]: "AuthenticationRequired",
    [r.Forbidden]: "Forbidden",
    [r.XRPCNotSupported]: "XRPCNotSupported",
    [r.PayloadTooLarge]: "PayloadTooLarge",
    [r.RateLimitExceeded]: "RateLimitExceeded",
    [r.InternalServerError]: "InternalServerError",
    [r.MethodNotImplemented]: "MethodNotImplemented",
    [r.UpstreamFailure]: "UpstreamFailure",
    [r.NotEnoughResources]: "NotEnoughResources",
    [r.UpstreamTimeout]: "UpstreamTimeout"
  }, t.ResponseTypeStrings = {
    [r.InvalidResponse]: "Invalid Response",
    [r.Success]: "Success",
    [r.InvalidRequest]: "Invalid Request",
    [r.AuthRequired]: "Authentication Required",
    [r.Forbidden]: "Forbidden",
    [r.XRPCNotSupported]: "XRPC Not Supported",
    [r.PayloadTooLarge]: "Payload Too Large",
    [r.RateLimitExceeded]: "Rate Limit Exceeded",
    [r.InternalServerError]: "Internal Server Error",
    [r.MethodNotImplemented]: "Method Not Implemented",
    [r.UpstreamFailure]: "Upstream Failure",
    [r.NotEnoughResources]: "Not Enough Resources",
    [r.UpstreamTimeout]: "Upstream Timeout"
  };
  class n {
    constructor(a, y) {
      Object.defineProperty(this, "data", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: a
      }), Object.defineProperty(this, "headers", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: y
      }), Object.defineProperty(this, "success", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: !0
      });
    }
  }
  t.XRPCResponse = n;
  class s extends Error {
    constructor(a, y, d, b) {
      super(d || y || t.ResponseTypeStrings[a]), Object.defineProperty(this, "status", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: a
      }), Object.defineProperty(this, "error", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: y
      }), Object.defineProperty(this, "success", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: !1
      }), Object.defineProperty(this, "headers", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), this.error || (this.error = t.ResponseTypeNames[a]), this.headers = b;
    }
  }
  t.XRPCError = s;
  class u extends s {
    constructor(a, y, d) {
      super(r.InvalidResponse, t.ResponseTypeStrings[r.InvalidResponse], "The server gave an invalid response and may be out of date."), Object.defineProperty(this, "lexiconNsid", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: a
      }), Object.defineProperty(this, "validationError", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: y
      }), Object.defineProperty(this, "responseBody", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: d
      });
    }
  }
  t.XRPCInvalidResponseError = u;
})(Ra);
var Zt = {}, be = {};
Object.defineProperty(be, "__esModule", { value: !0 });
be.httpResponseBodyParse = be.httpResponseCodeToEnum = be.encodeMethodCallBody = be.constructMethodCallHeaders = be.normalizeHeaders = be.encodeQueryParam = be.constructMethodCallUri = be.getMethodSchemaHTTPMethod = void 0;
const Zc = mn, xt = Ra;
function y0(t) {
  return t.type === "procedure" ? "post" : "get";
}
be.getMethodSchemaHTTPMethod = y0;
function m0(t, e, r, n) {
  const s = new URL(r);
  if (s.pathname = `/xrpc/${t}`, n)
    for (const [u, c] of Object.entries(n)) {
      const a = e.parameters?.properties?.[u];
      if (!a)
        throw new Error(`Invalid query parameter: ${u}`);
      c !== void 0 && (a.type === "array" ? [].concat(c).forEach((d) => {
        s.searchParams.append(u, sl(a.items.type, d));
      }) : s.searchParams.set(u, sl(a.type, c)));
    }
  return s.toString();
}
be.constructMethodCallUri = m0;
function sl(t, e) {
  if (t === "string" || t === "unknown")
    return String(e);
  if (t === "float")
    return String(Number(e));
  if (t === "integer")
    return String(Number(e) | 0);
  if (t === "boolean")
    return e ? "true" : "false";
  if (t === "datetime")
    return e instanceof Date ? e.toISOString() : String(e);
  throw new Error(`Unsupported query param type: ${t}`);
}
be.encodeQueryParam = sl;
function b0(t) {
  const e = {};
  for (const [r, n] of Object.entries(t))
    e[r.toLowerCase()] = n;
  return e;
}
be.normalizeHeaders = b0;
function h0(t, e, r) {
  const n = r?.headers || {};
  return t.type === "procedure" && (r?.encoding && (n["Content-Type"] = r.encoding), e && typeof e == "object" && (n["Content-Type"] || (n["Content-Type"] = "application/json"))), n;
}
be.constructMethodCallHeaders = h0;
function E0(t, e) {
  if (!(!t["content-type"] || typeof e > "u"))
    return e instanceof ArrayBuffer ? e : t["content-type"].startsWith("text/") ? new TextEncoder().encode(e.toString()) : t["content-type"].startsWith("application/json") ? new TextEncoder().encode((0, Zc.stringifyLex)(e)) : e;
}
be.encodeMethodCallBody = E0;
function x0(t) {
  let e;
  return t in xt.ResponseType ? e = t : t >= 100 && t < 200 ? e = xt.ResponseType.XRPCNotSupported : t >= 200 && t < 300 ? e = xt.ResponseType.Success : t >= 300 && t < 400 ? e = xt.ResponseType.XRPCNotSupported : t >= 400 && t < 500 ? e = xt.ResponseType.InvalidRequest : e = xt.ResponseType.InternalServerError, e;
}
be.httpResponseCodeToEnum = x0;
function g0(t, e) {
  if (t) {
    if (t.includes("application/json") && e?.byteLength)
      try {
        const r = new TextDecoder().decode(e);
        return (0, Zc.jsonStringToLex)(r);
      } catch (r) {
        throw new xt.XRPCError(xt.ResponseType.InvalidResponse, `Failed to parse response body: ${String(r)}`);
      }
    if (t.startsWith("text/") && e?.byteLength)
      try {
        return new TextDecoder().decode(e);
      } catch (r) {
        throw new xt.XRPCError(xt.ResponseType.InvalidResponse, `Failed to parse response body: ${String(r)}`);
      }
  }
  return e instanceof ArrayBuffer ? new Uint8Array(e) : e;
}
be.httpResponseBodyParse = g0;
Object.defineProperty(Zt, "__esModule", { value: !0 });
Zt.defaultFetchHandler = Zt.ServiceClient = Zt.Client = void 0;
const Hc = mn, jr = be, hr = Ra;
class R0 {
  constructor() {
    Object.defineProperty(this, "fetch", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Jc
    }), Object.defineProperty(this, "lex", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Hc.Lexicons()
    });
  }
  // method calls
  //
  async call(e, r, n, s, u) {
    return this.service(e).call(r, n, s, u);
  }
  service(e) {
    return new Wc(this, e);
  }
  // schemas
  // =
  addLexicon(e) {
    this.lex.add(e);
  }
  addLexicons(e) {
    for (const r of e)
      this.addLexicon(r);
  }
  removeLexicon(e) {
    this.lex.remove(e);
  }
}
Zt.Client = R0;
class Wc {
  constructor(e, r) {
    Object.defineProperty(this, "baseClient", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "uri", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), this.baseClient = e, this.uri = typeof r == "string" ? new URL(r) : r;
  }
  setHeader(e, r) {
    this.headers[e] = r;
  }
  unsetHeader(e) {
    delete this.headers[e];
  }
  async call(e, r, n, s) {
    const u = this.baseClient.lex.getDefOrThrow(e);
    if (!u || u.type !== "query" && u.type !== "procedure")
      throw new Error(`Invalid lexicon: ${e}. Must be a query or procedure.`);
    const c = (0, jr.getMethodSchemaHTTPMethod)(u), a = (0, jr.constructMethodCallUri)(e, u, this.uri, r), y = (0, jr.constructMethodCallHeaders)(u, n, {
      headers: {
        ...this.headers,
        ...s?.headers
      },
      encoding: s?.encoding
    }), d = await this.baseClient.fetch(a, c, y, n), b = (0, jr.httpResponseCodeToEnum)(d.status);
    if (b === hr.ResponseType.Success) {
      try {
        this.baseClient.lex.assertValidXrpcOutput(e, d.body);
      } catch (g) {
        throw g instanceof Hc.ValidationError ? new hr.XRPCInvalidResponseError(e, g, d.body) : g;
      }
      return new hr.XRPCResponse(d.body, d.headers);
    } else
      throw d.body && v0(d.body) ? new hr.XRPCError(b, d.body.error, d.body.message, d.headers) : new hr.XRPCError(b);
  }
}
Zt.ServiceClient = Wc;
async function Jc(t, e, r, n) {
  try {
    const s = (0, jr.normalizeHeaders)(r), u = {
      method: e,
      headers: s,
      body: (0, jr.encodeMethodCallBody)(s, n),
      duplex: "half"
    }, c = await fetch(t, u), a = await c.arrayBuffer();
    return {
      status: c.status,
      headers: Object.fromEntries(c.headers.entries()),
      body: (0, jr.httpResponseBodyParse)(c.headers.get("content-type"), a)
    };
  } catch (s) {
    throw new hr.XRPCError(hr.ResponseType.Unknown, String(s));
  }
}
Zt.defaultFetchHandler = Jc;
function v0(t) {
  return hr.errorResponseBody.safeParse(t).success;
}
(function(t) {
  var e = S && S.__createBinding || (Object.create ? function(u, c, a, y) {
    y === void 0 && (y = a);
    var d = Object.getOwnPropertyDescriptor(c, a);
    (!d || ("get" in d ? !c.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return c[a];
    } }), Object.defineProperty(u, y, d);
  } : function(u, c, a, y) {
    y === void 0 && (y = a), u[y] = c[a];
  }), r = S && S.__exportStar || function(u, c) {
    for (var a in u) a !== "default" && !Object.prototype.hasOwnProperty.call(c, a) && e(c, u, a);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), r(Ra, t), r(Zt, t);
  const n = Zt, s = new n.Client();
  t.default = s;
})(v);
var $ = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ids = t.lexicons = t.schemas = t.schemaDict = void 0;
  const e = mn;
  t.schemaDict = {
    ComAtprotoAdminDefs: {
      lexicon: 1,
      id: "com.atproto.admin.defs",
      defs: {
        statusAttr: {
          type: "object",
          required: ["applied"],
          properties: {
            applied: {
              type: "boolean"
            },
            ref: {
              type: "string"
            }
          }
        },
        accountView: {
          type: "object",
          required: ["did", "handle", "indexedAt"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            email: {
              type: "string"
            },
            relatedRecords: {
              type: "array",
              items: {
                type: "unknown"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            invitedBy: {
              type: "ref",
              ref: "lex:com.atproto.server.defs#inviteCode"
            },
            invites: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.server.defs#inviteCode"
              }
            },
            invitesDisabled: {
              type: "boolean"
            },
            emailConfirmedAt: {
              type: "string",
              format: "datetime"
            },
            inviteNote: {
              type: "string"
            },
            deactivatedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        repoRef: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        },
        repoBlobRef: {
          type: "object",
          required: ["did", "cid"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            recordUri: {
              type: "string",
              format: "at-uri"
            }
          }
        }
      }
    },
    ComAtprotoAdminDeleteAccount: {
      lexicon: 1,
      id: "com.atproto.admin.deleteAccount",
      defs: {
        main: {
          type: "procedure",
          description: "Delete a user account as an administrator.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminDisableAccountInvites: {
      lexicon: 1,
      id: "com.atproto.admin.disableAccountInvites",
      defs: {
        main: {
          type: "procedure",
          description: "Disable an account from receiving new invite codes, but does not invalidate existing codes.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["account"],
              properties: {
                account: {
                  type: "string",
                  format: "did"
                },
                note: {
                  type: "string",
                  description: "Optional reason for disabled invites."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminDisableInviteCodes: {
      lexicon: 1,
      id: "com.atproto.admin.disableInviteCodes",
      defs: {
        main: {
          type: "procedure",
          description: "Disable some set of codes and/or all codes associated with a set of users.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                codes: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                accounts: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminEnableAccountInvites: {
      lexicon: 1,
      id: "com.atproto.admin.enableAccountInvites",
      defs: {
        main: {
          type: "procedure",
          description: "Re-enable an account's ability to receive invite codes.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["account"],
              properties: {
                account: {
                  type: "string",
                  format: "did"
                },
                note: {
                  type: "string",
                  description: "Optional reason for enabled invites."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminGetAccountInfo: {
      lexicon: 1,
      id: "com.atproto.admin.getAccountInfo",
      defs: {
        main: {
          type: "query",
          description: "Get details about an account.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:com.atproto.admin.defs#accountView"
            }
          }
        }
      }
    },
    ComAtprotoAdminGetAccountInfos: {
      lexicon: 1,
      id: "com.atproto.admin.getAccountInfos",
      defs: {
        main: {
          type: "query",
          description: "Get details about some accounts.",
          parameters: {
            type: "params",
            required: ["dids"],
            properties: {
              dids: {
                type: "array",
                items: {
                  type: "string",
                  format: "did"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["infos"],
              properties: {
                infos: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#accountView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminGetInviteCodes: {
      lexicon: 1,
      id: "com.atproto.admin.getInviteCodes",
      defs: {
        main: {
          type: "query",
          description: "Get an admin view of invite codes.",
          parameters: {
            type: "params",
            properties: {
              sort: {
                type: "string",
                knownValues: ["recent", "usage"],
                default: "recent"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 500,
                default: 100
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["codes"],
              properties: {
                cursor: {
                  type: "string"
                },
                codes: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.defs#inviteCode"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminGetSubjectStatus: {
      lexicon: 1,
      id: "com.atproto.admin.getSubjectStatus",
      defs: {
        main: {
          type: "query",
          description: "Get the service-specific admin status of a subject (account, record, or blob).",
          parameters: {
            type: "params",
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              uri: {
                type: "string",
                format: "at-uri"
              },
              blob: {
                type: "string",
                format: "cid"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject"],
              properties: {
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef",
                    "lex:com.atproto.admin.defs#repoBlobRef"
                  ]
                },
                takedown: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#statusAttr"
                },
                deactivated: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#statusAttr"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminSearchAccounts: {
      lexicon: 1,
      id: "com.atproto.admin.searchAccounts",
      defs: {
        main: {
          type: "query",
          description: "Get list of accounts that matches your search query.",
          parameters: {
            type: "params",
            properties: {
              email: {
                type: "string"
              },
              cursor: {
                type: "string"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["accounts"],
              properties: {
                cursor: {
                  type: "string"
                },
                accounts: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#accountView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminSendEmail: {
      lexicon: 1,
      id: "com.atproto.admin.sendEmail",
      defs: {
        main: {
          type: "procedure",
          description: "Send email to a user's account email address.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["recipientDid", "content", "senderDid"],
              properties: {
                recipientDid: {
                  type: "string",
                  format: "did"
                },
                content: {
                  type: "string"
                },
                subject: {
                  type: "string"
                },
                senderDid: {
                  type: "string",
                  format: "did"
                },
                comment: {
                  type: "string",
                  description: "Additional comment by the sender that won't be used in the email itself but helpful to provide more context for moderators/reviewers"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["sent"],
              properties: {
                sent: {
                  type: "boolean"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminUpdateAccountEmail: {
      lexicon: 1,
      id: "com.atproto.admin.updateAccountEmail",
      defs: {
        main: {
          type: "procedure",
          description: "Administrative action to update an account's email.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["account", "email"],
              properties: {
                account: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo."
                },
                email: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminUpdateAccountHandle: {
      lexicon: 1,
      id: "com.atproto.admin.updateAccountHandle",
      defs: {
        main: {
          type: "procedure",
          description: "Administrative action to update an account's handle.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "handle"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminUpdateAccountPassword: {
      lexicon: 1,
      id: "com.atproto.admin.updateAccountPassword",
      defs: {
        main: {
          type: "procedure",
          description: "Update the password for a user account as an administrator.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "password"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                password: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminUpdateSubjectStatus: {
      lexicon: 1,
      id: "com.atproto.admin.updateSubjectStatus",
      defs: {
        main: {
          type: "procedure",
          description: "Update the service-specific admin status of a subject (account, record, or blob).",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject"],
              properties: {
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef",
                    "lex:com.atproto.admin.defs#repoBlobRef"
                  ]
                },
                takedown: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#statusAttr"
                },
                deactivated: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#statusAttr"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject"],
              properties: {
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef",
                    "lex:com.atproto.admin.defs#repoBlobRef"
                  ]
                },
                takedown: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#statusAttr"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoIdentityGetRecommendedDidCredentials: {
      lexicon: 1,
      id: "com.atproto.identity.getRecommendedDidCredentials",
      defs: {
        main: {
          type: "query",
          description: "Describe the credentials that should be included in the DID doc of an account that is migrating to this service.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                rotationKeys: {
                  description: "Recommended rotation keys for PLC dids. Should be undefined (or ignored) for did:webs.",
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                alsoKnownAs: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                verificationMethods: {
                  type: "unknown"
                },
                services: {
                  type: "unknown"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoIdentityRequestPlcOperationSignature: {
      lexicon: 1,
      id: "com.atproto.identity.requestPlcOperationSignature",
      defs: {
        main: {
          type: "procedure",
          description: "Request an email with a code to in order to request a signed PLC operation. Requires Auth."
        }
      }
    },
    ComAtprotoIdentityResolveHandle: {
      lexicon: 1,
      id: "com.atproto.identity.resolveHandle",
      defs: {
        main: {
          type: "query",
          description: "Resolves a handle (domain name) to a DID.",
          parameters: {
            type: "params",
            required: ["handle"],
            properties: {
              handle: {
                type: "string",
                format: "handle",
                description: "The handle to resolve."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoIdentitySignPlcOperation: {
      lexicon: 1,
      id: "com.atproto.identity.signPlcOperation",
      defs: {
        main: {
          type: "procedure",
          description: "Signs a PLC operation to update some value(s) in the requesting DID's document.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                token: {
                  description: "A token received through com.atproto.identity.requestPlcOperationSignature",
                  type: "string"
                },
                rotationKeys: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                alsoKnownAs: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                verificationMethods: {
                  type: "unknown"
                },
                services: {
                  type: "unknown"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["operation"],
              properties: {
                operation: {
                  type: "unknown",
                  description: "A signed DID PLC operation."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoIdentitySubmitPlcOperation: {
      lexicon: 1,
      id: "com.atproto.identity.submitPlcOperation",
      defs: {
        main: {
          type: "procedure",
          description: "Validates a PLC operation to ensure that it doesn't violate a service's constraints or get the identity into a bad state, then submits it to the PLC registry",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["operation"],
              properties: {
                operation: {
                  type: "unknown"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoIdentityUpdateHandle: {
      lexicon: 1,
      id: "com.atproto.identity.updateHandle",
      defs: {
        main: {
          type: "procedure",
          description: "Updates the current account's handle. Verifies handle validity, and updates did:plc document if necessary. Implemented by PDS, and requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["handle"],
              properties: {
                handle: {
                  type: "string",
                  format: "handle",
                  description: "The new handle."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoLabelDefs: {
      lexicon: 1,
      id: "com.atproto.label.defs",
      defs: {
        label: {
          type: "object",
          description: "Metadata tag on an atproto resource (eg, repo or record).",
          required: ["src", "uri", "val", "cts"],
          properties: {
            ver: {
              type: "integer",
              description: "The AT Protocol version of the label object."
            },
            src: {
              type: "string",
              format: "did",
              description: "DID of the actor who created this label."
            },
            uri: {
              type: "string",
              format: "uri",
              description: "AT URI of the record, repository (account), or other resource that this label applies to."
            },
            cid: {
              type: "string",
              format: "cid",
              description: "Optionally, CID specifying the specific version of 'uri' resource this label applies to."
            },
            val: {
              type: "string",
              maxLength: 128,
              description: "The short string name of the value or type of this label."
            },
            neg: {
              type: "boolean",
              description: "If true, this is a negation label, overwriting a previous label."
            },
            cts: {
              type: "string",
              format: "datetime",
              description: "Timestamp when this label was created."
            },
            exp: {
              type: "string",
              format: "datetime",
              description: "Timestamp at which this label expires (no longer applies)."
            },
            sig: {
              type: "bytes",
              description: "Signature of dag-cbor encoded label."
            }
          }
        },
        selfLabels: {
          type: "object",
          description: "Metadata tags on an atproto record, published by the author within the record.",
          required: ["values"],
          properties: {
            values: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#selfLabel"
              },
              maxLength: 10
            }
          }
        },
        selfLabel: {
          type: "object",
          description: "Metadata tag on an atproto record, published by the author within the record. Note that schemas should use #selfLabels, not #selfLabel.",
          required: ["val"],
          properties: {
            val: {
              type: "string",
              maxLength: 128,
              description: "The short string name of the value or type of this label."
            }
          }
        },
        labelValueDefinition: {
          type: "object",
          description: "Declares a label value and its expected interpretations and behaviors.",
          required: ["identifier", "severity", "blurs", "locales"],
          properties: {
            identifier: {
              type: "string",
              description: "The value of the label being defined. Must only include lowercase ascii and the '-' character ([a-z-]+).",
              maxLength: 100,
              maxGraphemes: 100
            },
            severity: {
              type: "string",
              description: "How should a client visually convey this label? 'inform' means neutral and informational; 'alert' means negative and warning; 'none' means show nothing.",
              knownValues: ["inform", "alert", "none"]
            },
            blurs: {
              type: "string",
              description: "What should this label hide in the UI, if applied? 'content' hides all of the target; 'media' hides the images/video/audio; 'none' hides nothing.",
              knownValues: ["content", "media", "none"]
            },
            defaultSetting: {
              type: "string",
              description: "The default setting for this label.",
              knownValues: ["ignore", "warn", "hide"],
              default: "warn"
            },
            adultOnly: {
              type: "boolean",
              description: "Does the user need to have adult content enabled in order to configure this label?"
            },
            locales: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#labelValueDefinitionStrings"
              }
            }
          }
        },
        labelValueDefinitionStrings: {
          type: "object",
          description: "Strings which describe the label in the UI, localized into a specific language.",
          required: ["lang", "name", "description"],
          properties: {
            lang: {
              type: "string",
              description: "The code of the language these strings are written in.",
              format: "language"
            },
            name: {
              type: "string",
              description: "A short human-readable name for the label.",
              maxGraphemes: 64,
              maxLength: 640
            },
            description: {
              type: "string",
              description: "A longer description of what the label means and why it might be applied.",
              maxGraphemes: 1e4,
              maxLength: 1e5
            }
          }
        },
        labelValue: {
          type: "string",
          knownValues: [
            "!hide",
            "!no-promote",
            "!warn",
            "!no-unauthenticated",
            "dmca-violation",
            "doxxing",
            "porn",
            "sexual",
            "nudity",
            "nsfl",
            "gore"
          ]
        }
      }
    },
    ComAtprotoLabelQueryLabels: {
      lexicon: 1,
      id: "com.atproto.label.queryLabels",
      defs: {
        main: {
          type: "query",
          description: "Find labels relevant to the provided AT-URI patterns. Public endpoint for moderation services, though may return different or additional results with auth.",
          parameters: {
            type: "params",
            required: ["uriPatterns"],
            properties: {
              uriPatterns: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "List of AT URI patterns to match (boolean 'OR'). Each may be a prefix (ending with '*'; will match inclusive of the string leading to '*'), or a full URI."
              },
              sources: {
                type: "array",
                items: {
                  type: "string",
                  format: "did"
                },
                description: "Optional list of label sources (DIDs) to filter on."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 250,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["labels"],
              properties: {
                cursor: {
                  type: "string"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoLabelSubscribeLabels: {
      lexicon: 1,
      id: "com.atproto.label.subscribeLabels",
      defs: {
        main: {
          type: "subscription",
          description: "Subscribe to stream of labels (and negations). Public endpoint implemented by mod services. Uses same sequencing scheme as repo event stream.",
          parameters: {
            type: "params",
            properties: {
              cursor: {
                type: "integer",
                description: "The last known event seq number to backfill from."
              }
            }
          },
          message: {
            schema: {
              type: "union",
              refs: [
                "lex:com.atproto.label.subscribeLabels#labels",
                "lex:com.atproto.label.subscribeLabels#info"
              ]
            }
          },
          errors: [
            {
              name: "FutureCursor"
            }
          ]
        },
        labels: {
          type: "object",
          required: ["seq", "labels"],
          properties: {
            seq: {
              type: "integer"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        info: {
          type: "object",
          required: ["name"],
          properties: {
            name: {
              type: "string",
              knownValues: ["OutdatedCursor"]
            },
            message: {
              type: "string"
            }
          }
        }
      }
    },
    ComAtprotoModerationCreateReport: {
      lexicon: 1,
      id: "com.atproto.moderation.createReport",
      defs: {
        main: {
          type: "procedure",
          description: "Submit a moderation report regarding an atproto account or record. Implemented by moderation services (with PDS proxying), and requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["reasonType", "subject"],
              properties: {
                reasonType: {
                  type: "ref",
                  description: "Indicates the broad category of violation the report is for.",
                  ref: "lex:com.atproto.moderation.defs#reasonType"
                },
                reason: {
                  type: "string",
                  maxGraphemes: 2e3,
                  maxLength: 2e4,
                  description: "Additional context about the content and violation."
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: [
                "id",
                "reasonType",
                "subject",
                "reportedBy",
                "createdAt"
              ],
              properties: {
                id: {
                  type: "integer"
                },
                reasonType: {
                  type: "ref",
                  ref: "lex:com.atproto.moderation.defs#reasonType"
                },
                reason: {
                  type: "string",
                  maxGraphemes: 2e3,
                  maxLength: 2e4
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                },
                reportedBy: {
                  type: "string",
                  format: "did"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoModerationDefs: {
      lexicon: 1,
      id: "com.atproto.moderation.defs",
      defs: {
        reasonType: {
          type: "string",
          knownValues: [
            "com.atproto.moderation.defs#reasonSpam",
            "com.atproto.moderation.defs#reasonViolation",
            "com.atproto.moderation.defs#reasonMisleading",
            "com.atproto.moderation.defs#reasonSexual",
            "com.atproto.moderation.defs#reasonRude",
            "com.atproto.moderation.defs#reasonOther",
            "com.atproto.moderation.defs#reasonAppeal"
          ]
        },
        reasonSpam: {
          type: "token",
          description: "Spam: frequent unwanted promotion, replies, mentions"
        },
        reasonViolation: {
          type: "token",
          description: "Direct violation of server rules, laws, terms of service"
        },
        reasonMisleading: {
          type: "token",
          description: "Misleading identity, affiliation, or content"
        },
        reasonSexual: {
          type: "token",
          description: "Unwanted or mislabeled sexual content"
        },
        reasonRude: {
          type: "token",
          description: "Rude, harassing, explicit, or otherwise unwelcoming behavior"
        },
        reasonOther: {
          type: "token",
          description: "Other: reports not falling under another report category"
        },
        reasonAppeal: {
          type: "token",
          description: "Appeal: appeal a previously taken moderation action"
        }
      }
    },
    ComAtprotoRepoApplyWrites: {
      lexicon: 1,
      id: "com.atproto.repo.applyWrites",
      defs: {
        main: {
          type: "procedure",
          description: "Apply a batch transaction of repository creates, updates, and deletes. Requires auth, implemented by PDS.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repo", "writes"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo (aka, current account)."
                },
                validate: {
                  type: "boolean",
                  default: !0,
                  description: "Can be set to 'false' to skip Lexicon schema validation of record data, for all operations."
                },
                writes: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:com.atproto.repo.applyWrites#create",
                      "lex:com.atproto.repo.applyWrites#update",
                      "lex:com.atproto.repo.applyWrites#delete"
                    ],
                    closed: !0
                  }
                },
                swapCommit: {
                  type: "string",
                  description: "If provided, the entire operation will fail if the current repo commit CID does not match this value. Used to prevent conflicting repo mutations.",
                  format: "cid"
                }
              }
            }
          },
          errors: [
            {
              name: "InvalidSwap",
              description: "Indicates that the 'swapCommit' parameter did not match current commit."
            }
          ]
        },
        create: {
          type: "object",
          description: "Operation which creates a new record.",
          required: ["collection", "value"],
          properties: {
            collection: {
              type: "string",
              format: "nsid"
            },
            rkey: {
              type: "string",
              maxLength: 15
            },
            value: {
              type: "unknown"
            }
          }
        },
        update: {
          type: "object",
          description: "Operation which updates an existing record.",
          required: ["collection", "rkey", "value"],
          properties: {
            collection: {
              type: "string",
              format: "nsid"
            },
            rkey: {
              type: "string"
            },
            value: {
              type: "unknown"
            }
          }
        },
        delete: {
          type: "object",
          description: "Operation which deletes an existing record.",
          required: ["collection", "rkey"],
          properties: {
            collection: {
              type: "string",
              format: "nsid"
            },
            rkey: {
              type: "string"
            }
          }
        }
      }
    },
    ComAtprotoRepoCreateRecord: {
      lexicon: 1,
      id: "com.atproto.repo.createRecord",
      defs: {
        main: {
          type: "procedure",
          description: "Create a single new repository record. Requires auth, implemented by PDS.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repo", "collection", "record"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo (aka, current account)."
                },
                collection: {
                  type: "string",
                  format: "nsid",
                  description: "The NSID of the record collection."
                },
                rkey: {
                  type: "string",
                  description: "The Record Key.",
                  maxLength: 15
                },
                validate: {
                  type: "boolean",
                  default: !0,
                  description: "Can be set to 'false' to skip Lexicon schema validation of record data."
                },
                record: {
                  type: "unknown",
                  description: "The record itself. Must contain a $type field."
                },
                swapCommit: {
                  type: "string",
                  format: "cid",
                  description: "Compare and swap with the previous commit by CID."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["uri", "cid"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                }
              }
            }
          },
          errors: [
            {
              name: "InvalidSwap",
              description: "Indicates that 'swapCommit' didn't match current repo commit."
            }
          ]
        }
      }
    },
    ComAtprotoRepoDeleteRecord: {
      lexicon: 1,
      id: "com.atproto.repo.deleteRecord",
      defs: {
        main: {
          type: "procedure",
          description: "Delete a repository record, or ensure it doesn't exist. Requires auth, implemented by PDS.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repo", "collection", "rkey"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo (aka, current account)."
                },
                collection: {
                  type: "string",
                  format: "nsid",
                  description: "The NSID of the record collection."
                },
                rkey: {
                  type: "string",
                  description: "The Record Key."
                },
                swapRecord: {
                  type: "string",
                  format: "cid",
                  description: "Compare and swap with the previous record by CID."
                },
                swapCommit: {
                  type: "string",
                  format: "cid",
                  description: "Compare and swap with the previous commit by CID."
                }
              }
            }
          },
          errors: [
            {
              name: "InvalidSwap"
            }
          ]
        }
      }
    },
    ComAtprotoRepoDescribeRepo: {
      lexicon: 1,
      id: "com.atproto.repo.describeRepo",
      defs: {
        main: {
          type: "query",
          description: "Get information about an account and repository, including the list of collections. Does not require auth.",
          parameters: {
            type: "params",
            required: ["repo"],
            properties: {
              repo: {
                type: "string",
                format: "at-identifier",
                description: "The handle or DID of the repo."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: [
                "handle",
                "did",
                "didDoc",
                "collections",
                "handleIsCorrect"
              ],
              properties: {
                handle: {
                  type: "string",
                  format: "handle"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                didDoc: {
                  type: "unknown",
                  description: "The complete DID document for this account."
                },
                collections: {
                  type: "array",
                  description: "List of all the collections (NSIDs) for which this repo contains at least one record.",
                  items: {
                    type: "string",
                    format: "nsid"
                  }
                },
                handleIsCorrect: {
                  type: "boolean",
                  description: "Indicates if handle is currently valid (resolves bi-directionally)"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoRepoGetRecord: {
      lexicon: 1,
      id: "com.atproto.repo.getRecord",
      defs: {
        main: {
          type: "query",
          description: "Get a single record from a repository. Does not require auth.",
          parameters: {
            type: "params",
            required: ["repo", "collection", "rkey"],
            properties: {
              repo: {
                type: "string",
                format: "at-identifier",
                description: "The handle or DID of the repo."
              },
              collection: {
                type: "string",
                format: "nsid",
                description: "The NSID of the record collection."
              },
              rkey: {
                type: "string",
                description: "The Record Key."
              },
              cid: {
                type: "string",
                format: "cid",
                description: "The CID of the version of the record. If not specified, then return the most recent version."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["uri", "value"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                value: {
                  type: "unknown"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoRepoImportRepo: {
      lexicon: 1,
      id: "com.atproto.repo.importRepo",
      defs: {
        main: {
          type: "procedure",
          description: "Import a repo in the form of a CAR file. Requires Content-Length HTTP header to be set.",
          input: {
            encoding: "application/vnd.ipld.car"
          }
        }
      }
    },
    ComAtprotoRepoListMissingBlobs: {
      lexicon: 1,
      id: "com.atproto.repo.listMissingBlobs",
      defs: {
        main: {
          type: "query",
          description: "Returns a list of missing blobs for the requesting account. Intended to be used in the account migration flow.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 1e3,
                default: 500
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["blobs"],
              properties: {
                cursor: {
                  type: "string"
                },
                blobs: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.listMissingBlobs#recordBlob"
                  }
                }
              }
            }
          }
        },
        recordBlob: {
          type: "object",
          required: ["cid", "recordUri"],
          properties: {
            cid: {
              type: "string",
              format: "cid"
            },
            recordUri: {
              type: "string",
              format: "at-uri"
            }
          }
        }
      }
    },
    ComAtprotoRepoListRecords: {
      lexicon: 1,
      id: "com.atproto.repo.listRecords",
      defs: {
        main: {
          type: "query",
          description: "List a range of records in a repository, matching a specific collection. Does not require auth.",
          parameters: {
            type: "params",
            required: ["repo", "collection"],
            properties: {
              repo: {
                type: "string",
                format: "at-identifier",
                description: "The handle or DID of the repo."
              },
              collection: {
                type: "string",
                format: "nsid",
                description: "The NSID of the record type."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50,
                description: "The number of records to return."
              },
              cursor: {
                type: "string"
              },
              rkeyStart: {
                type: "string",
                description: "DEPRECATED: The lowest sort-ordered rkey to start from (exclusive)"
              },
              rkeyEnd: {
                type: "string",
                description: "DEPRECATED: The highest sort-ordered rkey to stop at (exclusive)"
              },
              reverse: {
                type: "boolean",
                description: "Flag to reverse the order of the returned records."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["records"],
              properties: {
                cursor: {
                  type: "string"
                },
                records: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.listRecords#record"
                  }
                }
              }
            }
          }
        },
        record: {
          type: "object",
          required: ["uri", "cid", "value"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            value: {
              type: "unknown"
            }
          }
        }
      }
    },
    ComAtprotoRepoPutRecord: {
      lexicon: 1,
      id: "com.atproto.repo.putRecord",
      defs: {
        main: {
          type: "procedure",
          description: "Write a repository record, creating or updating it as needed. Requires auth, implemented by PDS.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repo", "collection", "rkey", "record"],
              nullable: ["swapRecord"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo (aka, current account)."
                },
                collection: {
                  type: "string",
                  format: "nsid",
                  description: "The NSID of the record collection."
                },
                rkey: {
                  type: "string",
                  description: "The Record Key.",
                  maxLength: 15
                },
                validate: {
                  type: "boolean",
                  default: !0,
                  description: "Can be set to 'false' to skip Lexicon schema validation of record data."
                },
                record: {
                  type: "unknown",
                  description: "The record to write."
                },
                swapRecord: {
                  type: "string",
                  format: "cid",
                  description: "Compare and swap with the previous record by CID. WARNING: nullable and optional field; may cause problems with golang implementation"
                },
                swapCommit: {
                  type: "string",
                  format: "cid",
                  description: "Compare and swap with the previous commit by CID."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["uri", "cid"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                }
              }
            }
          },
          errors: [
            {
              name: "InvalidSwap"
            }
          ]
        }
      }
    },
    ComAtprotoRepoStrongRef: {
      lexicon: 1,
      id: "com.atproto.repo.strongRef",
      description: "A URI with a content-hash fingerprint.",
      defs: {
        main: {
          type: "object",
          required: ["uri", "cid"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            }
          }
        }
      }
    },
    ComAtprotoRepoUploadBlob: {
      lexicon: 1,
      id: "com.atproto.repo.uploadBlob",
      defs: {
        main: {
          type: "procedure",
          description: "Upload a new blob, to be referenced from a repository record. The blob will be deleted if it is not referenced within a time window (eg, minutes). Blob restrictions (mimetype, size, etc) are enforced when the reference is created. Requires auth, implemented by PDS.",
          input: {
            encoding: "*/*"
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["blob"],
              properties: {
                blob: {
                  type: "blob"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerActivateAccount: {
      lexicon: 1,
      id: "com.atproto.server.activateAccount",
      defs: {
        main: {
          type: "procedure",
          description: "Activates a currently deactivated account. Used to finalize account migration after the account's repo is imported and identity is setup."
        }
      }
    },
    ComAtprotoServerCheckAccountStatus: {
      lexicon: 1,
      id: "com.atproto.server.checkAccountStatus",
      defs: {
        main: {
          type: "query",
          description: "Returns the status of an account, especially as pertaining to import or recovery. Can be called many times over the course of an account migration. Requires auth and can only be called pertaining to oneself.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: [
                "activated",
                "validDid",
                "repoCommit",
                "repoRev",
                "repoBlocks",
                "indexedRecords",
                "privateStateValues",
                "expectedBlobs",
                "importedBlobs"
              ],
              properties: {
                activated: {
                  type: "boolean"
                },
                validDid: {
                  type: "boolean"
                },
                repoCommit: {
                  type: "string",
                  format: "cid"
                },
                repoRev: {
                  type: "string"
                },
                repoBlocks: {
                  type: "integer"
                },
                indexedRecords: {
                  type: "integer"
                },
                privateStateValues: {
                  type: "integer"
                },
                expectedBlobs: {
                  type: "integer"
                },
                importedBlobs: {
                  type: "integer"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerConfirmEmail: {
      lexicon: 1,
      id: "com.atproto.server.confirmEmail",
      defs: {
        main: {
          type: "procedure",
          description: "Confirm an email using a token from com.atproto.server.requestEmailConfirmation.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["email", "token"],
              properties: {
                email: {
                  type: "string"
                },
                token: {
                  type: "string"
                }
              }
            }
          },
          errors: [
            {
              name: "AccountNotFound"
            },
            {
              name: "ExpiredToken"
            },
            {
              name: "InvalidToken"
            },
            {
              name: "InvalidEmail"
            }
          ]
        }
      }
    },
    ComAtprotoServerCreateAccount: {
      lexicon: 1,
      id: "com.atproto.server.createAccount",
      defs: {
        main: {
          type: "procedure",
          description: "Create an account. Implemented by PDS.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["handle"],
              properties: {
                email: {
                  type: "string"
                },
                handle: {
                  type: "string",
                  format: "handle",
                  description: "Requested handle for the account."
                },
                did: {
                  type: "string",
                  format: "did",
                  description: "Pre-existing atproto DID, being imported to a new account."
                },
                inviteCode: {
                  type: "string"
                },
                verificationCode: {
                  type: "string"
                },
                verificationPhone: {
                  type: "string"
                },
                password: {
                  type: "string",
                  description: "Initial account password. May need to meet instance-specific password strength requirements."
                },
                recoveryKey: {
                  type: "string",
                  description: "DID PLC rotation key (aka, recovery key) to be included in PLC creation operation."
                },
                plcOp: {
                  type: "unknown",
                  description: "A signed DID PLC operation to be submitted as part of importing an existing account to this instance. NOTE: this optional field may be updated when full account migration is implemented."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              description: "Account login session returned on successful account creation.",
              required: ["accessJwt", "refreshJwt", "handle", "did"],
              properties: {
                accessJwt: {
                  type: "string"
                },
                refreshJwt: {
                  type: "string"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID of the new account."
                },
                didDoc: {
                  type: "unknown",
                  description: "Complete DID document."
                }
              }
            }
          },
          errors: [
            {
              name: "InvalidHandle"
            },
            {
              name: "InvalidPassword"
            },
            {
              name: "InvalidInviteCode"
            },
            {
              name: "HandleNotAvailable"
            },
            {
              name: "UnsupportedDomain"
            },
            {
              name: "UnresolvableDid"
            },
            {
              name: "IncompatibleDidDoc"
            }
          ]
        }
      }
    },
    ComAtprotoServerCreateAppPassword: {
      lexicon: 1,
      id: "com.atproto.server.createAppPassword",
      defs: {
        main: {
          type: "procedure",
          description: "Create an App Password.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["name"],
              properties: {
                name: {
                  type: "string",
                  description: "A short name for the App Password, to help distinguish them."
                },
                privileged: {
                  type: "boolean",
                  description: "If an app password has 'privileged' access to possibly sensitive account state. Meant for use with trusted clients."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:com.atproto.server.createAppPassword#appPassword"
            }
          },
          errors: [
            {
              name: "AccountTakedown"
            }
          ]
        },
        appPassword: {
          type: "object",
          required: ["name", "password", "createdAt"],
          properties: {
            name: {
              type: "string"
            },
            password: {
              type: "string"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            privileged: {
              type: "boolean"
            }
          }
        }
      }
    },
    ComAtprotoServerCreateInviteCode: {
      lexicon: 1,
      id: "com.atproto.server.createInviteCode",
      defs: {
        main: {
          type: "procedure",
          description: "Create an invite code.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["useCount"],
              properties: {
                useCount: {
                  type: "integer"
                },
                forAccount: {
                  type: "string",
                  format: "did"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["code"],
              properties: {
                code: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerCreateInviteCodes: {
      lexicon: 1,
      id: "com.atproto.server.createInviteCodes",
      defs: {
        main: {
          type: "procedure",
          description: "Create invite codes.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["codeCount", "useCount"],
              properties: {
                codeCount: {
                  type: "integer",
                  default: 1
                },
                useCount: {
                  type: "integer"
                },
                forAccounts: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "did"
                  }
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["codes"],
              properties: {
                codes: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.createInviteCodes#accountCodes"
                  }
                }
              }
            }
          }
        },
        accountCodes: {
          type: "object",
          required: ["account", "codes"],
          properties: {
            account: {
              type: "string"
            },
            codes: {
              type: "array",
              items: {
                type: "string"
              }
            }
          }
        }
      }
    },
    ComAtprotoServerCreateSession: {
      lexicon: 1,
      id: "com.atproto.server.createSession",
      defs: {
        main: {
          type: "procedure",
          description: "Create an authentication session.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["identifier", "password"],
              properties: {
                identifier: {
                  type: "string",
                  description: "Handle or other identifier supported by the server for the authenticating user."
                },
                password: {
                  type: "string"
                },
                authFactorToken: {
                  type: "string"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["accessJwt", "refreshJwt", "handle", "did"],
              properties: {
                accessJwt: {
                  type: "string"
                },
                refreshJwt: {
                  type: "string"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                didDoc: {
                  type: "unknown"
                },
                email: {
                  type: "string"
                },
                emailConfirmed: {
                  type: "boolean"
                },
                emailAuthFactor: {
                  type: "boolean"
                },
                active: {
                  type: "boolean"
                },
                status: {
                  type: "string",
                  description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
                  knownValues: ["takendown", "suspended", "deactivated"]
                }
              }
            }
          },
          errors: [
            {
              name: "AccountTakedown"
            },
            {
              name: "AuthFactorTokenRequired"
            }
          ]
        }
      }
    },
    ComAtprotoServerDeactivateAccount: {
      lexicon: 1,
      id: "com.atproto.server.deactivateAccount",
      defs: {
        main: {
          type: "procedure",
          description: "Deactivates a currently active account. Stops serving of repo, and future writes to repo until reactivated. Used to finalize account migration with the old host after the account has been activated on the new host.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                deleteAfter: {
                  type: "string",
                  format: "datetime",
                  description: "A recommendation to server as to how long they should hold onto the deactivated account before deleting."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerDefs: {
      lexicon: 1,
      id: "com.atproto.server.defs",
      defs: {
        inviteCode: {
          type: "object",
          required: [
            "code",
            "available",
            "disabled",
            "forAccount",
            "createdBy",
            "createdAt",
            "uses"
          ],
          properties: {
            code: {
              type: "string"
            },
            available: {
              type: "integer"
            },
            disabled: {
              type: "boolean"
            },
            forAccount: {
              type: "string"
            },
            createdBy: {
              type: "string"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            uses: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.server.defs#inviteCodeUse"
              }
            }
          }
        },
        inviteCodeUse: {
          type: "object",
          required: ["usedBy", "usedAt"],
          properties: {
            usedBy: {
              type: "string",
              format: "did"
            },
            usedAt: {
              type: "string",
              format: "datetime"
            }
          }
        }
      }
    },
    ComAtprotoServerDeleteAccount: {
      lexicon: 1,
      id: "com.atproto.server.deleteAccount",
      defs: {
        main: {
          type: "procedure",
          description: "Delete an actor's account with a token and password. Can only be called after requesting a deletion token. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "password", "token"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                password: {
                  type: "string"
                },
                token: {
                  type: "string"
                }
              }
            }
          },
          errors: [
            {
              name: "ExpiredToken"
            },
            {
              name: "InvalidToken"
            }
          ]
        }
      }
    },
    ComAtprotoServerDeleteSession: {
      lexicon: 1,
      id: "com.atproto.server.deleteSession",
      defs: {
        main: {
          type: "procedure",
          description: "Delete the current session. Requires auth."
        }
      }
    },
    ComAtprotoServerDescribeServer: {
      lexicon: 1,
      id: "com.atproto.server.describeServer",
      defs: {
        main: {
          type: "query",
          description: "Describes the server's account creation requirements and capabilities. Implemented by PDS.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "availableUserDomains"],
              properties: {
                inviteCodeRequired: {
                  type: "boolean",
                  description: "If true, an invite code must be supplied to create an account on this instance."
                },
                phoneVerificationRequired: {
                  type: "boolean",
                  description: "If true, a phone verification token must be supplied to create an account on this instance."
                },
                availableUserDomains: {
                  type: "array",
                  description: "List of domain suffixes that can be used in account handles.",
                  items: {
                    type: "string"
                  }
                },
                links: {
                  type: "ref",
                  description: "URLs of service policy documents.",
                  ref: "lex:com.atproto.server.describeServer#links"
                },
                contact: {
                  type: "ref",
                  description: "Contact information",
                  ref: "lex:com.atproto.server.describeServer#contact"
                },
                did: {
                  type: "string",
                  format: "did"
                }
              }
            }
          }
        },
        links: {
          type: "object",
          properties: {
            privacyPolicy: {
              type: "string",
              format: "uri"
            },
            termsOfService: {
              type: "string",
              format: "uri"
            }
          }
        },
        contact: {
          type: "object",
          properties: {
            email: {
              type: "string"
            }
          }
        }
      }
    },
    ComAtprotoServerGetAccountInviteCodes: {
      lexicon: 1,
      id: "com.atproto.server.getAccountInviteCodes",
      defs: {
        main: {
          type: "query",
          description: "Get all invite codes for the current account. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              includeUsed: {
                type: "boolean",
                default: !0
              },
              createAvailable: {
                type: "boolean",
                default: !0,
                description: "Controls whether any new 'earned' but not 'created' invites should be created."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["codes"],
              properties: {
                codes: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.defs#inviteCode"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "DuplicateCreate"
            }
          ]
        }
      }
    },
    ComAtprotoServerGetServiceAuth: {
      lexicon: 1,
      id: "com.atproto.server.getServiceAuth",
      defs: {
        main: {
          type: "query",
          description: "Get a signed token on behalf of the requesting DID for the requested service.",
          parameters: {
            type: "params",
            required: ["aud"],
            properties: {
              aud: {
                type: "string",
                format: "did",
                description: "The DID of the service that the token will be used to authenticate with"
              },
              exp: {
                type: "integer",
                description: "The time in Unix Epoch seconds that the JWT expires. Defaults to 60 seconds in the future. The service may enforce certain time bounds on tokens depending on the requested scope."
              },
              lxm: {
                type: "string",
                format: "nsid",
                description: "Lexicon (XRPC) method to bind the requested token to"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["token"],
              properties: {
                token: {
                  type: "string"
                }
              }
            }
          },
          errors: [
            {
              name: "BadExpiration",
              description: "Indicates that the requested expiration date is not a valid. May be in the past or may be reliant on the requested scopes."
            }
          ]
        }
      }
    },
    ComAtprotoServerGetSession: {
      lexicon: 1,
      id: "com.atproto.server.getSession",
      defs: {
        main: {
          type: "query",
          description: "Get information about the current auth session. Requires auth.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["handle", "did"],
              properties: {
                handle: {
                  type: "string",
                  format: "handle"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                email: {
                  type: "string"
                },
                emailConfirmed: {
                  type: "boolean"
                },
                emailAuthFactor: {
                  type: "boolean"
                },
                didDoc: {
                  type: "unknown"
                },
                active: {
                  type: "boolean"
                },
                status: {
                  type: "string",
                  description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
                  knownValues: ["takendown", "suspended", "deactivated"]
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerListAppPasswords: {
      lexicon: 1,
      id: "com.atproto.server.listAppPasswords",
      defs: {
        main: {
          type: "query",
          description: "List all App Passwords.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["passwords"],
              properties: {
                passwords: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.listAppPasswords#appPassword"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "AccountTakedown"
            }
          ]
        },
        appPassword: {
          type: "object",
          required: ["name", "createdAt"],
          properties: {
            name: {
              type: "string"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            privileged: {
              type: "boolean"
            }
          }
        }
      }
    },
    ComAtprotoServerRefreshSession: {
      lexicon: 1,
      id: "com.atproto.server.refreshSession",
      defs: {
        main: {
          type: "procedure",
          description: "Refresh an authentication session. Requires auth using the 'refreshJwt' (not the 'accessJwt').",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["accessJwt", "refreshJwt", "handle", "did"],
              properties: {
                accessJwt: {
                  type: "string"
                },
                refreshJwt: {
                  type: "string"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                didDoc: {
                  type: "unknown"
                },
                active: {
                  type: "boolean"
                },
                status: {
                  type: "string",
                  description: "Hosting status of the account. If not specified, then assume 'active'.",
                  knownValues: ["takendown", "suspended", "deactivated"]
                }
              }
            }
          },
          errors: [
            {
              name: "AccountTakedown"
            }
          ]
        }
      }
    },
    ComAtprotoServerRequestAccountDelete: {
      lexicon: 1,
      id: "com.atproto.server.requestAccountDelete",
      defs: {
        main: {
          type: "procedure",
          description: "Initiate a user account deletion via email."
        }
      }
    },
    ComAtprotoServerRequestEmailConfirmation: {
      lexicon: 1,
      id: "com.atproto.server.requestEmailConfirmation",
      defs: {
        main: {
          type: "procedure",
          description: "Request an email with a code to confirm ownership of email."
        }
      }
    },
    ComAtprotoServerRequestEmailUpdate: {
      lexicon: 1,
      id: "com.atproto.server.requestEmailUpdate",
      defs: {
        main: {
          type: "procedure",
          description: "Request a token in order to update email.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["tokenRequired"],
              properties: {
                tokenRequired: {
                  type: "boolean"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerRequestPasswordReset: {
      lexicon: 1,
      id: "com.atproto.server.requestPasswordReset",
      defs: {
        main: {
          type: "procedure",
          description: "Initiate a user account password reset via email.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["email"],
              properties: {
                email: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerReserveSigningKey: {
      lexicon: 1,
      id: "com.atproto.server.reserveSigningKey",
      defs: {
        main: {
          type: "procedure",
          description: "Reserve a repo signing key, for use with account creation. Necessary so that a DID PLC update operation can be constructed during an account migraiton. Public and does not require auth; implemented by PDS. NOTE: this endpoint may change when full account migration is implemented.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID to reserve a key for."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["signingKey"],
              properties: {
                signingKey: {
                  type: "string",
                  description: "The public key for the reserved signing key, in did:key serialization."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerResetPassword: {
      lexicon: 1,
      id: "com.atproto.server.resetPassword",
      defs: {
        main: {
          type: "procedure",
          description: "Reset a user account password using a token.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["token", "password"],
              properties: {
                token: {
                  type: "string"
                },
                password: {
                  type: "string"
                }
              }
            }
          },
          errors: [
            {
              name: "ExpiredToken"
            },
            {
              name: "InvalidToken"
            }
          ]
        }
      }
    },
    ComAtprotoServerRevokeAppPassword: {
      lexicon: 1,
      id: "com.atproto.server.revokeAppPassword",
      defs: {
        main: {
          type: "procedure",
          description: "Revoke an App Password by name.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["name"],
              properties: {
                name: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerUpdateEmail: {
      lexicon: 1,
      id: "com.atproto.server.updateEmail",
      defs: {
        main: {
          type: "procedure",
          description: "Update an account's email.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["email"],
              properties: {
                email: {
                  type: "string"
                },
                emailAuthFactor: {
                  type: "boolean"
                },
                token: {
                  type: "string",
                  description: "Requires a token from com.atproto.sever.requestEmailUpdate if the account's email has been confirmed."
                }
              }
            }
          },
          errors: [
            {
              name: "ExpiredToken"
            },
            {
              name: "InvalidToken"
            },
            {
              name: "TokenRequired"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetBlob: {
      lexicon: 1,
      id: "com.atproto.sync.getBlob",
      defs: {
        main: {
          type: "query",
          description: "Get a blob associated with a given account. Returns the full blob as originally uploaded. Does not require auth; implemented by PDS.",
          parameters: {
            type: "params",
            required: ["did", "cid"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the account."
              },
              cid: {
                type: "string",
                format: "cid",
                description: "The CID of the blob to fetch"
              }
            }
          },
          output: {
            encoding: "*/*"
          },
          errors: [
            {
              name: "BlobNotFound"
            },
            {
              name: "RepoNotFound"
            },
            {
              name: "RepoTakendown"
            },
            {
              name: "RepoSuspended"
            },
            {
              name: "RepoDeactivated"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetBlocks: {
      lexicon: 1,
      id: "com.atproto.sync.getBlocks",
      defs: {
        main: {
          type: "query",
          description: "Get data blocks from a given repo, by CID. For example, intermediate MST nodes, or records. Does not require auth; implemented by PDS.",
          parameters: {
            type: "params",
            required: ["did", "cids"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              },
              cids: {
                type: "array",
                items: {
                  type: "string",
                  format: "cid"
                }
              }
            }
          },
          output: {
            encoding: "application/vnd.ipld.car"
          },
          errors: [
            {
              name: "BlockNotFound"
            },
            {
              name: "RepoNotFound"
            },
            {
              name: "RepoTakendown"
            },
            {
              name: "RepoSuspended"
            },
            {
              name: "RepoDeactivated"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetCheckout: {
      lexicon: 1,
      id: "com.atproto.sync.getCheckout",
      defs: {
        main: {
          type: "query",
          description: "DEPRECATED - please use com.atproto.sync.getRepo instead",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              }
            }
          },
          output: {
            encoding: "application/vnd.ipld.car"
          }
        }
      }
    },
    ComAtprotoSyncGetHead: {
      lexicon: 1,
      id: "com.atproto.sync.getHead",
      defs: {
        main: {
          type: "query",
          description: "DEPRECATED - please use com.atproto.sync.getLatestCommit instead",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["root"],
              properties: {
                root: {
                  type: "string",
                  format: "cid"
                }
              }
            }
          },
          errors: [
            {
              name: "HeadNotFound"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetLatestCommit: {
      lexicon: 1,
      id: "com.atproto.sync.getLatestCommit",
      defs: {
        main: {
          type: "query",
          description: "Get the current commit CID & revision of the specified repo. Does not require auth.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["cid", "rev"],
              properties: {
                cid: {
                  type: "string",
                  format: "cid"
                },
                rev: {
                  type: "string"
                }
              }
            }
          },
          errors: [
            {
              name: "RepoNotFound"
            },
            {
              name: "RepoTakendown"
            },
            {
              name: "RepoSuspended"
            },
            {
              name: "RepoDeactivated"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetRecord: {
      lexicon: 1,
      id: "com.atproto.sync.getRecord",
      defs: {
        main: {
          type: "query",
          description: "Get data blocks needed to prove the existence or non-existence of record in the current version of repo. Does not require auth.",
          parameters: {
            type: "params",
            required: ["did", "collection", "rkey"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              },
              collection: {
                type: "string",
                format: "nsid"
              },
              rkey: {
                type: "string",
                description: "Record Key"
              },
              commit: {
                type: "string",
                format: "cid",
                description: "DEPRECATED: referenced a repo commit by CID, and retrieved record as of that commit"
              }
            }
          },
          output: {
            encoding: "application/vnd.ipld.car"
          },
          errors: [
            {
              name: "RecordNotFound"
            },
            {
              name: "RepoNotFound"
            },
            {
              name: "RepoTakendown"
            },
            {
              name: "RepoSuspended"
            },
            {
              name: "RepoDeactivated"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetRepo: {
      lexicon: 1,
      id: "com.atproto.sync.getRepo",
      defs: {
        main: {
          type: "query",
          description: "Download a repository export as CAR file. Optionally only a 'diff' since a previous revision. Does not require auth; implemented by PDS.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              },
              since: {
                type: "string",
                description: "The revision ('rev') of the repo to create a diff from."
              }
            }
          },
          output: {
            encoding: "application/vnd.ipld.car"
          },
          errors: [
            {
              name: "RepoNotFound"
            },
            {
              name: "RepoTakendown"
            },
            {
              name: "RepoSuspended"
            },
            {
              name: "RepoDeactivated"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetRepoStatus: {
      lexicon: 1,
      id: "com.atproto.sync.getRepoStatus",
      defs: {
        main: {
          type: "query",
          description: "Get the hosting status for a repository, on this server. Expected to be implemented by PDS and Relay.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "active"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                active: {
                  type: "boolean"
                },
                status: {
                  type: "string",
                  description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
                  knownValues: ["takendown", "suspended", "deactivated"]
                },
                rev: {
                  type: "string",
                  description: "Optional field, the current rev of the repo, if active=true"
                }
              }
            }
          },
          errors: [
            {
              name: "RepoNotFound"
            }
          ]
        }
      }
    },
    ComAtprotoSyncListBlobs: {
      lexicon: 1,
      id: "com.atproto.sync.listBlobs",
      defs: {
        main: {
          type: "query",
          description: "List blob CIDs for an account, since some repo revision. Does not require auth; implemented by PDS.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              },
              since: {
                type: "string",
                description: "Optional revision of the repo to list blobs since."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 1e3,
                default: 500
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["cids"],
              properties: {
                cursor: {
                  type: "string"
                },
                cids: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "cid"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "RepoNotFound"
            },
            {
              name: "RepoTakendown"
            },
            {
              name: "RepoSuspended"
            },
            {
              name: "RepoDeactivated"
            }
          ]
        }
      }
    },
    ComAtprotoSyncListRepos: {
      lexicon: 1,
      id: "com.atproto.sync.listRepos",
      defs: {
        main: {
          type: "query",
          description: "Enumerates all the DID, rev, and commit CID for all repos hosted by this service. Does not require auth; implemented by PDS and Relay.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 1e3,
                default: 500
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repos"],
              properties: {
                cursor: {
                  type: "string"
                },
                repos: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.sync.listRepos#repo"
                  }
                }
              }
            }
          }
        },
        repo: {
          type: "object",
          required: ["did", "head", "rev"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            head: {
              type: "string",
              format: "cid",
              description: "Current repo commit CID"
            },
            rev: {
              type: "string"
            },
            active: {
              type: "boolean"
            },
            status: {
              type: "string",
              description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
              knownValues: ["takendown", "suspended", "deactivated"]
            }
          }
        }
      }
    },
    ComAtprotoSyncNotifyOfUpdate: {
      lexicon: 1,
      id: "com.atproto.sync.notifyOfUpdate",
      defs: {
        main: {
          type: "procedure",
          description: "Notify a crawling service of a recent update, and that crawling should resume. Intended use is after a gap between repo stream events caused the crawling service to disconnect. Does not require auth; implemented by Relay.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["hostname"],
              properties: {
                hostname: {
                  type: "string",
                  description: "Hostname of the current service (usually a PDS) that is notifying of update."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoSyncRequestCrawl: {
      lexicon: 1,
      id: "com.atproto.sync.requestCrawl",
      defs: {
        main: {
          type: "procedure",
          description: "Request a service to persistently crawl hosted repos. Expected use is new PDS instances declaring their existence to Relays. Does not require auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["hostname"],
              properties: {
                hostname: {
                  type: "string",
                  description: "Hostname of the current service (eg, PDS) that is requesting to be crawled."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoSyncSubscribeRepos: {
      lexicon: 1,
      id: "com.atproto.sync.subscribeRepos",
      defs: {
        main: {
          type: "subscription",
          description: "Repository event stream, aka Firehose endpoint. Outputs repo commits with diff data, and identity update events, for all repositories on the current server. See the atproto specifications for details around stream sequencing, repo versioning, CAR diff format, and more. Public and does not require auth; implemented by PDS and Relay.",
          parameters: {
            type: "params",
            properties: {
              cursor: {
                type: "integer",
                description: "The last known event seq number to backfill from."
              }
            }
          },
          message: {
            schema: {
              type: "union",
              refs: [
                "lex:com.atproto.sync.subscribeRepos#commit",
                "lex:com.atproto.sync.subscribeRepos#identity",
                "lex:com.atproto.sync.subscribeRepos#account",
                "lex:com.atproto.sync.subscribeRepos#handle",
                "lex:com.atproto.sync.subscribeRepos#migrate",
                "lex:com.atproto.sync.subscribeRepos#tombstone",
                "lex:com.atproto.sync.subscribeRepos#info"
              ]
            }
          },
          errors: [
            {
              name: "FutureCursor"
            },
            {
              name: "ConsumerTooSlow",
              description: "If the consumer of the stream can not keep up with events, and a backlog gets too large, the server will drop the connection."
            }
          ]
        },
        commit: {
          type: "object",
          description: "Represents an update of repository state. Note that empty commits are allowed, which include no repo data changes, but an update to rev and signature.",
          required: [
            "seq",
            "rebase",
            "tooBig",
            "repo",
            "commit",
            "rev",
            "since",
            "blocks",
            "ops",
            "blobs",
            "time"
          ],
          nullable: ["prev", "since"],
          properties: {
            seq: {
              type: "integer",
              description: "The stream sequence number of this message."
            },
            rebase: {
              type: "boolean",
              description: "DEPRECATED -- unused"
            },
            tooBig: {
              type: "boolean",
              description: "Indicates that this commit contained too many ops, or data size was too large. Consumers will need to make a separate request to get missing data."
            },
            repo: {
              type: "string",
              format: "did",
              description: "The repo this event comes from."
            },
            commit: {
              type: "cid-link",
              description: "Repo commit object CID."
            },
            prev: {
              type: "cid-link",
              description: "DEPRECATED -- unused. WARNING -- nullable and optional; stick with optional to ensure golang interoperability."
            },
            rev: {
              type: "string",
              description: "The rev of the emitted commit. Note that this information is also in the commit object included in blocks, unless this is a tooBig event."
            },
            since: {
              type: "string",
              description: "The rev of the last emitted commit from this repo (if any)."
            },
            blocks: {
              type: "bytes",
              description: "CAR file containing relevant blocks, as a diff since the previous repo state.",
              maxLength: 1e6
            },
            ops: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.sync.subscribeRepos#repoOp",
                description: "List of repo mutation operations in this commit (eg, records created, updated, or deleted)."
              },
              maxLength: 200
            },
            blobs: {
              type: "array",
              items: {
                type: "cid-link",
                description: "List of new blobs (by CID) referenced by records in this commit."
              }
            },
            time: {
              type: "string",
              format: "datetime",
              description: "Timestamp of when this message was originally broadcast."
            }
          }
        },
        identity: {
          type: "object",
          description: "Represents a change to an account's identity. Could be an updated handle, signing key, or pds hosting endpoint. Serves as a prod to all downstream services to refresh their identity cache.",
          required: ["seq", "did", "time"],
          properties: {
            seq: {
              type: "integer"
            },
            did: {
              type: "string",
              format: "did"
            },
            time: {
              type: "string",
              format: "datetime"
            },
            handle: {
              type: "string",
              format: "handle",
              description: "The current handle for the account, or 'handle.invalid' if validation fails. This field is optional, might have been validated or passed-through from an upstream source. Semantics and behaviors for PDS vs Relay may evolve in the future; see atproto specs for more details."
            }
          }
        },
        account: {
          type: "object",
          description: "Represents a change to an account's status on a host (eg, PDS or Relay). The semantics of this event are that the status is at the host which emitted the event, not necessarily that at the currently active PDS. Eg, a Relay takedown would emit a takedown with active=false, even if the PDS is still active.",
          required: ["seq", "did", "time", "active"],
          properties: {
            seq: {
              type: "integer"
            },
            did: {
              type: "string",
              format: "did"
            },
            time: {
              type: "string",
              format: "datetime"
            },
            active: {
              type: "boolean",
              description: "Indicates that the account has a repository which can be fetched from the host that emitted this event."
            },
            status: {
              type: "string",
              description: "If active=false, this optional field indicates a reason for why the account is not active.",
              knownValues: ["takendown", "suspended", "deleted", "deactivated"]
            }
          }
        },
        handle: {
          type: "object",
          description: "DEPRECATED -- Use #identity event instead",
          required: ["seq", "did", "handle", "time"],
          properties: {
            seq: {
              type: "integer"
            },
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            time: {
              type: "string",
              format: "datetime"
            }
          }
        },
        migrate: {
          type: "object",
          description: "DEPRECATED -- Use #account event instead",
          required: ["seq", "did", "migrateTo", "time"],
          nullable: ["migrateTo"],
          properties: {
            seq: {
              type: "integer"
            },
            did: {
              type: "string",
              format: "did"
            },
            migrateTo: {
              type: "string"
            },
            time: {
              type: "string",
              format: "datetime"
            }
          }
        },
        tombstone: {
          type: "object",
          description: "DEPRECATED -- Use #account event instead",
          required: ["seq", "did", "time"],
          properties: {
            seq: {
              type: "integer"
            },
            did: {
              type: "string",
              format: "did"
            },
            time: {
              type: "string",
              format: "datetime"
            }
          }
        },
        info: {
          type: "object",
          required: ["name"],
          properties: {
            name: {
              type: "string",
              knownValues: ["OutdatedCursor"]
            },
            message: {
              type: "string"
            }
          }
        },
        repoOp: {
          type: "object",
          description: "A repo operation, ie a mutation of a single record.",
          required: ["action", "path", "cid"],
          nullable: ["cid"],
          properties: {
            action: {
              type: "string",
              knownValues: ["create", "update", "delete"]
            },
            path: {
              type: "string"
            },
            cid: {
              type: "cid-link",
              description: "For creates and updates, the new record CID. For deletions, null."
            }
          }
        }
      }
    },
    ComAtprotoTempCheckSignupQueue: {
      lexicon: 1,
      id: "com.atproto.temp.checkSignupQueue",
      defs: {
        main: {
          type: "query",
          description: "Check accounts location in signup queue.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["activated"],
              properties: {
                activated: {
                  type: "boolean"
                },
                placeInQueue: {
                  type: "integer"
                },
                estimatedTimeMs: {
                  type: "integer"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoTempFetchLabels: {
      lexicon: 1,
      id: "com.atproto.temp.fetchLabels",
      defs: {
        main: {
          type: "query",
          description: "DEPRECATED: use queryLabels or subscribeLabels instead -- Fetch all labels from a labeler created after a certain date.",
          parameters: {
            type: "params",
            properties: {
              since: {
                type: "integer"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 250,
                default: 50
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["labels"],
              properties: {
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoTempRequestPhoneVerification: {
      lexicon: 1,
      id: "com.atproto.temp.requestPhoneVerification",
      defs: {
        main: {
          type: "procedure",
          description: "Request a verification code to be sent to the supplied phone number",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["phoneNumber"],
              properties: {
                phoneNumber: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorDefs: {
      lexicon: 1,
      id: "app.bsky.actor.defs",
      defs: {
        profileViewBasic: {
          type: "object",
          required: ["did", "handle"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            displayName: {
              type: "string",
              maxGraphemes: 64,
              maxLength: 640
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            associated: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileAssociated"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#viewerState"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            createdAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        profileView: {
          type: "object",
          required: ["did", "handle"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            displayName: {
              type: "string",
              maxGraphemes: 64,
              maxLength: 640
            },
            description: {
              type: "string",
              maxGraphemes: 256,
              maxLength: 2560
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            associated: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileAssociated"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#viewerState"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        profileViewDetailed: {
          type: "object",
          required: ["did", "handle"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            displayName: {
              type: "string",
              maxGraphemes: 64,
              maxLength: 640
            },
            description: {
              type: "string",
              maxGraphemes: 256,
              maxLength: 2560
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            banner: {
              type: "string",
              format: "uri"
            },
            followersCount: {
              type: "integer"
            },
            followsCount: {
              type: "integer"
            },
            postsCount: {
              type: "integer"
            },
            associated: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileAssociated"
            },
            joinedViaStarterPack: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#starterPackViewBasic"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#viewerState"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        profileAssociated: {
          type: "object",
          properties: {
            lists: {
              type: "integer"
            },
            feedgens: {
              type: "integer"
            },
            starterPacks: {
              type: "integer"
            },
            labeler: {
              type: "boolean"
            },
            chat: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileAssociatedChat"
            }
          }
        },
        profileAssociatedChat: {
          type: "object",
          required: ["allowIncoming"],
          properties: {
            allowIncoming: {
              type: "string",
              knownValues: ["all", "none", "following"]
            }
          }
        },
        viewerState: {
          type: "object",
          description: "Metadata about the requesting account's relationship with the subject account. Only has meaningful content for authed requests.",
          properties: {
            muted: {
              type: "boolean"
            },
            mutedByList: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listViewBasic"
            },
            blockedBy: {
              type: "boolean"
            },
            blocking: {
              type: "string",
              format: "at-uri"
            },
            blockingByList: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listViewBasic"
            },
            following: {
              type: "string",
              format: "at-uri"
            },
            followedBy: {
              type: "string",
              format: "at-uri"
            },
            knownFollowers: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#knownFollowers"
            }
          }
        },
        knownFollowers: {
          type: "object",
          description: "The subject's followers whom you also follow",
          required: ["count", "followers"],
          properties: {
            count: {
              type: "integer"
            },
            followers: {
              type: "array",
              minLength: 0,
              maxLength: 5,
              items: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileViewBasic"
              }
            }
          }
        },
        preferences: {
          type: "array",
          items: {
            type: "union",
            refs: [
              "lex:app.bsky.actor.defs#adultContentPref",
              "lex:app.bsky.actor.defs#contentLabelPref",
              "lex:app.bsky.actor.defs#savedFeedsPref",
              "lex:app.bsky.actor.defs#savedFeedsPrefV2",
              "lex:app.bsky.actor.defs#personalDetailsPref",
              "lex:app.bsky.actor.defs#feedViewPref",
              "lex:app.bsky.actor.defs#threadViewPref",
              "lex:app.bsky.actor.defs#interestsPref",
              "lex:app.bsky.actor.defs#mutedWordsPref",
              "lex:app.bsky.actor.defs#hiddenPostsPref",
              "lex:app.bsky.actor.defs#bskyAppStatePref",
              "lex:app.bsky.actor.defs#labelersPref"
            ]
          }
        },
        adultContentPref: {
          type: "object",
          required: ["enabled"],
          properties: {
            enabled: {
              type: "boolean",
              default: !1
            }
          }
        },
        contentLabelPref: {
          type: "object",
          required: ["label", "visibility"],
          properties: {
            labelerDid: {
              type: "string",
              description: "Which labeler does this preference apply to? If undefined, applies globally.",
              format: "did"
            },
            label: {
              type: "string"
            },
            visibility: {
              type: "string",
              knownValues: ["ignore", "show", "warn", "hide"]
            }
          }
        },
        savedFeed: {
          type: "object",
          required: ["id", "type", "value", "pinned"],
          properties: {
            id: {
              type: "string"
            },
            type: {
              type: "string",
              knownValues: ["feed", "list", "timeline"]
            },
            value: {
              type: "string"
            },
            pinned: {
              type: "boolean"
            }
          }
        },
        savedFeedsPrefV2: {
          type: "object",
          required: ["items"],
          properties: {
            items: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#savedFeed"
              }
            }
          }
        },
        savedFeedsPref: {
          type: "object",
          required: ["pinned", "saved"],
          properties: {
            pinned: {
              type: "array",
              items: {
                type: "string",
                format: "at-uri"
              }
            },
            saved: {
              type: "array",
              items: {
                type: "string",
                format: "at-uri"
              }
            },
            timelineIndex: {
              type: "integer"
            }
          }
        },
        personalDetailsPref: {
          type: "object",
          properties: {
            birthDate: {
              type: "string",
              format: "datetime",
              description: "The birth date of account owner."
            }
          }
        },
        feedViewPref: {
          type: "object",
          required: ["feed"],
          properties: {
            feed: {
              type: "string",
              description: "The URI of the feed, or an identifier which describes the feed."
            },
            hideReplies: {
              type: "boolean",
              description: "Hide replies in the feed."
            },
            hideRepliesByUnfollowed: {
              type: "boolean",
              description: "Hide replies in the feed if they are not by followed users.",
              default: !0
            },
            hideRepliesByLikeCount: {
              type: "integer",
              description: "Hide replies in the feed if they do not have this number of likes."
            },
            hideReposts: {
              type: "boolean",
              description: "Hide reposts in the feed."
            },
            hideQuotePosts: {
              type: "boolean",
              description: "Hide quote posts in the feed."
            }
          }
        },
        threadViewPref: {
          type: "object",
          properties: {
            sort: {
              type: "string",
              description: "Sorting mode for threads.",
              knownValues: ["oldest", "newest", "most-likes", "random"]
            },
            prioritizeFollowedUsers: {
              type: "boolean",
              description: "Show followed users at the top of all replies."
            }
          }
        },
        interestsPref: {
          type: "object",
          required: ["tags"],
          properties: {
            tags: {
              type: "array",
              maxLength: 100,
              items: {
                type: "string",
                maxLength: 640,
                maxGraphemes: 64
              },
              description: "A list of tags which describe the account owner's interests gathered during onboarding."
            }
          }
        },
        mutedWordTarget: {
          type: "string",
          knownValues: ["content", "tag"],
          maxLength: 640,
          maxGraphemes: 64
        },
        mutedWord: {
          type: "object",
          description: "A word that the account owner has muted.",
          required: ["value", "targets"],
          properties: {
            id: {
              type: "string"
            },
            value: {
              type: "string",
              description: "The muted word itself.",
              maxLength: 1e4,
              maxGraphemes: 1e3
            },
            targets: {
              type: "array",
              description: "The intended targets of the muted word.",
              items: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#mutedWordTarget"
              }
            },
            actorTarget: {
              type: "string",
              description: "Groups of users to apply the muted word to. If undefined, applies to all users.",
              knownValues: ["all", "exclude-following"],
              default: "all"
            },
            expiresAt: {
              type: "string",
              format: "datetime",
              description: "The date and time at which the muted word will expire and no longer be applied."
            }
          }
        },
        mutedWordsPref: {
          type: "object",
          required: ["items"],
          properties: {
            items: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#mutedWord"
              },
              description: "A list of words the account owner has muted."
            }
          }
        },
        hiddenPostsPref: {
          type: "object",
          required: ["items"],
          properties: {
            items: {
              type: "array",
              items: {
                type: "string",
                format: "at-uri"
              },
              description: "A list of URIs of posts the account owner has hidden."
            }
          }
        },
        labelersPref: {
          type: "object",
          required: ["labelers"],
          properties: {
            labelers: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#labelerPrefItem"
              }
            }
          }
        },
        labelerPrefItem: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        },
        bskyAppStatePref: {
          description: "A grab bag of state that's specific to the bsky.app program. Third-party apps shouldn't use this.",
          type: "object",
          properties: {
            activeProgressGuide: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#bskyAppProgressGuide"
            },
            queuedNudges: {
              description: "An array of tokens which identify nudges (modals, popups, tours, highlight dots) that should be shown to the user.",
              type: "array",
              maxLength: 1e3,
              items: {
                type: "string",
                maxLength: 100
              }
            }
          }
        },
        bskyAppProgressGuide: {
          description: "If set, an active progress guide. Once completed, can be set to undefined. Should have unspecced fields tracking progress.",
          type: "object",
          required: ["guide"],
          properties: {
            guide: {
              type: "string",
              maxLength: 100
            }
          }
        }
      }
    },
    AppBskyActorGetPreferences: {
      lexicon: 1,
      id: "app.bsky.actor.getPreferences",
      defs: {
        main: {
          type: "query",
          description: "Get private preferences attached to the current account. Expected use is synchronization between multiple devices, and import/export during account migration. Requires auth.",
          parameters: {
            type: "params",
            properties: {}
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["preferences"],
              properties: {
                preferences: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#preferences"
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorGetProfile: {
      lexicon: 1,
      id: "app.bsky.actor.getProfile",
      defs: {
        main: {
          type: "query",
          description: "Get detailed profile view of an actor. Does not require auth, but contains relevant metadata with auth.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier",
                description: "Handle or DID of account to fetch profile of."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewDetailed"
            }
          }
        }
      }
    },
    AppBskyActorGetProfiles: {
      lexicon: 1,
      id: "app.bsky.actor.getProfiles",
      defs: {
        main: {
          type: "query",
          description: "Get detailed profile views of multiple actors.",
          parameters: {
            type: "params",
            required: ["actors"],
            properties: {
              actors: {
                type: "array",
                items: {
                  type: "string",
                  format: "at-identifier"
                },
                maxLength: 25
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["profiles"],
              properties: {
                profiles: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileViewDetailed"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorGetSuggestions: {
      lexicon: 1,
      id: "app.bsky.actor.getSuggestions",
      defs: {
        main: {
          type: "query",
          description: "Get a list of suggested actors. Expected use is discovery of accounts to follow during new account onboarding.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actors"],
              properties: {
                cursor: {
                  type: "string"
                },
                actors: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorProfile: {
      lexicon: 1,
      id: "app.bsky.actor.profile",
      defs: {
        main: {
          type: "record",
          description: "A declaration of a Bluesky account profile.",
          key: "literal:self",
          record: {
            type: "object",
            properties: {
              displayName: {
                type: "string",
                maxGraphemes: 64,
                maxLength: 640
              },
              description: {
                type: "string",
                description: "Free-form profile description text.",
                maxGraphemes: 256,
                maxLength: 2560
              },
              avatar: {
                type: "blob",
                description: "Small image to be displayed next to posts from account. AKA, 'profile picture'",
                accept: ["image/png", "image/jpeg"],
                maxSize: 1e6
              },
              banner: {
                type: "blob",
                description: "Larger horizontal image to display behind profile view.",
                accept: ["image/png", "image/jpeg"],
                maxSize: 1e6
              },
              labels: {
                type: "union",
                description: "Self-label values, specific to the Bluesky application, on the overall account.",
                refs: ["lex:com.atproto.label.defs#selfLabels"]
              },
              joinedViaStarterPack: {
                type: "ref",
                ref: "lex:com.atproto.repo.strongRef"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyActorPutPreferences: {
      lexicon: 1,
      id: "app.bsky.actor.putPreferences",
      defs: {
        main: {
          type: "procedure",
          description: "Set the private preferences attached to the account.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["preferences"],
              properties: {
                preferences: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#preferences"
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorSearchActors: {
      lexicon: 1,
      id: "app.bsky.actor.searchActors",
      defs: {
        main: {
          type: "query",
          description: "Find actors (profiles) matching search criteria. Does not require auth.",
          parameters: {
            type: "params",
            properties: {
              term: {
                type: "string",
                description: "DEPRECATED: use 'q' instead."
              },
              q: {
                type: "string",
                description: "Search query string. Syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 25
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actors"],
              properties: {
                cursor: {
                  type: "string"
                },
                actors: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorSearchActorsTypeahead: {
      lexicon: 1,
      id: "app.bsky.actor.searchActorsTypeahead",
      defs: {
        main: {
          type: "query",
          description: "Find actor suggestions for a prefix search term. Expected use is for auto-completion during text field entry. Does not require auth.",
          parameters: {
            type: "params",
            properties: {
              term: {
                type: "string",
                description: "DEPRECATED: use 'q' instead."
              },
              q: {
                type: "string",
                description: "Search query prefix; not a full query string."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 10
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actors"],
              properties: {
                actors: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileViewBasic"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyEmbedExternal: {
      lexicon: 1,
      id: "app.bsky.embed.external",
      defs: {
        main: {
          type: "object",
          description: "A representation of some externally linked content (eg, a URL and 'card'), embedded in a Bluesky record (eg, a post).",
          required: ["external"],
          properties: {
            external: {
              type: "ref",
              ref: "lex:app.bsky.embed.external#external"
            }
          }
        },
        external: {
          type: "object",
          required: ["uri", "title", "description"],
          properties: {
            uri: {
              type: "string",
              format: "uri"
            },
            title: {
              type: "string"
            },
            description: {
              type: "string"
            },
            thumb: {
              type: "blob",
              accept: ["image/*"],
              maxSize: 1e6
            }
          }
        },
        view: {
          type: "object",
          required: ["external"],
          properties: {
            external: {
              type: "ref",
              ref: "lex:app.bsky.embed.external#viewExternal"
            }
          }
        },
        viewExternal: {
          type: "object",
          required: ["uri", "title", "description"],
          properties: {
            uri: {
              type: "string",
              format: "uri"
            },
            title: {
              type: "string"
            },
            description: {
              type: "string"
            },
            thumb: {
              type: "string",
              format: "uri"
            }
          }
        }
      }
    },
    AppBskyEmbedImages: {
      lexicon: 1,
      id: "app.bsky.embed.images",
      description: "A set of images embedded in a Bluesky record (eg, a post).",
      defs: {
        main: {
          type: "object",
          required: ["images"],
          properties: {
            images: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.embed.images#image"
              },
              maxLength: 4
            }
          }
        },
        image: {
          type: "object",
          required: ["image", "alt"],
          properties: {
            image: {
              type: "blob",
              accept: ["image/*"],
              maxSize: 1e6
            },
            alt: {
              type: "string",
              description: "Alt text description of the image, for accessibility."
            },
            aspectRatio: {
              type: "ref",
              ref: "lex:app.bsky.embed.images#aspectRatio"
            }
          }
        },
        aspectRatio: {
          type: "object",
          description: "width:height represents an aspect ratio. It may be approximate, and may not correspond to absolute dimensions in any given unit.",
          required: ["width", "height"],
          properties: {
            width: {
              type: "integer",
              minimum: 1
            },
            height: {
              type: "integer",
              minimum: 1
            }
          }
        },
        view: {
          type: "object",
          required: ["images"],
          properties: {
            images: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.embed.images#viewImage"
              },
              maxLength: 4
            }
          }
        },
        viewImage: {
          type: "object",
          required: ["thumb", "fullsize", "alt"],
          properties: {
            thumb: {
              type: "string",
              format: "uri",
              description: "Fully-qualified URL where a thumbnail of the image can be fetched. For example, CDN location provided by the App View."
            },
            fullsize: {
              type: "string",
              format: "uri",
              description: "Fully-qualified URL where a large version of the image can be fetched. May or may not be the exact original blob. For example, CDN location provided by the App View."
            },
            alt: {
              type: "string",
              description: "Alt text description of the image, for accessibility."
            },
            aspectRatio: {
              type: "ref",
              ref: "lex:app.bsky.embed.images#aspectRatio"
            }
          }
        }
      }
    },
    AppBskyEmbedRecord: {
      lexicon: 1,
      id: "app.bsky.embed.record",
      description: "A representation of a record embedded in a Bluesky record (eg, a post). For example, a quote-post, or sharing a feed generator record.",
      defs: {
        main: {
          type: "object",
          required: ["record"],
          properties: {
            record: {
              type: "ref",
              ref: "lex:com.atproto.repo.strongRef"
            }
          }
        },
        view: {
          type: "object",
          required: ["record"],
          properties: {
            record: {
              type: "union",
              refs: [
                "lex:app.bsky.embed.record#viewRecord",
                "lex:app.bsky.embed.record#viewNotFound",
                "lex:app.bsky.embed.record#viewBlocked",
                "lex:app.bsky.feed.defs#generatorView",
                "lex:app.bsky.graph.defs#listView",
                "lex:app.bsky.labeler.defs#labelerView",
                "lex:app.bsky.graph.defs#starterPackViewBasic"
              ]
            }
          }
        },
        viewRecord: {
          type: "object",
          required: ["uri", "cid", "author", "value", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            author: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic"
            },
            value: {
              type: "unknown",
              description: "The record data itself."
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            replyCount: {
              type: "integer"
            },
            repostCount: {
              type: "integer"
            },
            likeCount: {
              type: "integer"
            },
            embeds: {
              type: "array",
              items: {
                type: "union",
                refs: [
                  "lex:app.bsky.embed.images#view",
                  "lex:app.bsky.embed.external#view",
                  "lex:app.bsky.embed.record#view",
                  "lex:app.bsky.embed.recordWithMedia#view"
                ]
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        viewNotFound: {
          type: "object",
          required: ["uri", "notFound"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            notFound: {
              type: "boolean",
              const: !0
            }
          }
        },
        viewBlocked: {
          type: "object",
          required: ["uri", "blocked", "author"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            blocked: {
              type: "boolean",
              const: !0
            },
            author: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#blockedAuthor"
            }
          }
        }
      }
    },
    AppBskyEmbedRecordWithMedia: {
      lexicon: 1,
      id: "app.bsky.embed.recordWithMedia",
      description: "A representation of a record embedded in a Bluesky record (eg, a post), alongside other compatible embeds. For example, a quote post and image, or a quote post and external URL card.",
      defs: {
        main: {
          type: "object",
          required: ["record", "media"],
          properties: {
            record: {
              type: "ref",
              ref: "lex:app.bsky.embed.record"
            },
            media: {
              type: "union",
              refs: ["lex:app.bsky.embed.images", "lex:app.bsky.embed.external"]
            }
          }
        },
        view: {
          type: "object",
          required: ["record", "media"],
          properties: {
            record: {
              type: "ref",
              ref: "lex:app.bsky.embed.record#view"
            },
            media: {
              type: "union",
              refs: [
                "lex:app.bsky.embed.images#view",
                "lex:app.bsky.embed.external#view"
              ]
            }
          }
        }
      }
    },
    AppBskyFeedDefs: {
      lexicon: 1,
      id: "app.bsky.feed.defs",
      defs: {
        postView: {
          type: "object",
          required: ["uri", "cid", "author", "record", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            author: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic"
            },
            record: {
              type: "unknown"
            },
            embed: {
              type: "union",
              refs: [
                "lex:app.bsky.embed.images#view",
                "lex:app.bsky.embed.external#view",
                "lex:app.bsky.embed.record#view",
                "lex:app.bsky.embed.recordWithMedia#view"
              ]
            },
            replyCount: {
              type: "integer"
            },
            repostCount: {
              type: "integer"
            },
            likeCount: {
              type: "integer"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#viewerState"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            threadgate: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#threadgateView"
            }
          }
        },
        viewerState: {
          type: "object",
          description: "Metadata about the requesting account's relationship with the subject content. Only has meaningful content for authed requests.",
          properties: {
            repost: {
              type: "string",
              format: "at-uri"
            },
            like: {
              type: "string",
              format: "at-uri"
            },
            threadMuted: {
              type: "boolean"
            },
            replyDisabled: {
              type: "boolean"
            }
          }
        },
        feedViewPost: {
          type: "object",
          required: ["post"],
          properties: {
            post: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#postView"
            },
            reply: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#replyRef"
            },
            reason: {
              type: "union",
              refs: ["lex:app.bsky.feed.defs#reasonRepost"]
            },
            feedContext: {
              type: "string",
              description: "Context provided by feed generator that may be passed back alongside interactions.",
              maxLength: 2e3
            }
          }
        },
        replyRef: {
          type: "object",
          required: ["root", "parent"],
          properties: {
            root: {
              type: "union",
              refs: [
                "lex:app.bsky.feed.defs#postView",
                "lex:app.bsky.feed.defs#notFoundPost",
                "lex:app.bsky.feed.defs#blockedPost"
              ]
            },
            parent: {
              type: "union",
              refs: [
                "lex:app.bsky.feed.defs#postView",
                "lex:app.bsky.feed.defs#notFoundPost",
                "lex:app.bsky.feed.defs#blockedPost"
              ]
            },
            grandparentAuthor: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic",
              description: "When parent is a reply to another post, this is the author of that post."
            }
          }
        },
        reasonRepost: {
          type: "object",
          required: ["by", "indexedAt"],
          properties: {
            by: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        threadViewPost: {
          type: "object",
          required: ["post"],
          properties: {
            post: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#postView"
            },
            parent: {
              type: "union",
              refs: [
                "lex:app.bsky.feed.defs#threadViewPost",
                "lex:app.bsky.feed.defs#notFoundPost",
                "lex:app.bsky.feed.defs#blockedPost"
              ]
            },
            replies: {
              type: "array",
              items: {
                type: "union",
                refs: [
                  "lex:app.bsky.feed.defs#threadViewPost",
                  "lex:app.bsky.feed.defs#notFoundPost",
                  "lex:app.bsky.feed.defs#blockedPost"
                ]
              }
            }
          }
        },
        notFoundPost: {
          type: "object",
          required: ["uri", "notFound"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            notFound: {
              type: "boolean",
              const: !0
            }
          }
        },
        blockedPost: {
          type: "object",
          required: ["uri", "blocked", "author"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            blocked: {
              type: "boolean",
              const: !0
            },
            author: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#blockedAuthor"
            }
          }
        },
        blockedAuthor: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#viewerState"
            }
          }
        },
        generatorView: {
          type: "object",
          required: ["uri", "cid", "did", "creator", "displayName", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            did: {
              type: "string",
              format: "did"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            },
            displayName: {
              type: "string"
            },
            description: {
              type: "string",
              maxGraphemes: 300,
              maxLength: 3e3
            },
            descriptionFacets: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.richtext.facet"
              }
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            likeCount: {
              type: "integer",
              minimum: 0
            },
            acceptsInteractions: {
              type: "boolean"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#generatorViewerState"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        generatorViewerState: {
          type: "object",
          properties: {
            like: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        skeletonFeedPost: {
          type: "object",
          required: ["post"],
          properties: {
            post: {
              type: "string",
              format: "at-uri"
            },
            reason: {
              type: "union",
              refs: ["lex:app.bsky.feed.defs#skeletonReasonRepost"]
            },
            feedContext: {
              type: "string",
              description: "Context that will be passed through to client and may be passed to feed generator back alongside interactions.",
              maxLength: 2e3
            }
          }
        },
        skeletonReasonRepost: {
          type: "object",
          required: ["repost"],
          properties: {
            repost: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        threadgateView: {
          type: "object",
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            record: {
              type: "unknown"
            },
            lists: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.graph.defs#listViewBasic"
              }
            }
          }
        },
        interaction: {
          type: "object",
          properties: {
            item: {
              type: "string",
              format: "at-uri"
            },
            event: {
              type: "string",
              knownValues: [
                "app.bsky.feed.defs#requestLess",
                "app.bsky.feed.defs#requestMore",
                "app.bsky.feed.defs#clickthroughItem",
                "app.bsky.feed.defs#clickthroughAuthor",
                "app.bsky.feed.defs#clickthroughReposter",
                "app.bsky.feed.defs#clickthroughEmbed",
                "app.bsky.feed.defs#interactionSeen",
                "app.bsky.feed.defs#interactionLike",
                "app.bsky.feed.defs#interactionRepost",
                "app.bsky.feed.defs#interactionReply",
                "app.bsky.feed.defs#interactionQuote",
                "app.bsky.feed.defs#interactionShare"
              ]
            },
            feedContext: {
              type: "string",
              description: "Context on a feed item that was originally supplied by the feed generator on getFeedSkeleton.",
              maxLength: 2e3
            }
          }
        },
        requestLess: {
          type: "token",
          description: "Request that less content like the given feed item be shown in the feed"
        },
        requestMore: {
          type: "token",
          description: "Request that more content like the given feed item be shown in the feed"
        },
        clickthroughItem: {
          type: "token",
          description: "User clicked through to the feed item"
        },
        clickthroughAuthor: {
          type: "token",
          description: "User clicked through to the author of the feed item"
        },
        clickthroughReposter: {
          type: "token",
          description: "User clicked through to the reposter of the feed item"
        },
        clickthroughEmbed: {
          type: "token",
          description: "User clicked through to the embedded content of the feed item"
        },
        interactionSeen: {
          type: "token",
          description: "Feed item was seen by user"
        },
        interactionLike: {
          type: "token",
          description: "User liked the feed item"
        },
        interactionRepost: {
          type: "token",
          description: "User reposted the feed item"
        },
        interactionReply: {
          type: "token",
          description: "User replied to the feed item"
        },
        interactionQuote: {
          type: "token",
          description: "User quoted the feed item"
        },
        interactionShare: {
          type: "token",
          description: "User shared the feed item"
        }
      }
    },
    AppBskyFeedDescribeFeedGenerator: {
      lexicon: 1,
      id: "app.bsky.feed.describeFeedGenerator",
      defs: {
        main: {
          type: "query",
          description: "Get information about a feed generator, including policies and offered feed URIs. Does not require auth; implemented by Feed Generator services (not App View).",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "feeds"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                feeds: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.describeFeedGenerator#feed"
                  }
                },
                links: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.describeFeedGenerator#links"
                }
              }
            }
          }
        },
        feed: {
          type: "object",
          required: ["uri"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        links: {
          type: "object",
          properties: {
            privacyPolicy: {
              type: "string"
            },
            termsOfService: {
              type: "string"
            }
          }
        }
      }
    },
    AppBskyFeedGenerator: {
      lexicon: 1,
      id: "app.bsky.feed.generator",
      defs: {
        main: {
          type: "record",
          description: "Record declaring of the existence of a feed generator, and containing metadata about it. The record can exist in any repository.",
          key: "any",
          record: {
            type: "object",
            required: ["did", "displayName", "createdAt"],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              displayName: {
                type: "string",
                maxGraphemes: 24,
                maxLength: 240
              },
              description: {
                type: "string",
                maxGraphemes: 300,
                maxLength: 3e3
              },
              descriptionFacets: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet"
                }
              },
              avatar: {
                type: "blob",
                accept: ["image/png", "image/jpeg"],
                maxSize: 1e6
              },
              acceptsInteractions: {
                type: "boolean",
                description: "Declaration that a feed accepts feedback interactions from a client through app.bsky.feed.sendInteractions"
              },
              labels: {
                type: "union",
                description: "Self-label values",
                refs: ["lex:com.atproto.label.defs#selfLabels"]
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetActorFeeds: {
      lexicon: 1,
      id: "app.bsky.feed.getActorFeeds",
      defs: {
        main: {
          type: "query",
          description: "Get a list of feeds (feed generator records) created by the actor (in the actor's repo).",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feeds"],
              properties: {
                cursor: {
                  type: "string"
                },
                feeds: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#generatorView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetActorLikes: {
      lexicon: 1,
      id: "app.bsky.feed.getActorLikes",
      defs: {
        main: {
          type: "query",
          description: "Get a list of posts liked by an actor. Does not require auth.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#feedViewPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "BlockedActor"
            },
            {
              name: "BlockedByActor"
            }
          ]
        }
      }
    },
    AppBskyFeedGetAuthorFeed: {
      lexicon: 1,
      id: "app.bsky.feed.getAuthorFeed",
      defs: {
        main: {
          type: "query",
          description: "Get a view of an actor's 'author feed' (post and reposts by the author). Does not require auth.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              },
              filter: {
                type: "string",
                description: "Combinations of post/repost types to include in response.",
                knownValues: [
                  "posts_with_replies",
                  "posts_no_replies",
                  "posts_with_media",
                  "posts_and_author_threads"
                ],
                default: "posts_with_replies"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#feedViewPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "BlockedActor"
            },
            {
              name: "BlockedByActor"
            }
          ]
        }
      }
    },
    AppBskyFeedGetFeed: {
      lexicon: 1,
      id: "app.bsky.feed.getFeed",
      defs: {
        main: {
          type: "query",
          description: "Get a hydrated feed from an actor's selected feed generator. Implemented by App View.",
          parameters: {
            type: "params",
            required: ["feed"],
            properties: {
              feed: {
                type: "string",
                format: "at-uri"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#feedViewPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "UnknownFeed"
            }
          ]
        }
      }
    },
    AppBskyFeedGetFeedGenerator: {
      lexicon: 1,
      id: "app.bsky.feed.getFeedGenerator",
      defs: {
        main: {
          type: "query",
          description: "Get information about a feed generator. Implemented by AppView.",
          parameters: {
            type: "params",
            required: ["feed"],
            properties: {
              feed: {
                type: "string",
                format: "at-uri",
                description: "AT-URI of the feed generator record."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["view", "isOnline", "isValid"],
              properties: {
                view: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#generatorView"
                },
                isOnline: {
                  type: "boolean",
                  description: "Indicates whether the feed generator service has been online recently, or else seems to be inactive."
                },
                isValid: {
                  type: "boolean",
                  description: "Indicates whether the feed generator service is compatible with the record declaration."
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetFeedGenerators: {
      lexicon: 1,
      id: "app.bsky.feed.getFeedGenerators",
      defs: {
        main: {
          type: "query",
          description: "Get information about a list of feed generators.",
          parameters: {
            type: "params",
            required: ["feeds"],
            properties: {
              feeds: {
                type: "array",
                items: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feeds"],
              properties: {
                feeds: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#generatorView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetFeedSkeleton: {
      lexicon: 1,
      id: "app.bsky.feed.getFeedSkeleton",
      defs: {
        main: {
          type: "query",
          description: "Get a skeleton of a feed provided by a feed generator. Auth is optional, depending on provider requirements, and provides the DID of the requester. Implemented by Feed Generator Service.",
          parameters: {
            type: "params",
            required: ["feed"],
            properties: {
              feed: {
                type: "string",
                format: "at-uri",
                description: "Reference to feed generator record describing the specific feed being requested."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#skeletonFeedPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "UnknownFeed"
            }
          ]
        }
      }
    },
    AppBskyFeedGetLikes: {
      lexicon: 1,
      id: "app.bsky.feed.getLikes",
      defs: {
        main: {
          type: "query",
          description: "Get like records which reference a subject (by AT-URI and CID).",
          parameters: {
            type: "params",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri",
                description: "AT-URI of the subject (eg, a post record)."
              },
              cid: {
                type: "string",
                format: "cid",
                description: "CID of the subject record (aka, specific version of record), to filter likes."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["uri", "likes"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                cursor: {
                  type: "string"
                },
                likes: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.getLikes#like"
                  }
                }
              }
            }
          }
        },
        like: {
          type: "object",
          required: ["indexedAt", "createdAt", "actor"],
          properties: {
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            actor: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            }
          }
        }
      }
    },
    AppBskyFeedGetListFeed: {
      lexicon: 1,
      id: "app.bsky.feed.getListFeed",
      defs: {
        main: {
          type: "query",
          description: "Get a feed of recent posts from a list (posts and reposts from any actors on the list). Does not require auth.",
          parameters: {
            type: "params",
            required: ["list"],
            properties: {
              list: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to the list record."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#feedViewPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "UnknownList"
            }
          ]
        }
      }
    },
    AppBskyFeedGetPostThread: {
      lexicon: 1,
      id: "app.bsky.feed.getPostThread",
      defs: {
        main: {
          type: "query",
          description: "Get posts in a thread. Does not require auth, but additional metadata and filtering will be applied for authed requests.",
          parameters: {
            type: "params",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to post record."
              },
              depth: {
                type: "integer",
                description: "How many levels of reply depth should be included in response.",
                default: 6,
                minimum: 0,
                maximum: 1e3
              },
              parentHeight: {
                type: "integer",
                description: "How many levels of parent (and grandparent, etc) post to include.",
                default: 80,
                minimum: 0,
                maximum: 1e3
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["thread"],
              properties: {
                thread: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#threadViewPost",
                    "lex:app.bsky.feed.defs#notFoundPost",
                    "lex:app.bsky.feed.defs#blockedPost"
                  ]
                }
              }
            }
          },
          errors: [
            {
              name: "NotFound"
            }
          ]
        }
      }
    },
    AppBskyFeedGetPosts: {
      lexicon: 1,
      id: "app.bsky.feed.getPosts",
      defs: {
        main: {
          type: "query",
          description: "Gets post views for a specified list of posts (by AT-URI). This is sometimes referred to as 'hydrating' a 'feed skeleton'.",
          parameters: {
            type: "params",
            required: ["uris"],
            properties: {
              uris: {
                type: "array",
                description: "List of post AT-URIs to return hydrated views for.",
                items: {
                  type: "string",
                  format: "at-uri"
                },
                maxLength: 25
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["posts"],
              properties: {
                posts: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#postView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetRepostedBy: {
      lexicon: 1,
      id: "app.bsky.feed.getRepostedBy",
      defs: {
        main: {
          type: "query",
          description: "Get a list of reposts for a given post.",
          parameters: {
            type: "params",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) of post record"
              },
              cid: {
                type: "string",
                format: "cid",
                description: "If supplied, filters to reposts of specific version (by CID) of the post record."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["uri", "repostedBy"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                cursor: {
                  type: "string"
                },
                repostedBy: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetSuggestedFeeds: {
      lexicon: 1,
      id: "app.bsky.feed.getSuggestedFeeds",
      defs: {
        main: {
          type: "query",
          description: "Get a list of suggested feeds (feed generators) for the requesting account.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feeds"],
              properties: {
                cursor: {
                  type: "string"
                },
                feeds: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#generatorView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetTimeline: {
      lexicon: 1,
      id: "app.bsky.feed.getTimeline",
      defs: {
        main: {
          type: "query",
          description: "Get a view of the requesting account's home timeline. This is expected to be some form of reverse-chronological feed.",
          parameters: {
            type: "params",
            properties: {
              algorithm: {
                type: "string",
                description: "Variant 'algorithm' for timeline. Implementation-specific. NOTE: most feed flexibility has been moved to feed generator mechanism."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#feedViewPost"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedLike: {
      lexicon: 1,
      id: "app.bsky.feed.like",
      defs: {
        main: {
          type: "record",
          description: "Record declaring a 'like' of a piece of subject content.",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "createdAt"],
            properties: {
              subject: {
                type: "ref",
                ref: "lex:com.atproto.repo.strongRef"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyFeedPost: {
      lexicon: 1,
      id: "app.bsky.feed.post",
      defs: {
        main: {
          type: "record",
          description: "Record containing a Bluesky post.",
          key: "tid",
          record: {
            type: "object",
            required: ["text", "createdAt"],
            properties: {
              text: {
                type: "string",
                maxLength: 3e3,
                maxGraphemes: 300,
                description: "The primary post content. May be an empty string, if there are embeds."
              },
              entities: {
                type: "array",
                description: "DEPRECATED: replaced by app.bsky.richtext.facet.",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.post#entity"
                }
              },
              facets: {
                type: "array",
                description: "Annotations of text (mentions, URLs, hashtags, etc)",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet"
                }
              },
              reply: {
                type: "ref",
                ref: "lex:app.bsky.feed.post#replyRef"
              },
              embed: {
                type: "union",
                refs: [
                  "lex:app.bsky.embed.images",
                  "lex:app.bsky.embed.external",
                  "lex:app.bsky.embed.record",
                  "lex:app.bsky.embed.recordWithMedia"
                ]
              },
              langs: {
                type: "array",
                description: "Indicates human language of post primary text content.",
                maxLength: 3,
                items: {
                  type: "string",
                  format: "language"
                }
              },
              labels: {
                type: "union",
                description: "Self-label values for this post. Effectively content warnings.",
                refs: ["lex:com.atproto.label.defs#selfLabels"]
              },
              tags: {
                type: "array",
                description: "Additional hashtags, in addition to any included in post text and facets.",
                maxLength: 8,
                items: {
                  type: "string",
                  maxLength: 640,
                  maxGraphemes: 64
                }
              },
              createdAt: {
                type: "string",
                format: "datetime",
                description: "Client-declared timestamp when this post was originally created."
              }
            }
          }
        },
        replyRef: {
          type: "object",
          required: ["root", "parent"],
          properties: {
            root: {
              type: "ref",
              ref: "lex:com.atproto.repo.strongRef"
            },
            parent: {
              type: "ref",
              ref: "lex:com.atproto.repo.strongRef"
            }
          }
        },
        entity: {
          type: "object",
          description: "Deprecated: use facets instead.",
          required: ["index", "type", "value"],
          properties: {
            index: {
              type: "ref",
              ref: "lex:app.bsky.feed.post#textSlice"
            },
            type: {
              type: "string",
              description: "Expected values are 'mention' and 'link'."
            },
            value: {
              type: "string"
            }
          }
        },
        textSlice: {
          type: "object",
          description: "Deprecated. Use app.bsky.richtext instead -- A text segment. Start is inclusive, end is exclusive. Indices are for utf16-encoded strings.",
          required: ["start", "end"],
          properties: {
            start: {
              type: "integer",
              minimum: 0
            },
            end: {
              type: "integer",
              minimum: 0
            }
          }
        }
      }
    },
    AppBskyFeedRepost: {
      lexicon: 1,
      id: "app.bsky.feed.repost",
      defs: {
        main: {
          description: "Record representing a 'repost' of an existing Bluesky post.",
          type: "record",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "createdAt"],
            properties: {
              subject: {
                type: "ref",
                ref: "lex:com.atproto.repo.strongRef"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyFeedSearchPosts: {
      lexicon: 1,
      id: "app.bsky.feed.searchPosts",
      defs: {
        main: {
          type: "query",
          description: "Find posts matching search criteria, returning views of those posts.",
          parameters: {
            type: "params",
            required: ["q"],
            properties: {
              q: {
                type: "string",
                description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
              },
              sort: {
                type: "string",
                knownValues: ["top", "latest"],
                default: "latest",
                description: "Specifies the ranking order of results."
              },
              since: {
                type: "string",
                description: "Filter results for posts after the indicated datetime (inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYYY-MM-DD)."
              },
              until: {
                type: "string",
                description: "Filter results for posts before the indicated datetime (not inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYY-MM-DD)."
              },
              mentions: {
                type: "string",
                format: "at-identifier",
                description: "Filter to posts which mention the given account. Handles are resolved to DID before query-time. Only matches rich-text facet mentions."
              },
              author: {
                type: "string",
                format: "at-identifier",
                description: "Filter to posts by the given account. Handles are resolved to DID before query-time."
              },
              lang: {
                type: "string",
                format: "language",
                description: "Filter to posts in the given language. Expected to be based on post language field, though server may override language detection."
              },
              domain: {
                type: "string",
                description: "Filter to posts with URLs (facet links or embeds) linking to the given domain (hostname). Server may apply hostname normalization."
              },
              url: {
                type: "string",
                format: "uri",
                description: "Filter to posts with links (facet links or embeds) pointing to this URL. Server may apply URL normalization or fuzzy matching."
              },
              tag: {
                type: "array",
                items: {
                  type: "string",
                  maxLength: 640,
                  maxGraphemes: 64
                },
                description: "Filter to posts with the given tag (hashtag), based on rich-text facet or tag field. Do not include the hash (#) prefix. Multiple tags can be specified, with 'AND' matching."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 25
              },
              cursor: {
                type: "string",
                description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["posts"],
              properties: {
                cursor: {
                  type: "string"
                },
                hitsTotal: {
                  type: "integer",
                  description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                },
                posts: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#postView"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "BadQueryString"
            }
          ]
        }
      }
    },
    AppBskyFeedSendInteractions: {
      lexicon: 1,
      id: "app.bsky.feed.sendInteractions",
      defs: {
        main: {
          type: "procedure",
          description: "Send information about interactions with feed items back to the feed generator that served them.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["interactions"],
              properties: {
                interactions: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#interaction"
                  }
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {}
            }
          }
        }
      }
    },
    AppBskyFeedThreadgate: {
      lexicon: 1,
      id: "app.bsky.feed.threadgate",
      defs: {
        main: {
          type: "record",
          key: "tid",
          description: "Record defining interaction gating rules for a thread (aka, reply controls). The record key (rkey) of the threadgate record must match the record key of the thread's root post, and that record must be in the same repository..",
          record: {
            type: "object",
            required: ["post", "createdAt"],
            properties: {
              post: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to the post record."
              },
              allow: {
                type: "array",
                maxLength: 5,
                items: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.threadgate#mentionRule",
                    "lex:app.bsky.feed.threadgate#followingRule",
                    "lex:app.bsky.feed.threadgate#listRule"
                  ]
                }
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        },
        mentionRule: {
          type: "object",
          description: "Allow replies from actors mentioned in your post.",
          properties: {}
        },
        followingRule: {
          type: "object",
          description: "Allow replies from actors you follow.",
          properties: {}
        },
        listRule: {
          type: "object",
          description: "Allow replies from actors on a list.",
          required: ["list"],
          properties: {
            list: {
              type: "string",
              format: "at-uri"
            }
          }
        }
      }
    },
    AppBskyGraphBlock: {
      lexicon: 1,
      id: "app.bsky.graph.block",
      defs: {
        main: {
          type: "record",
          description: "Record declaring a 'block' relationship against another account. NOTE: blocks are public in Bluesky; see blog posts for details.",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "createdAt"],
            properties: {
              subject: {
                type: "string",
                format: "did",
                description: "DID of the account to be blocked."
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyGraphDefs: {
      lexicon: 1,
      id: "app.bsky.graph.defs",
      defs: {
        listViewBasic: {
          type: "object",
          required: ["uri", "cid", "name", "purpose"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            name: {
              type: "string",
              maxLength: 64,
              minLength: 1
            },
            purpose: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listPurpose"
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            listItemCount: {
              type: "integer",
              minimum: 0
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listViewerState"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        listView: {
          type: "object",
          required: ["uri", "cid", "creator", "name", "purpose", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            },
            name: {
              type: "string",
              maxLength: 64,
              minLength: 1
            },
            purpose: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listPurpose"
            },
            description: {
              type: "string",
              maxGraphemes: 300,
              maxLength: 3e3
            },
            descriptionFacets: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.richtext.facet"
              }
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            listItemCount: {
              type: "integer",
              minimum: 0
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listViewerState"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        listItemView: {
          type: "object",
          required: ["uri", "subject"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            subject: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            }
          }
        },
        starterPackView: {
          type: "object",
          required: ["uri", "cid", "record", "creator", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            record: {
              type: "unknown"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic"
            },
            list: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listViewBasic"
            },
            listItemsSample: {
              type: "array",
              maxLength: 12,
              items: {
                type: "ref",
                ref: "lex:app.bsky.graph.defs#listItemView"
              }
            },
            feeds: {
              type: "array",
              maxLength: 3,
              items: {
                type: "ref",
                ref: "lex:app.bsky.feed.defs#generatorView"
              }
            },
            joinedWeekCount: {
              type: "integer",
              minimum: 0
            },
            joinedAllTimeCount: {
              type: "integer",
              minimum: 0
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        starterPackViewBasic: {
          type: "object",
          required: ["uri", "cid", "record", "creator", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            record: {
              type: "unknown"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic"
            },
            listItemCount: {
              type: "integer",
              minimum: 0
            },
            joinedWeekCount: {
              type: "integer",
              minimum: 0
            },
            joinedAllTimeCount: {
              type: "integer",
              minimum: 0
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        listPurpose: {
          type: "string",
          knownValues: [
            "app.bsky.graph.defs#modlist",
            "app.bsky.graph.defs#curatelist",
            "app.bsky.graph.defs#referencelist"
          ]
        },
        modlist: {
          type: "token",
          description: "A list of actors to apply an aggregate moderation action (mute/block) on."
        },
        curatelist: {
          type: "token",
          description: "A list of actors used for curation purposes such as list feeds or interaction gating."
        },
        referencelist: {
          type: "token",
          description: "A list of actors used for only for reference purposes such as within a starter pack."
        },
        listViewerState: {
          type: "object",
          properties: {
            muted: {
              type: "boolean"
            },
            blocked: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        notFoundActor: {
          type: "object",
          description: "indicates that a handle or DID could not be resolved",
          required: ["actor", "notFound"],
          properties: {
            actor: {
              type: "string",
              format: "at-identifier"
            },
            notFound: {
              type: "boolean",
              const: !0
            }
          }
        },
        relationship: {
          type: "object",
          description: "lists the bi-directional graph relationships between one actor (not indicated in the object), and the target actors (the DID included in the object)",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            following: {
              type: "string",
              format: "at-uri",
              description: "if the actor follows this DID, this is the AT-URI of the follow record"
            },
            followedBy: {
              type: "string",
              format: "at-uri",
              description: "if the actor is followed by this DID, contains the AT-URI of the follow record"
            }
          }
        }
      }
    },
    AppBskyGraphFollow: {
      lexicon: 1,
      id: "app.bsky.graph.follow",
      defs: {
        main: {
          type: "record",
          description: "Record declaring a social 'follow' relationship of another account. Duplicate follows will be ignored by the AppView.",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "createdAt"],
            properties: {
              subject: {
                type: "string",
                format: "did"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetActorStarterPacks: {
      lexicon: 1,
      id: "app.bsky.graph.getActorStarterPacks",
      defs: {
        main: {
          type: "query",
          description: "Get a list of starter packs created by the actor.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["starterPacks"],
              properties: {
                cursor: {
                  type: "string"
                },
                starterPacks: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#starterPackViewBasic"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetBlocks: {
      lexicon: 1,
      id: "app.bsky.graph.getBlocks",
      defs: {
        main: {
          type: "query",
          description: "Enumerates which accounts the requesting account is currently blocking. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["blocks"],
              properties: {
                cursor: {
                  type: "string"
                },
                blocks: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetFollowers: {
      lexicon: 1,
      id: "app.bsky.graph.getFollowers",
      defs: {
        main: {
          type: "query",
          description: "Enumerates accounts which follow a specified account (actor).",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject", "followers"],
              properties: {
                subject: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                cursor: {
                  type: "string"
                },
                followers: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetFollows: {
      lexicon: 1,
      id: "app.bsky.graph.getFollows",
      defs: {
        main: {
          type: "query",
          description: "Enumerates accounts which a specified account (actor) follows.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject", "follows"],
              properties: {
                subject: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                cursor: {
                  type: "string"
                },
                follows: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetKnownFollowers: {
      lexicon: 1,
      id: "app.bsky.graph.getKnownFollowers",
      defs: {
        main: {
          type: "query",
          description: "Enumerates accounts which follow a specified account (actor) and are followed by the viewer.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject", "followers"],
              properties: {
                subject: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                cursor: {
                  type: "string"
                },
                followers: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetList: {
      lexicon: 1,
      id: "app.bsky.graph.getList",
      defs: {
        main: {
          type: "query",
          description: "Gets a 'view' (with additional context) of a specified list.",
          parameters: {
            type: "params",
            required: ["list"],
            properties: {
              list: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) of the list record to hydrate."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["list", "items"],
              properties: {
                cursor: {
                  type: "string"
                },
                list: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listView"
                },
                items: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listItemView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetListBlocks: {
      lexicon: 1,
      id: "app.bsky.graph.getListBlocks",
      defs: {
        main: {
          type: "query",
          description: "Get mod lists that the requesting account (actor) is blocking. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["lists"],
              properties: {
                cursor: {
                  type: "string"
                },
                lists: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetListMutes: {
      lexicon: 1,
      id: "app.bsky.graph.getListMutes",
      defs: {
        main: {
          type: "query",
          description: "Enumerates mod lists that the requesting account (actor) currently has muted. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["lists"],
              properties: {
                cursor: {
                  type: "string"
                },
                lists: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetLists: {
      lexicon: 1,
      id: "app.bsky.graph.getLists",
      defs: {
        main: {
          type: "query",
          description: "Enumerates the lists created by a specified account (actor).",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier",
                description: "The account (actor) to enumerate lists from."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["lists"],
              properties: {
                cursor: {
                  type: "string"
                },
                lists: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetMutes: {
      lexicon: 1,
      id: "app.bsky.graph.getMutes",
      defs: {
        main: {
          type: "query",
          description: "Enumerates accounts that the requesting account (actor) currently has muted. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["mutes"],
              properties: {
                cursor: {
                  type: "string"
                },
                mutes: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetRelationships: {
      lexicon: 1,
      id: "app.bsky.graph.getRelationships",
      defs: {
        main: {
          type: "query",
          description: "Enumerates public relationships between one account, and a list of other accounts. Does not require auth.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier",
                description: "Primary account requesting relationships for."
              },
              others: {
                type: "array",
                description: "List of 'other' accounts to be related back to the primary.",
                maxLength: 30,
                items: {
                  type: "string",
                  format: "at-identifier"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["relationships"],
              properties: {
                actor: {
                  type: "string",
                  format: "did"
                },
                relationships: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.graph.defs#relationship",
                      "lex:app.bsky.graph.defs#notFoundActor"
                    ]
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "ActorNotFound",
              description: "the primary actor at-identifier could not be resolved"
            }
          ]
        }
      }
    },
    AppBskyGraphGetStarterPack: {
      lexicon: 1,
      id: "app.bsky.graph.getStarterPack",
      defs: {
        main: {
          type: "query",
          description: "Gets a view of a starter pack.",
          parameters: {
            type: "params",
            required: ["starterPack"],
            properties: {
              starterPack: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) of the starter pack record."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["starterPack"],
              properties: {
                starterPack: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#starterPackView"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetStarterPacks: {
      lexicon: 1,
      id: "app.bsky.graph.getStarterPacks",
      defs: {
        main: {
          type: "query",
          description: "Get views for a list of starter packs.",
          parameters: {
            type: "params",
            required: ["uris"],
            properties: {
              uris: {
                type: "array",
                items: {
                  type: "string",
                  format: "at-uri"
                },
                maxLength: 25
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["starterPacks"],
              properties: {
                starterPacks: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#starterPackViewBasic"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetSuggestedFollowsByActor: {
      lexicon: 1,
      id: "app.bsky.graph.getSuggestedFollowsByActor",
      defs: {
        main: {
          type: "query",
          description: "Enumerates follows similar to a given account (actor). Expected use is to recommend additional accounts immediately after following one account.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["suggestions"],
              properties: {
                suggestions: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphList: {
      lexicon: 1,
      id: "app.bsky.graph.list",
      defs: {
        main: {
          type: "record",
          description: "Record representing a list of accounts (actors). Scope includes both moderation-oriented lists and curration-oriented lists.",
          key: "tid",
          record: {
            type: "object",
            required: ["name", "purpose", "createdAt"],
            properties: {
              purpose: {
                type: "ref",
                description: "Defines the purpose of the list (aka, moderation-oriented or curration-oriented)",
                ref: "lex:app.bsky.graph.defs#listPurpose"
              },
              name: {
                type: "string",
                maxLength: 64,
                minLength: 1,
                description: "Display name for list; can not be empty."
              },
              description: {
                type: "string",
                maxGraphemes: 300,
                maxLength: 3e3
              },
              descriptionFacets: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet"
                }
              },
              avatar: {
                type: "blob",
                accept: ["image/png", "image/jpeg"],
                maxSize: 1e6
              },
              labels: {
                type: "union",
                refs: ["lex:com.atproto.label.defs#selfLabels"]
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyGraphListblock: {
      lexicon: 1,
      id: "app.bsky.graph.listblock",
      defs: {
        main: {
          type: "record",
          description: "Record representing a block relationship against an entire an entire list of accounts (actors).",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "createdAt"],
            properties: {
              subject: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to the mod list record."
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyGraphListitem: {
      lexicon: 1,
      id: "app.bsky.graph.listitem",
      defs: {
        main: {
          type: "record",
          description: "Record representing an account's inclusion on a specific list. The AppView will ignore duplicate listitem records.",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "list", "createdAt"],
            properties: {
              subject: {
                type: "string",
                format: "did",
                description: "The account which is included on the list."
              },
              list: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to the list record (app.bsky.graph.list)."
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyGraphMuteActor: {
      lexicon: 1,
      id: "app.bsky.graph.muteActor",
      defs: {
        main: {
          type: "procedure",
          description: "Creates a mute relationship for the specified account. Mutes are private in Bluesky. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphMuteActorList: {
      lexicon: 1,
      id: "app.bsky.graph.muteActorList",
      defs: {
        main: {
          type: "procedure",
          description: "Creates a mute relationship for the specified list of accounts. Mutes are private in Bluesky. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["list"],
              properties: {
                list: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphMuteThread: {
      lexicon: 1,
      id: "app.bsky.graph.muteThread",
      defs: {
        main: {
          type: "procedure",
          description: "Mutes a thread preventing notifications from the thread and any of its children. Mutes are private in Bluesky. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["root"],
              properties: {
                root: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphStarterpack: {
      lexicon: 1,
      id: "app.bsky.graph.starterpack",
      defs: {
        main: {
          type: "record",
          description: "Record defining a starter pack of actors and feeds for new users.",
          key: "tid",
          record: {
            type: "object",
            required: ["name", "list", "createdAt"],
            properties: {
              name: {
                type: "string",
                maxGraphemes: 50,
                maxLength: 500,
                minLength: 1,
                description: "Display name for starter pack; can not be empty."
              },
              description: {
                type: "string",
                maxGraphemes: 300,
                maxLength: 3e3
              },
              descriptionFacets: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet"
                }
              },
              list: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to the list record."
              },
              feeds: {
                type: "array",
                maxLength: 3,
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.starterpack#feedItem"
                }
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        },
        feedItem: {
          type: "object",
          required: ["uri"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            }
          }
        }
      }
    },
    AppBskyGraphUnmuteActor: {
      lexicon: 1,
      id: "app.bsky.graph.unmuteActor",
      defs: {
        main: {
          type: "procedure",
          description: "Unmutes the specified account. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphUnmuteActorList: {
      lexicon: 1,
      id: "app.bsky.graph.unmuteActorList",
      defs: {
        main: {
          type: "procedure",
          description: "Unmutes the specified list of accounts. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["list"],
              properties: {
                list: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphUnmuteThread: {
      lexicon: 1,
      id: "app.bsky.graph.unmuteThread",
      defs: {
        main: {
          type: "procedure",
          description: "Unmutes the specified thread. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["root"],
              properties: {
                root: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        }
      }
    },
    AppBskyLabelerDefs: {
      lexicon: 1,
      id: "app.bsky.labeler.defs",
      defs: {
        labelerView: {
          type: "object",
          required: ["uri", "cid", "creator", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            },
            likeCount: {
              type: "integer",
              minimum: 0
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.labeler.defs#labelerViewerState"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        labelerViewDetailed: {
          type: "object",
          required: ["uri", "cid", "creator", "policies", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            },
            policies: {
              type: "ref",
              ref: "lex:app.bsky.labeler.defs#labelerPolicies"
            },
            likeCount: {
              type: "integer",
              minimum: 0
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.labeler.defs#labelerViewerState"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        labelerViewerState: {
          type: "object",
          properties: {
            like: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        labelerPolicies: {
          type: "object",
          required: ["labelValues"],
          properties: {
            labelValues: {
              type: "array",
              description: "The label values which this labeler publishes. May include global or custom labels.",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#labelValue"
              }
            },
            labelValueDefinitions: {
              type: "array",
              description: "Label values created by this labeler and scoped exclusively to it. Labels defined here will override global label definitions for this labeler.",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#labelValueDefinition"
              }
            }
          }
        }
      }
    },
    AppBskyLabelerGetServices: {
      lexicon: 1,
      id: "app.bsky.labeler.getServices",
      defs: {
        main: {
          type: "query",
          description: "Get information about a list of labeler services.",
          parameters: {
            type: "params",
            required: ["dids"],
            properties: {
              dids: {
                type: "array",
                items: {
                  type: "string",
                  format: "did"
                }
              },
              detailed: {
                type: "boolean",
                default: !1
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["views"],
              properties: {
                views: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.labeler.defs#labelerView",
                      "lex:app.bsky.labeler.defs#labelerViewDetailed"
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyLabelerService: {
      lexicon: 1,
      id: "app.bsky.labeler.service",
      defs: {
        main: {
          type: "record",
          description: "A declaration of the existence of labeler service.",
          key: "literal:self",
          record: {
            type: "object",
            required: ["policies", "createdAt"],
            properties: {
              policies: {
                type: "ref",
                ref: "lex:app.bsky.labeler.defs#labelerPolicies"
              },
              labels: {
                type: "union",
                refs: ["lex:com.atproto.label.defs#selfLabels"]
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyNotificationGetUnreadCount: {
      lexicon: 1,
      id: "app.bsky.notification.getUnreadCount",
      defs: {
        main: {
          type: "query",
          description: "Count the number of unread notifications for the requesting account. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              priority: {
                type: "boolean"
              },
              seenAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["count"],
              properties: {
                count: {
                  type: "integer"
                }
              }
            }
          }
        }
      }
    },
    AppBskyNotificationListNotifications: {
      lexicon: 1,
      id: "app.bsky.notification.listNotifications",
      defs: {
        main: {
          type: "query",
          description: "Enumerate notifications for the requesting account. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              priority: {
                type: "boolean"
              },
              cursor: {
                type: "string"
              },
              seenAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["notifications"],
              properties: {
                cursor: {
                  type: "string"
                },
                notifications: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.notification.listNotifications#notification"
                  }
                },
                priority: {
                  type: "boolean"
                },
                seenAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        },
        notification: {
          type: "object",
          required: [
            "uri",
            "cid",
            "author",
            "reason",
            "record",
            "isRead",
            "indexedAt"
          ],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            author: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            },
            reason: {
              type: "string",
              description: "Expected values are 'like', 'repost', 'follow', 'mention', 'reply', 'quote', and 'starterpack-joined'.",
              knownValues: [
                "like",
                "repost",
                "follow",
                "mention",
                "reply",
                "quote",
                "starterpack-joined"
              ]
            },
            reasonSubject: {
              type: "string",
              format: "at-uri"
            },
            record: {
              type: "unknown"
            },
            isRead: {
              type: "boolean"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        }
      }
    },
    AppBskyNotificationPutPreferences: {
      lexicon: 1,
      id: "app.bsky.notification.putPreferences",
      defs: {
        main: {
          type: "procedure",
          description: "Set notification-related preferences for an account. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["priority"],
              properties: {
                priority: {
                  type: "boolean"
                }
              }
            }
          }
        }
      }
    },
    AppBskyNotificationRegisterPush: {
      lexicon: 1,
      id: "app.bsky.notification.registerPush",
      defs: {
        main: {
          type: "procedure",
          description: "Register to receive push notifications, via a specified service, for the requesting account. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["serviceDid", "token", "platform", "appId"],
              properties: {
                serviceDid: {
                  type: "string",
                  format: "did"
                },
                token: {
                  type: "string"
                },
                platform: {
                  type: "string",
                  knownValues: ["ios", "android", "web"]
                },
                appId: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    AppBskyNotificationUpdateSeen: {
      lexicon: 1,
      id: "app.bsky.notification.updateSeen",
      defs: {
        main: {
          type: "procedure",
          description: "Notify server that the requesting account has seen notifications. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["seenAt"],
              properties: {
                seenAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      }
    },
    AppBskyRichtextFacet: {
      lexicon: 1,
      id: "app.bsky.richtext.facet",
      defs: {
        main: {
          type: "object",
          description: "Annotation of a sub-string within rich text.",
          required: ["index", "features"],
          properties: {
            index: {
              type: "ref",
              ref: "lex:app.bsky.richtext.facet#byteSlice"
            },
            features: {
              type: "array",
              items: {
                type: "union",
                refs: [
                  "lex:app.bsky.richtext.facet#mention",
                  "lex:app.bsky.richtext.facet#link",
                  "lex:app.bsky.richtext.facet#tag"
                ]
              }
            }
          }
        },
        mention: {
          type: "object",
          description: "Facet feature for mention of another account. The text is usually a handle, including a '@' prefix, but the facet reference is a DID.",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        },
        link: {
          type: "object",
          description: "Facet feature for a URL. The text URL may have been simplified or truncated, but the facet reference should be a complete URL.",
          required: ["uri"],
          properties: {
            uri: {
              type: "string",
              format: "uri"
            }
          }
        },
        tag: {
          type: "object",
          description: "Facet feature for a hashtag. The text usually includes a '#' prefix, but the facet reference should not (except in the case of 'double hash tags').",
          required: ["tag"],
          properties: {
            tag: {
              type: "string",
              maxLength: 640,
              maxGraphemes: 64
            }
          }
        },
        byteSlice: {
          type: "object",
          description: "Specifies the sub-string range a facet feature applies to. Start index is inclusive, end index is exclusive. Indices are zero-indexed, counting bytes of the UTF-8 encoded text. NOTE: some languages, like Javascript, use UTF-16 or Unicode codepoints for string slice indexing; in these languages, convert to byte arrays before working with facets.",
          required: ["byteStart", "byteEnd"],
          properties: {
            byteStart: {
              type: "integer",
              minimum: 0
            },
            byteEnd: {
              type: "integer",
              minimum: 0
            }
          }
        }
      }
    },
    AppBskyUnspeccedDefs: {
      lexicon: 1,
      id: "app.bsky.unspecced.defs",
      defs: {
        skeletonSearchPost: {
          type: "object",
          required: ["uri"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        skeletonSearchActor: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        }
      }
    },
    AppBskyUnspeccedGetPopularFeedGenerators: {
      lexicon: 1,
      id: "app.bsky.unspecced.getPopularFeedGenerators",
      defs: {
        main: {
          type: "query",
          description: "An unspecced view of globally popular feed generators.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              },
              query: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feeds"],
              properties: {
                cursor: {
                  type: "string"
                },
                feeds: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#generatorView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyUnspeccedGetSuggestionsSkeleton: {
      lexicon: 1,
      id: "app.bsky.unspecced.getSuggestionsSkeleton",
      defs: {
        main: {
          type: "query",
          description: "Get a skeleton of suggested actors. Intended to be called and then hydrated through app.bsky.actor.getSuggestions",
          parameters: {
            type: "params",
            properties: {
              viewer: {
                type: "string",
                format: "did",
                description: "DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              },
              relativeToDid: {
                type: "string",
                format: "did",
                description: "DID of the account to get suggestions relative to. If not provided, suggestions will be based on the viewer."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actors"],
              properties: {
                cursor: {
                  type: "string"
                },
                actors: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.unspecced.defs#skeletonSearchActor"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyUnspeccedGetTaggedSuggestions: {
      lexicon: 1,
      id: "app.bsky.unspecced.getTaggedSuggestions",
      defs: {
        main: {
          type: "query",
          description: "Get a list of suggestions (feeds and users) tagged with categories",
          parameters: {
            type: "params",
            properties: {}
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["suggestions"],
              properties: {
                suggestions: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.unspecced.getTaggedSuggestions#suggestion"
                  }
                }
              }
            }
          }
        },
        suggestion: {
          type: "object",
          required: ["tag", "subjectType", "subject"],
          properties: {
            tag: {
              type: "string"
            },
            subjectType: {
              type: "string",
              knownValues: ["actor", "feed"]
            },
            subject: {
              type: "string",
              format: "uri"
            }
          }
        }
      }
    },
    AppBskyUnspeccedSearchActorsSkeleton: {
      lexicon: 1,
      id: "app.bsky.unspecced.searchActorsSkeleton",
      defs: {
        main: {
          type: "query",
          description: "Backend Actors (profile) search, returns only skeleton.",
          parameters: {
            type: "params",
            required: ["q"],
            properties: {
              q: {
                type: "string",
                description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. For typeahead search, only simple term match is supported, not full syntax."
              },
              viewer: {
                type: "string",
                format: "did",
                description: "DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking."
              },
              typeahead: {
                type: "boolean",
                description: "If true, acts as fast/simple 'typeahead' query."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 25
              },
              cursor: {
                type: "string",
                description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actors"],
              properties: {
                cursor: {
                  type: "string"
                },
                hitsTotal: {
                  type: "integer",
                  description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                },
                actors: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.unspecced.defs#skeletonSearchActor"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "BadQueryString"
            }
          ]
        }
      }
    },
    AppBskyUnspeccedSearchPostsSkeleton: {
      lexicon: 1,
      id: "app.bsky.unspecced.searchPostsSkeleton",
      defs: {
        main: {
          type: "query",
          description: "Backend Posts search, returns only skeleton",
          parameters: {
            type: "params",
            required: ["q"],
            properties: {
              q: {
                type: "string",
                description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
              },
              sort: {
                type: "string",
                knownValues: ["top", "latest"],
                default: "latest",
                description: "Specifies the ranking order of results."
              },
              since: {
                type: "string",
                description: "Filter results for posts after the indicated datetime (inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYYY-MM-DD)."
              },
              until: {
                type: "string",
                description: "Filter results for posts before the indicated datetime (not inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYY-MM-DD)."
              },
              mentions: {
                type: "string",
                format: "at-identifier",
                description: "Filter to posts which mention the given account. Handles are resolved to DID before query-time. Only matches rich-text facet mentions."
              },
              author: {
                type: "string",
                format: "at-identifier",
                description: "Filter to posts by the given account. Handles are resolved to DID before query-time."
              },
              lang: {
                type: "string",
                format: "language",
                description: "Filter to posts in the given language. Expected to be based on post language field, though server may override language detection."
              },
              domain: {
                type: "string",
                description: "Filter to posts with URLs (facet links or embeds) linking to the given domain (hostname). Server may apply hostname normalization."
              },
              url: {
                type: "string",
                format: "uri",
                description: "Filter to posts with links (facet links or embeds) pointing to this URL. Server may apply URL normalization or fuzzy matching."
              },
              tag: {
                type: "array",
                items: {
                  type: "string",
                  maxLength: 640,
                  maxGraphemes: 64
                },
                description: "Filter to posts with the given tag (hashtag), based on rich-text facet or tag field. Do not include the hash (#) prefix. Multiple tags can be specified, with 'AND' matching."
              },
              viewer: {
                type: "string",
                format: "did",
                description: "DID of the account making the request (not included for public/unauthenticated queries). Used for 'from:me' queries."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 25
              },
              cursor: {
                type: "string",
                description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["posts"],
              properties: {
                cursor: {
                  type: "string"
                },
                hitsTotal: {
                  type: "integer",
                  description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                },
                posts: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.unspecced.defs#skeletonSearchPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "BadQueryString"
            }
          ]
        }
      }
    },
    ChatBskyActorDeclaration: {
      lexicon: 1,
      id: "chat.bsky.actor.declaration",
      defs: {
        main: {
          type: "record",
          description: "A declaration of a Bluesky chat account.",
          key: "literal:self",
          record: {
            type: "object",
            required: ["allowIncoming"],
            properties: {
              allowIncoming: {
                type: "string",
                knownValues: ["all", "none", "following"]
              }
            }
          }
        }
      }
    },
    ChatBskyActorDefs: {
      lexicon: 1,
      id: "chat.bsky.actor.defs",
      defs: {
        profileViewBasic: {
          type: "object",
          required: ["did", "handle"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            displayName: {
              type: "string",
              maxGraphemes: 64,
              maxLength: 640
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            associated: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileAssociated"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#viewerState"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            chatDisabled: {
              type: "boolean",
              description: "Set to true when the actor cannot actively participate in converations"
            }
          }
        }
      }
    },
    ChatBskyActorDeleteAccount: {
      lexicon: 1,
      id: "chat.bsky.actor.deleteAccount",
      defs: {
        main: {
          type: "procedure",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {}
            }
          }
        }
      }
    },
    ChatBskyActorExportAccountData: {
      lexicon: 1,
      id: "chat.bsky.actor.exportAccountData",
      defs: {
        main: {
          type: "query",
          output: {
            encoding: "application/jsonl"
          }
        }
      }
    },
    ChatBskyConvoDefs: {
      lexicon: 1,
      id: "chat.bsky.convo.defs",
      defs: {
        messageRef: {
          type: "object",
          required: ["did", "messageId", "convoId"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            convoId: {
              type: "string"
            },
            messageId: {
              type: "string"
            }
          }
        },
        messageInput: {
          type: "object",
          required: ["text"],
          properties: {
            text: {
              type: "string",
              maxLength: 1e4,
              maxGraphemes: 1e3
            },
            facets: {
              type: "array",
              description: "Annotations of text (mentions, URLs, hashtags, etc)",
              items: {
                type: "ref",
                ref: "lex:app.bsky.richtext.facet"
              }
            },
            embed: {
              type: "union",
              refs: ["lex:app.bsky.embed.record"]
            }
          }
        },
        messageView: {
          type: "object",
          required: ["id", "rev", "text", "sender", "sentAt"],
          properties: {
            id: {
              type: "string"
            },
            rev: {
              type: "string"
            },
            text: {
              type: "string",
              maxLength: 1e4,
              maxGraphemes: 1e3
            },
            facets: {
              type: "array",
              description: "Annotations of text (mentions, URLs, hashtags, etc)",
              items: {
                type: "ref",
                ref: "lex:app.bsky.richtext.facet"
              }
            },
            embed: {
              type: "union",
              refs: ["lex:app.bsky.embed.record#view"]
            },
            sender: {
              type: "ref",
              ref: "lex:chat.bsky.convo.defs#messageViewSender"
            },
            sentAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        deletedMessageView: {
          type: "object",
          required: ["id", "rev", "sender", "sentAt"],
          properties: {
            id: {
              type: "string"
            },
            rev: {
              type: "string"
            },
            sender: {
              type: "ref",
              ref: "lex:chat.bsky.convo.defs#messageViewSender"
            },
            sentAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        messageViewSender: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        },
        convoView: {
          type: "object",
          required: ["id", "rev", "members", "muted", "unreadCount"],
          properties: {
            id: {
              type: "string"
            },
            rev: {
              type: "string"
            },
            members: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:chat.bsky.actor.defs#profileViewBasic"
              }
            },
            lastMessage: {
              type: "union",
              refs: [
                "lex:chat.bsky.convo.defs#messageView",
                "lex:chat.bsky.convo.defs#deletedMessageView"
              ]
            },
            muted: {
              type: "boolean"
            },
            unreadCount: {
              type: "integer"
            }
          }
        },
        logBeginConvo: {
          type: "object",
          required: ["rev", "convoId"],
          properties: {
            rev: {
              type: "string"
            },
            convoId: {
              type: "string"
            }
          }
        },
        logLeaveConvo: {
          type: "object",
          required: ["rev", "convoId"],
          properties: {
            rev: {
              type: "string"
            },
            convoId: {
              type: "string"
            }
          }
        },
        logCreateMessage: {
          type: "object",
          required: ["rev", "convoId", "message"],
          properties: {
            rev: {
              type: "string"
            },
            convoId: {
              type: "string"
            },
            message: {
              type: "union",
              refs: [
                "lex:chat.bsky.convo.defs#messageView",
                "lex:chat.bsky.convo.defs#deletedMessageView"
              ]
            }
          }
        },
        logDeleteMessage: {
          type: "object",
          required: ["rev", "convoId", "message"],
          properties: {
            rev: {
              type: "string"
            },
            convoId: {
              type: "string"
            },
            message: {
              type: "union",
              refs: [
                "lex:chat.bsky.convo.defs#messageView",
                "lex:chat.bsky.convo.defs#deletedMessageView"
              ]
            }
          }
        }
      }
    },
    ChatBskyConvoDeleteMessageForSelf: {
      lexicon: 1,
      id: "chat.bsky.convo.deleteMessageForSelf",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId", "messageId"],
              properties: {
                convoId: {
                  type: "string"
                },
                messageId: {
                  type: "string"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:chat.bsky.convo.defs#deletedMessageView"
            }
          }
        }
      }
    },
    ChatBskyConvoGetConvo: {
      lexicon: 1,
      id: "chat.bsky.convo.getConvo",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            required: ["convoId"],
            properties: {
              convoId: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convo"],
              properties: {
                convo: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#convoView"
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoGetConvoForMembers: {
      lexicon: 1,
      id: "chat.bsky.convo.getConvoForMembers",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            required: ["members"],
            properties: {
              members: {
                type: "array",
                minLength: 1,
                maxLength: 10,
                items: {
                  type: "string",
                  format: "did"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convo"],
              properties: {
                convo: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#convoView"
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoGetLog: {
      lexicon: 1,
      id: "chat.bsky.convo.getLog",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            required: [],
            properties: {
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["logs"],
              properties: {
                cursor: {
                  type: "string"
                },
                logs: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:chat.bsky.convo.defs#logBeginConvo",
                      "lex:chat.bsky.convo.defs#logLeaveConvo",
                      "lex:chat.bsky.convo.defs#logCreateMessage",
                      "lex:chat.bsky.convo.defs#logDeleteMessage"
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoGetMessages: {
      lexicon: 1,
      id: "chat.bsky.convo.getMessages",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            required: ["convoId"],
            properties: {
              convoId: {
                type: "string"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["messages"],
              properties: {
                cursor: {
                  type: "string"
                },
                messages: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:chat.bsky.convo.defs#messageView",
                      "lex:chat.bsky.convo.defs#deletedMessageView"
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoLeaveConvo: {
      lexicon: 1,
      id: "chat.bsky.convo.leaveConvo",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId"],
              properties: {
                convoId: {
                  type: "string"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId", "rev"],
              properties: {
                convoId: {
                  type: "string"
                },
                rev: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoListConvos: {
      lexicon: 1,
      id: "chat.bsky.convo.listConvos",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convos"],
              properties: {
                cursor: {
                  type: "string"
                },
                convos: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:chat.bsky.convo.defs#convoView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoMuteConvo: {
      lexicon: 1,
      id: "chat.bsky.convo.muteConvo",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId"],
              properties: {
                convoId: {
                  type: "string"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convo"],
              properties: {
                convo: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#convoView"
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoSendMessage: {
      lexicon: 1,
      id: "chat.bsky.convo.sendMessage",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId", "message"],
              properties: {
                convoId: {
                  type: "string"
                },
                message: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#messageInput"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:chat.bsky.convo.defs#messageView"
            }
          }
        }
      }
    },
    ChatBskyConvoSendMessageBatch: {
      lexicon: 1,
      id: "chat.bsky.convo.sendMessageBatch",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["items"],
              properties: {
                items: {
                  type: "array",
                  maxLength: 100,
                  items: {
                    type: "ref",
                    ref: "lex:chat.bsky.convo.sendMessageBatch#batchItem"
                  }
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["items"],
              properties: {
                items: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:chat.bsky.convo.defs#messageView"
                  }
                }
              }
            }
          }
        },
        batchItem: {
          type: "object",
          required: ["convoId", "message"],
          properties: {
            convoId: {
              type: "string"
            },
            message: {
              type: "ref",
              ref: "lex:chat.bsky.convo.defs#messageInput"
            }
          }
        }
      }
    },
    ChatBskyConvoUnmuteConvo: {
      lexicon: 1,
      id: "chat.bsky.convo.unmuteConvo",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId"],
              properties: {
                convoId: {
                  type: "string"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convo"],
              properties: {
                convo: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#convoView"
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoUpdateRead: {
      lexicon: 1,
      id: "chat.bsky.convo.updateRead",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId"],
              properties: {
                convoId: {
                  type: "string"
                },
                messageId: {
                  type: "string"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convo"],
              properties: {
                convo: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#convoView"
                }
              }
            }
          }
        }
      }
    },
    ChatBskyModerationGetActorMetadata: {
      lexicon: 1,
      id: "chat.bsky.moderation.getActorMetadata",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "did"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["day", "month", "all"],
              properties: {
                day: {
                  type: "ref",
                  ref: "lex:chat.bsky.moderation.getActorMetadata#metadata"
                },
                month: {
                  type: "ref",
                  ref: "lex:chat.bsky.moderation.getActorMetadata#metadata"
                },
                all: {
                  type: "ref",
                  ref: "lex:chat.bsky.moderation.getActorMetadata#metadata"
                }
              }
            }
          }
        },
        metadata: {
          type: "object",
          required: [
            "messagesSent",
            "messagesReceived",
            "convos",
            "convosStarted"
          ],
          properties: {
            messagesSent: {
              type: "integer"
            },
            messagesReceived: {
              type: "integer"
            },
            convos: {
              type: "integer"
            },
            convosStarted: {
              type: "integer"
            }
          }
        }
      }
    },
    ChatBskyModerationGetMessageContext: {
      lexicon: 1,
      id: "chat.bsky.moderation.getMessageContext",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            required: ["messageId"],
            properties: {
              convoId: {
                type: "string",
                description: "Conversation that the message is from. NOTE: this field will eventually be required."
              },
              messageId: {
                type: "string"
              },
              before: {
                type: "integer",
                default: 5
              },
              after: {
                type: "integer",
                default: 5
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["messages"],
              properties: {
                messages: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:chat.bsky.convo.defs#messageView",
                      "lex:chat.bsky.convo.defs#deletedMessageView"
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    ChatBskyModerationUpdateActorAccess: {
      lexicon: 1,
      id: "chat.bsky.moderation.updateActorAccess",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actor", "allowAccess"],
              properties: {
                actor: {
                  type: "string",
                  format: "did"
                },
                allowAccess: {
                  type: "boolean"
                },
                ref: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneCommunicationCreateTemplate: {
      lexicon: 1,
      id: "tools.ozone.communication.createTemplate",
      defs: {
        main: {
          type: "procedure",
          description: "Administrative action to create a new, re-usable communication (email for now) template.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject", "contentMarkdown", "name"],
              properties: {
                name: {
                  type: "string",
                  description: "Name of the template."
                },
                contentMarkdown: {
                  type: "string",
                  description: "Content of the template, markdown supported, can contain variable placeholders."
                },
                subject: {
                  type: "string",
                  description: "Subject of the message, used in emails."
                },
                createdBy: {
                  type: "string",
                  format: "did",
                  description: "DID of the user who is creating the template."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.communication.defs#templateView"
            }
          }
        }
      }
    },
    ToolsOzoneCommunicationDefs: {
      lexicon: 1,
      id: "tools.ozone.communication.defs",
      defs: {
        templateView: {
          type: "object",
          required: [
            "id",
            "name",
            "contentMarkdown",
            "disabled",
            "lastUpdatedBy",
            "createdAt",
            "updatedAt"
          ],
          properties: {
            id: {
              type: "string"
            },
            name: {
              type: "string",
              description: "Name of the template."
            },
            subject: {
              type: "string",
              description: "Content of the template, can contain markdown and variable placeholders."
            },
            contentMarkdown: {
              type: "string",
              description: "Subject of the message, used in emails."
            },
            disabled: {
              type: "boolean"
            },
            lastUpdatedBy: {
              type: "string",
              format: "did",
              description: "DID of the user who last updated the template."
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            updatedAt: {
              type: "string",
              format: "datetime"
            }
          }
        }
      }
    },
    ToolsOzoneCommunicationDeleteTemplate: {
      lexicon: 1,
      id: "tools.ozone.communication.deleteTemplate",
      defs: {
        main: {
          type: "procedure",
          description: "Delete a communication template.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["id"],
              properties: {
                id: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneCommunicationListTemplates: {
      lexicon: 1,
      id: "tools.ozone.communication.listTemplates",
      defs: {
        main: {
          type: "query",
          description: "Get list of all communication templates.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["communicationTemplates"],
              properties: {
                communicationTemplates: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.communication.defs#templateView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneCommunicationUpdateTemplate: {
      lexicon: 1,
      id: "tools.ozone.communication.updateTemplate",
      defs: {
        main: {
          type: "procedure",
          description: "Administrative action to update an existing communication template. Allows passing partial fields to patch specific fields only.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["id"],
              properties: {
                id: {
                  type: "string",
                  description: "ID of the template to be updated."
                },
                name: {
                  type: "string",
                  description: "Name of the template."
                },
                contentMarkdown: {
                  type: "string",
                  description: "Content of the template, markdown supported, can contain variable placeholders."
                },
                subject: {
                  type: "string",
                  description: "Subject of the message, used in emails."
                },
                updatedBy: {
                  type: "string",
                  format: "did",
                  description: "DID of the user who is updating the template."
                },
                disabled: {
                  type: "boolean"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.communication.defs#templateView"
            }
          }
        }
      }
    },
    ToolsOzoneModerationDefs: {
      lexicon: 1,
      id: "tools.ozone.moderation.defs",
      defs: {
        modEventView: {
          type: "object",
          required: [
            "id",
            "event",
            "subject",
            "subjectBlobCids",
            "createdBy",
            "createdAt"
          ],
          properties: {
            id: {
              type: "integer"
            },
            event: {
              type: "union",
              refs: [
                "lex:tools.ozone.moderation.defs#modEventTakedown",
                "lex:tools.ozone.moderation.defs#modEventReverseTakedown",
                "lex:tools.ozone.moderation.defs#modEventComment",
                "lex:tools.ozone.moderation.defs#modEventReport",
                "lex:tools.ozone.moderation.defs#modEventLabel",
                "lex:tools.ozone.moderation.defs#modEventAcknowledge",
                "lex:tools.ozone.moderation.defs#modEventEscalate",
                "lex:tools.ozone.moderation.defs#modEventMute",
                "lex:tools.ozone.moderation.defs#modEventUnmute",
                "lex:tools.ozone.moderation.defs#modEventMuteReporter",
                "lex:tools.ozone.moderation.defs#modEventUnmuteReporter",
                "lex:tools.ozone.moderation.defs#modEventEmail",
                "lex:tools.ozone.moderation.defs#modEventResolveAppeal",
                "lex:tools.ozone.moderation.defs#modEventDivert",
                "lex:tools.ozone.moderation.defs#modEventTag"
              ]
            },
            subject: {
              type: "union",
              refs: [
                "lex:com.atproto.admin.defs#repoRef",
                "lex:com.atproto.repo.strongRef",
                "lex:chat.bsky.convo.defs#messageRef"
              ]
            },
            subjectBlobCids: {
              type: "array",
              items: {
                type: "string"
              }
            },
            createdBy: {
              type: "string",
              format: "did"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            creatorHandle: {
              type: "string"
            },
            subjectHandle: {
              type: "string"
            }
          }
        },
        modEventViewDetail: {
          type: "object",
          required: [
            "id",
            "event",
            "subject",
            "subjectBlobs",
            "createdBy",
            "createdAt"
          ],
          properties: {
            id: {
              type: "integer"
            },
            event: {
              type: "union",
              refs: [
                "lex:tools.ozone.moderation.defs#modEventTakedown",
                "lex:tools.ozone.moderation.defs#modEventReverseTakedown",
                "lex:tools.ozone.moderation.defs#modEventComment",
                "lex:tools.ozone.moderation.defs#modEventReport",
                "lex:tools.ozone.moderation.defs#modEventLabel",
                "lex:tools.ozone.moderation.defs#modEventAcknowledge",
                "lex:tools.ozone.moderation.defs#modEventEscalate",
                "lex:tools.ozone.moderation.defs#modEventMute",
                "lex:tools.ozone.moderation.defs#modEventUnmute",
                "lex:tools.ozone.moderation.defs#modEventMuteReporter",
                "lex:tools.ozone.moderation.defs#modEventUnmuteReporter",
                "lex:tools.ozone.moderation.defs#modEventEmail",
                "lex:tools.ozone.moderation.defs#modEventResolveAppeal",
                "lex:tools.ozone.moderation.defs#modEventDivert",
                "lex:tools.ozone.moderation.defs#modEventTag"
              ]
            },
            subject: {
              type: "union",
              refs: [
                "lex:tools.ozone.moderation.defs#repoView",
                "lex:tools.ozone.moderation.defs#repoViewNotFound",
                "lex:tools.ozone.moderation.defs#recordView",
                "lex:tools.ozone.moderation.defs#recordViewNotFound"
              ]
            },
            subjectBlobs: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#blobView"
              }
            },
            createdBy: {
              type: "string",
              format: "did"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        subjectStatusView: {
          type: "object",
          required: ["id", "subject", "createdAt", "updatedAt", "reviewState"],
          properties: {
            id: {
              type: "integer"
            },
            subject: {
              type: "union",
              refs: [
                "lex:com.atproto.admin.defs#repoRef",
                "lex:com.atproto.repo.strongRef"
              ]
            },
            subjectBlobCids: {
              type: "array",
              items: {
                type: "string",
                format: "cid"
              }
            },
            subjectRepoHandle: {
              type: "string"
            },
            updatedAt: {
              type: "string",
              format: "datetime",
              description: "Timestamp referencing when the last update was made to the moderation status of the subject"
            },
            createdAt: {
              type: "string",
              format: "datetime",
              description: "Timestamp referencing the first moderation status impacting event was emitted on the subject"
            },
            reviewState: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#subjectReviewState"
            },
            comment: {
              type: "string",
              description: "Sticky comment on the subject."
            },
            muteUntil: {
              type: "string",
              format: "datetime"
            },
            muteReportingUntil: {
              type: "string",
              format: "datetime"
            },
            lastReviewedBy: {
              type: "string",
              format: "did"
            },
            lastReviewedAt: {
              type: "string",
              format: "datetime"
            },
            lastReportedAt: {
              type: "string",
              format: "datetime"
            },
            lastAppealedAt: {
              type: "string",
              format: "datetime",
              description: "Timestamp referencing when the author of the subject appealed a moderation action"
            },
            takendown: {
              type: "boolean"
            },
            appealed: {
              type: "boolean",
              description: "True indicates that the a previously taken moderator action was appealed against, by the author of the content. False indicates last appeal was resolved by moderators."
            },
            suspendUntil: {
              type: "string",
              format: "datetime"
            },
            tags: {
              type: "array",
              items: {
                type: "string"
              }
            }
          }
        },
        subjectReviewState: {
          type: "string",
          knownValues: [
            "lex:tools.ozone.moderation.defs#reviewOpen",
            "lex:tools.ozone.moderation.defs#reviewEscalated",
            "lex:tools.ozone.moderation.defs#reviewClosed",
            "lex:tools.ozone.moderation.defs#reviewNone"
          ]
        },
        reviewOpen: {
          type: "token",
          description: "Moderator review status of a subject: Open. Indicates that the subject needs to be reviewed by a moderator"
        },
        reviewEscalated: {
          type: "token",
          description: "Moderator review status of a subject: Escalated. Indicates that the subject was escalated for review by a moderator"
        },
        reviewClosed: {
          type: "token",
          description: "Moderator review status of a subject: Closed. Indicates that the subject was already reviewed and resolved by a moderator"
        },
        reviewNone: {
          type: "token",
          description: "Moderator review status of a subject: Unnecessary. Indicates that the subject does not need a review at the moment but there is probably some moderation related metadata available for it"
        },
        modEventTakedown: {
          type: "object",
          description: "Take down a subject permanently or temporarily",
          properties: {
            comment: {
              type: "string"
            },
            durationInHours: {
              type: "integer",
              description: "Indicates how long the takedown should be in effect before automatically expiring."
            }
          }
        },
        modEventReverseTakedown: {
          type: "object",
          description: "Revert take down action on a subject",
          properties: {
            comment: {
              type: "string",
              description: "Describe reasoning behind the reversal."
            }
          }
        },
        modEventResolveAppeal: {
          type: "object",
          description: "Resolve appeal on a subject",
          properties: {
            comment: {
              type: "string",
              description: "Describe resolution."
            }
          }
        },
        modEventComment: {
          type: "object",
          description: "Add a comment to a subject",
          required: ["comment"],
          properties: {
            comment: {
              type: "string"
            },
            sticky: {
              type: "boolean",
              description: "Make the comment persistent on the subject"
            }
          }
        },
        modEventReport: {
          type: "object",
          description: "Report a subject",
          required: ["reportType"],
          properties: {
            comment: {
              type: "string"
            },
            isReporterMuted: {
              type: "boolean",
              description: "Set to true if the reporter was muted from reporting at the time of the event. These reports won't impact the reviewState of the subject."
            },
            reportType: {
              type: "ref",
              ref: "lex:com.atproto.moderation.defs#reasonType"
            }
          }
        },
        modEventLabel: {
          type: "object",
          description: "Apply/Negate labels on a subject",
          required: ["createLabelVals", "negateLabelVals"],
          properties: {
            comment: {
              type: "string"
            },
            createLabelVals: {
              type: "array",
              items: {
                type: "string"
              }
            },
            negateLabelVals: {
              type: "array",
              items: {
                type: "string"
              }
            }
          }
        },
        modEventAcknowledge: {
          type: "object",
          properties: {
            comment: {
              type: "string"
            }
          }
        },
        modEventEscalate: {
          type: "object",
          properties: {
            comment: {
              type: "string"
            }
          }
        },
        modEventMute: {
          type: "object",
          description: "Mute incoming reports on a subject",
          required: ["durationInHours"],
          properties: {
            comment: {
              type: "string"
            },
            durationInHours: {
              type: "integer",
              description: "Indicates how long the subject should remain muted."
            }
          }
        },
        modEventUnmute: {
          type: "object",
          description: "Unmute action on a subject",
          properties: {
            comment: {
              type: "string",
              description: "Describe reasoning behind the reversal."
            }
          }
        },
        modEventMuteReporter: {
          type: "object",
          description: "Mute incoming reports from an account",
          required: ["durationInHours"],
          properties: {
            comment: {
              type: "string"
            },
            durationInHours: {
              type: "integer",
              description: "Indicates how long the account should remain muted."
            }
          }
        },
        modEventUnmuteReporter: {
          type: "object",
          description: "Unmute incoming reports from an account",
          properties: {
            comment: {
              type: "string",
              description: "Describe reasoning behind the reversal."
            }
          }
        },
        modEventEmail: {
          type: "object",
          description: "Keep a log of outgoing email to a user",
          required: ["subjectLine"],
          properties: {
            subjectLine: {
              type: "string",
              description: "The subject line of the email sent to the user."
            },
            content: {
              type: "string",
              description: "The content of the email sent to the user."
            },
            comment: {
              type: "string",
              description: "Additional comment about the outgoing comm."
            }
          }
        },
        modEventDivert: {
          type: "object",
          description: "Divert a record's blobs to a 3rd party service for further scanning/tagging",
          properties: {
            comment: {
              type: "string"
            }
          }
        },
        modEventTag: {
          type: "object",
          description: "Add/Remove a tag on a subject",
          required: ["add", "remove"],
          properties: {
            add: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Tags to be added to the subject. If already exists, won't be duplicated."
            },
            remove: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Tags to be removed to the subject. Ignores a tag If it doesn't exist, won't be duplicated."
            },
            comment: {
              type: "string",
              description: "Additional comment about added/removed tags."
            }
          }
        },
        repoView: {
          type: "object",
          required: [
            "did",
            "handle",
            "relatedRecords",
            "indexedAt",
            "moderation"
          ],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            email: {
              type: "string"
            },
            relatedRecords: {
              type: "array",
              items: {
                type: "unknown"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            moderation: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#moderation"
            },
            invitedBy: {
              type: "ref",
              ref: "lex:com.atproto.server.defs#inviteCode"
            },
            invitesDisabled: {
              type: "boolean"
            },
            inviteNote: {
              type: "string"
            },
            deactivatedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        repoViewDetail: {
          type: "object",
          required: [
            "did",
            "handle",
            "relatedRecords",
            "indexedAt",
            "moderation"
          ],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            email: {
              type: "string"
            },
            relatedRecords: {
              type: "array",
              items: {
                type: "unknown"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            moderation: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#moderationDetail"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            invitedBy: {
              type: "ref",
              ref: "lex:com.atproto.server.defs#inviteCode"
            },
            invites: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.server.defs#inviteCode"
              }
            },
            invitesDisabled: {
              type: "boolean"
            },
            inviteNote: {
              type: "string"
            },
            emailConfirmedAt: {
              type: "string",
              format: "datetime"
            },
            deactivatedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        repoViewNotFound: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        },
        recordView: {
          type: "object",
          required: [
            "uri",
            "cid",
            "value",
            "blobCids",
            "indexedAt",
            "moderation",
            "repo"
          ],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            value: {
              type: "unknown"
            },
            blobCids: {
              type: "array",
              items: {
                type: "string",
                format: "cid"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            moderation: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#moderation"
            },
            repo: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#repoView"
            }
          }
        },
        recordViewDetail: {
          type: "object",
          required: [
            "uri",
            "cid",
            "value",
            "blobs",
            "indexedAt",
            "moderation",
            "repo"
          ],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            value: {
              type: "unknown"
            },
            blobs: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#blobView"
              }
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            moderation: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#moderationDetail"
            },
            repo: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#repoView"
            }
          }
        },
        recordViewNotFound: {
          type: "object",
          required: ["uri"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        moderation: {
          type: "object",
          properties: {
            subjectStatus: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#subjectStatusView"
            }
          }
        },
        moderationDetail: {
          type: "object",
          properties: {
            subjectStatus: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#subjectStatusView"
            }
          }
        },
        blobView: {
          type: "object",
          required: ["cid", "mimeType", "size", "createdAt"],
          properties: {
            cid: {
              type: "string",
              format: "cid"
            },
            mimeType: {
              type: "string"
            },
            size: {
              type: "integer"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            details: {
              type: "union",
              refs: [
                "lex:tools.ozone.moderation.defs#imageDetails",
                "lex:tools.ozone.moderation.defs#videoDetails"
              ]
            },
            moderation: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#moderation"
            }
          }
        },
        imageDetails: {
          type: "object",
          required: ["width", "height"],
          properties: {
            width: {
              type: "integer"
            },
            height: {
              type: "integer"
            }
          }
        },
        videoDetails: {
          type: "object",
          required: ["width", "height", "length"],
          properties: {
            width: {
              type: "integer"
            },
            height: {
              type: "integer"
            },
            length: {
              type: "integer"
            }
          }
        }
      }
    },
    ToolsOzoneModerationEmitEvent: {
      lexicon: 1,
      id: "tools.ozone.moderation.emitEvent",
      defs: {
        main: {
          type: "procedure",
          description: "Take a moderation action on an actor.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["event", "subject", "createdBy"],
              properties: {
                event: {
                  type: "union",
                  refs: [
                    "lex:tools.ozone.moderation.defs#modEventTakedown",
                    "lex:tools.ozone.moderation.defs#modEventAcknowledge",
                    "lex:tools.ozone.moderation.defs#modEventEscalate",
                    "lex:tools.ozone.moderation.defs#modEventComment",
                    "lex:tools.ozone.moderation.defs#modEventLabel",
                    "lex:tools.ozone.moderation.defs#modEventReport",
                    "lex:tools.ozone.moderation.defs#modEventMute",
                    "lex:tools.ozone.moderation.defs#modEventUnmute",
                    "lex:tools.ozone.moderation.defs#modEventMuteReporter",
                    "lex:tools.ozone.moderation.defs#modEventUnmuteReporter",
                    "lex:tools.ozone.moderation.defs#modEventReverseTakedown",
                    "lex:tools.ozone.moderation.defs#modEventEmail",
                    "lex:tools.ozone.moderation.defs#modEventTag"
                  ]
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                },
                subjectBlobCids: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "cid"
                  }
                },
                createdBy: {
                  type: "string",
                  format: "did"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#modEventView"
            }
          },
          errors: [
            {
              name: "SubjectHasAction"
            }
          ]
        }
      }
    },
    ToolsOzoneModerationGetEvent: {
      lexicon: 1,
      id: "tools.ozone.moderation.getEvent",
      defs: {
        main: {
          type: "query",
          description: "Get details about a moderation event.",
          parameters: {
            type: "params",
            required: ["id"],
            properties: {
              id: {
                type: "integer"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#modEventViewDetail"
            }
          }
        }
      }
    },
    ToolsOzoneModerationGetRecord: {
      lexicon: 1,
      id: "tools.ozone.moderation.getRecord",
      defs: {
        main: {
          type: "query",
          description: "Get details about a record.",
          parameters: {
            type: "params",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#recordViewDetail"
            }
          },
          errors: [
            {
              name: "RecordNotFound"
            }
          ]
        }
      }
    },
    ToolsOzoneModerationGetRepo: {
      lexicon: 1,
      id: "tools.ozone.moderation.getRepo",
      defs: {
        main: {
          type: "query",
          description: "Get details about a repository.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#repoViewDetail"
            }
          },
          errors: [
            {
              name: "RepoNotFound"
            }
          ]
        }
      }
    },
    ToolsOzoneModerationQueryEvents: {
      lexicon: 1,
      id: "tools.ozone.moderation.queryEvents",
      defs: {
        main: {
          type: "query",
          description: "List moderation events related to a subject.",
          parameters: {
            type: "params",
            properties: {
              types: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "The types of events (fully qualified string in the format of tools.ozone.moderation.defs#modEvent<name>) to filter by. If not specified, all events are returned."
              },
              createdBy: {
                type: "string",
                format: "did"
              },
              sortDirection: {
                type: "string",
                default: "desc",
                enum: ["asc", "desc"],
                description: "Sort direction for the events. Defaults to descending order of created at timestamp."
              },
              createdAfter: {
                type: "string",
                format: "datetime",
                description: "Retrieve events created after a given timestamp"
              },
              createdBefore: {
                type: "string",
                format: "datetime",
                description: "Retrieve events created before a given timestamp"
              },
              subject: {
                type: "string",
                format: "uri"
              },
              includeAllUserRecords: {
                type: "boolean",
                default: !1,
                description: "If true, events on all record types (posts, lists, profile etc.) owned by the did are returned"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              hasComment: {
                type: "boolean",
                description: "If true, only events with comments are returned"
              },
              comment: {
                type: "string",
                description: "If specified, only events with comments containing the keyword are returned"
              },
              addedLabels: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "If specified, only events where all of these labels were added are returned"
              },
              removedLabels: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "If specified, only events where all of these labels were removed are returned"
              },
              addedTags: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "If specified, only events where all of these tags were added are returned"
              },
              removedTags: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "If specified, only events where all of these tags were removed are returned"
              },
              reportTypes: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["events"],
              properties: {
                cursor: {
                  type: "string"
                },
                events: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.moderation.defs#modEventView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneModerationQueryStatuses: {
      lexicon: 1,
      id: "tools.ozone.moderation.queryStatuses",
      defs: {
        main: {
          type: "query",
          description: "View moderation statuses of subjects (record or repo).",
          parameters: {
            type: "params",
            properties: {
              subject: {
                type: "string",
                format: "uri"
              },
              comment: {
                type: "string",
                description: "Search subjects by keyword from comments"
              },
              reportedAfter: {
                type: "string",
                format: "datetime",
                description: "Search subjects reported after a given timestamp"
              },
              reportedBefore: {
                type: "string",
                format: "datetime",
                description: "Search subjects reported before a given timestamp"
              },
              reviewedAfter: {
                type: "string",
                format: "datetime",
                description: "Search subjects reviewed after a given timestamp"
              },
              reviewedBefore: {
                type: "string",
                format: "datetime",
                description: "Search subjects reviewed before a given timestamp"
              },
              includeMuted: {
                type: "boolean",
                description: "By default, we don't include muted subjects in the results. Set this to true to include them."
              },
              onlyMuted: {
                type: "boolean",
                description: "When set to true, only muted subjects and reporters will be returned."
              },
              reviewState: {
                type: "string",
                description: "Specify when fetching subjects in a certain state"
              },
              ignoreSubjects: {
                type: "array",
                items: {
                  type: "string",
                  format: "uri"
                }
              },
              lastReviewedBy: {
                type: "string",
                format: "did",
                description: "Get all subject statuses that were reviewed by a specific moderator"
              },
              sortField: {
                type: "string",
                default: "lastReportedAt",
                enum: ["lastReviewedAt", "lastReportedAt"]
              },
              sortDirection: {
                type: "string",
                default: "desc",
                enum: ["asc", "desc"]
              },
              takendown: {
                type: "boolean",
                description: "Get subjects that were taken down"
              },
              appealed: {
                type: "boolean",
                description: "Get subjects in unresolved appealed status"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              tags: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              excludeTags: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subjectStatuses"],
              properties: {
                cursor: {
                  type: "string"
                },
                subjectStatuses: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.moderation.defs#subjectStatusView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneModerationSearchRepos: {
      lexicon: 1,
      id: "tools.ozone.moderation.searchRepos",
      defs: {
        main: {
          type: "query",
          description: "Find repositories based on a search term.",
          parameters: {
            type: "params",
            properties: {
              term: {
                type: "string",
                description: "DEPRECATED: use 'q' instead"
              },
              q: {
                type: "string"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repos"],
              properties: {
                cursor: {
                  type: "string"
                },
                repos: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.moderation.defs#repoView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneServerGetConfig: {
      lexicon: 1,
      id: "tools.ozone.server.getConfig",
      defs: {
        main: {
          type: "query",
          description: "Get details about ozone's server configuration.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                appview: {
                  type: "ref",
                  ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                },
                pds: {
                  type: "ref",
                  ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                },
                blobDivert: {
                  type: "ref",
                  ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                },
                chat: {
                  type: "ref",
                  ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:tools.ozone.server.getConfig#viewerConfig"
                }
              }
            }
          }
        },
        serviceConfig: {
          type: "object",
          properties: {
            url: {
              type: "string",
              format: "uri"
            }
          }
        },
        viewerConfig: {
          type: "object",
          properties: {
            role: {
              type: "string",
              knownValues: [
                "tools.ozone.team.defs#roleAdmin",
                "tools.ozone.team.defs#roleModerator",
                "tools.ozone.team.defs#roleTriage"
              ]
            }
          }
        }
      }
    },
    ToolsOzoneTeamAddMember: {
      lexicon: 1,
      id: "tools.ozone.team.addMember",
      defs: {
        main: {
          type: "procedure",
          description: "Add a member to the ozone team. Requires admin role.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "role"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                role: {
                  type: "string",
                  knownValues: [
                    "tools.ozone.team.defs#roleAdmin",
                    "tools.ozone.team.defs#roleModerator",
                    "tools.ozone.team.defs#roleTriage"
                  ]
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.team.defs#member"
            }
          },
          errors: [
            {
              name: "MemberAlreadyExists",
              description: "Member already exists in the team."
            }
          ]
        }
      }
    },
    ToolsOzoneTeamDefs: {
      lexicon: 1,
      id: "tools.ozone.team.defs",
      defs: {
        member: {
          type: "object",
          required: ["did", "role"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            disabled: {
              type: "boolean"
            },
            profile: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewDetailed"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            updatedAt: {
              type: "string",
              format: "datetime"
            },
            lastUpdatedBy: {
              type: "string"
            },
            role: {
              type: "string",
              knownValues: [
                "lex:tools.ozone.team.defs#roleAdmin",
                "lex:tools.ozone.team.defs#roleModerator",
                "lex:tools.ozone.team.defs#roleTriage"
              ]
            }
          }
        },
        roleAdmin: {
          type: "token",
          description: "Admin role. Highest level of access, can perform all actions."
        },
        roleModerator: {
          type: "token",
          description: "Moderator role. Can perform most actions."
        },
        roleTriage: {
          type: "token",
          description: "Triage role. Mostly intended for monitoring and escalating issues."
        }
      }
    },
    ToolsOzoneTeamDeleteMember: {
      lexicon: 1,
      id: "tools.ozone.team.deleteMember",
      defs: {
        main: {
          type: "procedure",
          description: "Delete a member from ozone team. Requires admin role.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            }
          },
          errors: [
            {
              name: "MemberNotFound",
              description: "The member being deleted does not exist"
            },
            {
              name: "CannotDeleteSelf",
              description: "You can not delete yourself from the team"
            }
          ]
        }
      }
    },
    ToolsOzoneTeamListMembers: {
      lexicon: 1,
      id: "tools.ozone.team.listMembers",
      defs: {
        main: {
          type: "query",
          description: "List all members with access to the ozone service.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["members"],
              properties: {
                cursor: {
                  type: "string"
                },
                members: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.team.defs#member"
                  }
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneTeamUpdateMember: {
      lexicon: 1,
      id: "tools.ozone.team.updateMember",
      defs: {
        main: {
          type: "procedure",
          description: "Update a member in the ozone service. Requires admin role.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                disabled: {
                  type: "boolean"
                },
                role: {
                  type: "string",
                  knownValues: [
                    "tools.ozone.team.defs#roleAdmin",
                    "tools.ozone.team.defs#roleModerator",
                    "tools.ozone.team.defs#roleTriage"
                  ]
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.team.defs#member"
            }
          },
          errors: [
            {
              name: "MemberNotFound",
              description: "The member being updated does not exist in the team"
            }
          ]
        }
      }
    }
  }, t.schemas = Object.values(t.schemaDict), t.lexicons = new e.Lexicons(t.schemas), t.ids = {
    ComAtprotoAdminDefs: "com.atproto.admin.defs",
    ComAtprotoAdminDeleteAccount: "com.atproto.admin.deleteAccount",
    ComAtprotoAdminDisableAccountInvites: "com.atproto.admin.disableAccountInvites",
    ComAtprotoAdminDisableInviteCodes: "com.atproto.admin.disableInviteCodes",
    ComAtprotoAdminEnableAccountInvites: "com.atproto.admin.enableAccountInvites",
    ComAtprotoAdminGetAccountInfo: "com.atproto.admin.getAccountInfo",
    ComAtprotoAdminGetAccountInfos: "com.atproto.admin.getAccountInfos",
    ComAtprotoAdminGetInviteCodes: "com.atproto.admin.getInviteCodes",
    ComAtprotoAdminGetSubjectStatus: "com.atproto.admin.getSubjectStatus",
    ComAtprotoAdminSearchAccounts: "com.atproto.admin.searchAccounts",
    ComAtprotoAdminSendEmail: "com.atproto.admin.sendEmail",
    ComAtprotoAdminUpdateAccountEmail: "com.atproto.admin.updateAccountEmail",
    ComAtprotoAdminUpdateAccountHandle: "com.atproto.admin.updateAccountHandle",
    ComAtprotoAdminUpdateAccountPassword: "com.atproto.admin.updateAccountPassword",
    ComAtprotoAdminUpdateSubjectStatus: "com.atproto.admin.updateSubjectStatus",
    ComAtprotoIdentityGetRecommendedDidCredentials: "com.atproto.identity.getRecommendedDidCredentials",
    ComAtprotoIdentityRequestPlcOperationSignature: "com.atproto.identity.requestPlcOperationSignature",
    ComAtprotoIdentityResolveHandle: "com.atproto.identity.resolveHandle",
    ComAtprotoIdentitySignPlcOperation: "com.atproto.identity.signPlcOperation",
    ComAtprotoIdentitySubmitPlcOperation: "com.atproto.identity.submitPlcOperation",
    ComAtprotoIdentityUpdateHandle: "com.atproto.identity.updateHandle",
    ComAtprotoLabelDefs: "com.atproto.label.defs",
    ComAtprotoLabelQueryLabels: "com.atproto.label.queryLabels",
    ComAtprotoLabelSubscribeLabels: "com.atproto.label.subscribeLabels",
    ComAtprotoModerationCreateReport: "com.atproto.moderation.createReport",
    ComAtprotoModerationDefs: "com.atproto.moderation.defs",
    ComAtprotoRepoApplyWrites: "com.atproto.repo.applyWrites",
    ComAtprotoRepoCreateRecord: "com.atproto.repo.createRecord",
    ComAtprotoRepoDeleteRecord: "com.atproto.repo.deleteRecord",
    ComAtprotoRepoDescribeRepo: "com.atproto.repo.describeRepo",
    ComAtprotoRepoGetRecord: "com.atproto.repo.getRecord",
    ComAtprotoRepoImportRepo: "com.atproto.repo.importRepo",
    ComAtprotoRepoListMissingBlobs: "com.atproto.repo.listMissingBlobs",
    ComAtprotoRepoListRecords: "com.atproto.repo.listRecords",
    ComAtprotoRepoPutRecord: "com.atproto.repo.putRecord",
    ComAtprotoRepoStrongRef: "com.atproto.repo.strongRef",
    ComAtprotoRepoUploadBlob: "com.atproto.repo.uploadBlob",
    ComAtprotoServerActivateAccount: "com.atproto.server.activateAccount",
    ComAtprotoServerCheckAccountStatus: "com.atproto.server.checkAccountStatus",
    ComAtprotoServerConfirmEmail: "com.atproto.server.confirmEmail",
    ComAtprotoServerCreateAccount: "com.atproto.server.createAccount",
    ComAtprotoServerCreateAppPassword: "com.atproto.server.createAppPassword",
    ComAtprotoServerCreateInviteCode: "com.atproto.server.createInviteCode",
    ComAtprotoServerCreateInviteCodes: "com.atproto.server.createInviteCodes",
    ComAtprotoServerCreateSession: "com.atproto.server.createSession",
    ComAtprotoServerDeactivateAccount: "com.atproto.server.deactivateAccount",
    ComAtprotoServerDefs: "com.atproto.server.defs",
    ComAtprotoServerDeleteAccount: "com.atproto.server.deleteAccount",
    ComAtprotoServerDeleteSession: "com.atproto.server.deleteSession",
    ComAtprotoServerDescribeServer: "com.atproto.server.describeServer",
    ComAtprotoServerGetAccountInviteCodes: "com.atproto.server.getAccountInviteCodes",
    ComAtprotoServerGetServiceAuth: "com.atproto.server.getServiceAuth",
    ComAtprotoServerGetSession: "com.atproto.server.getSession",
    ComAtprotoServerListAppPasswords: "com.atproto.server.listAppPasswords",
    ComAtprotoServerRefreshSession: "com.atproto.server.refreshSession",
    ComAtprotoServerRequestAccountDelete: "com.atproto.server.requestAccountDelete",
    ComAtprotoServerRequestEmailConfirmation: "com.atproto.server.requestEmailConfirmation",
    ComAtprotoServerRequestEmailUpdate: "com.atproto.server.requestEmailUpdate",
    ComAtprotoServerRequestPasswordReset: "com.atproto.server.requestPasswordReset",
    ComAtprotoServerReserveSigningKey: "com.atproto.server.reserveSigningKey",
    ComAtprotoServerResetPassword: "com.atproto.server.resetPassword",
    ComAtprotoServerRevokeAppPassword: "com.atproto.server.revokeAppPassword",
    ComAtprotoServerUpdateEmail: "com.atproto.server.updateEmail",
    ComAtprotoSyncGetBlob: "com.atproto.sync.getBlob",
    ComAtprotoSyncGetBlocks: "com.atproto.sync.getBlocks",
    ComAtprotoSyncGetCheckout: "com.atproto.sync.getCheckout",
    ComAtprotoSyncGetHead: "com.atproto.sync.getHead",
    ComAtprotoSyncGetLatestCommit: "com.atproto.sync.getLatestCommit",
    ComAtprotoSyncGetRecord: "com.atproto.sync.getRecord",
    ComAtprotoSyncGetRepo: "com.atproto.sync.getRepo",
    ComAtprotoSyncGetRepoStatus: "com.atproto.sync.getRepoStatus",
    ComAtprotoSyncListBlobs: "com.atproto.sync.listBlobs",
    ComAtprotoSyncListRepos: "com.atproto.sync.listRepos",
    ComAtprotoSyncNotifyOfUpdate: "com.atproto.sync.notifyOfUpdate",
    ComAtprotoSyncRequestCrawl: "com.atproto.sync.requestCrawl",
    ComAtprotoSyncSubscribeRepos: "com.atproto.sync.subscribeRepos",
    ComAtprotoTempCheckSignupQueue: "com.atproto.temp.checkSignupQueue",
    ComAtprotoTempFetchLabels: "com.atproto.temp.fetchLabels",
    ComAtprotoTempRequestPhoneVerification: "com.atproto.temp.requestPhoneVerification",
    AppBskyActorDefs: "app.bsky.actor.defs",
    AppBskyActorGetPreferences: "app.bsky.actor.getPreferences",
    AppBskyActorGetProfile: "app.bsky.actor.getProfile",
    AppBskyActorGetProfiles: "app.bsky.actor.getProfiles",
    AppBskyActorGetSuggestions: "app.bsky.actor.getSuggestions",
    AppBskyActorProfile: "app.bsky.actor.profile",
    AppBskyActorPutPreferences: "app.bsky.actor.putPreferences",
    AppBskyActorSearchActors: "app.bsky.actor.searchActors",
    AppBskyActorSearchActorsTypeahead: "app.bsky.actor.searchActorsTypeahead",
    AppBskyEmbedExternal: "app.bsky.embed.external",
    AppBskyEmbedImages: "app.bsky.embed.images",
    AppBskyEmbedRecord: "app.bsky.embed.record",
    AppBskyEmbedRecordWithMedia: "app.bsky.embed.recordWithMedia",
    AppBskyFeedDefs: "app.bsky.feed.defs",
    AppBskyFeedDescribeFeedGenerator: "app.bsky.feed.describeFeedGenerator",
    AppBskyFeedGenerator: "app.bsky.feed.generator",
    AppBskyFeedGetActorFeeds: "app.bsky.feed.getActorFeeds",
    AppBskyFeedGetActorLikes: "app.bsky.feed.getActorLikes",
    AppBskyFeedGetAuthorFeed: "app.bsky.feed.getAuthorFeed",
    AppBskyFeedGetFeed: "app.bsky.feed.getFeed",
    AppBskyFeedGetFeedGenerator: "app.bsky.feed.getFeedGenerator",
    AppBskyFeedGetFeedGenerators: "app.bsky.feed.getFeedGenerators",
    AppBskyFeedGetFeedSkeleton: "app.bsky.feed.getFeedSkeleton",
    AppBskyFeedGetLikes: "app.bsky.feed.getLikes",
    AppBskyFeedGetListFeed: "app.bsky.feed.getListFeed",
    AppBskyFeedGetPostThread: "app.bsky.feed.getPostThread",
    AppBskyFeedGetPosts: "app.bsky.feed.getPosts",
    AppBskyFeedGetRepostedBy: "app.bsky.feed.getRepostedBy",
    AppBskyFeedGetSuggestedFeeds: "app.bsky.feed.getSuggestedFeeds",
    AppBskyFeedGetTimeline: "app.bsky.feed.getTimeline",
    AppBskyFeedLike: "app.bsky.feed.like",
    AppBskyFeedPost: "app.bsky.feed.post",
    AppBskyFeedRepost: "app.bsky.feed.repost",
    AppBskyFeedSearchPosts: "app.bsky.feed.searchPosts",
    AppBskyFeedSendInteractions: "app.bsky.feed.sendInteractions",
    AppBskyFeedThreadgate: "app.bsky.feed.threadgate",
    AppBskyGraphBlock: "app.bsky.graph.block",
    AppBskyGraphDefs: "app.bsky.graph.defs",
    AppBskyGraphFollow: "app.bsky.graph.follow",
    AppBskyGraphGetActorStarterPacks: "app.bsky.graph.getActorStarterPacks",
    AppBskyGraphGetBlocks: "app.bsky.graph.getBlocks",
    AppBskyGraphGetFollowers: "app.bsky.graph.getFollowers",
    AppBskyGraphGetFollows: "app.bsky.graph.getFollows",
    AppBskyGraphGetKnownFollowers: "app.bsky.graph.getKnownFollowers",
    AppBskyGraphGetList: "app.bsky.graph.getList",
    AppBskyGraphGetListBlocks: "app.bsky.graph.getListBlocks",
    AppBskyGraphGetListMutes: "app.bsky.graph.getListMutes",
    AppBskyGraphGetLists: "app.bsky.graph.getLists",
    AppBskyGraphGetMutes: "app.bsky.graph.getMutes",
    AppBskyGraphGetRelationships: "app.bsky.graph.getRelationships",
    AppBskyGraphGetStarterPack: "app.bsky.graph.getStarterPack",
    AppBskyGraphGetStarterPacks: "app.bsky.graph.getStarterPacks",
    AppBskyGraphGetSuggestedFollowsByActor: "app.bsky.graph.getSuggestedFollowsByActor",
    AppBskyGraphList: "app.bsky.graph.list",
    AppBskyGraphListblock: "app.bsky.graph.listblock",
    AppBskyGraphListitem: "app.bsky.graph.listitem",
    AppBskyGraphMuteActor: "app.bsky.graph.muteActor",
    AppBskyGraphMuteActorList: "app.bsky.graph.muteActorList",
    AppBskyGraphMuteThread: "app.bsky.graph.muteThread",
    AppBskyGraphStarterpack: "app.bsky.graph.starterpack",
    AppBskyGraphUnmuteActor: "app.bsky.graph.unmuteActor",
    AppBskyGraphUnmuteActorList: "app.bsky.graph.unmuteActorList",
    AppBskyGraphUnmuteThread: "app.bsky.graph.unmuteThread",
    AppBskyLabelerDefs: "app.bsky.labeler.defs",
    AppBskyLabelerGetServices: "app.bsky.labeler.getServices",
    AppBskyLabelerService: "app.bsky.labeler.service",
    AppBskyNotificationGetUnreadCount: "app.bsky.notification.getUnreadCount",
    AppBskyNotificationListNotifications: "app.bsky.notification.listNotifications",
    AppBskyNotificationPutPreferences: "app.bsky.notification.putPreferences",
    AppBskyNotificationRegisterPush: "app.bsky.notification.registerPush",
    AppBskyNotificationUpdateSeen: "app.bsky.notification.updateSeen",
    AppBskyRichtextFacet: "app.bsky.richtext.facet",
    AppBskyUnspeccedDefs: "app.bsky.unspecced.defs",
    AppBskyUnspeccedGetPopularFeedGenerators: "app.bsky.unspecced.getPopularFeedGenerators",
    AppBskyUnspeccedGetSuggestionsSkeleton: "app.bsky.unspecced.getSuggestionsSkeleton",
    AppBskyUnspeccedGetTaggedSuggestions: "app.bsky.unspecced.getTaggedSuggestions",
    AppBskyUnspeccedSearchActorsSkeleton: "app.bsky.unspecced.searchActorsSkeleton",
    AppBskyUnspeccedSearchPostsSkeleton: "app.bsky.unspecced.searchPostsSkeleton",
    ChatBskyActorDeclaration: "chat.bsky.actor.declaration",
    ChatBskyActorDefs: "chat.bsky.actor.defs",
    ChatBskyActorDeleteAccount: "chat.bsky.actor.deleteAccount",
    ChatBskyActorExportAccountData: "chat.bsky.actor.exportAccountData",
    ChatBskyConvoDefs: "chat.bsky.convo.defs",
    ChatBskyConvoDeleteMessageForSelf: "chat.bsky.convo.deleteMessageForSelf",
    ChatBskyConvoGetConvo: "chat.bsky.convo.getConvo",
    ChatBskyConvoGetConvoForMembers: "chat.bsky.convo.getConvoForMembers",
    ChatBskyConvoGetLog: "chat.bsky.convo.getLog",
    ChatBskyConvoGetMessages: "chat.bsky.convo.getMessages",
    ChatBskyConvoLeaveConvo: "chat.bsky.convo.leaveConvo",
    ChatBskyConvoListConvos: "chat.bsky.convo.listConvos",
    ChatBskyConvoMuteConvo: "chat.bsky.convo.muteConvo",
    ChatBskyConvoSendMessage: "chat.bsky.convo.sendMessage",
    ChatBskyConvoSendMessageBatch: "chat.bsky.convo.sendMessageBatch",
    ChatBskyConvoUnmuteConvo: "chat.bsky.convo.unmuteConvo",
    ChatBskyConvoUpdateRead: "chat.bsky.convo.updateRead",
    ChatBskyModerationGetActorMetadata: "chat.bsky.moderation.getActorMetadata",
    ChatBskyModerationGetMessageContext: "chat.bsky.moderation.getMessageContext",
    ChatBskyModerationUpdateActorAccess: "chat.bsky.moderation.updateActorAccess",
    ToolsOzoneCommunicationCreateTemplate: "tools.ozone.communication.createTemplate",
    ToolsOzoneCommunicationDefs: "tools.ozone.communication.defs",
    ToolsOzoneCommunicationDeleteTemplate: "tools.ozone.communication.deleteTemplate",
    ToolsOzoneCommunicationListTemplates: "tools.ozone.communication.listTemplates",
    ToolsOzoneCommunicationUpdateTemplate: "tools.ozone.communication.updateTemplate",
    ToolsOzoneModerationDefs: "tools.ozone.moderation.defs",
    ToolsOzoneModerationEmitEvent: "tools.ozone.moderation.emitEvent",
    ToolsOzoneModerationGetEvent: "tools.ozone.moderation.getEvent",
    ToolsOzoneModerationGetRecord: "tools.ozone.moderation.getRecord",
    ToolsOzoneModerationGetRepo: "tools.ozone.moderation.getRepo",
    ToolsOzoneModerationQueryEvents: "tools.ozone.moderation.queryEvents",
    ToolsOzoneModerationQueryStatuses: "tools.ozone.moderation.queryStatuses",
    ToolsOzoneModerationSearchRepos: "tools.ozone.moderation.searchRepos",
    ToolsOzoneServerGetConfig: "tools.ozone.server.getConfig",
    ToolsOzoneTeamAddMember: "tools.ozone.team.addMember",
    ToolsOzoneTeamDefs: "tools.ozone.team.defs",
    ToolsOzoneTeamDeleteMember: "tools.ozone.team.deleteMember",
    ToolsOzoneTeamListMembers: "tools.ozone.team.listMembers",
    ToolsOzoneTeamUpdateMember: "tools.ozone.team.updateMember"
  };
})($);
var gn = {};
Object.defineProperty(gn, "__esModule", { value: !0 });
gn.toKnownErr = void 0;
const A0 = v;
function w0(t) {
  return t instanceof A0.XRPCError, t;
}
gn.toKnownErr = w0;
var Rn = {};
Object.defineProperty(Rn, "__esModule", { value: !0 });
Rn.toKnownErr = void 0;
const C0 = v;
function _0(t) {
  return t instanceof C0.XRPCError, t;
}
Rn.toKnownErr = _0;
var vn = {};
Object.defineProperty(vn, "__esModule", { value: !0 });
vn.toKnownErr = void 0;
const T0 = v;
function S0(t) {
  return t instanceof T0.XRPCError, t;
}
vn.toKnownErr = S0;
var An = {};
Object.defineProperty(An, "__esModule", { value: !0 });
An.toKnownErr = void 0;
const L0 = v;
function k0(t) {
  return t instanceof L0.XRPCError, t;
}
An.toKnownErr = k0;
var wn = {};
Object.defineProperty(wn, "__esModule", { value: !0 });
wn.toKnownErr = void 0;
const B0 = v;
function P0(t) {
  return t instanceof B0.XRPCError, t;
}
wn.toKnownErr = P0;
var Cn = {};
Object.defineProperty(Cn, "__esModule", { value: !0 });
Cn.toKnownErr = void 0;
const D0 = v;
function K0(t) {
  return t instanceof D0.XRPCError, t;
}
Cn.toKnownErr = K0;
var _n = {};
Object.defineProperty(_n, "__esModule", { value: !0 });
_n.toKnownErr = void 0;
const U0 = v;
function V0(t) {
  return t instanceof U0.XRPCError, t;
}
_n.toKnownErr = V0;
var Tn = {};
Object.defineProperty(Tn, "__esModule", { value: !0 });
Tn.toKnownErr = void 0;
const I0 = v;
function j0(t) {
  return t instanceof I0.XRPCError, t;
}
Tn.toKnownErr = j0;
var Sn = {};
Object.defineProperty(Sn, "__esModule", { value: !0 });
Sn.toKnownErr = void 0;
const O0 = v;
function M0(t) {
  return t instanceof O0.XRPCError, t;
}
Sn.toKnownErr = M0;
var Ln = {};
Object.defineProperty(Ln, "__esModule", { value: !0 });
Ln.toKnownErr = void 0;
const N0 = v;
function $0(t) {
  return t instanceof N0.XRPCError, t;
}
Ln.toKnownErr = $0;
var kn = {};
Object.defineProperty(kn, "__esModule", { value: !0 });
kn.toKnownErr = void 0;
const G0 = v;
function q0(t) {
  return t instanceof G0.XRPCError, t;
}
kn.toKnownErr = q0;
var Bn = {};
Object.defineProperty(Bn, "__esModule", { value: !0 });
Bn.toKnownErr = void 0;
const F0 = v;
function z0(t) {
  return t instanceof F0.XRPCError, t;
}
Bn.toKnownErr = z0;
var Pn = {};
Object.defineProperty(Pn, "__esModule", { value: !0 });
Pn.toKnownErr = void 0;
const X0 = v;
function Z0(t) {
  return t instanceof X0.XRPCError, t;
}
Pn.toKnownErr = Z0;
var Dn = {};
Object.defineProperty(Dn, "__esModule", { value: !0 });
Dn.toKnownErr = void 0;
const H0 = v;
function W0(t) {
  return t instanceof H0.XRPCError, t;
}
Dn.toKnownErr = W0;
var Kn = {};
Object.defineProperty(Kn, "__esModule", { value: !0 });
Kn.toKnownErr = void 0;
const J0 = v;
function Q0(t) {
  return t instanceof J0.XRPCError, t;
}
Kn.toKnownErr = Q0;
var Un = {};
Object.defineProperty(Un, "__esModule", { value: !0 });
Un.toKnownErr = void 0;
const Y0 = v;
function eE(t) {
  return t instanceof Y0.XRPCError, t;
}
Un.toKnownErr = eE;
var Vn = {};
Object.defineProperty(Vn, "__esModule", { value: !0 });
Vn.toKnownErr = void 0;
const tE = v;
function rE(t) {
  return t instanceof tE.XRPCError, t;
}
Vn.toKnownErr = rE;
var In = {};
Object.defineProperty(In, "__esModule", { value: !0 });
In.toKnownErr = void 0;
const iE = v;
function nE(t) {
  return t instanceof iE.XRPCError, t;
}
In.toKnownErr = nE;
var jn = {};
Object.defineProperty(jn, "__esModule", { value: !0 });
jn.toKnownErr = void 0;
const sE = v;
function oE(t) {
  return t instanceof sE.XRPCError, t;
}
jn.toKnownErr = oE;
var On = {};
Object.defineProperty(On, "__esModule", { value: !0 });
On.toKnownErr = void 0;
const aE = v;
function lE(t) {
  return t instanceof aE.XRPCError, t;
}
On.toKnownErr = lE;
var Mn = {};
Object.defineProperty(Mn, "__esModule", { value: !0 });
Mn.toKnownErr = void 0;
const uE = v;
function cE(t) {
  return t instanceof uE.XRPCError, t;
}
Mn.toKnownErr = cE;
var Nn = {};
Object.defineProperty(Nn, "__esModule", { value: !0 });
Nn.toKnownErr = void 0;
const pE = v;
function dE(t) {
  return t instanceof pE.XRPCError, t;
}
Nn.toKnownErr = dE;
var ye = {}, N = {};
Object.defineProperty(N, "__esModule", { value: !0 });
N.hasProp = N.isObj = void 0;
function fE(t) {
  return typeof t == "object" && t !== null;
}
N.isObj = fE;
function yE(t, e) {
  return e in t;
}
N.hasProp = yE;
Object.defineProperty(ye, "__esModule", { value: !0 });
ye.validateDelete = ye.isDelete = ye.validateUpdate = ye.isUpdate = ye.validateCreate = ye.isCreate = ye.toKnownErr = ye.InvalidSwapError = void 0;
const Qc = v, Ri = N, Rl = $;
let Yc = class extends Qc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
ye.InvalidSwapError = Yc;
function mE(t) {
  return t instanceof Qc.XRPCError && t.error === "InvalidSwap" ? new Yc(t) : t;
}
ye.toKnownErr = mE;
function bE(t) {
  return (0, Ri.isObj)(t) && (0, Ri.hasProp)(t, "$type") && t.$type === "com.atproto.repo.applyWrites#create";
}
ye.isCreate = bE;
function hE(t) {
  return Rl.lexicons.validate("com.atproto.repo.applyWrites#create", t);
}
ye.validateCreate = hE;
function EE(t) {
  return (0, Ri.isObj)(t) && (0, Ri.hasProp)(t, "$type") && t.$type === "com.atproto.repo.applyWrites#update";
}
ye.isUpdate = EE;
function xE(t) {
  return Rl.lexicons.validate("com.atproto.repo.applyWrites#update", t);
}
ye.validateUpdate = xE;
function gE(t) {
  return (0, Ri.isObj)(t) && (0, Ri.hasProp)(t, "$type") && t.$type === "com.atproto.repo.applyWrites#delete";
}
ye.isDelete = gE;
function RE(t) {
  return Rl.lexicons.validate("com.atproto.repo.applyWrites#delete", t);
}
ye.validateDelete = RE;
var Or = {};
Object.defineProperty(Or, "__esModule", { value: !0 });
Or.toKnownErr = Or.InvalidSwapError = void 0;
const ep = v;
let tp = class extends ep.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Or.InvalidSwapError = tp;
function vE(t) {
  return t instanceof ep.XRPCError && t.error === "InvalidSwap" ? new tp(t) : t;
}
Or.toKnownErr = vE;
var Mr = {};
Object.defineProperty(Mr, "__esModule", { value: !0 });
Mr.toKnownErr = Mr.InvalidSwapError = void 0;
const rp = v;
let ip = class extends rp.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Mr.InvalidSwapError = ip;
function AE(t) {
  return t instanceof rp.XRPCError && t.error === "InvalidSwap" ? new ip(t) : t;
}
Mr.toKnownErr = AE;
var $n = {};
Object.defineProperty($n, "__esModule", { value: !0 });
$n.toKnownErr = void 0;
const wE = v;
function CE(t) {
  return t instanceof wE.XRPCError, t;
}
$n.toKnownErr = CE;
var Gn = {};
Object.defineProperty(Gn, "__esModule", { value: !0 });
Gn.toKnownErr = void 0;
const _E = v;
function TE(t) {
  return t instanceof _E.XRPCError, t;
}
Gn.toKnownErr = TE;
var qn = {};
Object.defineProperty(qn, "__esModule", { value: !0 });
qn.toKnownErr = void 0;
const SE = v;
function LE(t) {
  return t instanceof SE.XRPCError, t;
}
qn.toKnownErr = LE;
var Ht = {};
Object.defineProperty(Ht, "__esModule", { value: !0 });
Ht.validateRecordBlob = Ht.isRecordBlob = Ht.toKnownErr = void 0;
const kE = v, ru = N, BE = $;
function PE(t) {
  return t instanceof kE.XRPCError, t;
}
Ht.toKnownErr = PE;
function DE(t) {
  return (0, ru.isObj)(t) && (0, ru.hasProp)(t, "$type") && t.$type === "com.atproto.repo.listMissingBlobs#recordBlob";
}
Ht.isRecordBlob = DE;
function KE(t) {
  return BE.lexicons.validate("com.atproto.repo.listMissingBlobs#recordBlob", t);
}
Ht.validateRecordBlob = KE;
var Wt = {};
Object.defineProperty(Wt, "__esModule", { value: !0 });
Wt.validateRecord = Wt.isRecord = Wt.toKnownErr = void 0;
const UE = v, iu = N, VE = $;
function IE(t) {
  return t instanceof UE.XRPCError, t;
}
Wt.toKnownErr = IE;
function jE(t) {
  return (0, iu.isObj)(t) && (0, iu.hasProp)(t, "$type") && t.$type === "com.atproto.repo.listRecords#record";
}
Wt.isRecord = jE;
function OE(t) {
  return VE.lexicons.validate("com.atproto.repo.listRecords#record", t);
}
Wt.validateRecord = OE;
var Nr = {};
Object.defineProperty(Nr, "__esModule", { value: !0 });
Nr.toKnownErr = Nr.InvalidSwapError = void 0;
const np = v;
class sp extends np.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Nr.InvalidSwapError = sp;
function ME(t) {
  return t instanceof np.XRPCError && t.error === "InvalidSwap" ? new sp(t) : t;
}
Nr.toKnownErr = ME;
var Fn = {};
Object.defineProperty(Fn, "__esModule", { value: !0 });
Fn.toKnownErr = void 0;
const NE = v;
function $E(t) {
  return t instanceof NE.XRPCError, t;
}
Fn.toKnownErr = $E;
var zn = {};
Object.defineProperty(zn, "__esModule", { value: !0 });
zn.toKnownErr = void 0;
const GE = v;
function qE(t) {
  return t instanceof GE.XRPCError, t;
}
zn.toKnownErr = qE;
var Xn = {};
Object.defineProperty(Xn, "__esModule", { value: !0 });
Xn.toKnownErr = void 0;
const FE = v;
function zE(t) {
  return t instanceof FE.XRPCError, t;
}
Xn.toKnownErr = zE;
var Fe = {};
Object.defineProperty(Fe, "__esModule", { value: !0 });
Fe.toKnownErr = Fe.InvalidEmailError = Fe.InvalidTokenError = Fe.ExpiredTokenError = Fe.AccountNotFoundError = void 0;
const Zn = v;
class op extends Zn.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Fe.AccountNotFoundError = op;
let ap = class extends Zn.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Fe.ExpiredTokenError = ap;
let lp = class extends Zn.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Fe.InvalidTokenError = lp;
class up extends Zn.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Fe.InvalidEmailError = up;
function XE(t) {
  if (t instanceof Zn.XRPCError) {
    if (t.error === "AccountNotFound")
      return new op(t);
    if (t.error === "ExpiredToken")
      return new ap(t);
    if (t.error === "InvalidToken")
      return new lp(t);
    if (t.error === "InvalidEmail")
      return new up(t);
  }
  return t;
}
Fe.toKnownErr = XE;
var me = {};
Object.defineProperty(me, "__esModule", { value: !0 });
me.toKnownErr = me.IncompatibleDidDocError = me.UnresolvableDidError = me.UnsupportedDomainError = me.HandleNotAvailableError = me.InvalidInviteCodeError = me.InvalidPasswordError = me.InvalidHandleError = void 0;
const Sr = v;
class cp extends Sr.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
me.InvalidHandleError = cp;
class pp extends Sr.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
me.InvalidPasswordError = pp;
class dp extends Sr.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
me.InvalidInviteCodeError = dp;
class fp extends Sr.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
me.HandleNotAvailableError = fp;
class yp extends Sr.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
me.UnsupportedDomainError = yp;
class mp extends Sr.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
me.UnresolvableDidError = mp;
class bp extends Sr.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
me.IncompatibleDidDocError = bp;
function ZE(t) {
  if (t instanceof Sr.XRPCError) {
    if (t.error === "InvalidHandle")
      return new cp(t);
    if (t.error === "InvalidPassword")
      return new pp(t);
    if (t.error === "InvalidInviteCode")
      return new dp(t);
    if (t.error === "HandleNotAvailable")
      return new fp(t);
    if (t.error === "UnsupportedDomain")
      return new yp(t);
    if (t.error === "UnresolvableDid")
      return new mp(t);
    if (t.error === "IncompatibleDidDoc")
      return new bp(t);
  }
  return t;
}
me.toKnownErr = ZE;
var lt = {};
Object.defineProperty(lt, "__esModule", { value: !0 });
lt.validateAppPassword = lt.isAppPassword = lt.toKnownErr = lt.AccountTakedownError = void 0;
const hp = v, nu = N, HE = $;
let Ep = class extends hp.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
lt.AccountTakedownError = Ep;
function WE(t) {
  return t instanceof hp.XRPCError && t.error === "AccountTakedown" ? new Ep(t) : t;
}
lt.toKnownErr = WE;
function JE(t) {
  return (0, nu.isObj)(t) && (0, nu.hasProp)(t, "$type") && t.$type === "com.atproto.server.createAppPassword#appPassword";
}
lt.isAppPassword = JE;
function QE(t) {
  return HE.lexicons.validate("com.atproto.server.createAppPassword#appPassword", t);
}
lt.validateAppPassword = QE;
var Hn = {};
Object.defineProperty(Hn, "__esModule", { value: !0 });
Hn.toKnownErr = void 0;
const YE = v;
function ex(t) {
  return t instanceof YE.XRPCError, t;
}
Hn.toKnownErr = ex;
var Jt = {};
Object.defineProperty(Jt, "__esModule", { value: !0 });
Jt.validateAccountCodes = Jt.isAccountCodes = Jt.toKnownErr = void 0;
const tx = v, su = N, rx = $;
function ix(t) {
  return t instanceof tx.XRPCError, t;
}
Jt.toKnownErr = ix;
function nx(t) {
  return (0, su.isObj)(t) && (0, su.hasProp)(t, "$type") && t.$type === "com.atproto.server.createInviteCodes#accountCodes";
}
Jt.isAccountCodes = nx;
function sx(t) {
  return rx.lexicons.validate("com.atproto.server.createInviteCodes#accountCodes", t);
}
Jt.validateAccountCodes = sx;
var Qt = {};
Object.defineProperty(Qt, "__esModule", { value: !0 });
Qt.toKnownErr = Qt.AuthFactorTokenRequiredError = Qt.AccountTakedownError = void 0;
const vl = v;
let xp = class extends vl.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Qt.AccountTakedownError = xp;
class gp extends vl.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Qt.AuthFactorTokenRequiredError = gp;
function ox(t) {
  if (t instanceof vl.XRPCError) {
    if (t.error === "AccountTakedown")
      return new xp(t);
    if (t.error === "AuthFactorTokenRequired")
      return new gp(t);
  }
  return t;
}
Qt.toKnownErr = ox;
var Wn = {};
Object.defineProperty(Wn, "__esModule", { value: !0 });
Wn.toKnownErr = void 0;
const ax = v;
function lx(t) {
  return t instanceof ax.XRPCError, t;
}
Wn.toKnownErr = lx;
var Yt = {};
Object.defineProperty(Yt, "__esModule", { value: !0 });
Yt.toKnownErr = Yt.InvalidTokenError = Yt.ExpiredTokenError = void 0;
const Al = v;
let Rp = class extends Al.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Yt.ExpiredTokenError = Rp;
let vp = class extends Al.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Yt.InvalidTokenError = vp;
function ux(t) {
  if (t instanceof Al.XRPCError) {
    if (t.error === "ExpiredToken")
      return new Rp(t);
    if (t.error === "InvalidToken")
      return new vp(t);
  }
  return t;
}
Yt.toKnownErr = ux;
var Jn = {};
Object.defineProperty(Jn, "__esModule", { value: !0 });
Jn.toKnownErr = void 0;
const cx = v;
function px(t) {
  return t instanceof cx.XRPCError, t;
}
Jn.toKnownErr = px;
var ze = {};
Object.defineProperty(ze, "__esModule", { value: !0 });
ze.validateContact = ze.isContact = ze.validateLinks = ze.isLinks = ze.toKnownErr = void 0;
const dx = v, na = N, Ap = $;
function fx(t) {
  return t instanceof dx.XRPCError, t;
}
ze.toKnownErr = fx;
function yx(t) {
  return (0, na.isObj)(t) && (0, na.hasProp)(t, "$type") && t.$type === "com.atproto.server.describeServer#links";
}
ze.isLinks = yx;
function mx(t) {
  return Ap.lexicons.validate("com.atproto.server.describeServer#links", t);
}
ze.validateLinks = mx;
function bx(t) {
  return (0, na.isObj)(t) && (0, na.hasProp)(t, "$type") && t.$type === "com.atproto.server.describeServer#contact";
}
ze.isContact = bx;
function hx(t) {
  return Ap.lexicons.validate("com.atproto.server.describeServer#contact", t);
}
ze.validateContact = hx;
var $r = {};
Object.defineProperty($r, "__esModule", { value: !0 });
$r.toKnownErr = $r.DuplicateCreateError = void 0;
const wp = v;
class Cp extends wp.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
$r.DuplicateCreateError = Cp;
function Ex(t) {
  return t instanceof wp.XRPCError && t.error === "DuplicateCreate" ? new Cp(t) : t;
}
$r.toKnownErr = Ex;
var Gr = {};
Object.defineProperty(Gr, "__esModule", { value: !0 });
Gr.toKnownErr = Gr.BadExpirationError = void 0;
const _p = v;
class Tp extends _p.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Gr.BadExpirationError = Tp;
function xx(t) {
  return t instanceof _p.XRPCError && t.error === "BadExpiration" ? new Tp(t) : t;
}
Gr.toKnownErr = xx;
var Qn = {};
Object.defineProperty(Qn, "__esModule", { value: !0 });
Qn.toKnownErr = void 0;
const gx = v;
function Rx(t) {
  return t instanceof gx.XRPCError, t;
}
Qn.toKnownErr = Rx;
var ut = {};
Object.defineProperty(ut, "__esModule", { value: !0 });
ut.validateAppPassword = ut.isAppPassword = ut.toKnownErr = ut.AccountTakedownError = void 0;
const Sp = v, ou = N, vx = $;
let Lp = class extends Sp.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
ut.AccountTakedownError = Lp;
function Ax(t) {
  return t instanceof Sp.XRPCError && t.error === "AccountTakedown" ? new Lp(t) : t;
}
ut.toKnownErr = Ax;
function wx(t) {
  return (0, ou.isObj)(t) && (0, ou.hasProp)(t, "$type") && t.$type === "com.atproto.server.listAppPasswords#appPassword";
}
ut.isAppPassword = wx;
function Cx(t) {
  return vx.lexicons.validate("com.atproto.server.listAppPasswords#appPassword", t);
}
ut.validateAppPassword = Cx;
var qr = {};
Object.defineProperty(qr, "__esModule", { value: !0 });
qr.toKnownErr = qr.AccountTakedownError = void 0;
const kp = v;
class Bp extends kp.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
qr.AccountTakedownError = Bp;
function _x(t) {
  return t instanceof kp.XRPCError && t.error === "AccountTakedown" ? new Bp(t) : t;
}
qr.toKnownErr = _x;
var Yn = {};
Object.defineProperty(Yn, "__esModule", { value: !0 });
Yn.toKnownErr = void 0;
const Tx = v;
function Sx(t) {
  return t instanceof Tx.XRPCError, t;
}
Yn.toKnownErr = Sx;
var es = {};
Object.defineProperty(es, "__esModule", { value: !0 });
es.toKnownErr = void 0;
const Lx = v;
function kx(t) {
  return t instanceof Lx.XRPCError, t;
}
es.toKnownErr = kx;
var ts = {};
Object.defineProperty(ts, "__esModule", { value: !0 });
ts.toKnownErr = void 0;
const Bx = v;
function Px(t) {
  return t instanceof Bx.XRPCError, t;
}
ts.toKnownErr = Px;
var rs = {};
Object.defineProperty(rs, "__esModule", { value: !0 });
rs.toKnownErr = void 0;
const Dx = v;
function Kx(t) {
  return t instanceof Dx.XRPCError, t;
}
rs.toKnownErr = Kx;
var is = {};
Object.defineProperty(is, "__esModule", { value: !0 });
is.toKnownErr = void 0;
const Ux = v;
function Vx(t) {
  return t instanceof Ux.XRPCError, t;
}
is.toKnownErr = Vx;
var er = {};
Object.defineProperty(er, "__esModule", { value: !0 });
er.toKnownErr = er.InvalidTokenError = er.ExpiredTokenError = void 0;
const wl = v;
let Pp = class extends wl.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
er.ExpiredTokenError = Pp;
let Dp = class extends wl.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
er.InvalidTokenError = Dp;
function Ix(t) {
  if (t instanceof wl.XRPCError) {
    if (t.error === "ExpiredToken")
      return new Pp(t);
    if (t.error === "InvalidToken")
      return new Dp(t);
  }
  return t;
}
er.toKnownErr = Ix;
var ns = {};
Object.defineProperty(ns, "__esModule", { value: !0 });
ns.toKnownErr = void 0;
const jx = v;
function Ox(t) {
  return t instanceof jx.XRPCError, t;
}
ns.toKnownErr = Ox;
var ct = {};
Object.defineProperty(ct, "__esModule", { value: !0 });
ct.toKnownErr = ct.TokenRequiredError = ct.InvalidTokenError = ct.ExpiredTokenError = void 0;
const va = v;
class Kp extends va.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
ct.ExpiredTokenError = Kp;
class Up extends va.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
ct.InvalidTokenError = Up;
class Vp extends va.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
ct.TokenRequiredError = Vp;
function Mx(t) {
  if (t instanceof va.XRPCError) {
    if (t.error === "ExpiredToken")
      return new Kp(t);
    if (t.error === "InvalidToken")
      return new Up(t);
    if (t.error === "TokenRequired")
      return new Vp(t);
  }
  return t;
}
ct.toKnownErr = Mx;
var Ve = {};
Object.defineProperty(Ve, "__esModule", { value: !0 });
Ve.toKnownErr = Ve.RepoDeactivatedError = Ve.RepoSuspendedError = Ve.RepoTakendownError = Ve.RepoNotFoundError = Ve.BlobNotFoundError = void 0;
const Mi = v;
class Ip extends Mi.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Ve.BlobNotFoundError = Ip;
let jp = class extends Mi.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Ve.RepoNotFoundError = jp;
let Op = class extends Mi.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Ve.RepoTakendownError = Op;
let Mp = class extends Mi.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Ve.RepoSuspendedError = Mp;
let Np = class extends Mi.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Ve.RepoDeactivatedError = Np;
function Nx(t) {
  if (t instanceof Mi.XRPCError) {
    if (t.error === "BlobNotFound")
      return new Ip(t);
    if (t.error === "RepoNotFound")
      return new jp(t);
    if (t.error === "RepoTakendown")
      return new Op(t);
    if (t.error === "RepoSuspended")
      return new Mp(t);
    if (t.error === "RepoDeactivated")
      return new Np(t);
  }
  return t;
}
Ve.toKnownErr = Nx;
var Ie = {};
Object.defineProperty(Ie, "__esModule", { value: !0 });
Ie.toKnownErr = Ie.RepoDeactivatedError = Ie.RepoSuspendedError = Ie.RepoTakendownError = Ie.RepoNotFoundError = Ie.BlockNotFoundError = void 0;
const Ni = v;
class $p extends Ni.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Ie.BlockNotFoundError = $p;
let Gp = class extends Ni.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Ie.RepoNotFoundError = Gp;
let qp = class extends Ni.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Ie.RepoTakendownError = qp;
let Fp = class extends Ni.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Ie.RepoSuspendedError = Fp;
let zp = class extends Ni.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Ie.RepoDeactivatedError = zp;
function $x(t) {
  if (t instanceof Ni.XRPCError) {
    if (t.error === "BlockNotFound")
      return new $p(t);
    if (t.error === "RepoNotFound")
      return new Gp(t);
    if (t.error === "RepoTakendown")
      return new qp(t);
    if (t.error === "RepoSuspended")
      return new Fp(t);
    if (t.error === "RepoDeactivated")
      return new zp(t);
  }
  return t;
}
Ie.toKnownErr = $x;
var ss = {};
Object.defineProperty(ss, "__esModule", { value: !0 });
ss.toKnownErr = void 0;
const Gx = v;
function qx(t) {
  return t instanceof Gx.XRPCError, t;
}
ss.toKnownErr = qx;
var Fr = {};
Object.defineProperty(Fr, "__esModule", { value: !0 });
Fr.toKnownErr = Fr.HeadNotFoundError = void 0;
const Xp = v;
class Zp extends Xp.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Fr.HeadNotFoundError = Zp;
function Fx(t) {
  return t instanceof Xp.XRPCError && t.error === "HeadNotFound" ? new Zp(t) : t;
}
Fr.toKnownErr = Fx;
var Xe = {};
Object.defineProperty(Xe, "__esModule", { value: !0 });
Xe.toKnownErr = Xe.RepoDeactivatedError = Xe.RepoSuspendedError = Xe.RepoTakendownError = Xe.RepoNotFoundError = void 0;
const os = v;
let Hp = class extends os.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Xe.RepoNotFoundError = Hp;
let Wp = class extends os.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Xe.RepoTakendownError = Wp;
let Jp = class extends os.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Xe.RepoSuspendedError = Jp;
let Qp = class extends os.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Xe.RepoDeactivatedError = Qp;
function zx(t) {
  if (t instanceof os.XRPCError) {
    if (t.error === "RepoNotFound")
      return new Hp(t);
    if (t.error === "RepoTakendown")
      return new Wp(t);
    if (t.error === "RepoSuspended")
      return new Jp(t);
    if (t.error === "RepoDeactivated")
      return new Qp(t);
  }
  return t;
}
Xe.toKnownErr = zx;
var je = {};
Object.defineProperty(je, "__esModule", { value: !0 });
je.toKnownErr = je.RepoDeactivatedError = je.RepoSuspendedError = je.RepoTakendownError = je.RepoNotFoundError = je.RecordNotFoundError = void 0;
const $i = v;
let Yp = class extends $i.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
je.RecordNotFoundError = Yp;
let ed = class extends $i.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
je.RepoNotFoundError = ed;
let td = class extends $i.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
je.RepoTakendownError = td;
let rd = class extends $i.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
je.RepoSuspendedError = rd;
let id = class extends $i.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
je.RepoDeactivatedError = id;
function Xx(t) {
  if (t instanceof $i.XRPCError) {
    if (t.error === "RecordNotFound")
      return new Yp(t);
    if (t.error === "RepoNotFound")
      return new ed(t);
    if (t.error === "RepoTakendown")
      return new td(t);
    if (t.error === "RepoSuspended")
      return new rd(t);
    if (t.error === "RepoDeactivated")
      return new id(t);
  }
  return t;
}
je.toKnownErr = Xx;
var Ze = {};
Object.defineProperty(Ze, "__esModule", { value: !0 });
Ze.toKnownErr = Ze.RepoDeactivatedError = Ze.RepoSuspendedError = Ze.RepoTakendownError = Ze.RepoNotFoundError = void 0;
const as = v;
let nd = class extends as.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Ze.RepoNotFoundError = nd;
let sd = class extends as.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Ze.RepoTakendownError = sd;
let od = class extends as.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Ze.RepoSuspendedError = od;
let ad = class extends as.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Ze.RepoDeactivatedError = ad;
function Zx(t) {
  if (t instanceof as.XRPCError) {
    if (t.error === "RepoNotFound")
      return new nd(t);
    if (t.error === "RepoTakendown")
      return new sd(t);
    if (t.error === "RepoSuspended")
      return new od(t);
    if (t.error === "RepoDeactivated")
      return new ad(t);
  }
  return t;
}
Ze.toKnownErr = Zx;
var zr = {};
Object.defineProperty(zr, "__esModule", { value: !0 });
zr.toKnownErr = zr.RepoNotFoundError = void 0;
const ld = v;
let ud = class extends ld.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
zr.RepoNotFoundError = ud;
function Hx(t) {
  return t instanceof ld.XRPCError && t.error === "RepoNotFound" ? new ud(t) : t;
}
zr.toKnownErr = Hx;
var He = {};
Object.defineProperty(He, "__esModule", { value: !0 });
He.toKnownErr = He.RepoDeactivatedError = He.RepoSuspendedError = He.RepoTakendownError = He.RepoNotFoundError = void 0;
const ls = v;
let cd = class extends ls.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
He.RepoNotFoundError = cd;
class pd extends ls.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
He.RepoTakendownError = pd;
class dd extends ls.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
He.RepoSuspendedError = dd;
class fd extends ls.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
He.RepoDeactivatedError = fd;
function Wx(t) {
  if (t instanceof ls.XRPCError) {
    if (t.error === "RepoNotFound")
      return new cd(t);
    if (t.error === "RepoTakendown")
      return new pd(t);
    if (t.error === "RepoSuspended")
      return new dd(t);
    if (t.error === "RepoDeactivated")
      return new fd(t);
  }
  return t;
}
He.toKnownErr = Wx;
var tr = {};
Object.defineProperty(tr, "__esModule", { value: !0 });
tr.validateRepo = tr.isRepo = tr.toKnownErr = void 0;
const Jx = v, au = N, Qx = $;
function Yx(t) {
  return t instanceof Jx.XRPCError, t;
}
tr.toKnownErr = Yx;
function eg(t) {
  return (0, au.isObj)(t) && (0, au.hasProp)(t, "$type") && t.$type === "com.atproto.sync.listRepos#repo";
}
tr.isRepo = eg;
function tg(t) {
  return Qx.lexicons.validate("com.atproto.sync.listRepos#repo", t);
}
tr.validateRepo = tg;
var us = {};
Object.defineProperty(us, "__esModule", { value: !0 });
us.toKnownErr = void 0;
const rg = v;
function ig(t) {
  return t instanceof rg.XRPCError, t;
}
us.toKnownErr = ig;
var cs = {};
Object.defineProperty(cs, "__esModule", { value: !0 });
cs.toKnownErr = void 0;
const ng = v;
function sg(t) {
  return t instanceof ng.XRPCError, t;
}
cs.toKnownErr = sg;
var ps = {};
Object.defineProperty(ps, "__esModule", { value: !0 });
ps.toKnownErr = void 0;
const og = v;
function ag(t) {
  return t instanceof og.XRPCError, t;
}
ps.toKnownErr = ag;
var ds = {};
Object.defineProperty(ds, "__esModule", { value: !0 });
ds.toKnownErr = void 0;
const lg = v;
function ug(t) {
  return t instanceof lg.XRPCError, t;
}
ds.toKnownErr = ug;
var fs = {};
Object.defineProperty(fs, "__esModule", { value: !0 });
fs.toKnownErr = void 0;
const cg = v;
function pg(t) {
  return t instanceof cg.XRPCError, t;
}
fs.toKnownErr = pg;
var ys = {};
Object.defineProperty(ys, "__esModule", { value: !0 });
ys.toKnownErr = void 0;
const dg = v;
function fg(t) {
  return t instanceof dg.XRPCError, t;
}
ys.toKnownErr = fg;
var ms = {};
Object.defineProperty(ms, "__esModule", { value: !0 });
ms.toKnownErr = void 0;
const yg = v;
function mg(t) {
  return t instanceof yg.XRPCError, t;
}
ms.toKnownErr = mg;
var bs = {};
Object.defineProperty(bs, "__esModule", { value: !0 });
bs.toKnownErr = void 0;
const bg = v;
function hg(t) {
  return t instanceof bg.XRPCError, t;
}
bs.toKnownErr = hg;
var hs = {};
Object.defineProperty(hs, "__esModule", { value: !0 });
hs.toKnownErr = void 0;
const Eg = v;
function xg(t) {
  return t instanceof Eg.XRPCError, t;
}
hs.toKnownErr = xg;
var Es = {};
Object.defineProperty(Es, "__esModule", { value: !0 });
Es.toKnownErr = void 0;
const gg = v;
function Rg(t) {
  return t instanceof gg.XRPCError, t;
}
Es.toKnownErr = Rg;
var xs = {};
Object.defineProperty(xs, "__esModule", { value: !0 });
xs.toKnownErr = void 0;
const vg = v;
function Ag(t) {
  return t instanceof vg.XRPCError, t;
}
xs.toKnownErr = Ag;
var gs = {};
Object.defineProperty(gs, "__esModule", { value: !0 });
gs.toKnownErr = void 0;
const wg = v;
function Cg(t) {
  return t instanceof wg.XRPCError, t;
}
gs.toKnownErr = Cg;
var We = {};
Object.defineProperty(We, "__esModule", { value: !0 });
We.validateLinks = We.isLinks = We.validateFeed = We.isFeed = We.toKnownErr = void 0;
const _g = v, sa = N, yd = $;
function Tg(t) {
  return t instanceof _g.XRPCError, t;
}
We.toKnownErr = Tg;
function Sg(t) {
  return (0, sa.isObj)(t) && (0, sa.hasProp)(t, "$type") && t.$type === "app.bsky.feed.describeFeedGenerator#feed";
}
We.isFeed = Sg;
function Lg(t) {
  return yd.lexicons.validate("app.bsky.feed.describeFeedGenerator#feed", t);
}
We.validateFeed = Lg;
function kg(t) {
  return (0, sa.isObj)(t) && (0, sa.hasProp)(t, "$type") && t.$type === "app.bsky.feed.describeFeedGenerator#links";
}
We.isLinks = kg;
function Bg(t) {
  return yd.lexicons.validate("app.bsky.feed.describeFeedGenerator#links", t);
}
We.validateLinks = Bg;
var Rs = {};
Object.defineProperty(Rs, "__esModule", { value: !0 });
Rs.toKnownErr = void 0;
const Pg = v;
function Dg(t) {
  return t instanceof Pg.XRPCError, t;
}
Rs.toKnownErr = Dg;
var rr = {};
Object.defineProperty(rr, "__esModule", { value: !0 });
rr.toKnownErr = rr.BlockedByActorError = rr.BlockedActorError = void 0;
const Cl = v;
let md = class extends Cl.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
rr.BlockedActorError = md;
let bd = class extends Cl.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
rr.BlockedByActorError = bd;
function Kg(t) {
  if (t instanceof Cl.XRPCError) {
    if (t.error === "BlockedActor")
      return new md(t);
    if (t.error === "BlockedByActor")
      return new bd(t);
  }
  return t;
}
rr.toKnownErr = Kg;
var ir = {};
Object.defineProperty(ir, "__esModule", { value: !0 });
ir.toKnownErr = ir.BlockedByActorError = ir.BlockedActorError = void 0;
const _l = v;
class hd extends _l.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
ir.BlockedActorError = hd;
class Ed extends _l.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
ir.BlockedByActorError = Ed;
function Ug(t) {
  if (t instanceof _l.XRPCError) {
    if (t.error === "BlockedActor")
      return new hd(t);
    if (t.error === "BlockedByActor")
      return new Ed(t);
  }
  return t;
}
ir.toKnownErr = Ug;
var Xr = {};
Object.defineProperty(Xr, "__esModule", { value: !0 });
Xr.toKnownErr = Xr.UnknownFeedError = void 0;
const xd = v;
let gd = class extends xd.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Xr.UnknownFeedError = gd;
function Vg(t) {
  return t instanceof xd.XRPCError && t.error === "UnknownFeed" ? new gd(t) : t;
}
Xr.toKnownErr = Vg;
var vs = {};
Object.defineProperty(vs, "__esModule", { value: !0 });
vs.toKnownErr = void 0;
const Ig = v;
function jg(t) {
  return t instanceof Ig.XRPCError, t;
}
vs.toKnownErr = jg;
var As = {};
Object.defineProperty(As, "__esModule", { value: !0 });
As.toKnownErr = void 0;
const Og = v;
function Mg(t) {
  return t instanceof Og.XRPCError, t;
}
As.toKnownErr = Mg;
var Zr = {};
Object.defineProperty(Zr, "__esModule", { value: !0 });
Zr.toKnownErr = Zr.UnknownFeedError = void 0;
const Rd = v;
class vd extends Rd.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Zr.UnknownFeedError = vd;
function Ng(t) {
  return t instanceof Rd.XRPCError && t.error === "UnknownFeed" ? new vd(t) : t;
}
Zr.toKnownErr = Ng;
var nr = {};
Object.defineProperty(nr, "__esModule", { value: !0 });
nr.validateLike = nr.isLike = nr.toKnownErr = void 0;
const $g = v, lu = N, Gg = $;
function qg(t) {
  return t instanceof $g.XRPCError, t;
}
nr.toKnownErr = qg;
function Fg(t) {
  return (0, lu.isObj)(t) && (0, lu.hasProp)(t, "$type") && t.$type === "app.bsky.feed.getLikes#like";
}
nr.isLike = Fg;
function zg(t) {
  return Gg.lexicons.validate("app.bsky.feed.getLikes#like", t);
}
nr.validateLike = zg;
var Hr = {};
Object.defineProperty(Hr, "__esModule", { value: !0 });
Hr.toKnownErr = Hr.UnknownListError = void 0;
const Ad = v;
class wd extends Ad.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Hr.UnknownListError = wd;
function Xg(t) {
  return t instanceof Ad.XRPCError && t.error === "UnknownList" ? new wd(t) : t;
}
Hr.toKnownErr = Xg;
var Wr = {};
Object.defineProperty(Wr, "__esModule", { value: !0 });
Wr.toKnownErr = Wr.NotFoundError = void 0;
const Cd = v;
class _d extends Cd.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Wr.NotFoundError = _d;
function Zg(t) {
  return t instanceof Cd.XRPCError && t.error === "NotFound" ? new _d(t) : t;
}
Wr.toKnownErr = Zg;
var ws = {};
Object.defineProperty(ws, "__esModule", { value: !0 });
ws.toKnownErr = void 0;
const Hg = v;
function Wg(t) {
  return t instanceof Hg.XRPCError, t;
}
ws.toKnownErr = Wg;
var Cs = {};
Object.defineProperty(Cs, "__esModule", { value: !0 });
Cs.toKnownErr = void 0;
const Jg = v;
function Qg(t) {
  return t instanceof Jg.XRPCError, t;
}
Cs.toKnownErr = Qg;
var _s = {};
Object.defineProperty(_s, "__esModule", { value: !0 });
_s.toKnownErr = void 0;
const Yg = v;
function eR(t) {
  return t instanceof Yg.XRPCError, t;
}
_s.toKnownErr = eR;
var Ts = {};
Object.defineProperty(Ts, "__esModule", { value: !0 });
Ts.toKnownErr = void 0;
const tR = v;
function rR(t) {
  return t instanceof tR.XRPCError, t;
}
Ts.toKnownErr = rR;
var Jr = {};
Object.defineProperty(Jr, "__esModule", { value: !0 });
Jr.toKnownErr = Jr.BadQueryStringError = void 0;
const Td = v;
let Sd = class extends Td.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Jr.BadQueryStringError = Sd;
function iR(t) {
  return t instanceof Td.XRPCError && t.error === "BadQueryString" ? new Sd(t) : t;
}
Jr.toKnownErr = iR;
var Ss = {};
Object.defineProperty(Ss, "__esModule", { value: !0 });
Ss.toKnownErr = void 0;
const nR = v;
function sR(t) {
  return t instanceof nR.XRPCError, t;
}
Ss.toKnownErr = sR;
var Ls = {};
Object.defineProperty(Ls, "__esModule", { value: !0 });
Ls.toKnownErr = void 0;
const oR = v;
function aR(t) {
  return t instanceof oR.XRPCError, t;
}
Ls.toKnownErr = aR;
var ks = {};
Object.defineProperty(ks, "__esModule", { value: !0 });
ks.toKnownErr = void 0;
const lR = v;
function uR(t) {
  return t instanceof lR.XRPCError, t;
}
ks.toKnownErr = uR;
var Bs = {};
Object.defineProperty(Bs, "__esModule", { value: !0 });
Bs.toKnownErr = void 0;
const cR = v;
function pR(t) {
  return t instanceof cR.XRPCError, t;
}
Bs.toKnownErr = pR;
var Ps = {};
Object.defineProperty(Ps, "__esModule", { value: !0 });
Ps.toKnownErr = void 0;
const dR = v;
function fR(t) {
  return t instanceof dR.XRPCError, t;
}
Ps.toKnownErr = fR;
var Ds = {};
Object.defineProperty(Ds, "__esModule", { value: !0 });
Ds.toKnownErr = void 0;
const yR = v;
function mR(t) {
  return t instanceof yR.XRPCError, t;
}
Ds.toKnownErr = mR;
var Ks = {};
Object.defineProperty(Ks, "__esModule", { value: !0 });
Ks.toKnownErr = void 0;
const bR = v;
function hR(t) {
  return t instanceof bR.XRPCError, t;
}
Ks.toKnownErr = hR;
var Us = {};
Object.defineProperty(Us, "__esModule", { value: !0 });
Us.toKnownErr = void 0;
const ER = v;
function xR(t) {
  return t instanceof ER.XRPCError, t;
}
Us.toKnownErr = xR;
var Vs = {};
Object.defineProperty(Vs, "__esModule", { value: !0 });
Vs.toKnownErr = void 0;
const gR = v;
function RR(t) {
  return t instanceof gR.XRPCError, t;
}
Vs.toKnownErr = RR;
var Is = {};
Object.defineProperty(Is, "__esModule", { value: !0 });
Is.toKnownErr = void 0;
const vR = v;
function AR(t) {
  return t instanceof vR.XRPCError, t;
}
Is.toKnownErr = AR;
var js = {};
Object.defineProperty(js, "__esModule", { value: !0 });
js.toKnownErr = void 0;
const wR = v;
function CR(t) {
  return t instanceof wR.XRPCError, t;
}
js.toKnownErr = CR;
var Qr = {};
Object.defineProperty(Qr, "__esModule", { value: !0 });
Qr.toKnownErr = Qr.ActorNotFoundError = void 0;
const Ld = v;
class kd extends Ld.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Qr.ActorNotFoundError = kd;
function _R(t) {
  return t instanceof Ld.XRPCError && t.error === "ActorNotFound" ? new kd(t) : t;
}
Qr.toKnownErr = _R;
var Os = {};
Object.defineProperty(Os, "__esModule", { value: !0 });
Os.toKnownErr = void 0;
const TR = v;
function SR(t) {
  return t instanceof TR.XRPCError, t;
}
Os.toKnownErr = SR;
var Ms = {};
Object.defineProperty(Ms, "__esModule", { value: !0 });
Ms.toKnownErr = void 0;
const LR = v;
function kR(t) {
  return t instanceof LR.XRPCError, t;
}
Ms.toKnownErr = kR;
var Ns = {};
Object.defineProperty(Ns, "__esModule", { value: !0 });
Ns.toKnownErr = void 0;
const BR = v;
function PR(t) {
  return t instanceof BR.XRPCError, t;
}
Ns.toKnownErr = PR;
var $s = {};
Object.defineProperty($s, "__esModule", { value: !0 });
$s.toKnownErr = void 0;
const DR = v;
function KR(t) {
  return t instanceof DR.XRPCError, t;
}
$s.toKnownErr = KR;
var Gs = {};
Object.defineProperty(Gs, "__esModule", { value: !0 });
Gs.toKnownErr = void 0;
const UR = v;
function VR(t) {
  return t instanceof UR.XRPCError, t;
}
Gs.toKnownErr = VR;
var qs = {};
Object.defineProperty(qs, "__esModule", { value: !0 });
qs.toKnownErr = void 0;
const IR = v;
function jR(t) {
  return t instanceof IR.XRPCError, t;
}
qs.toKnownErr = jR;
var Fs = {};
Object.defineProperty(Fs, "__esModule", { value: !0 });
Fs.toKnownErr = void 0;
const OR = v;
function MR(t) {
  return t instanceof OR.XRPCError, t;
}
Fs.toKnownErr = MR;
var zs = {};
Object.defineProperty(zs, "__esModule", { value: !0 });
zs.toKnownErr = void 0;
const NR = v;
function $R(t) {
  return t instanceof NR.XRPCError, t;
}
zs.toKnownErr = $R;
var Xs = {};
Object.defineProperty(Xs, "__esModule", { value: !0 });
Xs.toKnownErr = void 0;
const GR = v;
function qR(t) {
  return t instanceof GR.XRPCError, t;
}
Xs.toKnownErr = qR;
var Zs = {};
Object.defineProperty(Zs, "__esModule", { value: !0 });
Zs.toKnownErr = void 0;
const FR = v;
function zR(t) {
  return t instanceof FR.XRPCError, t;
}
Zs.toKnownErr = zR;
var Hs = {};
Object.defineProperty(Hs, "__esModule", { value: !0 });
Hs.toKnownErr = void 0;
const XR = v;
function ZR(t) {
  return t instanceof XR.XRPCError, t;
}
Hs.toKnownErr = ZR;
var sr = {};
Object.defineProperty(sr, "__esModule", { value: !0 });
sr.validateNotification = sr.isNotification = sr.toKnownErr = void 0;
const HR = v, uu = N, WR = $;
function JR(t) {
  return t instanceof HR.XRPCError, t;
}
sr.toKnownErr = JR;
function QR(t) {
  return (0, uu.isObj)(t) && (0, uu.hasProp)(t, "$type") && t.$type === "app.bsky.notification.listNotifications#notification";
}
sr.isNotification = QR;
function YR(t) {
  return WR.lexicons.validate("app.bsky.notification.listNotifications#notification", t);
}
sr.validateNotification = YR;
var Ws = {};
Object.defineProperty(Ws, "__esModule", { value: !0 });
Ws.toKnownErr = void 0;
const ev = v;
function tv(t) {
  return t instanceof ev.XRPCError, t;
}
Ws.toKnownErr = tv;
var Js = {};
Object.defineProperty(Js, "__esModule", { value: !0 });
Js.toKnownErr = void 0;
const rv = v;
function iv(t) {
  return t instanceof rv.XRPCError, t;
}
Js.toKnownErr = iv;
var Qs = {};
Object.defineProperty(Qs, "__esModule", { value: !0 });
Qs.toKnownErr = void 0;
const nv = v;
function sv(t) {
  return t instanceof nv.XRPCError, t;
}
Qs.toKnownErr = sv;
var Ys = {};
Object.defineProperty(Ys, "__esModule", { value: !0 });
Ys.toKnownErr = void 0;
const ov = v;
function av(t) {
  return t instanceof ov.XRPCError, t;
}
Ys.toKnownErr = av;
var eo = {};
Object.defineProperty(eo, "__esModule", { value: !0 });
eo.toKnownErr = void 0;
const lv = v;
function uv(t) {
  return t instanceof lv.XRPCError, t;
}
eo.toKnownErr = uv;
var or = {};
Object.defineProperty(or, "__esModule", { value: !0 });
or.validateSuggestion = or.isSuggestion = or.toKnownErr = void 0;
const cv = v, cu = N, pv = $;
function dv(t) {
  return t instanceof cv.XRPCError, t;
}
or.toKnownErr = dv;
function fv(t) {
  return (0, cu.isObj)(t) && (0, cu.hasProp)(t, "$type") && t.$type === "app.bsky.unspecced.getTaggedSuggestions#suggestion";
}
or.isSuggestion = fv;
function yv(t) {
  return pv.lexicons.validate("app.bsky.unspecced.getTaggedSuggestions#suggestion", t);
}
or.validateSuggestion = yv;
var Yr = {};
Object.defineProperty(Yr, "__esModule", { value: !0 });
Yr.toKnownErr = Yr.BadQueryStringError = void 0;
const Bd = v;
let Pd = class extends Bd.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Yr.BadQueryStringError = Pd;
function mv(t) {
  return t instanceof Bd.XRPCError && t.error === "BadQueryString" ? new Pd(t) : t;
}
Yr.toKnownErr = mv;
var ei = {};
Object.defineProperty(ei, "__esModule", { value: !0 });
ei.toKnownErr = ei.BadQueryStringError = void 0;
const Dd = v;
class Kd extends Dd.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
ei.BadQueryStringError = Kd;
function bv(t) {
  return t instanceof Dd.XRPCError && t.error === "BadQueryString" ? new Kd(t) : t;
}
ei.toKnownErr = bv;
var to = {};
Object.defineProperty(to, "__esModule", { value: !0 });
to.toKnownErr = void 0;
const hv = v;
function Ev(t) {
  return t instanceof hv.XRPCError, t;
}
to.toKnownErr = Ev;
var ro = {};
Object.defineProperty(ro, "__esModule", { value: !0 });
ro.toKnownErr = void 0;
const xv = v;
function gv(t) {
  return t instanceof xv.XRPCError, t;
}
ro.toKnownErr = gv;
var io = {};
Object.defineProperty(io, "__esModule", { value: !0 });
io.toKnownErr = void 0;
const Rv = v;
function vv(t) {
  return t instanceof Rv.XRPCError, t;
}
io.toKnownErr = vv;
var no = {};
Object.defineProperty(no, "__esModule", { value: !0 });
no.toKnownErr = void 0;
const Av = v;
function wv(t) {
  return t instanceof Av.XRPCError, t;
}
no.toKnownErr = wv;
var so = {};
Object.defineProperty(so, "__esModule", { value: !0 });
so.toKnownErr = void 0;
const Cv = v;
function _v(t) {
  return t instanceof Cv.XRPCError, t;
}
so.toKnownErr = _v;
var oo = {};
Object.defineProperty(oo, "__esModule", { value: !0 });
oo.toKnownErr = void 0;
const Tv = v;
function Sv(t) {
  return t instanceof Tv.XRPCError, t;
}
oo.toKnownErr = Sv;
var ao = {};
Object.defineProperty(ao, "__esModule", { value: !0 });
ao.toKnownErr = void 0;
const Lv = v;
function kv(t) {
  return t instanceof Lv.XRPCError, t;
}
ao.toKnownErr = kv;
var lo = {};
Object.defineProperty(lo, "__esModule", { value: !0 });
lo.toKnownErr = void 0;
const Bv = v;
function Pv(t) {
  return t instanceof Bv.XRPCError, t;
}
lo.toKnownErr = Pv;
var uo = {};
Object.defineProperty(uo, "__esModule", { value: !0 });
uo.toKnownErr = void 0;
const Dv = v;
function Kv(t) {
  return t instanceof Dv.XRPCError, t;
}
uo.toKnownErr = Kv;
var co = {};
Object.defineProperty(co, "__esModule", { value: !0 });
co.toKnownErr = void 0;
const Uv = v;
function Vv(t) {
  return t instanceof Uv.XRPCError, t;
}
co.toKnownErr = Vv;
var po = {};
Object.defineProperty(po, "__esModule", { value: !0 });
po.toKnownErr = void 0;
const Iv = v;
function jv(t) {
  return t instanceof Iv.XRPCError, t;
}
po.toKnownErr = jv;
var ar = {};
Object.defineProperty(ar, "__esModule", { value: !0 });
ar.validateBatchItem = ar.isBatchItem = ar.toKnownErr = void 0;
const Ov = v, pu = N, Mv = $;
function Nv(t) {
  return t instanceof Ov.XRPCError, t;
}
ar.toKnownErr = Nv;
function $v(t) {
  return (0, pu.isObj)(t) && (0, pu.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.sendMessageBatch#batchItem";
}
ar.isBatchItem = $v;
function Gv(t) {
  return Mv.lexicons.validate("chat.bsky.convo.sendMessageBatch#batchItem", t);
}
ar.validateBatchItem = Gv;
var fo = {};
Object.defineProperty(fo, "__esModule", { value: !0 });
fo.toKnownErr = void 0;
const qv = v;
function Fv(t) {
  return t instanceof qv.XRPCError, t;
}
fo.toKnownErr = Fv;
var yo = {};
Object.defineProperty(yo, "__esModule", { value: !0 });
yo.toKnownErr = void 0;
const zv = v;
function Xv(t) {
  return t instanceof zv.XRPCError, t;
}
yo.toKnownErr = Xv;
var lr = {};
Object.defineProperty(lr, "__esModule", { value: !0 });
lr.validateMetadata = lr.isMetadata = lr.toKnownErr = void 0;
const Zv = v, du = N, Hv = $;
function Wv(t) {
  return t instanceof Zv.XRPCError, t;
}
lr.toKnownErr = Wv;
function Jv(t) {
  return (0, du.isObj)(t) && (0, du.hasProp)(t, "$type") && t.$type === "chat.bsky.moderation.getActorMetadata#metadata";
}
lr.isMetadata = Jv;
function Qv(t) {
  return Hv.lexicons.validate("chat.bsky.moderation.getActorMetadata#metadata", t);
}
lr.validateMetadata = Qv;
var mo = {};
Object.defineProperty(mo, "__esModule", { value: !0 });
mo.toKnownErr = void 0;
const Yv = v;
function eA(t) {
  return t instanceof Yv.XRPCError, t;
}
mo.toKnownErr = eA;
var bo = {};
Object.defineProperty(bo, "__esModule", { value: !0 });
bo.toKnownErr = void 0;
const tA = v;
function rA(t) {
  return t instanceof tA.XRPCError, t;
}
bo.toKnownErr = rA;
var ho = {};
Object.defineProperty(ho, "__esModule", { value: !0 });
ho.toKnownErr = void 0;
const iA = v;
function nA(t) {
  return t instanceof iA.XRPCError, t;
}
ho.toKnownErr = nA;
var Eo = {};
Object.defineProperty(Eo, "__esModule", { value: !0 });
Eo.toKnownErr = void 0;
const sA = v;
function oA(t) {
  return t instanceof sA.XRPCError, t;
}
Eo.toKnownErr = oA;
var xo = {};
Object.defineProperty(xo, "__esModule", { value: !0 });
xo.toKnownErr = void 0;
const aA = v;
function lA(t) {
  return t instanceof aA.XRPCError, t;
}
xo.toKnownErr = lA;
var go = {};
Object.defineProperty(go, "__esModule", { value: !0 });
go.toKnownErr = void 0;
const uA = v;
function cA(t) {
  return t instanceof uA.XRPCError, t;
}
go.toKnownErr = cA;
var ti = {};
Object.defineProperty(ti, "__esModule", { value: !0 });
ti.toKnownErr = ti.SubjectHasActionError = void 0;
const Ud = v;
class Vd extends Ud.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
ti.SubjectHasActionError = Vd;
function pA(t) {
  return t instanceof Ud.XRPCError && t.error === "SubjectHasAction" ? new Vd(t) : t;
}
ti.toKnownErr = pA;
var Ro = {};
Object.defineProperty(Ro, "__esModule", { value: !0 });
Ro.toKnownErr = void 0;
const dA = v;
function fA(t) {
  return t instanceof dA.XRPCError, t;
}
Ro.toKnownErr = fA;
var ri = {};
Object.defineProperty(ri, "__esModule", { value: !0 });
ri.toKnownErr = ri.RecordNotFoundError = void 0;
const Id = v;
class jd extends Id.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
ri.RecordNotFoundError = jd;
function yA(t) {
  return t instanceof Id.XRPCError && t.error === "RecordNotFound" ? new jd(t) : t;
}
ri.toKnownErr = yA;
var ii = {};
Object.defineProperty(ii, "__esModule", { value: !0 });
ii.toKnownErr = ii.RepoNotFoundError = void 0;
const Od = v;
class Md extends Od.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
ii.RepoNotFoundError = Md;
function mA(t) {
  return t instanceof Od.XRPCError && t.error === "RepoNotFound" ? new Md(t) : t;
}
ii.toKnownErr = mA;
var vo = {};
Object.defineProperty(vo, "__esModule", { value: !0 });
vo.toKnownErr = void 0;
const bA = v;
function hA(t) {
  return t instanceof bA.XRPCError, t;
}
vo.toKnownErr = hA;
var Ao = {};
Object.defineProperty(Ao, "__esModule", { value: !0 });
Ao.toKnownErr = void 0;
const EA = v;
function xA(t) {
  return t instanceof EA.XRPCError, t;
}
Ao.toKnownErr = xA;
var wo = {};
Object.defineProperty(wo, "__esModule", { value: !0 });
wo.toKnownErr = void 0;
const gA = v;
function RA(t) {
  return t instanceof gA.XRPCError, t;
}
wo.toKnownErr = RA;
var Je = {};
Object.defineProperty(Je, "__esModule", { value: !0 });
Je.validateViewerConfig = Je.isViewerConfig = Je.validateServiceConfig = Je.isServiceConfig = Je.toKnownErr = void 0;
const vA = v, oa = N, Nd = $;
function AA(t) {
  return t instanceof vA.XRPCError, t;
}
Je.toKnownErr = AA;
function wA(t) {
  return (0, oa.isObj)(t) && (0, oa.hasProp)(t, "$type") && t.$type === "tools.ozone.server.getConfig#serviceConfig";
}
Je.isServiceConfig = wA;
function CA(t) {
  return Nd.lexicons.validate("tools.ozone.server.getConfig#serviceConfig", t);
}
Je.validateServiceConfig = CA;
function _A(t) {
  return (0, oa.isObj)(t) && (0, oa.hasProp)(t, "$type") && t.$type === "tools.ozone.server.getConfig#viewerConfig";
}
Je.isViewerConfig = _A;
function TA(t) {
  return Nd.lexicons.validate("tools.ozone.server.getConfig#viewerConfig", t);
}
Je.validateViewerConfig = TA;
var ni = {};
Object.defineProperty(ni, "__esModule", { value: !0 });
ni.toKnownErr = ni.MemberAlreadyExistsError = void 0;
const $d = v;
class Gd extends $d.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
ni.MemberAlreadyExistsError = Gd;
function SA(t) {
  return t instanceof $d.XRPCError && t.error === "MemberAlreadyExists" ? new Gd(t) : t;
}
ni.toKnownErr = SA;
var ur = {};
Object.defineProperty(ur, "__esModule", { value: !0 });
ur.toKnownErr = ur.CannotDeleteSelfError = ur.MemberNotFoundError = void 0;
const Tl = v;
let qd = class extends Tl.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
ur.MemberNotFoundError = qd;
class Fd extends Tl.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
ur.CannotDeleteSelfError = Fd;
function LA(t) {
  if (t instanceof Tl.XRPCError) {
    if (t.error === "MemberNotFound")
      return new qd(t);
    if (t.error === "CannotDeleteSelf")
      return new Fd(t);
  }
  return t;
}
ur.toKnownErr = LA;
var Co = {};
Object.defineProperty(Co, "__esModule", { value: !0 });
Co.toKnownErr = void 0;
const kA = v;
function BA(t) {
  return t instanceof kA.XRPCError, t;
}
Co.toKnownErr = BA;
var si = {};
Object.defineProperty(si, "__esModule", { value: !0 });
si.toKnownErr = si.MemberNotFoundError = void 0;
const zd = v;
class Xd extends zd.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
si.MemberNotFoundError = Xd;
function PA(t) {
  return t instanceof zd.XRPCError && t.error === "MemberNotFound" ? new Xd(t) : t;
}
si.toKnownErr = PA;
var he = {};
Object.defineProperty(he, "__esModule", { value: !0 });
he.validateRepoBlobRef = he.isRepoBlobRef = he.validateRepoRef = he.isRepoRef = he.validateAccountView = he.isAccountView = he.validateStatusAttr = he.isStatusAttr = void 0;
const gr = N, Aa = $;
function DA(t) {
  return (0, gr.isObj)(t) && (0, gr.hasProp)(t, "$type") && t.$type === "com.atproto.admin.defs#statusAttr";
}
he.isStatusAttr = DA;
function KA(t) {
  return Aa.lexicons.validate("com.atproto.admin.defs#statusAttr", t);
}
he.validateStatusAttr = KA;
function UA(t) {
  return (0, gr.isObj)(t) && (0, gr.hasProp)(t, "$type") && t.$type === "com.atproto.admin.defs#accountView";
}
he.isAccountView = UA;
function VA(t) {
  return Aa.lexicons.validate("com.atproto.admin.defs#accountView", t);
}
he.validateAccountView = VA;
function IA(t) {
  return (0, gr.isObj)(t) && (0, gr.hasProp)(t, "$type") && t.$type === "com.atproto.admin.defs#repoRef";
}
he.isRepoRef = IA;
function jA(t) {
  return Aa.lexicons.validate("com.atproto.admin.defs#repoRef", t);
}
he.validateRepoRef = jA;
function OA(t) {
  return (0, gr.isObj)(t) && (0, gr.hasProp)(t, "$type") && t.$type === "com.atproto.admin.defs#repoBlobRef";
}
he.isRepoBlobRef = OA;
function MA(t) {
  return Aa.lexicons.validate("com.atproto.admin.defs#repoBlobRef", t);
}
he.validateRepoBlobRef = MA;
var le = {};
Object.defineProperty(le, "__esModule", { value: !0 });
le.validateLabelValueDefinitionStrings = le.isLabelValueDefinitionStrings = le.validateLabelValueDefinition = le.isLabelValueDefinition = le.validateSelfLabel = le.isSelfLabel = le.validateSelfLabels = le.isSelfLabels = le.validateLabel = le.isLabel = void 0;
const kt = N, _o = $;
function NA(t) {
  return (0, kt.isObj)(t) && (0, kt.hasProp)(t, "$type") && t.$type === "com.atproto.label.defs#label";
}
le.isLabel = NA;
function $A(t) {
  return _o.lexicons.validate("com.atproto.label.defs#label", t);
}
le.validateLabel = $A;
function GA(t) {
  return (0, kt.isObj)(t) && (0, kt.hasProp)(t, "$type") && t.$type === "com.atproto.label.defs#selfLabels";
}
le.isSelfLabels = GA;
function qA(t) {
  return _o.lexicons.validate("com.atproto.label.defs#selfLabels", t);
}
le.validateSelfLabels = qA;
function FA(t) {
  return (0, kt.isObj)(t) && (0, kt.hasProp)(t, "$type") && t.$type === "com.atproto.label.defs#selfLabel";
}
le.isSelfLabel = FA;
function zA(t) {
  return _o.lexicons.validate("com.atproto.label.defs#selfLabel", t);
}
le.validateSelfLabel = zA;
function XA(t) {
  return (0, kt.isObj)(t) && (0, kt.hasProp)(t, "$type") && t.$type === "com.atproto.label.defs#labelValueDefinition";
}
le.isLabelValueDefinition = XA;
function ZA(t) {
  return _o.lexicons.validate("com.atproto.label.defs#labelValueDefinition", t);
}
le.validateLabelValueDefinition = ZA;
function HA(t) {
  return (0, kt.isObj)(t) && (0, kt.hasProp)(t, "$type") && t.$type === "com.atproto.label.defs#labelValueDefinitionStrings";
}
le.isLabelValueDefinitionStrings = HA;
function WA(t) {
  return _o.lexicons.validate("com.atproto.label.defs#labelValueDefinitionStrings", t);
}
le.validateLabelValueDefinitionStrings = WA;
var Rt = {};
Object.defineProperty(Rt, "__esModule", { value: !0 });
Rt.validateInfo = Rt.isInfo = Rt.validateLabels = Rt.isLabels = void 0;
const aa = N, Zd = $;
function JA(t) {
  return (0, aa.isObj)(t) && (0, aa.hasProp)(t, "$type") && t.$type === "com.atproto.label.subscribeLabels#labels";
}
Rt.isLabels = JA;
function QA(t) {
  return Zd.lexicons.validate("com.atproto.label.subscribeLabels#labels", t);
}
Rt.validateLabels = QA;
function YA(t) {
  return (0, aa.isObj)(t) && (0, aa.hasProp)(t, "$type") && t.$type === "com.atproto.label.subscribeLabels#info";
}
Rt.isInfo = YA;
function ew(t) {
  return Zd.lexicons.validate("com.atproto.label.subscribeLabels#info", t);
}
Rt.validateInfo = ew;
var ke = {};
Object.defineProperty(ke, "__esModule", { value: !0 });
ke.REASONAPPEAL = ke.REASONOTHER = ke.REASONRUDE = ke.REASONSEXUAL = ke.REASONMISLEADING = ke.REASONVIOLATION = ke.REASONSPAM = void 0;
ke.REASONSPAM = "com.atproto.moderation.defs#reasonSpam";
ke.REASONVIOLATION = "com.atproto.moderation.defs#reasonViolation";
ke.REASONMISLEADING = "com.atproto.moderation.defs#reasonMisleading";
ke.REASONSEXUAL = "com.atproto.moderation.defs#reasonSexual";
ke.REASONRUDE = "com.atproto.moderation.defs#reasonRude";
ke.REASONOTHER = "com.atproto.moderation.defs#reasonOther";
ke.REASONAPPEAL = "com.atproto.moderation.defs#reasonAppeal";
var vi = {};
Object.defineProperty(vi, "__esModule", { value: !0 });
vi.validateMain = vi.isMain = void 0;
const fu = N, tw = $;
function rw(t) {
  return (0, fu.isObj)(t) && (0, fu.hasProp)(t, "$type") && (t.$type === "com.atproto.repo.strongRef#main" || t.$type === "com.atproto.repo.strongRef");
}
vi.isMain = rw;
function iw(t) {
  return tw.lexicons.validate("com.atproto.repo.strongRef#main", t);
}
vi.validateMain = iw;
var vt = {};
Object.defineProperty(vt, "__esModule", { value: !0 });
vt.validateInviteCodeUse = vt.isInviteCodeUse = vt.validateInviteCode = vt.isInviteCode = void 0;
const la = N, Hd = $;
function nw(t) {
  return (0, la.isObj)(t) && (0, la.hasProp)(t, "$type") && t.$type === "com.atproto.server.defs#inviteCode";
}
vt.isInviteCode = nw;
function sw(t) {
  return Hd.lexicons.validate("com.atproto.server.defs#inviteCode", t);
}
vt.validateInviteCode = sw;
function ow(t) {
  return (0, la.isObj)(t) && (0, la.hasProp)(t, "$type") && t.$type === "com.atproto.server.defs#inviteCodeUse";
}
vt.isInviteCodeUse = ow;
function aw(t) {
  return Hd.lexicons.validate("com.atproto.server.defs#inviteCodeUse", t);
}
vt.validateInviteCodeUse = aw;
var Q = {};
Object.defineProperty(Q, "__esModule", { value: !0 });
Q.validateRepoOp = Q.isRepoOp = Q.validateInfo = Q.isInfo = Q.validateTombstone = Q.isTombstone = Q.validateMigrate = Q.isMigrate = Q.validateHandle = Q.isHandle = Q.validateAccount = Q.isAccount = Q.validateIdentity = Q.isIdentity = Q.validateCommit = Q.isCommit = void 0;
const Pe = N, Lr = $;
function lw(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#commit";
}
Q.isCommit = lw;
function uw(t) {
  return Lr.lexicons.validate("com.atproto.sync.subscribeRepos#commit", t);
}
Q.validateCommit = uw;
function cw(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#identity";
}
Q.isIdentity = cw;
function pw(t) {
  return Lr.lexicons.validate("com.atproto.sync.subscribeRepos#identity", t);
}
Q.validateIdentity = pw;
function dw(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#account";
}
Q.isAccount = dw;
function fw(t) {
  return Lr.lexicons.validate("com.atproto.sync.subscribeRepos#account", t);
}
Q.validateAccount = fw;
function yw(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#handle";
}
Q.isHandle = yw;
function mw(t) {
  return Lr.lexicons.validate("com.atproto.sync.subscribeRepos#handle", t);
}
Q.validateHandle = mw;
function bw(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#migrate";
}
Q.isMigrate = bw;
function hw(t) {
  return Lr.lexicons.validate("com.atproto.sync.subscribeRepos#migrate", t);
}
Q.validateMigrate = hw;
function Ew(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#tombstone";
}
Q.isTombstone = Ew;
function xw(t) {
  return Lr.lexicons.validate("com.atproto.sync.subscribeRepos#tombstone", t);
}
Q.validateTombstone = xw;
function gw(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#info";
}
Q.isInfo = gw;
function Rw(t) {
  return Lr.lexicons.validate("com.atproto.sync.subscribeRepos#info", t);
}
Q.validateInfo = Rw;
function vw(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#repoOp";
}
Q.isRepoOp = vw;
function Aw(t) {
  return Lr.lexicons.validate("com.atproto.sync.subscribeRepos#repoOp", t);
}
Q.validateRepoOp = Aw;
var k = {};
Object.defineProperty(k, "__esModule", { value: !0 });
k.validateBskyAppProgressGuide = k.isBskyAppProgressGuide = k.validateBskyAppStatePref = k.isBskyAppStatePref = k.validateLabelerPrefItem = k.isLabelerPrefItem = k.validateLabelersPref = k.isLabelersPref = k.validateHiddenPostsPref = k.isHiddenPostsPref = k.validateMutedWordsPref = k.isMutedWordsPref = k.validateMutedWord = k.isMutedWord = k.validateInterestsPref = k.isInterestsPref = k.validateThreadViewPref = k.isThreadViewPref = k.validateFeedViewPref = k.isFeedViewPref = k.validatePersonalDetailsPref = k.isPersonalDetailsPref = k.validateSavedFeedsPref = k.isSavedFeedsPref = k.validateSavedFeedsPrefV2 = k.isSavedFeedsPrefV2 = k.validateSavedFeed = k.isSavedFeed = k.validateContentLabelPref = k.isContentLabelPref = k.validateAdultContentPref = k.isAdultContentPref = k.validateKnownFollowers = k.isKnownFollowers = k.validateViewerState = k.isViewerState = k.validateProfileAssociatedChat = k.isProfileAssociatedChat = k.validateProfileAssociated = k.isProfileAssociated = k.validateProfileViewDetailed = k.isProfileViewDetailed = k.validateProfileView = k.isProfileView = k.validateProfileViewBasic = k.isProfileViewBasic = void 0;
const F = N, ae = $;
function ww(t) {
  return (0, F.isObj)(t) && (0, F.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#profileViewBasic";
}
k.isProfileViewBasic = ww;
function Cw(t) {
  return ae.lexicons.validate("app.bsky.actor.defs#profileViewBasic", t);
}
k.validateProfileViewBasic = Cw;
function _w(t) {
  return (0, F.isObj)(t) && (0, F.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#profileView";
}
k.isProfileView = _w;
function Tw(t) {
  return ae.lexicons.validate("app.bsky.actor.defs#profileView", t);
}
k.validateProfileView = Tw;
function Sw(t) {
  return (0, F.isObj)(t) && (0, F.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#profileViewDetailed";
}
k.isProfileViewDetailed = Sw;
function Lw(t) {
  return ae.lexicons.validate("app.bsky.actor.defs#profileViewDetailed", t);
}
k.validateProfileViewDetailed = Lw;
function kw(t) {
  return (0, F.isObj)(t) && (0, F.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#profileAssociated";
}
k.isProfileAssociated = kw;
function Bw(t) {
  return ae.lexicons.validate("app.bsky.actor.defs#profileAssociated", t);
}
k.validateProfileAssociated = Bw;
function Pw(t) {
  return (0, F.isObj)(t) && (0, F.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#profileAssociatedChat";
}
k.isProfileAssociatedChat = Pw;
function Dw(t) {
  return ae.lexicons.validate("app.bsky.actor.defs#profileAssociatedChat", t);
}
k.validateProfileAssociatedChat = Dw;
function Kw(t) {
  return (0, F.isObj)(t) && (0, F.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#viewerState";
}
k.isViewerState = Kw;
function Uw(t) {
  return ae.lexicons.validate("app.bsky.actor.defs#viewerState", t);
}
k.validateViewerState = Uw;
function Vw(t) {
  return (0, F.isObj)(t) && (0, F.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#knownFollowers";
}
k.isKnownFollowers = Vw;
function Iw(t) {
  return ae.lexicons.validate("app.bsky.actor.defs#knownFollowers", t);
}
k.validateKnownFollowers = Iw;
function jw(t) {
  return (0, F.isObj)(t) && (0, F.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#adultContentPref";
}
k.isAdultContentPref = jw;
function Ow(t) {
  return ae.lexicons.validate("app.bsky.actor.defs#adultContentPref", t);
}
k.validateAdultContentPref = Ow;
function Mw(t) {
  return (0, F.isObj)(t) && (0, F.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#contentLabelPref";
}
k.isContentLabelPref = Mw;
function Nw(t) {
  return ae.lexicons.validate("app.bsky.actor.defs#contentLabelPref", t);
}
k.validateContentLabelPref = Nw;
function $w(t) {
  return (0, F.isObj)(t) && (0, F.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#savedFeed";
}
k.isSavedFeed = $w;
function Gw(t) {
  return ae.lexicons.validate("app.bsky.actor.defs#savedFeed", t);
}
k.validateSavedFeed = Gw;
function qw(t) {
  return (0, F.isObj)(t) && (0, F.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#savedFeedsPrefV2";
}
k.isSavedFeedsPrefV2 = qw;
function Fw(t) {
  return ae.lexicons.validate("app.bsky.actor.defs#savedFeedsPrefV2", t);
}
k.validateSavedFeedsPrefV2 = Fw;
function zw(t) {
  return (0, F.isObj)(t) && (0, F.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#savedFeedsPref";
}
k.isSavedFeedsPref = zw;
function Xw(t) {
  return ae.lexicons.validate("app.bsky.actor.defs#savedFeedsPref", t);
}
k.validateSavedFeedsPref = Xw;
function Zw(t) {
  return (0, F.isObj)(t) && (0, F.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#personalDetailsPref";
}
k.isPersonalDetailsPref = Zw;
function Hw(t) {
  return ae.lexicons.validate("app.bsky.actor.defs#personalDetailsPref", t);
}
k.validatePersonalDetailsPref = Hw;
function Ww(t) {
  return (0, F.isObj)(t) && (0, F.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#feedViewPref";
}
k.isFeedViewPref = Ww;
function Jw(t) {
  return ae.lexicons.validate("app.bsky.actor.defs#feedViewPref", t);
}
k.validateFeedViewPref = Jw;
function Qw(t) {
  return (0, F.isObj)(t) && (0, F.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#threadViewPref";
}
k.isThreadViewPref = Qw;
function Yw(t) {
  return ae.lexicons.validate("app.bsky.actor.defs#threadViewPref", t);
}
k.validateThreadViewPref = Yw;
function eC(t) {
  return (0, F.isObj)(t) && (0, F.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#interestsPref";
}
k.isInterestsPref = eC;
function tC(t) {
  return ae.lexicons.validate("app.bsky.actor.defs#interestsPref", t);
}
k.validateInterestsPref = tC;
function rC(t) {
  return (0, F.isObj)(t) && (0, F.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#mutedWord";
}
k.isMutedWord = rC;
function iC(t) {
  return ae.lexicons.validate("app.bsky.actor.defs#mutedWord", t);
}
k.validateMutedWord = iC;
function nC(t) {
  return (0, F.isObj)(t) && (0, F.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#mutedWordsPref";
}
k.isMutedWordsPref = nC;
function sC(t) {
  return ae.lexicons.validate("app.bsky.actor.defs#mutedWordsPref", t);
}
k.validateMutedWordsPref = sC;
function oC(t) {
  return (0, F.isObj)(t) && (0, F.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#hiddenPostsPref";
}
k.isHiddenPostsPref = oC;
function aC(t) {
  return ae.lexicons.validate("app.bsky.actor.defs#hiddenPostsPref", t);
}
k.validateHiddenPostsPref = aC;
function lC(t) {
  return (0, F.isObj)(t) && (0, F.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#labelersPref";
}
k.isLabelersPref = lC;
function uC(t) {
  return ae.lexicons.validate("app.bsky.actor.defs#labelersPref", t);
}
k.validateLabelersPref = uC;
function cC(t) {
  return (0, F.isObj)(t) && (0, F.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#labelerPrefItem";
}
k.isLabelerPrefItem = cC;
function pC(t) {
  return ae.lexicons.validate("app.bsky.actor.defs#labelerPrefItem", t);
}
k.validateLabelerPrefItem = pC;
function dC(t) {
  return (0, F.isObj)(t) && (0, F.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#bskyAppStatePref";
}
k.isBskyAppStatePref = dC;
function fC(t) {
  return ae.lexicons.validate("app.bsky.actor.defs#bskyAppStatePref", t);
}
k.validateBskyAppStatePref = fC;
function yC(t) {
  return (0, F.isObj)(t) && (0, F.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#bskyAppProgressGuide";
}
k.isBskyAppProgressGuide = yC;
function mC(t) {
  return ae.lexicons.validate("app.bsky.actor.defs#bskyAppProgressGuide", t);
}
k.validateBskyAppProgressGuide = mC;
var Ai = {};
Object.defineProperty(Ai, "__esModule", { value: !0 });
Ai.validateRecord = Ai.isRecord = void 0;
const yu = N, bC = $;
function hC(t) {
  return (0, yu.isObj)(t) && (0, yu.hasProp)(t, "$type") && (t.$type === "app.bsky.actor.profile#main" || t.$type === "app.bsky.actor.profile");
}
Ai.isRecord = hC;
function EC(t) {
  return bC.lexicons.validate("app.bsky.actor.profile#main", t);
}
Ai.validateRecord = EC;
var Ee = {};
Object.defineProperty(Ee, "__esModule", { value: !0 });
Ee.validateViewExternal = Ee.isViewExternal = Ee.validateView = Ee.isView = Ee.validateExternal = Ee.isExternal = Ee.validateMain = Ee.isMain = void 0;
const Rr = N, wa = $;
function xC(t) {
  return (0, Rr.isObj)(t) && (0, Rr.hasProp)(t, "$type") && (t.$type === "app.bsky.embed.external#main" || t.$type === "app.bsky.embed.external");
}
Ee.isMain = xC;
function gC(t) {
  return wa.lexicons.validate("app.bsky.embed.external#main", t);
}
Ee.validateMain = gC;
function RC(t) {
  return (0, Rr.isObj)(t) && (0, Rr.hasProp)(t, "$type") && t.$type === "app.bsky.embed.external#external";
}
Ee.isExternal = RC;
function vC(t) {
  return wa.lexicons.validate("app.bsky.embed.external#external", t);
}
Ee.validateExternal = vC;
function AC(t) {
  return (0, Rr.isObj)(t) && (0, Rr.hasProp)(t, "$type") && t.$type === "app.bsky.embed.external#view";
}
Ee.isView = AC;
function wC(t) {
  return wa.lexicons.validate("app.bsky.embed.external#view", t);
}
Ee.validateView = wC;
function CC(t) {
  return (0, Rr.isObj)(t) && (0, Rr.hasProp)(t, "$type") && t.$type === "app.bsky.embed.external#viewExternal";
}
Ee.isViewExternal = CC;
function _C(t) {
  return wa.lexicons.validate("app.bsky.embed.external#viewExternal", t);
}
Ee.validateViewExternal = _C;
var ue = {};
Object.defineProperty(ue, "__esModule", { value: !0 });
ue.validateViewImage = ue.isViewImage = ue.validateView = ue.isView = ue.validateAspectRatio = ue.isAspectRatio = ue.validateImage = ue.isImage = ue.validateMain = ue.isMain = void 0;
const Bt = N, To = $;
function TC(t) {
  return (0, Bt.isObj)(t) && (0, Bt.hasProp)(t, "$type") && (t.$type === "app.bsky.embed.images#main" || t.$type === "app.bsky.embed.images");
}
ue.isMain = TC;
function SC(t) {
  return To.lexicons.validate("app.bsky.embed.images#main", t);
}
ue.validateMain = SC;
function LC(t) {
  return (0, Bt.isObj)(t) && (0, Bt.hasProp)(t, "$type") && t.$type === "app.bsky.embed.images#image";
}
ue.isImage = LC;
function kC(t) {
  return To.lexicons.validate("app.bsky.embed.images#image", t);
}
ue.validateImage = kC;
function BC(t) {
  return (0, Bt.isObj)(t) && (0, Bt.hasProp)(t, "$type") && t.$type === "app.bsky.embed.images#aspectRatio";
}
ue.isAspectRatio = BC;
function PC(t) {
  return To.lexicons.validate("app.bsky.embed.images#aspectRatio", t);
}
ue.validateAspectRatio = PC;
function DC(t) {
  return (0, Bt.isObj)(t) && (0, Bt.hasProp)(t, "$type") && t.$type === "app.bsky.embed.images#view";
}
ue.isView = DC;
function KC(t) {
  return To.lexicons.validate("app.bsky.embed.images#view", t);
}
ue.validateView = KC;
function UC(t) {
  return (0, Bt.isObj)(t) && (0, Bt.hasProp)(t, "$type") && t.$type === "app.bsky.embed.images#viewImage";
}
ue.isViewImage = UC;
function VC(t) {
  return To.lexicons.validate("app.bsky.embed.images#viewImage", t);
}
ue.validateViewImage = VC;
var ce = {};
Object.defineProperty(ce, "__esModule", { value: !0 });
ce.validateViewBlocked = ce.isViewBlocked = ce.validateViewNotFound = ce.isViewNotFound = ce.validateViewRecord = ce.isViewRecord = ce.validateView = ce.isView = ce.validateMain = ce.isMain = void 0;
const Pt = N, So = $;
function IC(t) {
  return (0, Pt.isObj)(t) && (0, Pt.hasProp)(t, "$type") && (t.$type === "app.bsky.embed.record#main" || t.$type === "app.bsky.embed.record");
}
ce.isMain = IC;
function jC(t) {
  return So.lexicons.validate("app.bsky.embed.record#main", t);
}
ce.validateMain = jC;
function OC(t) {
  return (0, Pt.isObj)(t) && (0, Pt.hasProp)(t, "$type") && t.$type === "app.bsky.embed.record#view";
}
ce.isView = OC;
function MC(t) {
  return So.lexicons.validate("app.bsky.embed.record#view", t);
}
ce.validateView = MC;
function NC(t) {
  return (0, Pt.isObj)(t) && (0, Pt.hasProp)(t, "$type") && t.$type === "app.bsky.embed.record#viewRecord";
}
ce.isViewRecord = NC;
function $C(t) {
  return So.lexicons.validate("app.bsky.embed.record#viewRecord", t);
}
ce.validateViewRecord = $C;
function GC(t) {
  return (0, Pt.isObj)(t) && (0, Pt.hasProp)(t, "$type") && t.$type === "app.bsky.embed.record#viewNotFound";
}
ce.isViewNotFound = GC;
function qC(t) {
  return So.lexicons.validate("app.bsky.embed.record#viewNotFound", t);
}
ce.validateViewNotFound = qC;
function FC(t) {
  return (0, Pt.isObj)(t) && (0, Pt.hasProp)(t, "$type") && t.$type === "app.bsky.embed.record#viewBlocked";
}
ce.isViewBlocked = FC;
function zC(t) {
  return So.lexicons.validate("app.bsky.embed.record#viewBlocked", t);
}
ce.validateViewBlocked = zC;
var At = {};
Object.defineProperty(At, "__esModule", { value: !0 });
At.validateView = At.isView = At.validateMain = At.isMain = void 0;
const ua = N, Wd = $;
function XC(t) {
  return (0, ua.isObj)(t) && (0, ua.hasProp)(t, "$type") && (t.$type === "app.bsky.embed.recordWithMedia#main" || t.$type === "app.bsky.embed.recordWithMedia");
}
At.isMain = XC;
function ZC(t) {
  return Wd.lexicons.validate("app.bsky.embed.recordWithMedia#main", t);
}
At.validateMain = ZC;
function HC(t) {
  return (0, ua.isObj)(t) && (0, ua.hasProp)(t, "$type") && t.$type === "app.bsky.embed.recordWithMedia#view";
}
At.isView = HC;
function WC(t) {
  return Wd.lexicons.validate("app.bsky.embed.recordWithMedia#view", t);
}
At.validateView = WC;
var P = {};
Object.defineProperty(P, "__esModule", { value: !0 });
P.INTERACTIONSHARE = P.INTERACTIONQUOTE = P.INTERACTIONREPLY = P.INTERACTIONREPOST = P.INTERACTIONLIKE = P.INTERACTIONSEEN = P.CLICKTHROUGHEMBED = P.CLICKTHROUGHREPOSTER = P.CLICKTHROUGHAUTHOR = P.CLICKTHROUGHITEM = P.REQUESTMORE = P.REQUESTLESS = P.validateInteraction = P.isInteraction = P.validateThreadgateView = P.isThreadgateView = P.validateSkeletonReasonRepost = P.isSkeletonReasonRepost = P.validateSkeletonFeedPost = P.isSkeletonFeedPost = P.validateGeneratorViewerState = P.isGeneratorViewerState = P.validateGeneratorView = P.isGeneratorView = P.validateBlockedAuthor = P.isBlockedAuthor = P.validateBlockedPost = P.isBlockedPost = P.validateNotFoundPost = P.isNotFoundPost = P.validateThreadViewPost = P.isThreadViewPost = P.validateReasonRepost = P.isReasonRepost = P.validateReplyRef = P.isReplyRef = P.validateFeedViewPost = P.isFeedViewPost = P.validateViewerState = P.isViewerState = P.validatePostView = P.isPostView = void 0;
const Y = N, Me = $;
function JC(t) {
  return (0, Y.isObj)(t) && (0, Y.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#postView";
}
P.isPostView = JC;
function QC(t) {
  return Me.lexicons.validate("app.bsky.feed.defs#postView", t);
}
P.validatePostView = QC;
function YC(t) {
  return (0, Y.isObj)(t) && (0, Y.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#viewerState";
}
P.isViewerState = YC;
function e_(t) {
  return Me.lexicons.validate("app.bsky.feed.defs#viewerState", t);
}
P.validateViewerState = e_;
function t_(t) {
  return (0, Y.isObj)(t) && (0, Y.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#feedViewPost";
}
P.isFeedViewPost = t_;
function r_(t) {
  return Me.lexicons.validate("app.bsky.feed.defs#feedViewPost", t);
}
P.validateFeedViewPost = r_;
function i_(t) {
  return (0, Y.isObj)(t) && (0, Y.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#replyRef";
}
P.isReplyRef = i_;
function n_(t) {
  return Me.lexicons.validate("app.bsky.feed.defs#replyRef", t);
}
P.validateReplyRef = n_;
function s_(t) {
  return (0, Y.isObj)(t) && (0, Y.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#reasonRepost";
}
P.isReasonRepost = s_;
function o_(t) {
  return Me.lexicons.validate("app.bsky.feed.defs#reasonRepost", t);
}
P.validateReasonRepost = o_;
function a_(t) {
  return (0, Y.isObj)(t) && (0, Y.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#threadViewPost";
}
P.isThreadViewPost = a_;
function l_(t) {
  return Me.lexicons.validate("app.bsky.feed.defs#threadViewPost", t);
}
P.validateThreadViewPost = l_;
function u_(t) {
  return (0, Y.isObj)(t) && (0, Y.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#notFoundPost";
}
P.isNotFoundPost = u_;
function c_(t) {
  return Me.lexicons.validate("app.bsky.feed.defs#notFoundPost", t);
}
P.validateNotFoundPost = c_;
function p_(t) {
  return (0, Y.isObj)(t) && (0, Y.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#blockedPost";
}
P.isBlockedPost = p_;
function d_(t) {
  return Me.lexicons.validate("app.bsky.feed.defs#blockedPost", t);
}
P.validateBlockedPost = d_;
function f_(t) {
  return (0, Y.isObj)(t) && (0, Y.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#blockedAuthor";
}
P.isBlockedAuthor = f_;
function y_(t) {
  return Me.lexicons.validate("app.bsky.feed.defs#blockedAuthor", t);
}
P.validateBlockedAuthor = y_;
function m_(t) {
  return (0, Y.isObj)(t) && (0, Y.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#generatorView";
}
P.isGeneratorView = m_;
function b_(t) {
  return Me.lexicons.validate("app.bsky.feed.defs#generatorView", t);
}
P.validateGeneratorView = b_;
function h_(t) {
  return (0, Y.isObj)(t) && (0, Y.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#generatorViewerState";
}
P.isGeneratorViewerState = h_;
function E_(t) {
  return Me.lexicons.validate("app.bsky.feed.defs#generatorViewerState", t);
}
P.validateGeneratorViewerState = E_;
function x_(t) {
  return (0, Y.isObj)(t) && (0, Y.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#skeletonFeedPost";
}
P.isSkeletonFeedPost = x_;
function g_(t) {
  return Me.lexicons.validate("app.bsky.feed.defs#skeletonFeedPost", t);
}
P.validateSkeletonFeedPost = g_;
function R_(t) {
  return (0, Y.isObj)(t) && (0, Y.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#skeletonReasonRepost";
}
P.isSkeletonReasonRepost = R_;
function v_(t) {
  return Me.lexicons.validate("app.bsky.feed.defs#skeletonReasonRepost", t);
}
P.validateSkeletonReasonRepost = v_;
function A_(t) {
  return (0, Y.isObj)(t) && (0, Y.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#threadgateView";
}
P.isThreadgateView = A_;
function w_(t) {
  return Me.lexicons.validate("app.bsky.feed.defs#threadgateView", t);
}
P.validateThreadgateView = w_;
function C_(t) {
  return (0, Y.isObj)(t) && (0, Y.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#interaction";
}
P.isInteraction = C_;
function __(t) {
  return Me.lexicons.validate("app.bsky.feed.defs#interaction", t);
}
P.validateInteraction = __;
P.REQUESTLESS = "app.bsky.feed.defs#requestLess";
P.REQUESTMORE = "app.bsky.feed.defs#requestMore";
P.CLICKTHROUGHITEM = "app.bsky.feed.defs#clickthroughItem";
P.CLICKTHROUGHAUTHOR = "app.bsky.feed.defs#clickthroughAuthor";
P.CLICKTHROUGHREPOSTER = "app.bsky.feed.defs#clickthroughReposter";
P.CLICKTHROUGHEMBED = "app.bsky.feed.defs#clickthroughEmbed";
P.INTERACTIONSEEN = "app.bsky.feed.defs#interactionSeen";
P.INTERACTIONLIKE = "app.bsky.feed.defs#interactionLike";
P.INTERACTIONREPOST = "app.bsky.feed.defs#interactionRepost";
P.INTERACTIONREPLY = "app.bsky.feed.defs#interactionReply";
P.INTERACTIONQUOTE = "app.bsky.feed.defs#interactionQuote";
P.INTERACTIONSHARE = "app.bsky.feed.defs#interactionShare";
var wi = {};
Object.defineProperty(wi, "__esModule", { value: !0 });
wi.validateRecord = wi.isRecord = void 0;
const mu = N, T_ = $;
function S_(t) {
  return (0, mu.isObj)(t) && (0, mu.hasProp)(t, "$type") && (t.$type === "app.bsky.feed.generator#main" || t.$type === "app.bsky.feed.generator");
}
wi.isRecord = S_;
function L_(t) {
  return T_.lexicons.validate("app.bsky.feed.generator#main", t);
}
wi.validateRecord = L_;
var Ci = {};
Object.defineProperty(Ci, "__esModule", { value: !0 });
Ci.validateRecord = Ci.isRecord = void 0;
const bu = N, k_ = $;
function B_(t) {
  return (0, bu.isObj)(t) && (0, bu.hasProp)(t, "$type") && (t.$type === "app.bsky.feed.like#main" || t.$type === "app.bsky.feed.like");
}
Ci.isRecord = B_;
function P_(t) {
  return k_.lexicons.validate("app.bsky.feed.like#main", t);
}
Ci.validateRecord = P_;
var xe = {};
Object.defineProperty(xe, "__esModule", { value: !0 });
xe.validateTextSlice = xe.isTextSlice = xe.validateEntity = xe.isEntity = xe.validateReplyRef = xe.isReplyRef = xe.validateRecord = xe.isRecord = void 0;
const vr = N, Ca = $;
function D_(t) {
  return (0, vr.isObj)(t) && (0, vr.hasProp)(t, "$type") && (t.$type === "app.bsky.feed.post#main" || t.$type === "app.bsky.feed.post");
}
xe.isRecord = D_;
function K_(t) {
  return Ca.lexicons.validate("app.bsky.feed.post#main", t);
}
xe.validateRecord = K_;
function U_(t) {
  return (0, vr.isObj)(t) && (0, vr.hasProp)(t, "$type") && t.$type === "app.bsky.feed.post#replyRef";
}
xe.isReplyRef = U_;
function V_(t) {
  return Ca.lexicons.validate("app.bsky.feed.post#replyRef", t);
}
xe.validateReplyRef = V_;
function I_(t) {
  return (0, vr.isObj)(t) && (0, vr.hasProp)(t, "$type") && t.$type === "app.bsky.feed.post#entity";
}
xe.isEntity = I_;
function j_(t) {
  return Ca.lexicons.validate("app.bsky.feed.post#entity", t);
}
xe.validateEntity = j_;
function O_(t) {
  return (0, vr.isObj)(t) && (0, vr.hasProp)(t, "$type") && t.$type === "app.bsky.feed.post#textSlice";
}
xe.isTextSlice = O_;
function M_(t) {
  return Ca.lexicons.validate("app.bsky.feed.post#textSlice", t);
}
xe.validateTextSlice = M_;
var _i = {};
Object.defineProperty(_i, "__esModule", { value: !0 });
_i.validateRecord = _i.isRecord = void 0;
const hu = N, N_ = $;
function $_(t) {
  return (0, hu.isObj)(t) && (0, hu.hasProp)(t, "$type") && (t.$type === "app.bsky.feed.repost#main" || t.$type === "app.bsky.feed.repost");
}
_i.isRecord = $_;
function G_(t) {
  return N_.lexicons.validate("app.bsky.feed.repost#main", t);
}
_i.validateRecord = G_;
var ge = {};
Object.defineProperty(ge, "__esModule", { value: !0 });
ge.validateListRule = ge.isListRule = ge.validateFollowingRule = ge.isFollowingRule = ge.validateMentionRule = ge.isMentionRule = ge.validateRecord = ge.isRecord = void 0;
const Ar = N, _a = $;
function q_(t) {
  return (0, Ar.isObj)(t) && (0, Ar.hasProp)(t, "$type") && (t.$type === "app.bsky.feed.threadgate#main" || t.$type === "app.bsky.feed.threadgate");
}
ge.isRecord = q_;
function F_(t) {
  return _a.lexicons.validate("app.bsky.feed.threadgate#main", t);
}
ge.validateRecord = F_;
function z_(t) {
  return (0, Ar.isObj)(t) && (0, Ar.hasProp)(t, "$type") && t.$type === "app.bsky.feed.threadgate#mentionRule";
}
ge.isMentionRule = z_;
function X_(t) {
  return _a.lexicons.validate("app.bsky.feed.threadgate#mentionRule", t);
}
ge.validateMentionRule = X_;
function Z_(t) {
  return (0, Ar.isObj)(t) && (0, Ar.hasProp)(t, "$type") && t.$type === "app.bsky.feed.threadgate#followingRule";
}
ge.isFollowingRule = Z_;
function H_(t) {
  return _a.lexicons.validate("app.bsky.feed.threadgate#followingRule", t);
}
ge.validateFollowingRule = H_;
function W_(t) {
  return (0, Ar.isObj)(t) && (0, Ar.hasProp)(t, "$type") && t.$type === "app.bsky.feed.threadgate#listRule";
}
ge.isListRule = W_;
function J_(t) {
  return _a.lexicons.validate("app.bsky.feed.threadgate#listRule", t);
}
ge.validateListRule = J_;
var Ti = {};
Object.defineProperty(Ti, "__esModule", { value: !0 });
Ti.validateRecord = Ti.isRecord = void 0;
const Eu = N, Q_ = $;
function Y_(t) {
  return (0, Eu.isObj)(t) && (0, Eu.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.block#main" || t.$type === "app.bsky.graph.block");
}
Ti.isRecord = Y_;
function eT(t) {
  return Q_.lexicons.validate("app.bsky.graph.block#main", t);
}
Ti.validateRecord = eT;
var H = {};
Object.defineProperty(H, "__esModule", { value: !0 });
H.validateRelationship = H.isRelationship = H.validateNotFoundActor = H.isNotFoundActor = H.validateListViewerState = H.isListViewerState = H.REFERENCELIST = H.CURATELIST = H.MODLIST = H.validateStarterPackViewBasic = H.isStarterPackViewBasic = H.validateStarterPackView = H.isStarterPackView = H.validateListItemView = H.isListItemView = H.validateListView = H.isListView = H.validateListViewBasic = H.isListViewBasic = void 0;
const De = N, kr = $;
function tT(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#listViewBasic";
}
H.isListViewBasic = tT;
function rT(t) {
  return kr.lexicons.validate("app.bsky.graph.defs#listViewBasic", t);
}
H.validateListViewBasic = rT;
function iT(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#listView";
}
H.isListView = iT;
function nT(t) {
  return kr.lexicons.validate("app.bsky.graph.defs#listView", t);
}
H.validateListView = nT;
function sT(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#listItemView";
}
H.isListItemView = sT;
function oT(t) {
  return kr.lexicons.validate("app.bsky.graph.defs#listItemView", t);
}
H.validateListItemView = oT;
function aT(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#starterPackView";
}
H.isStarterPackView = aT;
function lT(t) {
  return kr.lexicons.validate("app.bsky.graph.defs#starterPackView", t);
}
H.validateStarterPackView = lT;
function uT(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#starterPackViewBasic";
}
H.isStarterPackViewBasic = uT;
function cT(t) {
  return kr.lexicons.validate("app.bsky.graph.defs#starterPackViewBasic", t);
}
H.validateStarterPackViewBasic = cT;
H.MODLIST = "app.bsky.graph.defs#modlist";
H.CURATELIST = "app.bsky.graph.defs#curatelist";
H.REFERENCELIST = "app.bsky.graph.defs#referencelist";
function pT(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#listViewerState";
}
H.isListViewerState = pT;
function dT(t) {
  return kr.lexicons.validate("app.bsky.graph.defs#listViewerState", t);
}
H.validateListViewerState = dT;
function fT(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#notFoundActor";
}
H.isNotFoundActor = fT;
function yT(t) {
  return kr.lexicons.validate("app.bsky.graph.defs#notFoundActor", t);
}
H.validateNotFoundActor = yT;
function mT(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#relationship";
}
H.isRelationship = mT;
function bT(t) {
  return kr.lexicons.validate("app.bsky.graph.defs#relationship", t);
}
H.validateRelationship = bT;
var Si = {};
Object.defineProperty(Si, "__esModule", { value: !0 });
Si.validateRecord = Si.isRecord = void 0;
const xu = N, hT = $;
function ET(t) {
  return (0, xu.isObj)(t) && (0, xu.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.follow#main" || t.$type === "app.bsky.graph.follow");
}
Si.isRecord = ET;
function xT(t) {
  return hT.lexicons.validate("app.bsky.graph.follow#main", t);
}
Si.validateRecord = xT;
var Li = {};
Object.defineProperty(Li, "__esModule", { value: !0 });
Li.validateRecord = Li.isRecord = void 0;
const gu = N, gT = $;
function RT(t) {
  return (0, gu.isObj)(t) && (0, gu.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.list#main" || t.$type === "app.bsky.graph.list");
}
Li.isRecord = RT;
function vT(t) {
  return gT.lexicons.validate("app.bsky.graph.list#main", t);
}
Li.validateRecord = vT;
var ki = {};
Object.defineProperty(ki, "__esModule", { value: !0 });
ki.validateRecord = ki.isRecord = void 0;
const Ru = N, AT = $;
function wT(t) {
  return (0, Ru.isObj)(t) && (0, Ru.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.listblock#main" || t.$type === "app.bsky.graph.listblock");
}
ki.isRecord = wT;
function CT(t) {
  return AT.lexicons.validate("app.bsky.graph.listblock#main", t);
}
ki.validateRecord = CT;
var Bi = {};
Object.defineProperty(Bi, "__esModule", { value: !0 });
Bi.validateRecord = Bi.isRecord = void 0;
const vu = N, _T = $;
function TT(t) {
  return (0, vu.isObj)(t) && (0, vu.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.listitem#main" || t.$type === "app.bsky.graph.listitem");
}
Bi.isRecord = TT;
function ST(t) {
  return _T.lexicons.validate("app.bsky.graph.listitem#main", t);
}
Bi.validateRecord = ST;
var wt = {};
Object.defineProperty(wt, "__esModule", { value: !0 });
wt.validateFeedItem = wt.isFeedItem = wt.validateRecord = wt.isRecord = void 0;
const ca = N, Jd = $;
function LT(t) {
  return (0, ca.isObj)(t) && (0, ca.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.starterpack#main" || t.$type === "app.bsky.graph.starterpack");
}
wt.isRecord = LT;
function kT(t) {
  return Jd.lexicons.validate("app.bsky.graph.starterpack#main", t);
}
wt.validateRecord = kT;
function BT(t) {
  return (0, ca.isObj)(t) && (0, ca.hasProp)(t, "$type") && t.$type === "app.bsky.graph.starterpack#feedItem";
}
wt.isFeedItem = BT;
function PT(t) {
  return Jd.lexicons.validate("app.bsky.graph.starterpack#feedItem", t);
}
wt.validateFeedItem = PT;
var Re = {};
Object.defineProperty(Re, "__esModule", { value: !0 });
Re.validateLabelerPolicies = Re.isLabelerPolicies = Re.validateLabelerViewerState = Re.isLabelerViewerState = Re.validateLabelerViewDetailed = Re.isLabelerViewDetailed = Re.validateLabelerView = Re.isLabelerView = void 0;
const wr = N, Ta = $;
function DT(t) {
  return (0, wr.isObj)(t) && (0, wr.hasProp)(t, "$type") && t.$type === "app.bsky.labeler.defs#labelerView";
}
Re.isLabelerView = DT;
function KT(t) {
  return Ta.lexicons.validate("app.bsky.labeler.defs#labelerView", t);
}
Re.validateLabelerView = KT;
function UT(t) {
  return (0, wr.isObj)(t) && (0, wr.hasProp)(t, "$type") && t.$type === "app.bsky.labeler.defs#labelerViewDetailed";
}
Re.isLabelerViewDetailed = UT;
function VT(t) {
  return Ta.lexicons.validate("app.bsky.labeler.defs#labelerViewDetailed", t);
}
Re.validateLabelerViewDetailed = VT;
function IT(t) {
  return (0, wr.isObj)(t) && (0, wr.hasProp)(t, "$type") && t.$type === "app.bsky.labeler.defs#labelerViewerState";
}
Re.isLabelerViewerState = IT;
function jT(t) {
  return Ta.lexicons.validate("app.bsky.labeler.defs#labelerViewerState", t);
}
Re.validateLabelerViewerState = jT;
function OT(t) {
  return (0, wr.isObj)(t) && (0, wr.hasProp)(t, "$type") && t.$type === "app.bsky.labeler.defs#labelerPolicies";
}
Re.isLabelerPolicies = OT;
function MT(t) {
  return Ta.lexicons.validate("app.bsky.labeler.defs#labelerPolicies", t);
}
Re.validateLabelerPolicies = MT;
var Pi = {};
Object.defineProperty(Pi, "__esModule", { value: !0 });
Pi.validateRecord = Pi.isRecord = void 0;
const Au = N, NT = $;
function $T(t) {
  return (0, Au.isObj)(t) && (0, Au.hasProp)(t, "$type") && (t.$type === "app.bsky.labeler.service#main" || t.$type === "app.bsky.labeler.service");
}
Pi.isRecord = $T;
function GT(t) {
  return NT.lexicons.validate("app.bsky.labeler.service#main", t);
}
Pi.validateRecord = GT;
var pe = {};
Object.defineProperty(pe, "__esModule", { value: !0 });
pe.validateByteSlice = pe.isByteSlice = pe.validateTag = pe.isTag = pe.validateLink = pe.isLink = pe.validateMention = pe.isMention = pe.validateMain = pe.isMain = void 0;
const Dt = N, Lo = $;
function qT(t) {
  return (0, Dt.isObj)(t) && (0, Dt.hasProp)(t, "$type") && (t.$type === "app.bsky.richtext.facet#main" || t.$type === "app.bsky.richtext.facet");
}
pe.isMain = qT;
function FT(t) {
  return Lo.lexicons.validate("app.bsky.richtext.facet#main", t);
}
pe.validateMain = FT;
function zT(t) {
  return (0, Dt.isObj)(t) && (0, Dt.hasProp)(t, "$type") && t.$type === "app.bsky.richtext.facet#mention";
}
pe.isMention = zT;
function XT(t) {
  return Lo.lexicons.validate("app.bsky.richtext.facet#mention", t);
}
pe.validateMention = XT;
function ZT(t) {
  return (0, Dt.isObj)(t) && (0, Dt.hasProp)(t, "$type") && t.$type === "app.bsky.richtext.facet#link";
}
pe.isLink = ZT;
function HT(t) {
  return Lo.lexicons.validate("app.bsky.richtext.facet#link", t);
}
pe.validateLink = HT;
function WT(t) {
  return (0, Dt.isObj)(t) && (0, Dt.hasProp)(t, "$type") && t.$type === "app.bsky.richtext.facet#tag";
}
pe.isTag = WT;
function JT(t) {
  return Lo.lexicons.validate("app.bsky.richtext.facet#tag", t);
}
pe.validateTag = JT;
function QT(t) {
  return (0, Dt.isObj)(t) && (0, Dt.hasProp)(t, "$type") && t.$type === "app.bsky.richtext.facet#byteSlice";
}
pe.isByteSlice = QT;
function YT(t) {
  return Lo.lexicons.validate("app.bsky.richtext.facet#byteSlice", t);
}
pe.validateByteSlice = YT;
var Ct = {};
Object.defineProperty(Ct, "__esModule", { value: !0 });
Ct.validateSkeletonSearchActor = Ct.isSkeletonSearchActor = Ct.validateSkeletonSearchPost = Ct.isSkeletonSearchPost = void 0;
const pa = N, Qd = $;
function e1(t) {
  return (0, pa.isObj)(t) && (0, pa.hasProp)(t, "$type") && t.$type === "app.bsky.unspecced.defs#skeletonSearchPost";
}
Ct.isSkeletonSearchPost = e1;
function t1(t) {
  return Qd.lexicons.validate("app.bsky.unspecced.defs#skeletonSearchPost", t);
}
Ct.validateSkeletonSearchPost = t1;
function r1(t) {
  return (0, pa.isObj)(t) && (0, pa.hasProp)(t, "$type") && t.$type === "app.bsky.unspecced.defs#skeletonSearchActor";
}
Ct.isSkeletonSearchActor = r1;
function i1(t) {
  return Qd.lexicons.validate("app.bsky.unspecced.defs#skeletonSearchActor", t);
}
Ct.validateSkeletonSearchActor = i1;
var Di = {};
Object.defineProperty(Di, "__esModule", { value: !0 });
Di.validateRecord = Di.isRecord = void 0;
const wu = N, n1 = $;
function s1(t) {
  return (0, wu.isObj)(t) && (0, wu.hasProp)(t, "$type") && (t.$type === "chat.bsky.actor.declaration#main" || t.$type === "chat.bsky.actor.declaration");
}
Di.isRecord = s1;
function o1(t) {
  return n1.lexicons.validate("chat.bsky.actor.declaration#main", t);
}
Di.validateRecord = o1;
var Ki = {};
Object.defineProperty(Ki, "__esModule", { value: !0 });
Ki.validateProfileViewBasic = Ki.isProfileViewBasic = void 0;
const Cu = N, a1 = $;
function l1(t) {
  return (0, Cu.isObj)(t) && (0, Cu.hasProp)(t, "$type") && t.$type === "chat.bsky.actor.defs#profileViewBasic";
}
Ki.isProfileViewBasic = l1;
function u1(t) {
  return a1.lexicons.validate("chat.bsky.actor.defs#profileViewBasic", t);
}
Ki.validateProfileViewBasic = u1;
var Z = {};
Object.defineProperty(Z, "__esModule", { value: !0 });
Z.validateLogDeleteMessage = Z.isLogDeleteMessage = Z.validateLogCreateMessage = Z.isLogCreateMessage = Z.validateLogLeaveConvo = Z.isLogLeaveConvo = Z.validateLogBeginConvo = Z.isLogBeginConvo = Z.validateConvoView = Z.isConvoView = Z.validateMessageViewSender = Z.isMessageViewSender = Z.validateDeletedMessageView = Z.isDeletedMessageView = Z.validateMessageView = Z.isMessageView = Z.validateMessageInput = Z.isMessageInput = Z.validateMessageRef = Z.isMessageRef = void 0;
const fe = N, It = $;
function c1(t) {
  return (0, fe.isObj)(t) && (0, fe.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#messageRef";
}
Z.isMessageRef = c1;
function p1(t) {
  return It.lexicons.validate("chat.bsky.convo.defs#messageRef", t);
}
Z.validateMessageRef = p1;
function d1(t) {
  return (0, fe.isObj)(t) && (0, fe.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#messageInput";
}
Z.isMessageInput = d1;
function f1(t) {
  return It.lexicons.validate("chat.bsky.convo.defs#messageInput", t);
}
Z.validateMessageInput = f1;
function y1(t) {
  return (0, fe.isObj)(t) && (0, fe.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#messageView";
}
Z.isMessageView = y1;
function m1(t) {
  return It.lexicons.validate("chat.bsky.convo.defs#messageView", t);
}
Z.validateMessageView = m1;
function b1(t) {
  return (0, fe.isObj)(t) && (0, fe.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#deletedMessageView";
}
Z.isDeletedMessageView = b1;
function h1(t) {
  return It.lexicons.validate("chat.bsky.convo.defs#deletedMessageView", t);
}
Z.validateDeletedMessageView = h1;
function E1(t) {
  return (0, fe.isObj)(t) && (0, fe.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#messageViewSender";
}
Z.isMessageViewSender = E1;
function x1(t) {
  return It.lexicons.validate("chat.bsky.convo.defs#messageViewSender", t);
}
Z.validateMessageViewSender = x1;
function g1(t) {
  return (0, fe.isObj)(t) && (0, fe.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#convoView";
}
Z.isConvoView = g1;
function R1(t) {
  return It.lexicons.validate("chat.bsky.convo.defs#convoView", t);
}
Z.validateConvoView = R1;
function v1(t) {
  return (0, fe.isObj)(t) && (0, fe.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#logBeginConvo";
}
Z.isLogBeginConvo = v1;
function A1(t) {
  return It.lexicons.validate("chat.bsky.convo.defs#logBeginConvo", t);
}
Z.validateLogBeginConvo = A1;
function w1(t) {
  return (0, fe.isObj)(t) && (0, fe.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#logLeaveConvo";
}
Z.isLogLeaveConvo = w1;
function C1(t) {
  return It.lexicons.validate("chat.bsky.convo.defs#logLeaveConvo", t);
}
Z.validateLogLeaveConvo = C1;
function _1(t) {
  return (0, fe.isObj)(t) && (0, fe.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#logCreateMessage";
}
Z.isLogCreateMessage = _1;
function T1(t) {
  return It.lexicons.validate("chat.bsky.convo.defs#logCreateMessage", t);
}
Z.validateLogCreateMessage = T1;
function S1(t) {
  return (0, fe.isObj)(t) && (0, fe.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#logDeleteMessage";
}
Z.isLogDeleteMessage = S1;
function L1(t) {
  return It.lexicons.validate("chat.bsky.convo.defs#logDeleteMessage", t);
}
Z.validateLogDeleteMessage = L1;
var Ui = {};
Object.defineProperty(Ui, "__esModule", { value: !0 });
Ui.validateTemplateView = Ui.isTemplateView = void 0;
const _u = N, k1 = $;
function B1(t) {
  return (0, _u.isObj)(t) && (0, _u.hasProp)(t, "$type") && t.$type === "tools.ozone.communication.defs#templateView";
}
Ui.isTemplateView = B1;
function P1(t) {
  return k1.lexicons.validate("tools.ozone.communication.defs#templateView", t);
}
Ui.validateTemplateView = P1;
var w = {};
Object.defineProperty(w, "__esModule", { value: !0 });
w.validateRecordViewDetail = w.isRecordViewDetail = w.validateRecordView = w.isRecordView = w.validateRepoViewNotFound = w.isRepoViewNotFound = w.validateRepoViewDetail = w.isRepoViewDetail = w.validateRepoView = w.isRepoView = w.validateModEventTag = w.isModEventTag = w.validateModEventDivert = w.isModEventDivert = w.validateModEventEmail = w.isModEventEmail = w.validateModEventUnmuteReporter = w.isModEventUnmuteReporter = w.validateModEventMuteReporter = w.isModEventMuteReporter = w.validateModEventUnmute = w.isModEventUnmute = w.validateModEventMute = w.isModEventMute = w.validateModEventEscalate = w.isModEventEscalate = w.validateModEventAcknowledge = w.isModEventAcknowledge = w.validateModEventLabel = w.isModEventLabel = w.validateModEventReport = w.isModEventReport = w.validateModEventComment = w.isModEventComment = w.validateModEventResolveAppeal = w.isModEventResolveAppeal = w.validateModEventReverseTakedown = w.isModEventReverseTakedown = w.validateModEventTakedown = w.isModEventTakedown = w.REVIEWNONE = w.REVIEWCLOSED = w.REVIEWESCALATED = w.REVIEWOPEN = w.validateSubjectStatusView = w.isSubjectStatusView = w.validateModEventViewDetail = w.isModEventViewDetail = w.validateModEventView = w.isModEventView = void 0;
w.validateVideoDetails = w.isVideoDetails = w.validateImageDetails = w.isImageDetails = w.validateBlobView = w.isBlobView = w.validateModerationDetail = w.isModerationDetail = w.validateModeration = w.isModeration = w.validateRecordViewNotFound = w.isRecordViewNotFound = void 0;
const M = N, te = $;
function D1(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventView";
}
w.isModEventView = D1;
function K1(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#modEventView", t);
}
w.validateModEventView = K1;
function U1(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventViewDetail";
}
w.isModEventViewDetail = U1;
function V1(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#modEventViewDetail", t);
}
w.validateModEventViewDetail = V1;
function I1(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#subjectStatusView";
}
w.isSubjectStatusView = I1;
function j1(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#subjectStatusView", t);
}
w.validateSubjectStatusView = j1;
w.REVIEWOPEN = "tools.ozone.moderation.defs#reviewOpen";
w.REVIEWESCALATED = "tools.ozone.moderation.defs#reviewEscalated";
w.REVIEWCLOSED = "tools.ozone.moderation.defs#reviewClosed";
w.REVIEWNONE = "tools.ozone.moderation.defs#reviewNone";
function O1(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventTakedown";
}
w.isModEventTakedown = O1;
function M1(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#modEventTakedown", t);
}
w.validateModEventTakedown = M1;
function N1(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventReverseTakedown";
}
w.isModEventReverseTakedown = N1;
function $1(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#modEventReverseTakedown", t);
}
w.validateModEventReverseTakedown = $1;
function G1(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventResolveAppeal";
}
w.isModEventResolveAppeal = G1;
function q1(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#modEventResolveAppeal", t);
}
w.validateModEventResolveAppeal = q1;
function F1(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventComment";
}
w.isModEventComment = F1;
function z1(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#modEventComment", t);
}
w.validateModEventComment = z1;
function X1(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventReport";
}
w.isModEventReport = X1;
function Z1(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#modEventReport", t);
}
w.validateModEventReport = Z1;
function H1(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventLabel";
}
w.isModEventLabel = H1;
function W1(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#modEventLabel", t);
}
w.validateModEventLabel = W1;
function J1(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventAcknowledge";
}
w.isModEventAcknowledge = J1;
function Q1(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#modEventAcknowledge", t);
}
w.validateModEventAcknowledge = Q1;
function Y1(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventEscalate";
}
w.isModEventEscalate = Y1;
function eS(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#modEventEscalate", t);
}
w.validateModEventEscalate = eS;
function tS(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventMute";
}
w.isModEventMute = tS;
function rS(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#modEventMute", t);
}
w.validateModEventMute = rS;
function iS(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventUnmute";
}
w.isModEventUnmute = iS;
function nS(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#modEventUnmute", t);
}
w.validateModEventUnmute = nS;
function sS(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventMuteReporter";
}
w.isModEventMuteReporter = sS;
function oS(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#modEventMuteReporter", t);
}
w.validateModEventMuteReporter = oS;
function aS(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventUnmuteReporter";
}
w.isModEventUnmuteReporter = aS;
function lS(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#modEventUnmuteReporter", t);
}
w.validateModEventUnmuteReporter = lS;
function uS(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventEmail";
}
w.isModEventEmail = uS;
function cS(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#modEventEmail", t);
}
w.validateModEventEmail = cS;
function pS(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventDivert";
}
w.isModEventDivert = pS;
function dS(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#modEventDivert", t);
}
w.validateModEventDivert = dS;
function fS(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventTag";
}
w.isModEventTag = fS;
function yS(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#modEventTag", t);
}
w.validateModEventTag = yS;
function mS(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#repoView";
}
w.isRepoView = mS;
function bS(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#repoView", t);
}
w.validateRepoView = bS;
function hS(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#repoViewDetail";
}
w.isRepoViewDetail = hS;
function ES(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#repoViewDetail", t);
}
w.validateRepoViewDetail = ES;
function xS(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#repoViewNotFound";
}
w.isRepoViewNotFound = xS;
function gS(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#repoViewNotFound", t);
}
w.validateRepoViewNotFound = gS;
function RS(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#recordView";
}
w.isRecordView = RS;
function vS(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#recordView", t);
}
w.validateRecordView = vS;
function AS(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#recordViewDetail";
}
w.isRecordViewDetail = AS;
function wS(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#recordViewDetail", t);
}
w.validateRecordViewDetail = wS;
function CS(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#recordViewNotFound";
}
w.isRecordViewNotFound = CS;
function _S(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#recordViewNotFound", t);
}
w.validateRecordViewNotFound = _S;
function TS(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#moderation";
}
w.isModeration = TS;
function SS(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#moderation", t);
}
w.validateModeration = SS;
function LS(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#moderationDetail";
}
w.isModerationDetail = LS;
function kS(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#moderationDetail", t);
}
w.validateModerationDetail = kS;
function BS(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#blobView";
}
w.isBlobView = BS;
function PS(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#blobView", t);
}
w.validateBlobView = PS;
function DS(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#imageDetails";
}
w.isImageDetails = DS;
function KS(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#imageDetails", t);
}
w.validateImageDetails = KS;
function US(t) {
  return (0, M.isObj)(t) && (0, M.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#videoDetails";
}
w.isVideoDetails = US;
function VS(t) {
  return te.lexicons.validate("tools.ozone.moderation.defs#videoDetails", t);
}
w.validateVideoDetails = VS;
var et = {};
Object.defineProperty(et, "__esModule", { value: !0 });
et.ROLETRIAGE = et.ROLEMODERATOR = et.ROLEADMIN = et.validateMember = et.isMember = void 0;
const Tu = N, IS = $;
function jS(t) {
  return (0, Tu.isObj)(t) && (0, Tu.hasProp)(t, "$type") && t.$type === "tools.ozone.team.defs#member";
}
et.isMember = jS;
function OS(t) {
  return IS.lexicons.validate("tools.ozone.team.defs#member", t);
}
et.validateMember = OS;
et.ROLEADMIN = "tools.ozone.team.defs#roleAdmin";
et.ROLEMODERATOR = "tools.ozone.team.defs#roleModerator";
et.ROLETRIAGE = "tools.ozone.team.defs#roleTriage";
var MS = S && S.__createBinding || (Object.create ? function(t, e, r, n) {
  n === void 0 && (n = r);
  var s = Object.getOwnPropertyDescriptor(e, r);
  (!s || ("get" in s ? !e.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, n, s);
} : function(t, e, r, n) {
  n === void 0 && (n = r), t[n] = e[r];
}), NS = S && S.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), f = S && S.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && MS(e, t, r);
  return NS(e, t), e;
};
Object.defineProperty(l, "__esModule", { value: !0 });
l.ComAtprotoServerDescribeServer = l.ComAtprotoServerDeleteSession = l.ComAtprotoServerDeleteAccount = l.ComAtprotoServerDefs = l.ComAtprotoServerDeactivateAccount = l.ComAtprotoServerCreateSession = l.ComAtprotoServerCreateInviteCodes = l.ComAtprotoServerCreateInviteCode = l.ComAtprotoServerCreateAppPassword = l.ComAtprotoServerCreateAccount = l.ComAtprotoServerConfirmEmail = l.ComAtprotoServerCheckAccountStatus = l.ComAtprotoServerActivateAccount = l.ComAtprotoRepoUploadBlob = l.ComAtprotoRepoStrongRef = l.ComAtprotoRepoPutRecord = l.ComAtprotoRepoListRecords = l.ComAtprotoRepoListMissingBlobs = l.ComAtprotoRepoImportRepo = l.ComAtprotoRepoGetRecord = l.ComAtprotoRepoDescribeRepo = l.ComAtprotoRepoDeleteRecord = l.ComAtprotoRepoCreateRecord = l.ComAtprotoRepoApplyWrites = l.ComAtprotoModerationDefs = l.ComAtprotoModerationCreateReport = l.ComAtprotoLabelSubscribeLabels = l.ComAtprotoLabelQueryLabels = l.ComAtprotoLabelDefs = l.ComAtprotoIdentityUpdateHandle = l.ComAtprotoIdentitySubmitPlcOperation = l.ComAtprotoIdentitySignPlcOperation = l.ComAtprotoIdentityResolveHandle = l.ComAtprotoIdentityRequestPlcOperationSignature = l.ComAtprotoIdentityGetRecommendedDidCredentials = l.ComAtprotoAdminUpdateSubjectStatus = l.ComAtprotoAdminUpdateAccountPassword = l.ComAtprotoAdminUpdateAccountHandle = l.ComAtprotoAdminUpdateAccountEmail = l.ComAtprotoAdminSendEmail = l.ComAtprotoAdminSearchAccounts = l.ComAtprotoAdminGetSubjectStatus = l.ComAtprotoAdminGetInviteCodes = l.ComAtprotoAdminGetAccountInfos = l.ComAtprotoAdminGetAccountInfo = l.ComAtprotoAdminEnableAccountInvites = l.ComAtprotoAdminDisableInviteCodes = l.ComAtprotoAdminDisableAccountInvites = l.ComAtprotoAdminDeleteAccount = l.ComAtprotoAdminDefs = void 0;
l.AppBskyFeedGetFeedGenerator = l.AppBskyFeedGetFeed = l.AppBskyFeedGetAuthorFeed = l.AppBskyFeedGetActorLikes = l.AppBskyFeedGetActorFeeds = l.AppBskyFeedGenerator = l.AppBskyFeedDescribeFeedGenerator = l.AppBskyFeedDefs = l.AppBskyEmbedRecordWithMedia = l.AppBskyEmbedRecord = l.AppBskyEmbedImages = l.AppBskyEmbedExternal = l.AppBskyActorSearchActorsTypeahead = l.AppBskyActorSearchActors = l.AppBskyActorPutPreferences = l.AppBskyActorProfile = l.AppBskyActorGetSuggestions = l.AppBskyActorGetProfiles = l.AppBskyActorGetProfile = l.AppBskyActorGetPreferences = l.AppBskyActorDefs = l.ComAtprotoTempRequestPhoneVerification = l.ComAtprotoTempFetchLabels = l.ComAtprotoTempCheckSignupQueue = l.ComAtprotoSyncSubscribeRepos = l.ComAtprotoSyncRequestCrawl = l.ComAtprotoSyncNotifyOfUpdate = l.ComAtprotoSyncListRepos = l.ComAtprotoSyncListBlobs = l.ComAtprotoSyncGetRepoStatus = l.ComAtprotoSyncGetRepo = l.ComAtprotoSyncGetRecord = l.ComAtprotoSyncGetLatestCommit = l.ComAtprotoSyncGetHead = l.ComAtprotoSyncGetCheckout = l.ComAtprotoSyncGetBlocks = l.ComAtprotoSyncGetBlob = l.ComAtprotoServerUpdateEmail = l.ComAtprotoServerRevokeAppPassword = l.ComAtprotoServerResetPassword = l.ComAtprotoServerReserveSigningKey = l.ComAtprotoServerRequestPasswordReset = l.ComAtprotoServerRequestEmailUpdate = l.ComAtprotoServerRequestEmailConfirmation = l.ComAtprotoServerRequestAccountDelete = l.ComAtprotoServerRefreshSession = l.ComAtprotoServerListAppPasswords = l.ComAtprotoServerGetSession = l.ComAtprotoServerGetServiceAuth = l.ComAtprotoServerGetAccountInviteCodes = void 0;
l.AppBskyNotificationUpdateSeen = l.AppBskyNotificationRegisterPush = l.AppBskyNotificationPutPreferences = l.AppBskyNotificationListNotifications = l.AppBskyNotificationGetUnreadCount = l.AppBskyLabelerService = l.AppBskyLabelerGetServices = l.AppBskyLabelerDefs = l.AppBskyGraphUnmuteThread = l.AppBskyGraphUnmuteActorList = l.AppBskyGraphUnmuteActor = l.AppBskyGraphStarterpack = l.AppBskyGraphMuteThread = l.AppBskyGraphMuteActorList = l.AppBskyGraphMuteActor = l.AppBskyGraphListitem = l.AppBskyGraphListblock = l.AppBskyGraphList = l.AppBskyGraphGetSuggestedFollowsByActor = l.AppBskyGraphGetStarterPacks = l.AppBskyGraphGetStarterPack = l.AppBskyGraphGetRelationships = l.AppBskyGraphGetMutes = l.AppBskyGraphGetLists = l.AppBskyGraphGetListMutes = l.AppBskyGraphGetListBlocks = l.AppBskyGraphGetList = l.AppBskyGraphGetKnownFollowers = l.AppBskyGraphGetFollows = l.AppBskyGraphGetFollowers = l.AppBskyGraphGetBlocks = l.AppBskyGraphGetActorStarterPacks = l.AppBskyGraphFollow = l.AppBskyGraphDefs = l.AppBskyGraphBlock = l.AppBskyFeedThreadgate = l.AppBskyFeedSendInteractions = l.AppBskyFeedSearchPosts = l.AppBskyFeedRepost = l.AppBskyFeedPost = l.AppBskyFeedLike = l.AppBskyFeedGetTimeline = l.AppBskyFeedGetSuggestedFeeds = l.AppBskyFeedGetRepostedBy = l.AppBskyFeedGetPosts = l.AppBskyFeedGetPostThread = l.AppBskyFeedGetListFeed = l.AppBskyFeedGetLikes = l.AppBskyFeedGetFeedSkeleton = l.AppBskyFeedGetFeedGenerators = void 0;
l.TOOLS_OZONE_MODERATION = l.APP_BSKY_GRAPH = l.APP_BSKY_FEED = l.COM_ATPROTO_MODERATION = l.ToolsOzoneTeamUpdateMember = l.ToolsOzoneTeamListMembers = l.ToolsOzoneTeamDeleteMember = l.ToolsOzoneTeamDefs = l.ToolsOzoneTeamAddMember = l.ToolsOzoneServerGetConfig = l.ToolsOzoneModerationSearchRepos = l.ToolsOzoneModerationQueryStatuses = l.ToolsOzoneModerationQueryEvents = l.ToolsOzoneModerationGetRepo = l.ToolsOzoneModerationGetRecord = l.ToolsOzoneModerationGetEvent = l.ToolsOzoneModerationEmitEvent = l.ToolsOzoneModerationDefs = l.ToolsOzoneCommunicationUpdateTemplate = l.ToolsOzoneCommunicationListTemplates = l.ToolsOzoneCommunicationDeleteTemplate = l.ToolsOzoneCommunicationDefs = l.ToolsOzoneCommunicationCreateTemplate = l.ChatBskyModerationUpdateActorAccess = l.ChatBskyModerationGetMessageContext = l.ChatBskyModerationGetActorMetadata = l.ChatBskyConvoUpdateRead = l.ChatBskyConvoUnmuteConvo = l.ChatBskyConvoSendMessageBatch = l.ChatBskyConvoSendMessage = l.ChatBskyConvoMuteConvo = l.ChatBskyConvoListConvos = l.ChatBskyConvoLeaveConvo = l.ChatBskyConvoGetMessages = l.ChatBskyConvoGetLog = l.ChatBskyConvoGetConvoForMembers = l.ChatBskyConvoGetConvo = l.ChatBskyConvoDeleteMessageForSelf = l.ChatBskyConvoDefs = l.ChatBskyActorExportAccountData = l.ChatBskyActorDeleteAccount = l.ChatBskyActorDefs = l.ChatBskyActorDeclaration = l.AppBskyUnspeccedSearchPostsSkeleton = l.AppBskyUnspeccedSearchActorsSkeleton = l.AppBskyUnspeccedGetTaggedSuggestions = l.AppBskyUnspeccedGetSuggestionsSkeleton = l.AppBskyUnspeccedGetPopularFeedGenerators = l.AppBskyUnspeccedDefs = l.AppBskyRichtextFacet = void 0;
l.ToolsOzoneTeamNS = l.ToolsOzoneServerNS = l.ToolsOzoneModerationNS = l.ToolsOzoneCommunicationNS = l.ToolsOzoneNS = l.ToolsNS = l.ChatBskyModerationNS = l.ChatBskyConvoNS = l.DeclarationRecord = l.ChatBskyActorNS = l.ChatBskyNS = l.ChatNS = l.AppBskyUnspeccedNS = l.AppBskyRichtextNS = l.AppBskyNotificationNS = l.ServiceRecord = l.AppBskyLabelerNS = l.StarterpackRecord = l.ListitemRecord = l.ListblockRecord = l.ListRecord = l.FollowRecord = l.BlockRecord = l.AppBskyGraphNS = l.ThreadgateRecord = l.RepostRecord = l.PostRecord = l.LikeRecord = l.GeneratorRecord = l.AppBskyFeedNS = l.AppBskyEmbedNS = l.ProfileRecord = l.AppBskyActorNS = l.AppBskyNS = l.AppNS = l.ComAtprotoTempNS = l.ComAtprotoSyncNS = l.ComAtprotoServerNS = l.ComAtprotoRepoNS = l.ComAtprotoModerationNS = l.ComAtprotoLabelNS = l.ComAtprotoIdentityNS = l.ComAtprotoAdminNS = l.ComAtprotoNS = l.ComNS = l.AtpServiceClient = l.AtpBaseClient = l.TOOLS_OZONE_TEAM = void 0;
const $S = v, GS = $, qS = f(gn), FS = f(Rn), zS = f(vn), XS = f(An), ZS = f(wn), HS = f(Cn), WS = f(_n), JS = f(Tn), QS = f(Sn), YS = f(Ln), eL = f(kn), tL = f(Bn), rL = f(Pn), iL = f(Dn), nL = f(Kn), sL = f(Un), oL = f(Vn), aL = f(In), lL = f(jn), uL = f(On), cL = f(Mn), pL = f(Nn), dL = f(ye), fL = f(Or), yL = f(Mr), mL = f($n), bL = f(Gn), hL = f(qn), EL = f(Ht), xL = f(Wt), gL = f(Nr), RL = f(Fn), vL = f(zn), AL = f(Xn), wL = f(Fe), CL = f(me), _L = f(lt), TL = f(Hn), SL = f(Jt), LL = f(Qt), kL = f(Wn), BL = f(Yt), PL = f(Jn), DL = f(ze), KL = f($r), UL = f(Gr), VL = f(Qn), IL = f(ut), jL = f(qr), OL = f(Yn), ML = f(es), NL = f(ts), $L = f(rs), GL = f(is), qL = f(er), FL = f(ns), zL = f(ct), XL = f(Ve), ZL = f(Ie), HL = f(ss), WL = f(Fr), JL = f(Xe), QL = f(je), YL = f(Ze), ek = f(zr), tk = f(He), rk = f(tr), ik = f(us), nk = f(cs), sk = f(ps), ok = f(ds), ak = f(fs), lk = f(ys), uk = f(ms), ck = f(bs), pk = f(hs), dk = f(Es), fk = f(xs), yk = f(gs), mk = f(We), bk = f(Rs), hk = f(rr), Ek = f(ir), xk = f(Xr), gk = f(vs), Rk = f(As), vk = f(Zr), Ak = f(nr), wk = f(Hr), Ck = f(Wr), _k = f(ws), Tk = f(Cs), Sk = f(_s), Lk = f(Ts), kk = f(Jr), Bk = f(Ss), Pk = f(Ls), Dk = f(ks), Kk = f(Bs), Uk = f(Ps), Vk = f(Ds), Ik = f(Ks), jk = f(Us), Ok = f(Vs), Mk = f(Is), Nk = f(js), $k = f(Qr), Gk = f(Os), qk = f(Ms), Fk = f(Ns), zk = f($s), Xk = f(Gs), Zk = f(qs), Hk = f(Fs), Wk = f(zs), Jk = f(Xs), Qk = f(Zs), Yk = f(Hs), eB = f(sr), tB = f(Ws), rB = f(Js), iB = f(Qs), nB = f(Ys), sB = f(eo), oB = f(or), aB = f(Yr), lB = f(ei), uB = f(to), cB = f(ro), pB = f(io), dB = f(no), fB = f(so), yB = f(oo), mB = f(ao), bB = f(lo), hB = f(uo), EB = f(co), xB = f(po), gB = f(ar), RB = f(fo), vB = f(yo), AB = f(lr), wB = f(mo), CB = f(bo), _B = f(ho), TB = f(Eo), SB = f(xo), LB = f(go), kB = f(ti), BB = f(Ro), PB = f(ri), DB = f(ii), KB = f(vo), UB = f(Ao), VB = f(wo), IB = f(Je), jB = f(ni), OB = f(ur), MB = f(Co), NB = f(si);
l.ComAtprotoAdminDefs = f(he);
l.ComAtprotoAdminDeleteAccount = f(gn);
l.ComAtprotoAdminDisableAccountInvites = f(Rn);
l.ComAtprotoAdminDisableInviteCodes = f(vn);
l.ComAtprotoAdminEnableAccountInvites = f(An);
l.ComAtprotoAdminGetAccountInfo = f(wn);
l.ComAtprotoAdminGetAccountInfos = f(Cn);
l.ComAtprotoAdminGetInviteCodes = f(_n);
l.ComAtprotoAdminGetSubjectStatus = f(Tn);
l.ComAtprotoAdminSearchAccounts = f(Sn);
l.ComAtprotoAdminSendEmail = f(Ln);
l.ComAtprotoAdminUpdateAccountEmail = f(kn);
l.ComAtprotoAdminUpdateAccountHandle = f(Bn);
l.ComAtprotoAdminUpdateAccountPassword = f(Pn);
l.ComAtprotoAdminUpdateSubjectStatus = f(Dn);
l.ComAtprotoIdentityGetRecommendedDidCredentials = f(Kn);
l.ComAtprotoIdentityRequestPlcOperationSignature = f(Un);
l.ComAtprotoIdentityResolveHandle = f(Vn);
l.ComAtprotoIdentitySignPlcOperation = f(In);
l.ComAtprotoIdentitySubmitPlcOperation = f(jn);
l.ComAtprotoIdentityUpdateHandle = f(On);
l.ComAtprotoLabelDefs = f(le);
l.ComAtprotoLabelQueryLabels = f(Mn);
l.ComAtprotoLabelSubscribeLabels = f(Rt);
l.ComAtprotoModerationCreateReport = f(Nn);
l.ComAtprotoModerationDefs = f(ke);
l.ComAtprotoRepoApplyWrites = f(ye);
l.ComAtprotoRepoCreateRecord = f(Or);
l.ComAtprotoRepoDeleteRecord = f(Mr);
l.ComAtprotoRepoDescribeRepo = f($n);
l.ComAtprotoRepoGetRecord = f(Gn);
l.ComAtprotoRepoImportRepo = f(qn);
l.ComAtprotoRepoListMissingBlobs = f(Ht);
l.ComAtprotoRepoListRecords = f(Wt);
l.ComAtprotoRepoPutRecord = f(Nr);
l.ComAtprotoRepoStrongRef = f(vi);
l.ComAtprotoRepoUploadBlob = f(Fn);
l.ComAtprotoServerActivateAccount = f(zn);
l.ComAtprotoServerCheckAccountStatus = f(Xn);
l.ComAtprotoServerConfirmEmail = f(Fe);
l.ComAtprotoServerCreateAccount = f(me);
l.ComAtprotoServerCreateAppPassword = f(lt);
l.ComAtprotoServerCreateInviteCode = f(Hn);
l.ComAtprotoServerCreateInviteCodes = f(Jt);
l.ComAtprotoServerCreateSession = f(Qt);
l.ComAtprotoServerDeactivateAccount = f(Wn);
l.ComAtprotoServerDefs = f(vt);
l.ComAtprotoServerDeleteAccount = f(Yt);
l.ComAtprotoServerDeleteSession = f(Jn);
l.ComAtprotoServerDescribeServer = f(ze);
l.ComAtprotoServerGetAccountInviteCodes = f($r);
l.ComAtprotoServerGetServiceAuth = f(Gr);
l.ComAtprotoServerGetSession = f(Qn);
l.ComAtprotoServerListAppPasswords = f(ut);
l.ComAtprotoServerRefreshSession = f(qr);
l.ComAtprotoServerRequestAccountDelete = f(Yn);
l.ComAtprotoServerRequestEmailConfirmation = f(es);
l.ComAtprotoServerRequestEmailUpdate = f(ts);
l.ComAtprotoServerRequestPasswordReset = f(rs);
l.ComAtprotoServerReserveSigningKey = f(is);
l.ComAtprotoServerResetPassword = f(er);
l.ComAtprotoServerRevokeAppPassword = f(ns);
l.ComAtprotoServerUpdateEmail = f(ct);
l.ComAtprotoSyncGetBlob = f(Ve);
l.ComAtprotoSyncGetBlocks = f(Ie);
l.ComAtprotoSyncGetCheckout = f(ss);
l.ComAtprotoSyncGetHead = f(Fr);
l.ComAtprotoSyncGetLatestCommit = f(Xe);
l.ComAtprotoSyncGetRecord = f(je);
l.ComAtprotoSyncGetRepo = f(Ze);
l.ComAtprotoSyncGetRepoStatus = f(zr);
l.ComAtprotoSyncListBlobs = f(He);
l.ComAtprotoSyncListRepos = f(tr);
l.ComAtprotoSyncNotifyOfUpdate = f(us);
l.ComAtprotoSyncRequestCrawl = f(cs);
l.ComAtprotoSyncSubscribeRepos = f(Q);
l.ComAtprotoTempCheckSignupQueue = f(ps);
l.ComAtprotoTempFetchLabels = f(ds);
l.ComAtprotoTempRequestPhoneVerification = f(fs);
l.AppBskyActorDefs = f(k);
l.AppBskyActorGetPreferences = f(ys);
l.AppBskyActorGetProfile = f(ms);
l.AppBskyActorGetProfiles = f(bs);
l.AppBskyActorGetSuggestions = f(hs);
l.AppBskyActorProfile = f(Ai);
l.AppBskyActorPutPreferences = f(Es);
l.AppBskyActorSearchActors = f(xs);
l.AppBskyActorSearchActorsTypeahead = f(gs);
l.AppBskyEmbedExternal = f(Ee);
l.AppBskyEmbedImages = f(ue);
l.AppBskyEmbedRecord = f(ce);
l.AppBskyEmbedRecordWithMedia = f(At);
l.AppBskyFeedDefs = f(P);
l.AppBskyFeedDescribeFeedGenerator = f(We);
l.AppBskyFeedGenerator = f(wi);
l.AppBskyFeedGetActorFeeds = f(Rs);
l.AppBskyFeedGetActorLikes = f(rr);
l.AppBskyFeedGetAuthorFeed = f(ir);
l.AppBskyFeedGetFeed = f(Xr);
l.AppBskyFeedGetFeedGenerator = f(vs);
l.AppBskyFeedGetFeedGenerators = f(As);
l.AppBskyFeedGetFeedSkeleton = f(Zr);
l.AppBskyFeedGetLikes = f(nr);
l.AppBskyFeedGetListFeed = f(Hr);
l.AppBskyFeedGetPostThread = f(Wr);
l.AppBskyFeedGetPosts = f(ws);
l.AppBskyFeedGetRepostedBy = f(Cs);
l.AppBskyFeedGetSuggestedFeeds = f(_s);
l.AppBskyFeedGetTimeline = f(Ts);
l.AppBskyFeedLike = f(Ci);
l.AppBskyFeedPost = f(xe);
l.AppBskyFeedRepost = f(_i);
l.AppBskyFeedSearchPosts = f(Jr);
l.AppBskyFeedSendInteractions = f(Ss);
l.AppBskyFeedThreadgate = f(ge);
l.AppBskyGraphBlock = f(Ti);
l.AppBskyGraphDefs = f(H);
l.AppBskyGraphFollow = f(Si);
l.AppBskyGraphGetActorStarterPacks = f(Ls);
l.AppBskyGraphGetBlocks = f(ks);
l.AppBskyGraphGetFollowers = f(Bs);
l.AppBskyGraphGetFollows = f(Ps);
l.AppBskyGraphGetKnownFollowers = f(Ds);
l.AppBskyGraphGetList = f(Ks);
l.AppBskyGraphGetListBlocks = f(Us);
l.AppBskyGraphGetListMutes = f(Vs);
l.AppBskyGraphGetLists = f(Is);
l.AppBskyGraphGetMutes = f(js);
l.AppBskyGraphGetRelationships = f(Qr);
l.AppBskyGraphGetStarterPack = f(Os);
l.AppBskyGraphGetStarterPacks = f(Ms);
l.AppBskyGraphGetSuggestedFollowsByActor = f(Ns);
l.AppBskyGraphList = f(Li);
l.AppBskyGraphListblock = f(ki);
l.AppBskyGraphListitem = f(Bi);
l.AppBskyGraphMuteActor = f($s);
l.AppBskyGraphMuteActorList = f(Gs);
l.AppBskyGraphMuteThread = f(qs);
l.AppBskyGraphStarterpack = f(wt);
l.AppBskyGraphUnmuteActor = f(Fs);
l.AppBskyGraphUnmuteActorList = f(zs);
l.AppBskyGraphUnmuteThread = f(Xs);
l.AppBskyLabelerDefs = f(Re);
l.AppBskyLabelerGetServices = f(Zs);
l.AppBskyLabelerService = f(Pi);
l.AppBskyNotificationGetUnreadCount = f(Hs);
l.AppBskyNotificationListNotifications = f(sr);
l.AppBskyNotificationPutPreferences = f(Ws);
l.AppBskyNotificationRegisterPush = f(Js);
l.AppBskyNotificationUpdateSeen = f(Qs);
l.AppBskyRichtextFacet = f(pe);
l.AppBskyUnspeccedDefs = f(Ct);
l.AppBskyUnspeccedGetPopularFeedGenerators = f(Ys);
l.AppBskyUnspeccedGetSuggestionsSkeleton = f(eo);
l.AppBskyUnspeccedGetTaggedSuggestions = f(or);
l.AppBskyUnspeccedSearchActorsSkeleton = f(Yr);
l.AppBskyUnspeccedSearchPostsSkeleton = f(ei);
l.ChatBskyActorDeclaration = f(Di);
l.ChatBskyActorDefs = f(Ki);
l.ChatBskyActorDeleteAccount = f(to);
l.ChatBskyActorExportAccountData = f(ro);
l.ChatBskyConvoDefs = f(Z);
l.ChatBskyConvoDeleteMessageForSelf = f(io);
l.ChatBskyConvoGetConvo = f(no);
l.ChatBskyConvoGetConvoForMembers = f(so);
l.ChatBskyConvoGetLog = f(oo);
l.ChatBskyConvoGetMessages = f(ao);
l.ChatBskyConvoLeaveConvo = f(lo);
l.ChatBskyConvoListConvos = f(uo);
l.ChatBskyConvoMuteConvo = f(co);
l.ChatBskyConvoSendMessage = f(po);
l.ChatBskyConvoSendMessageBatch = f(ar);
l.ChatBskyConvoUnmuteConvo = f(fo);
l.ChatBskyConvoUpdateRead = f(yo);
l.ChatBskyModerationGetActorMetadata = f(lr);
l.ChatBskyModerationGetMessageContext = f(mo);
l.ChatBskyModerationUpdateActorAccess = f(bo);
l.ToolsOzoneCommunicationCreateTemplate = f(ho);
l.ToolsOzoneCommunicationDefs = f(Ui);
l.ToolsOzoneCommunicationDeleteTemplate = f(Eo);
l.ToolsOzoneCommunicationListTemplates = f(xo);
l.ToolsOzoneCommunicationUpdateTemplate = f(go);
l.ToolsOzoneModerationDefs = f(w);
l.ToolsOzoneModerationEmitEvent = f(ti);
l.ToolsOzoneModerationGetEvent = f(Ro);
l.ToolsOzoneModerationGetRecord = f(ri);
l.ToolsOzoneModerationGetRepo = f(ii);
l.ToolsOzoneModerationQueryEvents = f(vo);
l.ToolsOzoneModerationQueryStatuses = f(Ao);
l.ToolsOzoneModerationSearchRepos = f(wo);
l.ToolsOzoneServerGetConfig = f(Je);
l.ToolsOzoneTeamAddMember = f(ni);
l.ToolsOzoneTeamDefs = f(et);
l.ToolsOzoneTeamDeleteMember = f(ur);
l.ToolsOzoneTeamListMembers = f(Co);
l.ToolsOzoneTeamUpdateMember = f(si);
l.COM_ATPROTO_MODERATION = {
  DefsReasonSpam: "com.atproto.moderation.defs#reasonSpam",
  DefsReasonViolation: "com.atproto.moderation.defs#reasonViolation",
  DefsReasonMisleading: "com.atproto.moderation.defs#reasonMisleading",
  DefsReasonSexual: "com.atproto.moderation.defs#reasonSexual",
  DefsReasonRude: "com.atproto.moderation.defs#reasonRude",
  DefsReasonOther: "com.atproto.moderation.defs#reasonOther",
  DefsReasonAppeal: "com.atproto.moderation.defs#reasonAppeal"
};
l.APP_BSKY_FEED = {
  DefsRequestLess: "app.bsky.feed.defs#requestLess",
  DefsRequestMore: "app.bsky.feed.defs#requestMore",
  DefsClickthroughItem: "app.bsky.feed.defs#clickthroughItem",
  DefsClickthroughAuthor: "app.bsky.feed.defs#clickthroughAuthor",
  DefsClickthroughReposter: "app.bsky.feed.defs#clickthroughReposter",
  DefsClickthroughEmbed: "app.bsky.feed.defs#clickthroughEmbed",
  DefsInteractionSeen: "app.bsky.feed.defs#interactionSeen",
  DefsInteractionLike: "app.bsky.feed.defs#interactionLike",
  DefsInteractionRepost: "app.bsky.feed.defs#interactionRepost",
  DefsInteractionReply: "app.bsky.feed.defs#interactionReply",
  DefsInteractionQuote: "app.bsky.feed.defs#interactionQuote",
  DefsInteractionShare: "app.bsky.feed.defs#interactionShare"
};
l.APP_BSKY_GRAPH = {
  DefsModlist: "app.bsky.graph.defs#modlist",
  DefsCuratelist: "app.bsky.graph.defs#curatelist",
  DefsReferencelist: "app.bsky.graph.defs#referencelist"
};
l.TOOLS_OZONE_MODERATION = {
  DefsReviewOpen: "tools.ozone.moderation.defs#reviewOpen",
  DefsReviewEscalated: "tools.ozone.moderation.defs#reviewEscalated",
  DefsReviewClosed: "tools.ozone.moderation.defs#reviewClosed",
  DefsReviewNone: "tools.ozone.moderation.defs#reviewNone"
};
l.TOOLS_OZONE_TEAM = {
  DefsRoleAdmin: "tools.ozone.team.defs#roleAdmin",
  DefsRoleModerator: "tools.ozone.team.defs#roleModerator",
  DefsRoleTriage: "tools.ozone.team.defs#roleTriage"
};
class $B {
  constructor() {
    Object.defineProperty(this, "xrpc", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new $S.Client()
    }), this.xrpc.addLexicons(GS.schemas);
  }
  service(e) {
    return new Yd(this, this.xrpc.service(e));
  }
}
l.AtpBaseClient = $B;
class Yd {
  constructor(e, r) {
    Object.defineProperty(this, "_baseClient", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "xrpc", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "com", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "app", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "chat", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tools", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._baseClient = e, this.xrpc = r, this.com = new ef(this), this.app = new pf(this), this.chat = new Kf(this), this.tools = new Mf(this);
  }
  setHeader(e, r) {
    this.xrpc.setHeader(e, r);
  }
}
l.AtpServiceClient = Yd;
class ef {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "atproto", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.atproto = new tf(e);
  }
}
l.ComNS = ef;
class tf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "admin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "identity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "label", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "moderation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "repo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "server", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "sync", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "temp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.admin = new rf(e), this.identity = new nf(e), this.label = new sf(e), this.moderation = new of(e), this.repo = new af(e), this.server = new lf(e), this.sync = new uf(e), this.temp = new cf(e);
  }
}
l.ComAtprotoNS = tf;
class rf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  deleteAccount(e, r) {
    return this._service.xrpc.call("com.atproto.admin.deleteAccount", r?.qp, e, r).catch((n) => {
      throw qS.toKnownErr(n);
    });
  }
  disableAccountInvites(e, r) {
    return this._service.xrpc.call("com.atproto.admin.disableAccountInvites", r?.qp, e, r).catch((n) => {
      throw FS.toKnownErr(n);
    });
  }
  disableInviteCodes(e, r) {
    return this._service.xrpc.call("com.atproto.admin.disableInviteCodes", r?.qp, e, r).catch((n) => {
      throw zS.toKnownErr(n);
    });
  }
  enableAccountInvites(e, r) {
    return this._service.xrpc.call("com.atproto.admin.enableAccountInvites", r?.qp, e, r).catch((n) => {
      throw XS.toKnownErr(n);
    });
  }
  getAccountInfo(e, r) {
    return this._service.xrpc.call("com.atproto.admin.getAccountInfo", e, void 0, r).catch((n) => {
      throw ZS.toKnownErr(n);
    });
  }
  getAccountInfos(e, r) {
    return this._service.xrpc.call("com.atproto.admin.getAccountInfos", e, void 0, r).catch((n) => {
      throw HS.toKnownErr(n);
    });
  }
  getInviteCodes(e, r) {
    return this._service.xrpc.call("com.atproto.admin.getInviteCodes", e, void 0, r).catch((n) => {
      throw WS.toKnownErr(n);
    });
  }
  getSubjectStatus(e, r) {
    return this._service.xrpc.call("com.atproto.admin.getSubjectStatus", e, void 0, r).catch((n) => {
      throw JS.toKnownErr(n);
    });
  }
  searchAccounts(e, r) {
    return this._service.xrpc.call("com.atproto.admin.searchAccounts", e, void 0, r).catch((n) => {
      throw QS.toKnownErr(n);
    });
  }
  sendEmail(e, r) {
    return this._service.xrpc.call("com.atproto.admin.sendEmail", r?.qp, e, r).catch((n) => {
      throw YS.toKnownErr(n);
    });
  }
  updateAccountEmail(e, r) {
    return this._service.xrpc.call("com.atproto.admin.updateAccountEmail", r?.qp, e, r).catch((n) => {
      throw eL.toKnownErr(n);
    });
  }
  updateAccountHandle(e, r) {
    return this._service.xrpc.call("com.atproto.admin.updateAccountHandle", r?.qp, e, r).catch((n) => {
      throw tL.toKnownErr(n);
    });
  }
  updateAccountPassword(e, r) {
    return this._service.xrpc.call("com.atproto.admin.updateAccountPassword", r?.qp, e, r).catch((n) => {
      throw rL.toKnownErr(n);
    });
  }
  updateSubjectStatus(e, r) {
    return this._service.xrpc.call("com.atproto.admin.updateSubjectStatus", r?.qp, e, r).catch((n) => {
      throw iL.toKnownErr(n);
    });
  }
}
l.ComAtprotoAdminNS = rf;
class nf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getRecommendedDidCredentials(e, r) {
    return this._service.xrpc.call("com.atproto.identity.getRecommendedDidCredentials", e, void 0, r).catch((n) => {
      throw nL.toKnownErr(n);
    });
  }
  requestPlcOperationSignature(e, r) {
    return this._service.xrpc.call("com.atproto.identity.requestPlcOperationSignature", r?.qp, e, r).catch((n) => {
      throw sL.toKnownErr(n);
    });
  }
  resolveHandle(e, r) {
    return this._service.xrpc.call("com.atproto.identity.resolveHandle", e, void 0, r).catch((n) => {
      throw oL.toKnownErr(n);
    });
  }
  signPlcOperation(e, r) {
    return this._service.xrpc.call("com.atproto.identity.signPlcOperation", r?.qp, e, r).catch((n) => {
      throw aL.toKnownErr(n);
    });
  }
  submitPlcOperation(e, r) {
    return this._service.xrpc.call("com.atproto.identity.submitPlcOperation", r?.qp, e, r).catch((n) => {
      throw lL.toKnownErr(n);
    });
  }
  updateHandle(e, r) {
    return this._service.xrpc.call("com.atproto.identity.updateHandle", r?.qp, e, r).catch((n) => {
      throw uL.toKnownErr(n);
    });
  }
}
l.ComAtprotoIdentityNS = nf;
class sf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  queryLabels(e, r) {
    return this._service.xrpc.call("com.atproto.label.queryLabels", e, void 0, r).catch((n) => {
      throw cL.toKnownErr(n);
    });
  }
}
l.ComAtprotoLabelNS = sf;
class of {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  createReport(e, r) {
    return this._service.xrpc.call("com.atproto.moderation.createReport", r?.qp, e, r).catch((n) => {
      throw pL.toKnownErr(n);
    });
  }
}
l.ComAtprotoModerationNS = of;
class af {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  applyWrites(e, r) {
    return this._service.xrpc.call("com.atproto.repo.applyWrites", r?.qp, e, r).catch((n) => {
      throw dL.toKnownErr(n);
    });
  }
  createRecord(e, r) {
    return this._service.xrpc.call("com.atproto.repo.createRecord", r?.qp, e, r).catch((n) => {
      throw fL.toKnownErr(n);
    });
  }
  deleteRecord(e, r) {
    return this._service.xrpc.call("com.atproto.repo.deleteRecord", r?.qp, e, r).catch((n) => {
      throw yL.toKnownErr(n);
    });
  }
  describeRepo(e, r) {
    return this._service.xrpc.call("com.atproto.repo.describeRepo", e, void 0, r).catch((n) => {
      throw mL.toKnownErr(n);
    });
  }
  getRecord(e, r) {
    return this._service.xrpc.call("com.atproto.repo.getRecord", e, void 0, r).catch((n) => {
      throw bL.toKnownErr(n);
    });
  }
  importRepo(e, r) {
    return this._service.xrpc.call("com.atproto.repo.importRepo", r?.qp, e, r).catch((n) => {
      throw hL.toKnownErr(n);
    });
  }
  listMissingBlobs(e, r) {
    return this._service.xrpc.call("com.atproto.repo.listMissingBlobs", e, void 0, r).catch((n) => {
      throw EL.toKnownErr(n);
    });
  }
  listRecords(e, r) {
    return this._service.xrpc.call("com.atproto.repo.listRecords", e, void 0, r).catch((n) => {
      throw xL.toKnownErr(n);
    });
  }
  putRecord(e, r) {
    return this._service.xrpc.call("com.atproto.repo.putRecord", r?.qp, e, r).catch((n) => {
      throw gL.toKnownErr(n);
    });
  }
  uploadBlob(e, r) {
    return this._service.xrpc.call("com.atproto.repo.uploadBlob", r?.qp, e, r).catch((n) => {
      throw RL.toKnownErr(n);
    });
  }
}
l.ComAtprotoRepoNS = af;
class lf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  activateAccount(e, r) {
    return this._service.xrpc.call("com.atproto.server.activateAccount", r?.qp, e, r).catch((n) => {
      throw vL.toKnownErr(n);
    });
  }
  checkAccountStatus(e, r) {
    return this._service.xrpc.call("com.atproto.server.checkAccountStatus", e, void 0, r).catch((n) => {
      throw AL.toKnownErr(n);
    });
  }
  confirmEmail(e, r) {
    return this._service.xrpc.call("com.atproto.server.confirmEmail", r?.qp, e, r).catch((n) => {
      throw wL.toKnownErr(n);
    });
  }
  createAccount(e, r) {
    return this._service.xrpc.call("com.atproto.server.createAccount", r?.qp, e, r).catch((n) => {
      throw CL.toKnownErr(n);
    });
  }
  createAppPassword(e, r) {
    return this._service.xrpc.call("com.atproto.server.createAppPassword", r?.qp, e, r).catch((n) => {
      throw _L.toKnownErr(n);
    });
  }
  createInviteCode(e, r) {
    return this._service.xrpc.call("com.atproto.server.createInviteCode", r?.qp, e, r).catch((n) => {
      throw TL.toKnownErr(n);
    });
  }
  createInviteCodes(e, r) {
    return this._service.xrpc.call("com.atproto.server.createInviteCodes", r?.qp, e, r).catch((n) => {
      throw SL.toKnownErr(n);
    });
  }
  createSession(e, r) {
    return this._service.xrpc.call("com.atproto.server.createSession", r?.qp, e, r).catch((n) => {
      throw LL.toKnownErr(n);
    });
  }
  deactivateAccount(e, r) {
    return this._service.xrpc.call("com.atproto.server.deactivateAccount", r?.qp, e, r).catch((n) => {
      throw kL.toKnownErr(n);
    });
  }
  deleteAccount(e, r) {
    return this._service.xrpc.call("com.atproto.server.deleteAccount", r?.qp, e, r).catch((n) => {
      throw BL.toKnownErr(n);
    });
  }
  deleteSession(e, r) {
    return this._service.xrpc.call("com.atproto.server.deleteSession", r?.qp, e, r).catch((n) => {
      throw PL.toKnownErr(n);
    });
  }
  describeServer(e, r) {
    return this._service.xrpc.call("com.atproto.server.describeServer", e, void 0, r).catch((n) => {
      throw DL.toKnownErr(n);
    });
  }
  getAccountInviteCodes(e, r) {
    return this._service.xrpc.call("com.atproto.server.getAccountInviteCodes", e, void 0, r).catch((n) => {
      throw KL.toKnownErr(n);
    });
  }
  getServiceAuth(e, r) {
    return this._service.xrpc.call("com.atproto.server.getServiceAuth", e, void 0, r).catch((n) => {
      throw UL.toKnownErr(n);
    });
  }
  getSession(e, r) {
    return this._service.xrpc.call("com.atproto.server.getSession", e, void 0, r).catch((n) => {
      throw VL.toKnownErr(n);
    });
  }
  listAppPasswords(e, r) {
    return this._service.xrpc.call("com.atproto.server.listAppPasswords", e, void 0, r).catch((n) => {
      throw IL.toKnownErr(n);
    });
  }
  refreshSession(e, r) {
    return this._service.xrpc.call("com.atproto.server.refreshSession", r?.qp, e, r).catch((n) => {
      throw jL.toKnownErr(n);
    });
  }
  requestAccountDelete(e, r) {
    return this._service.xrpc.call("com.atproto.server.requestAccountDelete", r?.qp, e, r).catch((n) => {
      throw OL.toKnownErr(n);
    });
  }
  requestEmailConfirmation(e, r) {
    return this._service.xrpc.call("com.atproto.server.requestEmailConfirmation", r?.qp, e, r).catch((n) => {
      throw ML.toKnownErr(n);
    });
  }
  requestEmailUpdate(e, r) {
    return this._service.xrpc.call("com.atproto.server.requestEmailUpdate", r?.qp, e, r).catch((n) => {
      throw NL.toKnownErr(n);
    });
  }
  requestPasswordReset(e, r) {
    return this._service.xrpc.call("com.atproto.server.requestPasswordReset", r?.qp, e, r).catch((n) => {
      throw $L.toKnownErr(n);
    });
  }
  reserveSigningKey(e, r) {
    return this._service.xrpc.call("com.atproto.server.reserveSigningKey", r?.qp, e, r).catch((n) => {
      throw GL.toKnownErr(n);
    });
  }
  resetPassword(e, r) {
    return this._service.xrpc.call("com.atproto.server.resetPassword", r?.qp, e, r).catch((n) => {
      throw qL.toKnownErr(n);
    });
  }
  revokeAppPassword(e, r) {
    return this._service.xrpc.call("com.atproto.server.revokeAppPassword", r?.qp, e, r).catch((n) => {
      throw FL.toKnownErr(n);
    });
  }
  updateEmail(e, r) {
    return this._service.xrpc.call("com.atproto.server.updateEmail", r?.qp, e, r).catch((n) => {
      throw zL.toKnownErr(n);
    });
  }
}
l.ComAtprotoServerNS = lf;
class uf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getBlob(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getBlob", e, void 0, r).catch((n) => {
      throw XL.toKnownErr(n);
    });
  }
  getBlocks(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getBlocks", e, void 0, r).catch((n) => {
      throw ZL.toKnownErr(n);
    });
  }
  getCheckout(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getCheckout", e, void 0, r).catch((n) => {
      throw HL.toKnownErr(n);
    });
  }
  getHead(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getHead", e, void 0, r).catch((n) => {
      throw WL.toKnownErr(n);
    });
  }
  getLatestCommit(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getLatestCommit", e, void 0, r).catch((n) => {
      throw JL.toKnownErr(n);
    });
  }
  getRecord(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getRecord", e, void 0, r).catch((n) => {
      throw QL.toKnownErr(n);
    });
  }
  getRepo(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getRepo", e, void 0, r).catch((n) => {
      throw YL.toKnownErr(n);
    });
  }
  getRepoStatus(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getRepoStatus", e, void 0, r).catch((n) => {
      throw ek.toKnownErr(n);
    });
  }
  listBlobs(e, r) {
    return this._service.xrpc.call("com.atproto.sync.listBlobs", e, void 0, r).catch((n) => {
      throw tk.toKnownErr(n);
    });
  }
  listRepos(e, r) {
    return this._service.xrpc.call("com.atproto.sync.listRepos", e, void 0, r).catch((n) => {
      throw rk.toKnownErr(n);
    });
  }
  notifyOfUpdate(e, r) {
    return this._service.xrpc.call("com.atproto.sync.notifyOfUpdate", r?.qp, e, r).catch((n) => {
      throw ik.toKnownErr(n);
    });
  }
  requestCrawl(e, r) {
    return this._service.xrpc.call("com.atproto.sync.requestCrawl", r?.qp, e, r).catch((n) => {
      throw nk.toKnownErr(n);
    });
  }
}
l.ComAtprotoSyncNS = uf;
class cf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  checkSignupQueue(e, r) {
    return this._service.xrpc.call("com.atproto.temp.checkSignupQueue", e, void 0, r).catch((n) => {
      throw sk.toKnownErr(n);
    });
  }
  fetchLabels(e, r) {
    return this._service.xrpc.call("com.atproto.temp.fetchLabels", e, void 0, r).catch((n) => {
      throw ok.toKnownErr(n);
    });
  }
  requestPhoneVerification(e, r) {
    return this._service.xrpc.call("com.atproto.temp.requestPhoneVerification", r?.qp, e, r).catch((n) => {
      throw ak.toKnownErr(n);
    });
  }
}
l.ComAtprotoTempNS = cf;
class pf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "bsky", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.bsky = new df(e);
  }
}
l.AppNS = pf;
class df {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "actor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "embed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "feed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "graph", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "labeler", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "notification", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "richtext", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "unspecced", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.actor = new ff(e), this.embed = new mf(e), this.feed = new bf(e), this.graph = new vf(e), this.labeler = new Lf(e), this.notification = new Bf(e), this.richtext = new Pf(e), this.unspecced = new Df(e);
  }
}
l.AppBskyNS = df;
class ff {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "profile", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.profile = new yf(e);
  }
  getPreferences(e, r) {
    return this._service.xrpc.call("app.bsky.actor.getPreferences", e, void 0, r).catch((n) => {
      throw lk.toKnownErr(n);
    });
  }
  getProfile(e, r) {
    return this._service.xrpc.call("app.bsky.actor.getProfile", e, void 0, r).catch((n) => {
      throw uk.toKnownErr(n);
    });
  }
  getProfiles(e, r) {
    return this._service.xrpc.call("app.bsky.actor.getProfiles", e, void 0, r).catch((n) => {
      throw ck.toKnownErr(n);
    });
  }
  getSuggestions(e, r) {
    return this._service.xrpc.call("app.bsky.actor.getSuggestions", e, void 0, r).catch((n) => {
      throw pk.toKnownErr(n);
    });
  }
  putPreferences(e, r) {
    return this._service.xrpc.call("app.bsky.actor.putPreferences", r?.qp, e, r).catch((n) => {
      throw dk.toKnownErr(n);
    });
  }
  searchActors(e, r) {
    return this._service.xrpc.call("app.bsky.actor.searchActors", e, void 0, r).catch((n) => {
      throw fk.toKnownErr(n);
    });
  }
  searchActorsTypeahead(e, r) {
    return this._service.xrpc.call("app.bsky.actor.searchActorsTypeahead", e, void 0, r).catch((n) => {
      throw yk.toKnownErr(n);
    });
  }
}
l.AppBskyActorNS = ff;
class yf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.actor.profile",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.actor.profile",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.actor.profile", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.actor.profile", rkey: "self", ...e, record: r }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.actor.profile", ...e }, { headers: r });
  }
}
l.ProfileRecord = yf;
class mf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
}
l.AppBskyEmbedNS = mf;
class bf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "generator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "like", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "post", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "repost", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "threadgate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.generator = new hf(e), this.like = new Ef(e), this.post = new xf(e), this.repost = new gf(e), this.threadgate = new Rf(e);
  }
  describeFeedGenerator(e, r) {
    return this._service.xrpc.call("app.bsky.feed.describeFeedGenerator", e, void 0, r).catch((n) => {
      throw mk.toKnownErr(n);
    });
  }
  getActorFeeds(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getActorFeeds", e, void 0, r).catch((n) => {
      throw bk.toKnownErr(n);
    });
  }
  getActorLikes(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getActorLikes", e, void 0, r).catch((n) => {
      throw hk.toKnownErr(n);
    });
  }
  getAuthorFeed(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getAuthorFeed", e, void 0, r).catch((n) => {
      throw Ek.toKnownErr(n);
    });
  }
  getFeed(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getFeed", e, void 0, r).catch((n) => {
      throw xk.toKnownErr(n);
    });
  }
  getFeedGenerator(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getFeedGenerator", e, void 0, r).catch((n) => {
      throw gk.toKnownErr(n);
    });
  }
  getFeedGenerators(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getFeedGenerators", e, void 0, r).catch((n) => {
      throw Rk.toKnownErr(n);
    });
  }
  getFeedSkeleton(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getFeedSkeleton", e, void 0, r).catch((n) => {
      throw vk.toKnownErr(n);
    });
  }
  getLikes(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getLikes", e, void 0, r).catch((n) => {
      throw Ak.toKnownErr(n);
    });
  }
  getListFeed(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getListFeed", e, void 0, r).catch((n) => {
      throw wk.toKnownErr(n);
    });
  }
  getPostThread(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getPostThread", e, void 0, r).catch((n) => {
      throw Ck.toKnownErr(n);
    });
  }
  getPosts(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getPosts", e, void 0, r).catch((n) => {
      throw _k.toKnownErr(n);
    });
  }
  getRepostedBy(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getRepostedBy", e, void 0, r).catch((n) => {
      throw Tk.toKnownErr(n);
    });
  }
  getSuggestedFeeds(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getSuggestedFeeds", e, void 0, r).catch((n) => {
      throw Sk.toKnownErr(n);
    });
  }
  getTimeline(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getTimeline", e, void 0, r).catch((n) => {
      throw Lk.toKnownErr(n);
    });
  }
  searchPosts(e, r) {
    return this._service.xrpc.call("app.bsky.feed.searchPosts", e, void 0, r).catch((n) => {
      throw kk.toKnownErr(n);
    });
  }
  sendInteractions(e, r) {
    return this._service.xrpc.call("app.bsky.feed.sendInteractions", r?.qp, e, r).catch((n) => {
      throw Bk.toKnownErr(n);
    });
  }
}
l.AppBskyFeedNS = bf;
class hf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.feed.generator",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.feed.generator",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.feed.generator", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.generator", ...e, record: r }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.generator", ...e }, { headers: r });
  }
}
l.GeneratorRecord = hf;
class Ef {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.feed.like",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.feed.like",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.feed.like", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.like", ...e, record: r }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.like", ...e }, { headers: r });
  }
}
l.LikeRecord = Ef;
class xf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.feed.post",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.feed.post",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.feed.post", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.post", ...e, record: r }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.post", ...e }, { headers: r });
  }
}
l.PostRecord = xf;
class gf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.feed.repost",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.feed.repost",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.feed.repost", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.repost", ...e, record: r }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.repost", ...e }, { headers: r });
  }
}
l.RepostRecord = gf;
class Rf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.feed.threadgate",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.feed.threadgate",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.feed.threadgate", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.threadgate", ...e, record: r }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.threadgate", ...e }, { headers: r });
  }
}
l.ThreadgateRecord = Rf;
class vf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "block", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "follow", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "list", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "listblock", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "listitem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "starterpack", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.block = new Af(e), this.follow = new wf(e), this.list = new Cf(e), this.listblock = new _f(e), this.listitem = new Tf(e), this.starterpack = new Sf(e);
  }
  getActorStarterPacks(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getActorStarterPacks", e, void 0, r).catch((n) => {
      throw Pk.toKnownErr(n);
    });
  }
  getBlocks(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getBlocks", e, void 0, r).catch((n) => {
      throw Dk.toKnownErr(n);
    });
  }
  getFollowers(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getFollowers", e, void 0, r).catch((n) => {
      throw Kk.toKnownErr(n);
    });
  }
  getFollows(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getFollows", e, void 0, r).catch((n) => {
      throw Uk.toKnownErr(n);
    });
  }
  getKnownFollowers(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getKnownFollowers", e, void 0, r).catch((n) => {
      throw Vk.toKnownErr(n);
    });
  }
  getList(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getList", e, void 0, r).catch((n) => {
      throw Ik.toKnownErr(n);
    });
  }
  getListBlocks(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getListBlocks", e, void 0, r).catch((n) => {
      throw jk.toKnownErr(n);
    });
  }
  getListMutes(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getListMutes", e, void 0, r).catch((n) => {
      throw Ok.toKnownErr(n);
    });
  }
  getLists(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getLists", e, void 0, r).catch((n) => {
      throw Mk.toKnownErr(n);
    });
  }
  getMutes(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getMutes", e, void 0, r).catch((n) => {
      throw Nk.toKnownErr(n);
    });
  }
  getRelationships(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getRelationships", e, void 0, r).catch((n) => {
      throw $k.toKnownErr(n);
    });
  }
  getStarterPack(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getStarterPack", e, void 0, r).catch((n) => {
      throw Gk.toKnownErr(n);
    });
  }
  getStarterPacks(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getStarterPacks", e, void 0, r).catch((n) => {
      throw qk.toKnownErr(n);
    });
  }
  getSuggestedFollowsByActor(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getSuggestedFollowsByActor", e, void 0, r).catch((n) => {
      throw Fk.toKnownErr(n);
    });
  }
  muteActor(e, r) {
    return this._service.xrpc.call("app.bsky.graph.muteActor", r?.qp, e, r).catch((n) => {
      throw zk.toKnownErr(n);
    });
  }
  muteActorList(e, r) {
    return this._service.xrpc.call("app.bsky.graph.muteActorList", r?.qp, e, r).catch((n) => {
      throw Xk.toKnownErr(n);
    });
  }
  muteThread(e, r) {
    return this._service.xrpc.call("app.bsky.graph.muteThread", r?.qp, e, r).catch((n) => {
      throw Zk.toKnownErr(n);
    });
  }
  unmuteActor(e, r) {
    return this._service.xrpc.call("app.bsky.graph.unmuteActor", r?.qp, e, r).catch((n) => {
      throw Hk.toKnownErr(n);
    });
  }
  unmuteActorList(e, r) {
    return this._service.xrpc.call("app.bsky.graph.unmuteActorList", r?.qp, e, r).catch((n) => {
      throw Wk.toKnownErr(n);
    });
  }
  unmuteThread(e, r) {
    return this._service.xrpc.call("app.bsky.graph.unmuteThread", r?.qp, e, r).catch((n) => {
      throw Jk.toKnownErr(n);
    });
  }
}
l.AppBskyGraphNS = vf;
class Af {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.block",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.block",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.graph.block", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.block", ...e, record: r }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.block", ...e }, { headers: r });
  }
}
l.BlockRecord = Af;
class wf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.follow",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.follow",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.graph.follow", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.follow", ...e, record: r }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.follow", ...e }, { headers: r });
  }
}
l.FollowRecord = wf;
class Cf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.list",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.list",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.graph.list", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.list", ...e, record: r }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.list", ...e }, { headers: r });
  }
}
l.ListRecord = Cf;
class _f {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.listblock",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.listblock",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.graph.listblock", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.listblock", ...e, record: r }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.listblock", ...e }, { headers: r });
  }
}
l.ListblockRecord = _f;
class Tf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.listitem",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.listitem",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.graph.listitem", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.listitem", ...e, record: r }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.listitem", ...e }, { headers: r });
  }
}
l.ListitemRecord = Tf;
class Sf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.starterpack",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.starterpack",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.graph.starterpack", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.starterpack", ...e, record: r }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.starterpack", ...e }, { headers: r });
  }
}
l.StarterpackRecord = Sf;
class Lf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.service = new kf(e);
  }
  getServices(e, r) {
    return this._service.xrpc.call("app.bsky.labeler.getServices", e, void 0, r).catch((n) => {
      throw Qk.toKnownErr(n);
    });
  }
}
l.AppBskyLabelerNS = Lf;
class kf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.labeler.service",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.labeler.service",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "app.bsky.labeler.service", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, {
      collection: "app.bsky.labeler.service",
      rkey: "self",
      ...e,
      record: r
    }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.labeler.service", ...e }, { headers: r });
  }
}
l.ServiceRecord = kf;
class Bf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getUnreadCount(e, r) {
    return this._service.xrpc.call("app.bsky.notification.getUnreadCount", e, void 0, r).catch((n) => {
      throw Yk.toKnownErr(n);
    });
  }
  listNotifications(e, r) {
    return this._service.xrpc.call("app.bsky.notification.listNotifications", e, void 0, r).catch((n) => {
      throw eB.toKnownErr(n);
    });
  }
  putPreferences(e, r) {
    return this._service.xrpc.call("app.bsky.notification.putPreferences", r?.qp, e, r).catch((n) => {
      throw tB.toKnownErr(n);
    });
  }
  registerPush(e, r) {
    return this._service.xrpc.call("app.bsky.notification.registerPush", r?.qp, e, r).catch((n) => {
      throw rB.toKnownErr(n);
    });
  }
  updateSeen(e, r) {
    return this._service.xrpc.call("app.bsky.notification.updateSeen", r?.qp, e, r).catch((n) => {
      throw iB.toKnownErr(n);
    });
  }
}
l.AppBskyNotificationNS = Bf;
class Pf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
}
l.AppBskyRichtextNS = Pf;
class Df {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getPopularFeedGenerators(e, r) {
    return this._service.xrpc.call("app.bsky.unspecced.getPopularFeedGenerators", e, void 0, r).catch((n) => {
      throw nB.toKnownErr(n);
    });
  }
  getSuggestionsSkeleton(e, r) {
    return this._service.xrpc.call("app.bsky.unspecced.getSuggestionsSkeleton", e, void 0, r).catch((n) => {
      throw sB.toKnownErr(n);
    });
  }
  getTaggedSuggestions(e, r) {
    return this._service.xrpc.call("app.bsky.unspecced.getTaggedSuggestions", e, void 0, r).catch((n) => {
      throw oB.toKnownErr(n);
    });
  }
  searchActorsSkeleton(e, r) {
    return this._service.xrpc.call("app.bsky.unspecced.searchActorsSkeleton", e, void 0, r).catch((n) => {
      throw aB.toKnownErr(n);
    });
  }
  searchPostsSkeleton(e, r) {
    return this._service.xrpc.call("app.bsky.unspecced.searchPostsSkeleton", e, void 0, r).catch((n) => {
      throw lB.toKnownErr(n);
    });
  }
}
l.AppBskyUnspeccedNS = Df;
class Kf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "bsky", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.bsky = new Uf(e);
  }
}
l.ChatNS = Kf;
class Uf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "actor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "convo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "moderation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.actor = new Vf(e), this.convo = new jf(e), this.moderation = new Of(e);
  }
}
l.ChatBskyNS = Uf;
class Vf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "declaration", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.declaration = new If(e);
  }
  deleteAccount(e, r) {
    return this._service.xrpc.call("chat.bsky.actor.deleteAccount", r?.qp, e, r).catch((n) => {
      throw uB.toKnownErr(n);
    });
  }
  exportAccountData(e, r) {
    return this._service.xrpc.call("chat.bsky.actor.exportAccountData", e, void 0, r).catch((n) => {
      throw cB.toKnownErr(n);
    });
  }
}
l.ChatBskyActorNS = Vf;
class If {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "chat.bsky.actor.declaration",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "chat.bsky.actor.declaration",
      ...e
    })).data;
  }
  async create(e, r, n) {
    return r.$type = "chat.bsky.actor.declaration", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, {
      collection: "chat.bsky.actor.declaration",
      rkey: "self",
      ...e,
      record: r
    }, { encoding: "application/json", headers: n })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "chat.bsky.actor.declaration", ...e }, { headers: r });
  }
}
l.DeclarationRecord = If;
class jf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  deleteMessageForSelf(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.deleteMessageForSelf", r?.qp, e, r).catch((n) => {
      throw pB.toKnownErr(n);
    });
  }
  getConvo(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.getConvo", e, void 0, r).catch((n) => {
      throw dB.toKnownErr(n);
    });
  }
  getConvoForMembers(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.getConvoForMembers", e, void 0, r).catch((n) => {
      throw fB.toKnownErr(n);
    });
  }
  getLog(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.getLog", e, void 0, r).catch((n) => {
      throw yB.toKnownErr(n);
    });
  }
  getMessages(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.getMessages", e, void 0, r).catch((n) => {
      throw mB.toKnownErr(n);
    });
  }
  leaveConvo(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.leaveConvo", r?.qp, e, r).catch((n) => {
      throw bB.toKnownErr(n);
    });
  }
  listConvos(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.listConvos", e, void 0, r).catch((n) => {
      throw hB.toKnownErr(n);
    });
  }
  muteConvo(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.muteConvo", r?.qp, e, r).catch((n) => {
      throw EB.toKnownErr(n);
    });
  }
  sendMessage(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.sendMessage", r?.qp, e, r).catch((n) => {
      throw xB.toKnownErr(n);
    });
  }
  sendMessageBatch(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.sendMessageBatch", r?.qp, e, r).catch((n) => {
      throw gB.toKnownErr(n);
    });
  }
  unmuteConvo(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.unmuteConvo", r?.qp, e, r).catch((n) => {
      throw RB.toKnownErr(n);
    });
  }
  updateRead(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.updateRead", r?.qp, e, r).catch((n) => {
      throw vB.toKnownErr(n);
    });
  }
}
l.ChatBskyConvoNS = jf;
class Of {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getActorMetadata(e, r) {
    return this._service.xrpc.call("chat.bsky.moderation.getActorMetadata", e, void 0, r).catch((n) => {
      throw AB.toKnownErr(n);
    });
  }
  getMessageContext(e, r) {
    return this._service.xrpc.call("chat.bsky.moderation.getMessageContext", e, void 0, r).catch((n) => {
      throw wB.toKnownErr(n);
    });
  }
  updateActorAccess(e, r) {
    return this._service.xrpc.call("chat.bsky.moderation.updateActorAccess", r?.qp, e, r).catch((n) => {
      throw CB.toKnownErr(n);
    });
  }
}
l.ChatBskyModerationNS = Of;
class Mf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "ozone", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.ozone = new Nf(e);
  }
}
l.ToolsNS = Mf;
class Nf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "communication", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "moderation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "server", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "team", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.communication = new $f(e), this.moderation = new Gf(e), this.server = new qf(e), this.team = new Ff(e);
  }
}
l.ToolsOzoneNS = Nf;
class $f {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  createTemplate(e, r) {
    return this._service.xrpc.call("tools.ozone.communication.createTemplate", r?.qp, e, r).catch((n) => {
      throw _B.toKnownErr(n);
    });
  }
  deleteTemplate(e, r) {
    return this._service.xrpc.call("tools.ozone.communication.deleteTemplate", r?.qp, e, r).catch((n) => {
      throw TB.toKnownErr(n);
    });
  }
  listTemplates(e, r) {
    return this._service.xrpc.call("tools.ozone.communication.listTemplates", e, void 0, r).catch((n) => {
      throw SB.toKnownErr(n);
    });
  }
  updateTemplate(e, r) {
    return this._service.xrpc.call("tools.ozone.communication.updateTemplate", r?.qp, e, r).catch((n) => {
      throw LB.toKnownErr(n);
    });
  }
}
l.ToolsOzoneCommunicationNS = $f;
class Gf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  emitEvent(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.emitEvent", r?.qp, e, r).catch((n) => {
      throw kB.toKnownErr(n);
    });
  }
  getEvent(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.getEvent", e, void 0, r).catch((n) => {
      throw BB.toKnownErr(n);
    });
  }
  getRecord(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.getRecord", e, void 0, r).catch((n) => {
      throw PB.toKnownErr(n);
    });
  }
  getRepo(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.getRepo", e, void 0, r).catch((n) => {
      throw DB.toKnownErr(n);
    });
  }
  queryEvents(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.queryEvents", e, void 0, r).catch((n) => {
      throw KB.toKnownErr(n);
    });
  }
  queryStatuses(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.queryStatuses", e, void 0, r).catch((n) => {
      throw UB.toKnownErr(n);
    });
  }
  searchRepos(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.searchRepos", e, void 0, r).catch((n) => {
      throw VB.toKnownErr(n);
    });
  }
}
l.ToolsOzoneModerationNS = Gf;
class qf {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getConfig(e, r) {
    return this._service.xrpc.call("tools.ozone.server.getConfig", e, void 0, r).catch((n) => {
      throw IB.toKnownErr(n);
    });
  }
}
l.ToolsOzoneServerNS = qf;
class Ff {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  addMember(e, r) {
    return this._service.xrpc.call("tools.ozone.team.addMember", r?.qp, e, r).catch((n) => {
      throw jB.toKnownErr(n);
    });
  }
  deleteMember(e, r) {
    return this._service.xrpc.call("tools.ozone.team.deleteMember", r?.qp, e, r).catch((n) => {
      throw OB.toKnownErr(n);
    });
  }
  listMembers(e, r) {
    return this._service.xrpc.call("tools.ozone.team.listMembers", e, void 0, r).catch((n) => {
      throw MB.toKnownErr(n);
    });
  }
  updateMember(e, r) {
    return this._service.xrpc.call("tools.ozone.team.updateMember", r?.qp, e, r).catch((n) => {
      throw NB.toKnownErr(n);
    });
  }
}
l.ToolsOzoneTeamNS = Ff;
var Vi = {};
Object.defineProperty(Vi, "__esModule", { value: !0 });
Vi.AtpAgent = void 0;
const GB = v, Zo = v, Su = Vt, qB = l, FB = xn, zB = "com.atproto.server.refreshSession";
class qe {
  get com() {
    return this.api.com;
  }
  /**
   * Configures the API globally.
   */
  static configure(e) {
    e.fetch && (qe.fetch = e.fetch), e.appLabelers && (qe.appLabelers = e.appLabelers);
  }
  constructor(e) {
    Object.defineProperty(this, "service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "api", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "session", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "labelersHeader", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "proxyHeader", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "pdsUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_baseClient", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_persistSession", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_refreshSessionPromise", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "uploadBlob", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (r, n) => this.api.com.atproto.repo.uploadBlob(r, n)
    }), Object.defineProperty(this, "resolveHandle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (r, n) => this.api.com.atproto.identity.resolveHandle(r, n)
    }), Object.defineProperty(this, "updateHandle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (r, n) => this.api.com.atproto.identity.updateHandle(r, n)
    }), Object.defineProperty(this, "createModerationReport", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (r, n) => this.api.com.atproto.moderation.createReport(r, n)
    }), this.service = e.service instanceof URL ? e.service : new URL(e.service), this._persistSession = e.persistSession, this._baseClient = new qB.AtpBaseClient(), this._baseClient.xrpc.fetch = this._fetch.bind(this), this.api = this._baseClient.service(e.service);
  }
  clone() {
    const e = new qe({
      service: this.service
    });
    return this.copyInto(e), e;
  }
  copyInto(e) {
    e.session = this.session, e.labelersHeader = this.labelersHeader, e.proxyHeader = this.proxyHeader, e.pdsUrl = this.pdsUrl, e.api.xrpc.uri = this.pdsUrl || this.service;
  }
  withProxy(e, r) {
    const n = this.clone();
    return n.configureProxyHeader(e, r), n;
  }
  /**
   * Is there any active session?
   */
  get hasSession() {
    return !!this.session;
  }
  /**
   * Sets the "Persist Session" method which can be used to store access tokens
   * as they change.
   */
  setPersistSessionHandler(e) {
    this._persistSession = e;
  }
  /**
   * Configures the moderation services to be applied on requests.
   * NOTE: this is called automatically by getPreferences() and the relevant moderation config
   * methods in BskyAgent instances.
   */
  configureLabelersHeader(e) {
    this.labelersHeader = e;
  }
  /**
   * Configures the atproto-proxy header to be applied on requests
   */
  configureProxyHeader(e, r) {
    r.startsWith("did:") && (this.proxyHeader = `${r}#${e}`);
  }
  /**
   * Create a new account and hydrate its session in this agent.
   */
  async createAccount(e) {
    try {
      const r = await this.api.com.atproto.server.createAccount(e);
      return this.session = {
        accessJwt: r.data.accessJwt,
        refreshJwt: r.data.refreshJwt,
        handle: r.data.handle,
        did: r.data.did,
        email: e.email,
        emailConfirmed: !1,
        emailAuthFactor: !1,
        active: !0
      }, this._updateApiEndpoint(r.data.didDoc), r;
    } catch (r) {
      throw this.session = void 0, r;
    } finally {
      this.session ? this._persistSession?.("create", this.session) : this._persistSession?.("create-failed", void 0);
    }
  }
  /**
   * Start a new session with this agent.
   */
  async login(e) {
    try {
      const r = await this.api.com.atproto.server.createSession({
        identifier: e.identifier,
        password: e.password,
        authFactorToken: e.authFactorToken
      });
      return this.session = {
        accessJwt: r.data.accessJwt,
        refreshJwt: r.data.refreshJwt,
        handle: r.data.handle,
        did: r.data.did,
        email: r.data.email,
        emailConfirmed: r.data.emailConfirmed,
        emailAuthFactor: r.data.emailAuthFactor,
        active: r.data.active ?? !0,
        status: r.data.status
      }, this._updateApiEndpoint(r.data.didDoc), r;
    } catch (r) {
      throw this.session = void 0, r;
    } finally {
      this.session ? this._persistSession?.("create", this.session) : this._persistSession?.("create-failed", void 0);
    }
  }
  /**
   * Resume a pre-existing session with this agent.
   */
  async resumeSession(e) {
    try {
      this.session = e;
      const r = await this.api.com.atproto.server.getSession();
      if (r.data.did !== this.session.did)
        throw new Zo.XRPCError(Zo.ResponseType.InvalidRequest, "Invalid session", "InvalidDID");
      return this.session.email = r.data.email, this.session.handle = r.data.handle, this.session.emailConfirmed = r.data.emailConfirmed, this.session.emailAuthFactor = r.data.emailAuthFactor, this.session.active = r.data.active ?? !0, this.session.status = r.data.status, this._updateApiEndpoint(r.data.didDoc), this._persistSession?.("update", this.session), r;
    } catch (r) {
      throw this.session = void 0, r instanceof Zo.XRPCError ? [1, 408, 425, 429, 500, 502, 503, 504, 522, 524].includes(r.status) ? this._persistSession?.("network-error", void 0) : this._persistSession?.("expired", void 0) : this._persistSession?.("network-error", void 0), r;
    }
  }
  /**
   * Internal helper to add authorization headers to requests.
   */
  _addHeaders(e) {
    !e.authorization && this.session?.accessJwt && (e = {
      ...e,
      authorization: `Bearer ${this.session.accessJwt}`
    }), this.proxyHeader && (e = {
      ...e,
      "atproto-proxy": this.proxyHeader
    });
    const r = "atproto-accept-labelers", n = qe.appLabelers.map((s) => `${s};redact`).concat(this.labelersHeader.filter((s) => s.startsWith("did:")));
    return e[r] && n.push(
      ...e[r].split(",").map((s) => s.trim())
    ), e = {
      ...e,
      [r]: n.join(", ")
    }, e;
  }
  /**
   * Internal fetch handler which adds access-token management
   */
  async _fetch(e, r, n, s) {
    if (!qe.fetch)
      throw new Error("AtpAgent fetch() method not configured");
    await this._refreshSessionPromise;
    let u = await qe.fetch(e, r, this._addHeaders(n), s);
    return Lu(u, ["ExpiredToken"]) && this.session?.refreshJwt && (await this.refreshSession(), u = await qe.fetch(e, r, this._addHeaders(n), s)), u;
  }
  /**
   * Internal helper to refresh sessions
   * - Wraps the actual implementation in a promise-guard to ensure only
   *   one refresh is attempted at a time.
   */
  async refreshSession() {
    if (this._refreshSessionPromise)
      return this._refreshSessionPromise;
    this._refreshSessionPromise = this._refreshSessionInner();
    try {
      await this._refreshSessionPromise;
    } finally {
      this._refreshSessionPromise = void 0;
    }
  }
  /**
   * Internal helper to refresh sessions (actual behavior)
   */
  async _refreshSessionInner() {
    if (!qe.fetch)
      throw new Error("AtpAgent fetch() method not configured");
    if (!this.session?.refreshJwt)
      return;
    const e = new URL((this.pdsUrl || this.service).origin);
    e.pathname = `/xrpc/${zB}`;
    const r = await qe.fetch(e.toString(), "POST", {
      authorization: `Bearer ${this.session.refreshJwt}`
    }, void 0);
    Lu(r, ["ExpiredToken", "InvalidToken"]) ? (this.session = void 0, this._persistSession?.("expired", void 0)) : ZB(this._baseClient, r.body) && (this.session = {
      ...this.session || {},
      accessJwt: r.body.accessJwt,
      refreshJwt: r.body.refreshJwt,
      handle: r.body.handle,
      did: r.body.did
    }, this._updateApiEndpoint(r.body.didDoc), this._persistSession?.("update", this.session));
  }
  /**
   * Helper to update the pds endpoint dynamically.
   *
   * The session methods (create, resume, refresh) may respond with the user's
   * did document which contains the user's canonical PDS endpoint. That endpoint
   * may differ from the endpoint used to contact the server. We capture that
   * PDS endpoint and update the client to use that given endpoint for future
   * requests. (This helps ensure smooth migrations between PDSes, especially
   * when the PDSes are operated by a single org.)
   */
  _updateApiEndpoint(e) {
    if ((0, Su.isValidDidDoc)(e)) {
      const r = (0, Su.getPdsEndpoint)(e);
      this.pdsUrl = r ? new URL(r) : void 0;
    }
    this.api.xrpc.uri = this.pdsUrl || this.service;
  }
}
Vi.AtpAgent = qe;
Object.defineProperty(qe, "fetch", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Zo.defaultFetchHandler
});
Object.defineProperty(qe, "appLabelers", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: [FB.BSKY_LABELER_DID]
});
function XB(t) {
  return GB.errorResponseBody.safeParse(t).success;
}
function Lu(t, e) {
  return t.status !== 400 || !XB(t.body) ? !1 : typeof t.body.error == "string" && e.includes(t.body.error);
}
function ZB(t, e) {
  try {
    return t.xrpc.lex.assertValidXrpcOutput("com.atproto.server.refreshSession", e), !0;
  } catch {
    return !1;
  }
}
var Ii = {}, Gi = {};
Object.defineProperty(Gi, "__esModule", { value: !0 });
Gi.UnicodeString = void 0;
const HB = Vt, ku = new TextEncoder(), WB = new TextDecoder();
class JB {
  constructor(e) {
    Object.defineProperty(this, "utf16", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "utf8", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_graphemeLen", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.utf16 = e, this.utf8 = ku.encode(e);
  }
  get length() {
    return this.utf8.byteLength;
  }
  get graphemeLength() {
    return this._graphemeLen || (this._graphemeLen = (0, HB.graphemeLen)(this.utf16)), this._graphemeLen;
  }
  slice(e, r) {
    return WB.decode(this.utf8.slice(e, r));
  }
  utf16IndexToUtf8Index(e) {
    return ku.encode(this.utf16.slice(0, e)).byteLength;
  }
  toString() {
    return this.utf16;
  }
}
Gi.UnicodeString = JB;
var ko = {};
Object.defineProperty(ko, "__esModule", { value: !0 });
ko.sanitizeRichText = void 0;
const QB = Gi, YB = /[\r\n]([\u00AD\u2060\u200D\u200C\u200B\s]*[\r\n]){2,}/, eP = `

`;
function tP(t, e) {
  return e.cleanNewlines && (t = rP(t, YB, eP)), t;
}
ko.sanitizeRichText = tP;
function rP(t, e, r) {
  t = t.clone();
  let n = t.unicodeText.utf16.match(e);
  for (; n && typeof n.index < "u"; ) {
    const s = t.unicodeText, u = t.unicodeText.utf16IndexToUtf8Index(n.index), c = u + new QB.UnicodeString(n[0]).length;
    if (t.delete(u, c), t.unicodeText.utf16 === s.utf16)
      break;
    t.insert(u, r), n = t.unicodeText.utf16.match(e);
  }
  return t;
}
var Sa = {};
const iP = [
  "aaa",
  "aarp",
  "abb",
  "abbott",
  "abbvie",
  "abc",
  "able",
  "abogado",
  "abudhabi",
  "ac",
  "academy",
  "accenture",
  "accountant",
  "accountants",
  "aco",
  "actor",
  "ad",
  "ads",
  "adult",
  "ae",
  "aeg",
  "aero",
  "aetna",
  "af",
  "afl",
  "africa",
  "ag",
  "agakhan",
  "agency",
  "ai",
  "aig",
  "airbus",
  "airforce",
  "airtel",
  "akdn",
  "al",
  "alibaba",
  "alipay",
  "allfinanz",
  "allstate",
  "ally",
  "alsace",
  "alstom",
  "am",
  "amazon",
  "americanexpress",
  "americanfamily",
  "amex",
  "amfam",
  "amica",
  "amsterdam",
  "analytics",
  "android",
  "anquan",
  "anz",
  "ao",
  "aol",
  "apartments",
  "app",
  "apple",
  "aq",
  "aquarelle",
  "ar",
  "arab",
  "aramco",
  "archi",
  "army",
  "arpa",
  "art",
  "arte",
  "as",
  "asda",
  "asia",
  "associates",
  "at",
  "athleta",
  "attorney",
  "au",
  "auction",
  "audi",
  "audible",
  "audio",
  "auspost",
  "author",
  "auto",
  "autos",
  "aw",
  "aws",
  "ax",
  "axa",
  "az",
  "azure",
  "ba",
  "baby",
  "baidu",
  "banamex",
  "band",
  "bank",
  "bar",
  "barcelona",
  "barclaycard",
  "barclays",
  "barefoot",
  "bargains",
  "baseball",
  "basketball",
  "bauhaus",
  "bayern",
  "bb",
  "bbc",
  "bbt",
  "bbva",
  "bcg",
  "bcn",
  "bd",
  "be",
  "beats",
  "beauty",
  "beer",
  "bentley",
  "berlin",
  "best",
  "bestbuy",
  "bet",
  "bf",
  "bg",
  "bh",
  "bharti",
  "bi",
  "bible",
  "bid",
  "bike",
  "bing",
  "bingo",
  "bio",
  "biz",
  "bj",
  "black",
  "blackfriday",
  "blockbuster",
  "blog",
  "bloomberg",
  "blue",
  "bm",
  "bms",
  "bmw",
  "bn",
  "bnpparibas",
  "bo",
  "boats",
  "boehringer",
  "bofa",
  "bom",
  "bond",
  "boo",
  "book",
  "booking",
  "bosch",
  "bostik",
  "boston",
  "bot",
  "boutique",
  "box",
  "br",
  "bradesco",
  "bridgestone",
  "broadway",
  "broker",
  "brother",
  "brussels",
  "bs",
  "bt",
  "build",
  "builders",
  "business",
  "buy",
  "buzz",
  "bv",
  "bw",
  "by",
  "bz",
  "bzh",
  "ca",
  "cab",
  "cafe",
  "cal",
  "call",
  "calvinklein",
  "cam",
  "camera",
  "camp",
  "canon",
  "capetown",
  "capital",
  "capitalone",
  "car",
  "caravan",
  "cards",
  "care",
  "career",
  "careers",
  "cars",
  "casa",
  "case",
  "cash",
  "casino",
  "cat",
  "catering",
  "catholic",
  "cba",
  "cbn",
  "cbre",
  "cc",
  "cd",
  "center",
  "ceo",
  "cern",
  "cf",
  "cfa",
  "cfd",
  "cg",
  "ch",
  "chanel",
  "channel",
  "charity",
  "chase",
  "chat",
  "cheap",
  "chintai",
  "christmas",
  "chrome",
  "church",
  "ci",
  "cipriani",
  "circle",
  "cisco",
  "citadel",
  "citi",
  "citic",
  "city",
  "ck",
  "cl",
  "claims",
  "cleaning",
  "click",
  "clinic",
  "clinique",
  "clothing",
  "cloud",
  "club",
  "clubmed",
  "cm",
  "cn",
  "co",
  "coach",
  "codes",
  "coffee",
  "college",
  "cologne",
  "com",
  "commbank",
  "community",
  "company",
  "compare",
  "computer",
  "comsec",
  "condos",
  "construction",
  "consulting",
  "contact",
  "contractors",
  "cooking",
  "cool",
  "coop",
  "corsica",
  "country",
  "coupon",
  "coupons",
  "courses",
  "cpa",
  "cr",
  "credit",
  "creditcard",
  "creditunion",
  "cricket",
  "crown",
  "crs",
  "cruise",
  "cruises",
  "cu",
  "cuisinella",
  "cv",
  "cw",
  "cx",
  "cy",
  "cymru",
  "cyou",
  "cz",
  "dabur",
  "dad",
  "dance",
  "data",
  "date",
  "dating",
  "datsun",
  "day",
  "dclk",
  "dds",
  "de",
  "deal",
  "dealer",
  "deals",
  "degree",
  "delivery",
  "dell",
  "deloitte",
  "delta",
  "democrat",
  "dental",
  "dentist",
  "desi",
  "design",
  "dev",
  "dhl",
  "diamonds",
  "diet",
  "digital",
  "direct",
  "directory",
  "discount",
  "discover",
  "dish",
  "diy",
  "dj",
  "dk",
  "dm",
  "dnp",
  "do",
  "docs",
  "doctor",
  "dog",
  "domains",
  "dot",
  "download",
  "drive",
  "dtv",
  "dubai",
  "dunlop",
  "dupont",
  "durban",
  "dvag",
  "dvr",
  "dz",
  "earth",
  "eat",
  "ec",
  "eco",
  "edeka",
  "edu",
  "education",
  "ee",
  "eg",
  "email",
  "emerck",
  "energy",
  "engineer",
  "engineering",
  "enterprises",
  "epson",
  "equipment",
  "er",
  "ericsson",
  "erni",
  "es",
  "esq",
  "estate",
  "et",
  "eu",
  "eurovision",
  "eus",
  "events",
  "exchange",
  "expert",
  "exposed",
  "express",
  "extraspace",
  "fage",
  "fail",
  "fairwinds",
  "faith",
  "family",
  "fan",
  "fans",
  "farm",
  "farmers",
  "fashion",
  "fast",
  "fedex",
  "feedback",
  "ferrari",
  "ferrero",
  "fi",
  "fidelity",
  "fido",
  "film",
  "final",
  "finance",
  "financial",
  "fire",
  "firestone",
  "firmdale",
  "fish",
  "fishing",
  "fit",
  "fitness",
  "fj",
  "fk",
  "flickr",
  "flights",
  "flir",
  "florist",
  "flowers",
  "fly",
  "fm",
  "fo",
  "foo",
  "food",
  "football",
  "ford",
  "forex",
  "forsale",
  "forum",
  "foundation",
  "fox",
  "fr",
  "free",
  "fresenius",
  "frl",
  "frogans",
  "frontier",
  "ftr",
  "fujitsu",
  "fun",
  "fund",
  "furniture",
  "futbol",
  "fyi",
  "ga",
  "gal",
  "gallery",
  "gallo",
  "gallup",
  "game",
  "games",
  "gap",
  "garden",
  "gay",
  "gb",
  "gbiz",
  "gd",
  "gdn",
  "ge",
  "gea",
  "gent",
  "genting",
  "george",
  "gf",
  "gg",
  "ggee",
  "gh",
  "gi",
  "gift",
  "gifts",
  "gives",
  "giving",
  "gl",
  "glass",
  "gle",
  "global",
  "globo",
  "gm",
  "gmail",
  "gmbh",
  "gmo",
  "gmx",
  "gn",
  "godaddy",
  "gold",
  "goldpoint",
  "golf",
  "goo",
  "goodyear",
  "goog",
  "google",
  "gop",
  "got",
  "gov",
  "gp",
  "gq",
  "gr",
  "grainger",
  "graphics",
  "gratis",
  "green",
  "gripe",
  "grocery",
  "group",
  "gs",
  "gt",
  "gu",
  "gucci",
  "guge",
  "guide",
  "guitars",
  "guru",
  "gw",
  "gy",
  "hair",
  "hamburg",
  "hangout",
  "haus",
  "hbo",
  "hdfc",
  "hdfcbank",
  "health",
  "healthcare",
  "help",
  "helsinki",
  "here",
  "hermes",
  "hiphop",
  "hisamitsu",
  "hitachi",
  "hiv",
  "hk",
  "hkt",
  "hm",
  "hn",
  "hockey",
  "holdings",
  "holiday",
  "homedepot",
  "homegoods",
  "homes",
  "homesense",
  "honda",
  "horse",
  "hospital",
  "host",
  "hosting",
  "hot",
  "hotels",
  "hotmail",
  "house",
  "how",
  "hr",
  "hsbc",
  "ht",
  "hu",
  "hughes",
  "hyatt",
  "hyundai",
  "ibm",
  "icbc",
  "ice",
  "icu",
  "id",
  "ie",
  "ieee",
  "ifm",
  "ikano",
  "il",
  "im",
  "imamat",
  "imdb",
  "immo",
  "immobilien",
  "in",
  "inc",
  "industries",
  "infiniti",
  "info",
  "ing",
  "ink",
  "institute",
  "insurance",
  "insure",
  "int",
  "international",
  "intuit",
  "investments",
  "io",
  "ipiranga",
  "iq",
  "ir",
  "irish",
  "is",
  "ismaili",
  "ist",
  "istanbul",
  "it",
  "itau",
  "itv",
  "jaguar",
  "java",
  "jcb",
  "je",
  "jeep",
  "jetzt",
  "jewelry",
  "jio",
  "jll",
  "jm",
  "jmp",
  "jnj",
  "jo",
  "jobs",
  "joburg",
  "jot",
  "joy",
  "jp",
  "jpmorgan",
  "jprs",
  "juegos",
  "juniper",
  "kaufen",
  "kddi",
  "ke",
  "kerryhotels",
  "kerrylogistics",
  "kerryproperties",
  "kfh",
  "kg",
  "kh",
  "ki",
  "kia",
  "kids",
  "kim",
  "kindle",
  "kitchen",
  "kiwi",
  "km",
  "kn",
  "koeln",
  "komatsu",
  "kosher",
  "kp",
  "kpmg",
  "kpn",
  "kr",
  "krd",
  "kred",
  "kuokgroup",
  "kw",
  "ky",
  "kyoto",
  "kz",
  "la",
  "lacaixa",
  "lamborghini",
  "lamer",
  "lancaster",
  "land",
  "landrover",
  "lanxess",
  "lasalle",
  "lat",
  "latino",
  "latrobe",
  "law",
  "lawyer",
  "lb",
  "lc",
  "lds",
  "lease",
  "leclerc",
  "lefrak",
  "legal",
  "lego",
  "lexus",
  "lgbt",
  "li",
  "lidl",
  "life",
  "lifeinsurance",
  "lifestyle",
  "lighting",
  "like",
  "lilly",
  "limited",
  "limo",
  "lincoln",
  "link",
  "lipsy",
  "live",
  "living",
  "lk",
  "llc",
  "llp",
  "loan",
  "loans",
  "locker",
  "locus",
  "lol",
  "london",
  "lotte",
  "lotto",
  "love",
  "lpl",
  "lplfinancial",
  "lr",
  "ls",
  "lt",
  "ltd",
  "ltda",
  "lu",
  "lundbeck",
  "luxe",
  "luxury",
  "lv",
  "ly",
  "ma",
  "madrid",
  "maif",
  "maison",
  "makeup",
  "man",
  "management",
  "mango",
  "map",
  "market",
  "marketing",
  "markets",
  "marriott",
  "marshalls",
  "mattel",
  "mba",
  "mc",
  "mckinsey",
  "md",
  "me",
  "med",
  "media",
  "meet",
  "melbourne",
  "meme",
  "memorial",
  "men",
  "menu",
  "merckmsd",
  "mg",
  "mh",
  "miami",
  "microsoft",
  "mil",
  "mini",
  "mint",
  "mit",
  "mitsubishi",
  "mk",
  "ml",
  "mlb",
  "mls",
  "mm",
  "mma",
  "mn",
  "mo",
  "mobi",
  "mobile",
  "moda",
  "moe",
  "moi",
  "mom",
  "monash",
  "money",
  "monster",
  "mormon",
  "mortgage",
  "moscow",
  "moto",
  "motorcycles",
  "mov",
  "movie",
  "mp",
  "mq",
  "mr",
  "ms",
  "msd",
  "mt",
  "mtn",
  "mtr",
  "mu",
  "museum",
  "music",
  "mv",
  "mw",
  "mx",
  "my",
  "mz",
  "na",
  "nab",
  "nagoya",
  "name",
  "navy",
  "nba",
  "nc",
  "ne",
  "nec",
  "net",
  "netbank",
  "netflix",
  "network",
  "neustar",
  "new",
  "news",
  "next",
  "nextdirect",
  "nexus",
  "nf",
  "nfl",
  "ng",
  "ngo",
  "nhk",
  "ni",
  "nico",
  "nike",
  "nikon",
  "ninja",
  "nissan",
  "nissay",
  "nl",
  "no",
  "nokia",
  "norton",
  "now",
  "nowruz",
  "nowtv",
  "np",
  "nr",
  "nra",
  "nrw",
  "ntt",
  "nu",
  "nyc",
  "nz",
  "obi",
  "observer",
  "office",
  "okinawa",
  "olayan",
  "olayangroup",
  "ollo",
  "om",
  "omega",
  "one",
  "ong",
  "onl",
  "online",
  "ooo",
  "open",
  "oracle",
  "orange",
  "org",
  "organic",
  "origins",
  "osaka",
  "otsuka",
  "ott",
  "ovh",
  "pa",
  "page",
  "panasonic",
  "paris",
  "pars",
  "partners",
  "parts",
  "party",
  "pay",
  "pccw",
  "pe",
  "pet",
  "pf",
  "pfizer",
  "pg",
  "ph",
  "pharmacy",
  "phd",
  "philips",
  "phone",
  "photo",
  "photography",
  "photos",
  "physio",
  "pics",
  "pictet",
  "pictures",
  "pid",
  "pin",
  "ping",
  "pink",
  "pioneer",
  "pizza",
  "pk",
  "pl",
  "place",
  "play",
  "playstation",
  "plumbing",
  "plus",
  "pm",
  "pn",
  "pnc",
  "pohl",
  "poker",
  "politie",
  "porn",
  "post",
  "pr",
  "pramerica",
  "praxi",
  "press",
  "prime",
  "pro",
  "prod",
  "productions",
  "prof",
  "progressive",
  "promo",
  "properties",
  "property",
  "protection",
  "pru",
  "prudential",
  "ps",
  "pt",
  "pub",
  "pw",
  "pwc",
  "py",
  "qa",
  "qpon",
  "quebec",
  "quest",
  "racing",
  "radio",
  "re",
  "read",
  "realestate",
  "realtor",
  "realty",
  "recipes",
  "red",
  "redstone",
  "redumbrella",
  "rehab",
  "reise",
  "reisen",
  "reit",
  "reliance",
  "ren",
  "rent",
  "rentals",
  "repair",
  "report",
  "republican",
  "rest",
  "restaurant",
  "review",
  "reviews",
  "rexroth",
  "rich",
  "richardli",
  "ricoh",
  "ril",
  "rio",
  "rip",
  "ro",
  "rocks",
  "rodeo",
  "rogers",
  "room",
  "rs",
  "rsvp",
  "ru",
  "rugby",
  "ruhr",
  "run",
  "rw",
  "rwe",
  "ryukyu",
  "sa",
  "saarland",
  "safe",
  "safety",
  "sakura",
  "sale",
  "salon",
  "samsclub",
  "samsung",
  "sandvik",
  "sandvikcoromant",
  "sanofi",
  "sap",
  "sarl",
  "sas",
  "save",
  "saxo",
  "sb",
  "sbi",
  "sbs",
  "sc",
  "scb",
  "schaeffler",
  "schmidt",
  "scholarships",
  "school",
  "schule",
  "schwarz",
  "science",
  "scot",
  "sd",
  "se",
  "search",
  "seat",
  "secure",
  "security",
  "seek",
  "select",
  "sener",
  "services",
  "seven",
  "sew",
  "sex",
  "sexy",
  "sfr",
  "sg",
  "sh",
  "shangrila",
  "sharp",
  "shell",
  "shia",
  "shiksha",
  "shoes",
  "shop",
  "shopping",
  "shouji",
  "show",
  "si",
  "silk",
  "sina",
  "singles",
  "site",
  "sj",
  "sk",
  "ski",
  "skin",
  "sky",
  "skype",
  "sl",
  "sling",
  "sm",
  "smart",
  "smile",
  "sn",
  "sncf",
  "so",
  "soccer",
  "social",
  "softbank",
  "software",
  "sohu",
  "solar",
  "solutions",
  "song",
  "sony",
  "soy",
  "spa",
  "space",
  "sport",
  "spot",
  "sr",
  "srl",
  "ss",
  "st",
  "stada",
  "staples",
  "star",
  "statebank",
  "statefarm",
  "stc",
  "stcgroup",
  "stockholm",
  "storage",
  "store",
  "stream",
  "studio",
  "study",
  "style",
  "su",
  "sucks",
  "supplies",
  "supply",
  "support",
  "surf",
  "surgery",
  "suzuki",
  "sv",
  "swatch",
  "swiss",
  "sx",
  "sy",
  "sydney",
  "systems",
  "sz",
  "tab",
  "taipei",
  "talk",
  "taobao",
  "target",
  "tatamotors",
  "tatar",
  "tattoo",
  "tax",
  "taxi",
  "tc",
  "tci",
  "td",
  "tdk",
  "team",
  "tech",
  "technology",
  "tel",
  "temasek",
  "tennis",
  "teva",
  "tf",
  "tg",
  "th",
  "thd",
  "theater",
  "theatre",
  "tiaa",
  "tickets",
  "tienda",
  "tips",
  "tires",
  "tirol",
  "tj",
  "tjmaxx",
  "tjx",
  "tk",
  "tkmaxx",
  "tl",
  "tm",
  "tmall",
  "tn",
  "to",
  "today",
  "tokyo",
  "tools",
  "top",
  "toray",
  "toshiba",
  "total",
  "tours",
  "town",
  "toyota",
  "toys",
  "tr",
  "trade",
  "trading",
  "training",
  "travel",
  "travelers",
  "travelersinsurance",
  "trust",
  "trv",
  "tt",
  "tube",
  "tui",
  "tunes",
  "tushu",
  "tv",
  "tvs",
  "tw",
  "tz",
  "ua",
  "ubank",
  "ubs",
  "ug",
  "uk",
  "unicom",
  "university",
  "uno",
  "uol",
  "ups",
  "us",
  "uy",
  "uz",
  "va",
  "vacations",
  "vana",
  "vanguard",
  "vc",
  "ve",
  "vegas",
  "ventures",
  "verisign",
  "vermgensberater",
  "vermgensberatung",
  "versicherung",
  "vet",
  "vg",
  "vi",
  "viajes",
  "video",
  "vig",
  "viking",
  "villas",
  "vin",
  "vip",
  "virgin",
  "visa",
  "vision",
  "viva",
  "vivo",
  "vlaanderen",
  "vn",
  "vodka",
  "volvo",
  "vote",
  "voting",
  "voto",
  "voyage",
  "vu",
  "wales",
  "walmart",
  "walter",
  "wang",
  "wanggou",
  "watch",
  "watches",
  "weather",
  "weatherchannel",
  "webcam",
  "weber",
  "website",
  "wed",
  "wedding",
  "weibo",
  "weir",
  "wf",
  "whoswho",
  "wien",
  "wiki",
  "williamhill",
  "win",
  "windows",
  "wine",
  "winners",
  "wme",
  "wolterskluwer",
  "woodside",
  "work",
  "works",
  "world",
  "wow",
  "ws",
  "wtc",
  "wtf",
  "xbox",
  "xerox",
  "xihuan",
  "xin",
  "xxx",
  "xyz",
  "yachts",
  "yahoo",
  "yamaxun",
  "yandex",
  "ye",
  "yodobashi",
  "yoga",
  "yokohama",
  "you",
  "youtube",
  "yt",
  "yun",
  "za",
  "zappos",
  "zara",
  "zero",
  "zip",
  "zm",
  "zone",
  "zuerich",
  "zw",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];
var pt = {};
Object.defineProperty(pt, "__esModule", { value: !0 });
pt.TAG_REGEX = pt.TRAILING_PUNCTUATION_REGEX = pt.URL_REGEX = pt.MENTION_REGEX = void 0;
pt.MENTION_REGEX = /(^|\s|\()(@)([a-zA-Z0-9.-]+)(\b)/g;
pt.URL_REGEX = /(^|\s|\()((https?:\/\/[\S]+)|((?<domain>[a-z][a-z0-9]*(\.[a-z0-9]+)+)[\S]*))/gim;
pt.TRAILING_PUNCTUATION_REGEX = /\p{P}+$/gu;
pt.TAG_REGEX = // eslint-disable-next-line no-misleading-character-class
/(^|\s)[#]((?!\ufe0f)[^\s\u00AD\u2060\u200A\u200B\u200C\u200D\u20e2]*[^\d\s\p{P}\u00AD\u2060\u200A\u200B\u200C\u200D\u20e2]+[^\s\u00AD\u2060\u200A\u200B\u200C\u200D\u20e2]*)?/gu;
var nP = S && S.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(Sa, "__esModule", { value: !0 });
Sa.detectFacets = void 0;
const sP = nP(iP), zo = pt;
function oP(t) {
  let e;
  const r = [];
  {
    const n = zo.MENTION_REGEX;
    for (; e = n.exec(t.utf16); ) {
      if (!Bu(e[3]) && !e[3].endsWith(".test"))
        continue;
      const s = t.utf16.indexOf(e[3], e.index) - 1;
      r.push({
        $type: "app.bsky.richtext.facet",
        index: {
          byteStart: t.utf16IndexToUtf8Index(s),
          byteEnd: t.utf16IndexToUtf8Index(s + e[3].length + 1)
        },
        features: [
          {
            $type: "app.bsky.richtext.facet#mention",
            did: e[3]
            // must be resolved afterwards
          }
        ]
      });
    }
  }
  {
    const n = zo.URL_REGEX;
    for (; e = n.exec(t.utf16); ) {
      let s = e[2];
      if (!s.startsWith("http")) {
        const a = e.groups?.domain;
        if (!a || !Bu(a))
          continue;
        s = `https://${s}`;
      }
      const u = t.utf16.indexOf(e[2], e.index), c = { start: u, end: u + e[2].length };
      /[.,;:!?]$/.test(s) && (s = s.slice(0, -1), c.end--), /[)]$/.test(s) && !s.includes("(") && (s = s.slice(0, -1), c.end--), r.push({
        index: {
          byteStart: t.utf16IndexToUtf8Index(c.start),
          byteEnd: t.utf16IndexToUtf8Index(c.end)
        },
        features: [
          {
            $type: "app.bsky.richtext.facet#link",
            uri: s
          }
        ]
      });
    }
  }
  {
    const n = zo.TAG_REGEX;
    for (; e = n.exec(t.utf16); ) {
      const s = e[1];
      let u = e[2];
      if (!u || (u = u.trim().replace(zo.TRAILING_PUNCTUATION_REGEX, ""), u.length === 0 || u.length > 64))
        continue;
      const c = e.index + s.length;
      r.push({
        index: {
          byteStart: t.utf16IndexToUtf8Index(c),
          byteEnd: t.utf16IndexToUtf8Index(c + 1 + u.length)
        },
        features: [
          {
            $type: "app.bsky.richtext.facet#tag",
            tag: u
          }
        ]
      });
    }
  }
  return r.length > 0 ? r : void 0;
}
Sa.detectFacets = oP;
function Bu(t) {
  return !!sP.default.find((e) => {
    const r = t.lastIndexOf(e);
    return r === -1 ? !1 : t.charAt(r - 1) === "." && r === t.length - e.length;
  });
}
Object.defineProperty(Ii, "__esModule", { value: !0 });
Ii.RichText = Ii.RichTextSegment = void 0;
const Vr = l, Fa = Gi, aP = ko, Pu = Sa;
class mi {
  constructor(e, r) {
    Object.defineProperty(this, "text", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "facet", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    });
  }
  get link() {
    const e = this.facet?.features.find(Vr.AppBskyRichtextFacet.isLink);
    if (Vr.AppBskyRichtextFacet.isLink(e))
      return e;
  }
  isLink() {
    return !!this.link;
  }
  get mention() {
    const e = this.facet?.features.find(Vr.AppBskyRichtextFacet.isMention);
    if (Vr.AppBskyRichtextFacet.isMention(e))
      return e;
  }
  isMention() {
    return !!this.mention;
  }
  get tag() {
    const e = this.facet?.features.find(Vr.AppBskyRichtextFacet.isTag);
    if (Vr.AppBskyRichtextFacet.isTag(e))
      return e;
  }
  isTag() {
    return !!this.tag;
  }
}
Ii.RichTextSegment = mi;
class Sl {
  constructor(e, r) {
    Object.defineProperty(this, "unicodeText", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "facets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.unicodeText = new Fa.UnicodeString(e.text), this.facets = e.facets, !this.facets?.length && e.entities?.length && (this.facets = lP(this.unicodeText, e.entities)), this.facets && this.facets.sort(za), r?.cleanNewlines && (0, aP.sanitizeRichText)(this, { cleanNewlines: !0 }).copyInto(this);
  }
  get text() {
    return this.unicodeText.toString();
  }
  get length() {
    return this.unicodeText.length;
  }
  get graphemeLength() {
    return this.unicodeText.graphemeLength;
  }
  clone() {
    return new Sl({
      text: this.unicodeText.utf16,
      facets: Du(this.facets)
    });
  }
  copyInto(e) {
    e.unicodeText = this.unicodeText, e.facets = Du(this.facets);
  }
  *segments() {
    const e = this.facets || [];
    if (!e.length) {
      yield new mi(this.unicodeText.utf16);
      return;
    }
    let r = 0, n = 0;
    do {
      const s = e[n];
      if (r < s.index.byteStart)
        yield new mi(this.unicodeText.slice(r, s.index.byteStart));
      else if (r > s.index.byteStart) {
        n++;
        continue;
      }
      if (s.index.byteStart < s.index.byteEnd) {
        const u = this.unicodeText.slice(s.index.byteStart, s.index.byteEnd);
        u.trim() ? yield new mi(u, s) : yield new mi(u);
      }
      r = s.index.byteEnd, n++;
    } while (n < e.length);
    r < this.unicodeText.length && (yield new mi(this.unicodeText.slice(r, this.unicodeText.length)));
  }
  insert(e, r) {
    if (this.unicodeText = new Fa.UnicodeString(this.unicodeText.slice(0, e) + r + this.unicodeText.slice(e)), !this.facets?.length)
      return this;
    const n = r.length;
    for (const s of this.facets)
      e <= s.index.byteStart ? (s.index.byteStart += n, s.index.byteEnd += n) : e >= s.index.byteStart && e < s.index.byteEnd && (s.index.byteEnd += n);
    return this;
  }
  delete(e, r) {
    if (this.unicodeText = new Fa.UnicodeString(this.unicodeText.slice(0, e) + this.unicodeText.slice(r)), !this.facets?.length)
      return this;
    const n = r - e;
    for (const s of this.facets)
      e <= s.index.byteStart && r >= s.index.byteEnd ? (s.index.byteStart = 0, s.index.byteEnd = 0) : e > s.index.byteEnd || (e > s.index.byteStart && e <= s.index.byteEnd && r > s.index.byteEnd ? s.index.byteEnd = e : e >= s.index.byteStart && r <= s.index.byteEnd ? s.index.byteEnd -= n : e < s.index.byteStart && r >= s.index.byteStart && r <= s.index.byteEnd ? (s.index.byteStart = e, s.index.byteEnd -= n) : r < s.index.byteStart && (s.index.byteStart -= n, s.index.byteEnd -= n));
    return this.facets = this.facets.filter((s) => s.index.byteStart < s.index.byteEnd), this;
  }
  /**
   * Detects facets such as links and mentions
   * Note: Overwrites the existing facets with auto-detected facets
   */
  async detectFacets(e) {
    if (this.facets = (0, Pu.detectFacets)(this.unicodeText), this.facets) {
      for (const r of this.facets)
        for (const n of r.features)
          if (Vr.AppBskyRichtextFacet.isMention(n)) {
            const s = await e.resolveHandle({ handle: n.did }).catch((u) => {
            }).then((u) => u?.data.did);
            n.did = s || "";
          }
      this.facets.sort(za);
    }
  }
  /**
   * Detects facets such as links and mentions but does not resolve them
   * Will produce invalid facets! For instance, mentions will not have their DIDs set.
   * Note: Overwrites the existing facets with auto-detected facets
   */
  detectFacetsWithoutResolution() {
    this.facets = (0, Pu.detectFacets)(this.unicodeText), this.facets && this.facets.sort(za);
  }
}
Ii.RichText = Sl;
const za = (t, e) => t.index.byteStart - e.index.byteStart;
function lP(t, e) {
  const r = [];
  for (const n of e)
    n.type === "link" ? r.push({
      $type: "app.bsky.richtext.facet",
      index: {
        byteStart: t.utf16IndexToUtf8Index(n.index.start),
        byteEnd: t.utf16IndexToUtf8Index(n.index.end)
      },
      features: [{ $type: "app.bsky.richtext.facet#link", uri: n.value }]
    }) : n.type === "mention" && r.push({
      $type: "app.bsky.richtext.facet",
      index: {
        byteStart: t.utf16IndexToUtf8Index(n.index.start),
        byteEnd: t.utf16IndexToUtf8Index(n.index.end)
      },
      features: [
        { $type: "app.bsky.richtext.facet#mention", did: n.value }
      ]
    });
  return r;
}
function Du(t) {
  return typeof t > "u" ? t : JSON.parse(JSON.stringify(t));
}
var Ll = {}, Kt = {}, dt = {}, Oe = {};
Object.defineProperty(Oe, "__esModule", { value: !0 });
Oe.NOOP_BEHAVIOR = Oe.HIDE_BEHAVIOR = Oe.MUTEWORD_BEHAVIOR = Oe.MUTE_BEHAVIOR = Oe.BLOCK_BEHAVIOR = Oe.CUSTOM_LABEL_VALUE_RE = void 0;
Oe.CUSTOM_LABEL_VALUE_RE = /^[a-z-]+$/;
Oe.BLOCK_BEHAVIOR = {
  profileList: "blur",
  profileView: "alert",
  avatar: "blur",
  banner: "blur",
  contentList: "blur",
  contentView: "blur"
};
Oe.MUTE_BEHAVIOR = {
  profileList: "inform",
  profileView: "alert",
  contentList: "blur",
  contentView: "inform"
};
Oe.MUTEWORD_BEHAVIOR = {
  contentList: "blur",
  contentView: "blur"
};
Oe.HIDE_BEHAVIOR = {
  contentList: "blur",
  contentView: "blur"
};
Oe.NOOP_BEHAVIOR = {};
var Bo = {};
Object.defineProperty(Bo, "__esModule", { value: !0 });
Bo.ModerationUI = void 0;
class uP {
  constructor() {
    Object.defineProperty(this, "noOverride", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "filters", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "blurs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "alerts", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "informs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  get filter() {
    return this.filters.length !== 0;
  }
  get blur() {
    return this.blurs.length !== 0;
  }
  get alert() {
    return this.alerts.length !== 0;
  }
  get inform() {
    return this.informs.length !== 0;
  }
}
Bo.ModerationUI = uP;
var Cr = {};
Object.defineProperty(Cr, "__esModule", { value: !0 });
Cr.LABELS = Cr.DEFAULT_LABEL_SETTINGS = void 0;
Cr.DEFAULT_LABEL_SETTINGS = {
  porn: "hide",
  sexual: "warn",
  nudity: "ignore",
  "graphic-media": "warn"
};
Cr.LABELS = {
  "!hide": {
    identifier: "!hide",
    configurable: !1,
    defaultSetting: "hide",
    flags: ["no-override", "no-self"],
    severity: "alert",
    blurs: "content",
    behaviors: {
      account: {
        profileList: "blur",
        profileView: "blur",
        avatar: "blur",
        banner: "blur",
        displayName: "blur",
        contentList: "blur",
        contentView: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur",
        displayName: "blur"
      },
      content: {
        contentList: "blur",
        contentView: "blur"
      }
    },
    locales: []
  },
  "!warn": {
    identifier: "!warn",
    configurable: !1,
    defaultSetting: "warn",
    flags: ["no-self"],
    severity: "none",
    blurs: "content",
    behaviors: {
      account: {
        profileList: "blur",
        profileView: "blur",
        avatar: "blur",
        banner: "blur",
        contentList: "blur",
        contentView: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur",
        displayName: "blur"
      },
      content: {
        contentList: "blur",
        contentView: "blur"
      }
    },
    locales: []
  },
  "!no-unauthenticated": {
    identifier: "!no-unauthenticated",
    configurable: !1,
    defaultSetting: "hide",
    flags: ["no-override", "unauthed"],
    severity: "none",
    blurs: "content",
    behaviors: {
      account: {
        profileList: "blur",
        profileView: "blur",
        avatar: "blur",
        banner: "blur",
        displayName: "blur",
        contentList: "blur",
        contentView: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur",
        displayName: "blur"
      },
      content: {
        contentList: "blur",
        contentView: "blur"
      }
    },
    locales: []
  },
  porn: {
    identifier: "porn",
    configurable: !0,
    defaultSetting: "hide",
    flags: ["adult"],
    severity: "none",
    blurs: "media",
    behaviors: {
      account: {
        avatar: "blur",
        banner: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur"
      },
      content: {
        contentMedia: "blur"
      }
    },
    locales: []
  },
  sexual: {
    identifier: "sexual",
    configurable: !0,
    defaultSetting: "warn",
    flags: ["adult"],
    severity: "none",
    blurs: "media",
    behaviors: {
      account: {
        avatar: "blur",
        banner: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur"
      },
      content: {
        contentMedia: "blur"
      }
    },
    locales: []
  },
  nudity: {
    identifier: "nudity",
    configurable: !0,
    defaultSetting: "ignore",
    flags: [],
    severity: "none",
    blurs: "media",
    behaviors: {
      account: {
        avatar: "blur",
        banner: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur"
      },
      content: {
        contentMedia: "blur"
      }
    },
    locales: []
  },
  "graphic-media": {
    identifier: "graphic-media",
    flags: ["adult"],
    configurable: !0,
    defaultSetting: "warn",
    severity: "none",
    blurs: "media",
    behaviors: {
      account: {
        avatar: "blur",
        banner: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur"
      },
      content: {
        contentMedia: "blur"
      }
    },
    locales: []
  }
};
Object.defineProperty(dt, "__esModule", { value: !0 });
dt.ModerationDecision = void 0;
const Ne = Oe, cP = Bo, Ku = Cr;
var Er;
(function(t) {
  t[t.High = 0] = "High", t[t.Medium = 1] = "Medium", t[t.Low = 2] = "Low";
})(Er || (Er = {}));
class kl {
  constructor() {
    Object.defineProperty(this, "did", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "isMe", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "causes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  static merge(...e) {
    const r = e.filter((s) => !!s), n = new kl();
    return r[0] && (n.did = r[0].did, n.isMe = r[0].isMe), n.causes = r.flatMap((s) => s.causes), n;
  }
  downgrade() {
    for (const e of this.causes)
      e.downgraded = !0;
    return this;
  }
  get blocked() {
    return !!this.blockCause;
  }
  get muted() {
    return !!this.muteCause;
  }
  get blockCause() {
    return this.causes.find((e) => e.type === "blocking" || e.type === "blocked-by" || e.type === "block-other");
  }
  get muteCause() {
    return this.causes.find((e) => e.type === "muted");
  }
  get labelCauses() {
    return this.causes.filter((e) => e.type === "label");
  }
  ui(e) {
    const r = new cP.ModerationUI();
    for (const n of this.causes)
      if (n.type === "blocking" || n.type === "blocked-by" || n.type === "block-other") {
        if (this.isMe)
          continue;
        (e === "profileList" || e === "contentList") && r.filters.push(n), n.downgraded || (Ne.BLOCK_BEHAVIOR[e] === "blur" ? (r.noOverride = !0, r.blurs.push(n)) : Ne.BLOCK_BEHAVIOR[e] === "alert" ? r.alerts.push(n) : Ne.BLOCK_BEHAVIOR[e] === "inform" && r.informs.push(n));
      } else if (n.type === "muted") {
        if (this.isMe)
          continue;
        (e === "profileList" || e === "contentList") && r.filters.push(n), n.downgraded || (Ne.MUTE_BEHAVIOR[e] === "blur" ? r.blurs.push(n) : Ne.MUTE_BEHAVIOR[e] === "alert" ? r.alerts.push(n) : Ne.MUTE_BEHAVIOR[e] === "inform" && r.informs.push(n));
      } else if (n.type === "mute-word") {
        if (this.isMe)
          continue;
        e === "contentList" && r.filters.push(n), n.downgraded || (Ne.MUTEWORD_BEHAVIOR[e] === "blur" ? r.blurs.push(n) : Ne.MUTEWORD_BEHAVIOR[e] === "alert" ? r.alerts.push(n) : Ne.MUTEWORD_BEHAVIOR[e] === "inform" && r.informs.push(n));
      } else n.type === "hidden" ? ((e === "profileList" || e === "contentList") && r.filters.push(n), n.downgraded || (Ne.HIDE_BEHAVIOR[e] === "blur" ? r.blurs.push(n) : Ne.HIDE_BEHAVIOR[e] === "alert" ? r.alerts.push(n) : Ne.HIDE_BEHAVIOR[e] === "inform" && r.informs.push(n))) : n.type === "label" && (e === "profileList" && n.target === "account" ? n.setting === "hide" && !this.isMe && r.filters.push(n) : e === "contentList" && (n.target === "account" || n.target === "content") && n.setting === "hide" && !this.isMe && r.filters.push(n), n.downgraded || (n.behavior[e] === "blur" ? (r.blurs.push(n), n.noOverride && !this.isMe && (r.noOverride = !0)) : n.behavior[e] === "alert" ? r.alerts.push(n) : n.behavior[e] === "inform" && r.informs.push(n)));
    return r.filters.sort(Uu), r.blurs.sort(Uu), r;
  }
  setDid(e) {
    this.did = e;
  }
  setIsMe(e) {
    this.isMe = e;
  }
  addHidden(e) {
    e && this.causes.push({
      type: "hidden",
      source: { type: "user" },
      priority: 6
    });
  }
  addMutedWord(e) {
    e && this.causes.push({
      type: "mute-word",
      source: { type: "user" },
      priority: 6
    });
  }
  addBlocking(e) {
    e && this.causes.push({
      type: "blocking",
      source: { type: "user" },
      priority: 3
    });
  }
  addBlockingByList(e) {
    e && this.causes.push({
      type: "blocking",
      source: { type: "list", list: e },
      priority: 3
    });
  }
  addBlockedBy(e) {
    e && this.causes.push({
      type: "blocked-by",
      source: { type: "user" },
      priority: 4
    });
  }
  addBlockOther(e) {
    e && this.causes.push({
      type: "block-other",
      source: { type: "user" },
      priority: 4
    });
  }
  addLabel(e, r, n) {
    const s = Ne.CUSTOM_LABEL_VALUE_RE.test(r.val) && n.labelDefs?.[r.src]?.find((g) => g.identifier === r.val) || Ku.LABELS[r.val];
    if (!s)
      return;
    const u = r.src === this.did, c = u ? void 0 : n.prefs.labelers.find((g) => g.did === r.src);
    if (!u && !c || u && s.flags.includes("no-self"))
      return;
    let a = s.defaultSetting || "ignore";
    if (s.configurable ? s.flags.includes("adult") && !n.prefs.adultContentEnabled ? a = "hide" : c?.labels[s.identifier] ? a = c?.labels[s.identifier] : n.prefs.labels[s.identifier] && (a = n.prefs.labels[s.identifier]) : a = s.defaultSetting || "hide", a === "ignore" || s.flags.includes("unauthed") && n.userDid)
      return;
    let y;
    const d = pP(s.behaviors[e]);
    s.flags.includes("no-override") || s.flags.includes("adult") && !n.prefs.adultContentEnabled ? y = 1 : a === "hide" ? y = 2 : d === Er.High ? y = 5 : d === Er.Medium ? y = 7 : y = 8;
    let b = !1;
    (s.flags.includes("no-override") || s.flags.includes("adult") && !n.prefs.adultContentEnabled) && (b = !0), this.causes.push({
      type: "label",
      source: u || !c ? { type: "user" } : { type: "labeler", did: c.did },
      label: r,
      labelDef: s,
      target: e,
      setting: a,
      behavior: s.behaviors[e] || Ne.NOOP_BEHAVIOR,
      noOverride: b,
      priority: y
    });
  }
  addMuted(e) {
    e && this.causes.push({
      type: "muted",
      source: { type: "user" },
      priority: 6
    });
  }
  addMutedByList(e) {
    e && this.causes.push({
      type: "muted",
      source: { type: "list", list: e },
      priority: 6
    });
  }
}
dt.ModerationDecision = kl;
function pP(t) {
  return t ? t.profileView === "blur" || t.contentView === "blur" ? Er.High : t.contentList === "blur" || t.contentMedia === "blur" ? Er.Medium : Er.Low : Er.Low;
}
function Uu(t, e) {
  return t.priority - e.priority;
}
Object.defineProperty(Kt, "__esModule", { value: !0 });
Kt.filterAccountLabels = Kt.decideAccount = void 0;
const dP = dt;
function fP(t, e) {
  const r = new dP.ModerationDecision();
  r.setDid(t.did), r.setIsMe(t.did === e.userDid), t.viewer?.muted && (t.viewer?.mutedByList ? r.addMutedByList(t.viewer?.mutedByList) : r.addMuted(t.viewer?.muted)), t.viewer?.blocking && (t.viewer?.blockingByList ? r.addBlockingByList(t.viewer?.blockingByList) : r.addBlocking(t.viewer?.blocking)), r.addBlockedBy(t.viewer?.blockedBy);
  for (const n of zf(t.labels))
    r.addLabel("account", n, e);
  return r;
}
Kt.decideAccount = fP;
function zf(t) {
  return t ? t.filter((e) => !e.uri.endsWith("/app.bsky.actor.profile/self") || e.val === "!no-unauthenticated") : [];
}
Kt.filterAccountLabels = zf;
var Ut = {};
Object.defineProperty(Ut, "__esModule", { value: !0 });
Ut.filterProfileLabels = Ut.decideProfile = void 0;
const yP = dt;
function mP(t, e) {
  const r = new yP.ModerationDecision();
  r.setDid(t.did), r.setIsMe(t.did === e.userDid);
  for (const n of Xf(t.labels))
    r.addLabel("profile", n, e);
  return r;
}
Ut.decideProfile = mP;
function Xf(t) {
  return t ? t.filter((e) => e.uri.endsWith("/app.bsky.actor.profile/self")) : [];
}
Ut.filterProfileLabels = Xf;
var La = {};
Object.defineProperty(La, "__esModule", { value: !0 });
La.decideNotification = void 0;
const Vu = dt, bP = Kt, hP = Ut;
function EP(t, e) {
  const r = new Vu.ModerationDecision();
  if (r.setDid(t.author.did), r.setIsMe(t.author.did === e.userDid), t.labels?.length)
    for (const n of t.labels)
      r.addLabel("content", n, e);
  return Vu.ModerationDecision.merge(r, (0, bP.decideAccount)(t.author, e), (0, hP.decideProfile)(t.author, e));
}
La.decideNotification = EP;
var ka = {}, Po = {};
Object.defineProperty(Po, "__esModule", { value: !0 });
Po.hasMutedWord = void 0;
const xP = l, Iu = {
  LEADING_TRAILING_PUNCTUATION: /(?:^\p{P}+|\p{P}+$)/gu,
  ESCAPE: /[[\]{}()*+?.\\^$|\s]/g,
  SEPARATORS: /[/\-()[\]_]+/g,
  WORD_BOUNDARY: /[\s\n\t\r\f\v]+?/g
}, gP = [
  "ja",
  // Japanese
  "zh",
  // Chinese
  "ko",
  // Korean
  "th",
  // Thai
  "vi"
  // Vietnamese
];
function RP({ mutedWords: t, text: e, facets: r, outlineTags: n, languages: s, actor: u }) {
  const c = gP.includes(s?.[0] || ""), a = [].concat(n || []).concat((r || []).flatMap((y) => y.features.filter(xP.AppBskyRichtextFacet.isTag).map((d) => d.tag))).map((y) => y.toLowerCase());
  for (const y of t) {
    const d = y.value.toLowerCase(), b = e.toLowerCase();
    if (y.expiresAt && y.expiresAt < (/* @__PURE__ */ new Date()).toISOString() || y.actorTarget === "exclude-following" && u?.viewer?.following)
      continue;
    if (a.includes(d))
      return !0;
    if (!y.targets.includes("content"))
      continue;
    if ((d.length === 1 || c) && b.includes(d))
      return !0;
    if (d.length > b.length)
      continue;
    if (d === b || /(?:\s|\p{P})+?/u.test(d) && b.includes(d))
      return !0;
    const g = b.split(Iu.WORD_BOUNDARY);
    for (const R of g) {
      if (R === d)
        return !0;
      const C = R.replace(Iu.LEADING_TRAILING_PUNCTUATION, "");
      if (d === C)
        return !0;
      if (!(d.length > C.length) && /\p{P}+/u.test(C)) {
        const D = C.replace(/\p{P}+/gu, " ");
        if (D === d || D.replace(/\s/gu, "") === d)
          return !0;
        const K = C.split(/\p{P}+/u);
        for (const A of K)
          if (A === d)
            return !0;
      }
    }
  }
  return !1;
}
Po.hasMutedWord = RP;
Object.defineProperty(ka, "__esModule", { value: !0 });
ka.decidePost = void 0;
const dn = dt, re = l, ht = Po, Zf = Kt, Hf = Ut;
function vP(t, e) {
  const r = new dn.ModerationDecision();
  if (r.setDid(t.author.did), r.setIsMe(t.author.did === e.userDid), t.labels?.length)
    for (const s of t.labels)
      r.addLabel("content", s, e);
  r.addHidden(AP(t, e.prefs.hiddenPosts)), r.isMe || r.addMutedWord(wP(t, e.prefs.mutedWords));
  let n;
  return t.embed && (re.AppBskyEmbedRecord.isViewRecord(t.embed.record) ? n = ju(t.embed.record, e) : re.AppBskyEmbedRecordWithMedia.isView(t.embed) && re.AppBskyEmbedRecord.isViewRecord(t.embed.record.record) ? n = ju(t.embed.record.record, e) : re.AppBskyEmbedRecord.isViewBlocked(t.embed.record) ? n = Ou(t.embed.record, e) : re.AppBskyEmbedRecordWithMedia.isView(t.embed) && re.AppBskyEmbedRecord.isViewBlocked(t.embed.record.record) && (n = Ou(t.embed.record.record, e))), dn.ModerationDecision.merge(r, n?.downgrade(), (0, Zf.decideAccount)(t.author, e), (0, Hf.decideProfile)(t.author, e));
}
ka.decidePost = vP;
function ju(t, e) {
  const r = new dn.ModerationDecision();
  if (r.setDid(t.author.did), r.setIsMe(t.author.did === e.userDid), t.labels?.length)
    for (const n of t.labels)
      r.addLabel("content", n, e);
  return dn.ModerationDecision.merge(r, (0, Zf.decideAccount)(t.author, e), (0, Hf.decideProfile)(t.author, e));
}
function Ou(t, e) {
  const r = new dn.ModerationDecision();
  return r.setDid(t.author.did), r.setIsMe(t.author.did === e.userDid), t.author.viewer?.muted && (t.author.viewer?.mutedByList ? r.addMutedByList(t.author.viewer?.mutedByList) : r.addMuted(t.author.viewer?.muted)), t.author.viewer?.blocking && (t.author.viewer?.blockingByList ? r.addBlockingByList(t.author.viewer?.blockingByList) : r.addBlocking(t.author.viewer?.blocking)), r.addBlockedBy(t.author.viewer?.blockedBy), r;
}
function AP(t, e) {
  return e?.length ? !!(e.includes(t.uri) || t.embed && (re.AppBskyEmbedRecord.isViewRecord(t.embed.record) && e.includes(t.embed.record.uri) || re.AppBskyEmbedRecordWithMedia.isView(t.embed) && re.AppBskyEmbedRecord.isViewRecord(t.embed.record.record) && e.includes(t.embed.record.record.uri))) : !1;
}
function wP(t, e) {
  if (!e?.length)
    return !1;
  const r = t.author;
  if (re.AppBskyFeedPost.isRecord(t.record)) {
    if ((0, ht.hasMutedWord)({
      mutedWords: e,
      text: t.record.text,
      facets: t.record.facets,
      outlineTags: t.record.tags,
      languages: t.record.langs,
      actor: r
    }))
      return !0;
    if (t.record.embed && re.AppBskyEmbedImages.isMain(t.record.embed)) {
      for (const n of t.record.embed.images)
        if ((0, ht.hasMutedWord)({
          mutedWords: e,
          text: n.alt,
          languages: t.record.langs,
          actor: r
        }))
          return !0;
    }
  }
  if (t.embed) {
    if (re.AppBskyEmbedRecord.isViewRecord(t.embed.record)) {
      if (re.AppBskyFeedPost.isRecord(t.embed.record.value)) {
        const n = t.embed.record.value, s = t.embed.record.author;
        if ((0, ht.hasMutedWord)({
          mutedWords: e,
          text: n.text,
          facets: n.facets,
          outlineTags: n.tags,
          languages: n.langs,
          actor: s
        }))
          return !0;
        if (re.AppBskyEmbedImages.isMain(n.embed)) {
          for (const u of n.embed.images)
            if ((0, ht.hasMutedWord)({
              mutedWords: e,
              text: u.alt,
              languages: n.langs,
              actor: s
            }))
              return !0;
        }
        if (re.AppBskyEmbedExternal.isMain(n.embed)) {
          const { external: u } = n.embed;
          if ((0, ht.hasMutedWord)({
            mutedWords: e,
            text: u.title + " " + u.description,
            languages: [],
            actor: s
          }))
            return !0;
        }
        if (re.AppBskyEmbedRecordWithMedia.isMain(n.embed)) {
          if (re.AppBskyEmbedExternal.isMain(n.embed.media)) {
            const { external: u } = n.embed.media;
            if ((0, ht.hasMutedWord)({
              mutedWords: e,
              text: u.title + " " + u.description,
              languages: [],
              actor: s
            }))
              return !0;
          }
          if (re.AppBskyEmbedImages.isMain(n.embed.media)) {
            for (const u of n.embed.media.images)
              if ((0, ht.hasMutedWord)({
                mutedWords: e,
                text: u.alt,
                languages: re.AppBskyFeedPost.isRecord(n.record) ? n.langs : [],
                actor: s
              }))
                return !0;
          }
        }
      }
    } else if (re.AppBskyEmbedExternal.isView(t.embed)) {
      const { external: n } = t.embed;
      if ((0, ht.hasMutedWord)({
        mutedWords: e,
        text: n.title + " " + n.description,
        languages: [],
        actor: r
      }))
        return !0;
    } else if (re.AppBskyEmbedRecordWithMedia.isView(t.embed) && re.AppBskyEmbedRecord.isViewRecord(t.embed.record.record)) {
      const n = t.embed.record.record.author;
      if (re.AppBskyFeedPost.isRecord(t.embed.record.record.value)) {
        const s = t.embed.record.record.value;
        if ((0, ht.hasMutedWord)({
          mutedWords: e,
          text: s.text,
          facets: s.facets,
          outlineTags: s.tags,
          languages: s.langs,
          actor: n
        }))
          return !0;
      }
      if (re.AppBskyEmbedImages.isView(t.embed.media)) {
        for (const s of t.embed.media.images)
          if ((0, ht.hasMutedWord)({
            mutedWords: e,
            text: s.alt,
            languages: re.AppBskyFeedPost.isRecord(t.record) ? t.record.langs : [],
            actor: n
          }))
            return !0;
      }
    }
  }
  return !1;
}
var Ba = {};
Object.defineProperty(Ba, "__esModule", { value: !0 });
Ba.decideFeedGenerator = void 0;
const Mu = dt, CP = Kt, _P = Ut;
function TP(t, e) {
  const r = new Mu.ModerationDecision();
  if (r.setDid(t.creator.did), r.setIsMe(t.creator.did === e.userDid), t.labels?.length)
    for (const n of t.labels)
      r.addLabel("content", n, e);
  return Mu.ModerationDecision.merge(r, (0, CP.decideAccount)(t.creator, e), (0, _P.decideProfile)(t.creator, e));
}
Ba.decideFeedGenerator = TP;
var Pa = {};
Object.defineProperty(Pa, "__esModule", { value: !0 });
Pa.decideUserList = void 0;
const SP = oi, Nu = dt, LP = Kt, kP = Ut;
function BP(t, e) {
  const r = new Nu.ModerationDecision(), n = PP(t.creator) ? t.creator : void 0;
  if (n) {
    if (r.setDid(n.did), r.setIsMe(n.did === e.userDid), t.labels?.length)
      for (const u of t.labels)
        r.addLabel("content", u, e);
    return Nu.ModerationDecision.merge(r, (0, LP.decideAccount)(n, e), (0, kP.decideProfile)(n, e));
  }
  const s = new SP.AtUri(t.uri).hostname;
  if (r.setDid(s), r.setIsMe(s === e.userDid), t.labels?.length)
    for (const u of t.labels)
      r.addLabel("content", u, e);
  return r;
}
Pa.decideUserList = BP;
function PP(t) {
  return t && typeof t == "object" && "did" in t;
}
var _t = {};
Object.defineProperty(_t, "__esModule", { value: !0 });
_t.interpretLabelValueDefinitions = _t.interpretLabelValueDefinition = _t.isQuotedPostWithMedia = _t.isQuotedPost = void 0;
const Bl = l;
function DP(t) {
  return !!(t && Bl.AppBskyEmbedRecord.isView(t));
}
_t.isQuotedPost = DP;
function KP(t) {
  return !!(t && Bl.AppBskyEmbedRecordWithMedia.isView(t));
}
_t.isQuotedPostWithMedia = KP;
function Wf(t, e) {
  const r = {
    account: {},
    profile: {},
    content: {}
  }, n = t.severity === "alert" ? "alert" : t.severity === "inform" ? "inform" : void 0;
  t.blurs === "content" ? (r.account.profileList = n, r.account.profileView = n, r.account.contentList = "blur", r.account.contentView = t.adultOnly ? "blur" : n, r.profile.profileList = n, r.profile.profileView = n, r.content.contentList = "blur", r.content.contentView = t.adultOnly ? "blur" : n) : t.blurs === "media" ? (r.account.profileList = n, r.account.profileView = n, r.account.avatar = "blur", r.account.banner = "blur", r.profile.profileList = n, r.profile.profileView = n, r.profile.avatar = "blur", r.profile.banner = "blur", r.content.contentMedia = "blur") : t.blurs === "none" && (r.account.profileList = n, r.account.profileView = n, r.account.contentList = n, r.account.contentView = n, r.profile.profileList = n, r.profile.profileView = n, r.content.contentList = n, r.content.contentView = n);
  let s = "warn";
  (t.defaultSetting === "hide" || t.defaultSetting === "ignore") && (s = t.defaultSetting);
  const u = ["no-self"];
  return t.adultOnly && u.push("adult"), {
    ...t,
    definedBy: e,
    configurable: !0,
    defaultSetting: s,
    flags: u,
    behaviors: r
  };
}
_t.interpretLabelValueDefinition = Wf;
function UP(t) {
  return (t.policies?.labelValueDefinitions || []).filter((e) => Bl.ComAtprotoLabelDefs.validateLabelValueDefinition(e).success).map((e) => Wf(e, t.creator.did));
}
_t.interpretLabelValueDefinitions = UP;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.moderateUserList = t.moderateFeedGenerator = t.moderateNotification = t.moderatePost = t.moderateProfile = t.interpretLabelValueDefinitions = t.interpretLabelValueDefinition = t.hasMutedWord = t.ModerationDecision = t.ModerationUI = void 0;
  const e = Kt, r = Ut, n = La, s = ka, u = Ba, c = Pa, a = dt;
  var y = Bo;
  Object.defineProperty(t, "ModerationUI", { enumerable: !0, get: function() {
    return y.ModerationUI;
  } });
  var d = dt;
  Object.defineProperty(t, "ModerationDecision", { enumerable: !0, get: function() {
    return d.ModerationDecision;
  } });
  var b = Po;
  Object.defineProperty(t, "hasMutedWord", { enumerable: !0, get: function() {
    return b.hasMutedWord;
  } });
  var g = _t;
  Object.defineProperty(t, "interpretLabelValueDefinition", { enumerable: !0, get: function() {
    return g.interpretLabelValueDefinition;
  } }), Object.defineProperty(t, "interpretLabelValueDefinitions", { enumerable: !0, get: function() {
    return g.interpretLabelValueDefinitions;
  } });
  function R(A, T) {
    return a.ModerationDecision.merge((0, e.decideAccount)(A, T), (0, r.decideProfile)(A, T));
  }
  t.moderateProfile = R;
  function C(A, T) {
    return (0, s.decidePost)(A, T);
  }
  t.moderatePost = C;
  function D(A, T) {
    return (0, n.decideNotification)(A, T);
  }
  t.moderateNotification = D;
  function U(A, T) {
    return (0, u.decideFeedGenerator)(A, T);
  }
  t.moderateFeedGenerator = U;
  function K(A, T) {
    return (0, c.decideUserList)(A, T);
  }
  t.moderateUserList = K;
})(Ll);
var Da = {};
Object.defineProperty(Da, "__esModule", { value: !0 });
Da.mock = void 0;
const an = "bafyreiclp443lavogvhj3d2ob2cxbfuscni2k5jk7bebjzg7khl3esabwq";
Da.mock = {
  post({ text: t, facets: e, reply: r, embed: n }) {
    return {
      $type: "app.bsky.feed.post",
      text: t,
      facets: e,
      reply: r,
      embed: n,
      langs: ["en"],
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  },
  postView({ record: t, author: e, embed: r, replyCount: n, repostCount: s, likeCount: u, viewer: c, labels: a }) {
    return {
      $type: "app.bsky.feed.defs#postView",
      uri: `at://${e.did}/app.bsky.feed.post/fake`,
      cid: an,
      author: e,
      record: t,
      embed: r,
      replyCount: n,
      repostCount: s,
      likeCount: u,
      indexedAt: (/* @__PURE__ */ new Date()).toISOString(),
      viewer: c,
      labels: a
    };
  },
  embedRecordView({ record: t, author: e, labels: r }) {
    return {
      $type: "app.bsky.embed.record#view",
      record: {
        $type: "app.bsky.embed.record#viewRecord",
        uri: `at://${e.did}/app.bsky.feed.post/fake`,
        cid: an,
        author: e,
        value: t,
        labels: r,
        indexedAt: (/* @__PURE__ */ new Date()).toISOString()
      }
    };
  },
  profileViewBasic({ handle: t, displayName: e, description: r, viewer: n, labels: s }) {
    return {
      did: `did:web:${t}`,
      handle: t,
      displayName: e,
      description: r,
      // technically not in ProfileViewBasic but useful in some cases
      viewer: n,
      labels: s
    };
  },
  actorViewerState({ muted: t, mutedByList: e, blockedBy: r, blocking: n, blockingByList: s, following: u, followedBy: c }) {
    return {
      muted: t,
      mutedByList: e,
      blockedBy: r,
      blocking: n,
      blockingByList: s,
      following: u,
      followedBy: c
    };
  },
  listViewBasic({ name: t }) {
    return {
      uri: "at://did:plc:fake/app.bsky.graph.list/fake",
      cid: an,
      name: t,
      purpose: "app.bsky.graph.defs#modlist",
      indexedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  },
  replyNotification({ author: t, record: e, labels: r }) {
    return {
      uri: `at://${t.did}/app.bsky.feed.post/fake`,
      cid: an,
      author: t,
      reason: "reply",
      reasonSubject: `at://${t.did}/app.bsky.feed.post/fake-parent`,
      record: e,
      isRead: !1,
      indexedAt: (/* @__PURE__ */ new Date()).toISOString(),
      labels: r
    };
  },
  followNotification({ author: t, subjectDid: e, labels: r }) {
    return {
      uri: `at://${t.did}/app.bsky.graph.follow/fake`,
      cid: an,
      author: t,
      reason: "follow",
      record: {
        $type: "app.bsky.graph.follow",
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        subject: e
      },
      isRead: !1,
      indexedAt: (/* @__PURE__ */ new Date()).toISOString(),
      labels: r
    };
  },
  label({ val: t, uri: e, src: r }) {
    return {
      src: r || "did:plc:fake-labeler",
      uri: e,
      val: t,
      cts: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
};
var Ka = {}, Pl = {}, Et = S && S.__classPrivateFieldGet || function(t, e, r, n) {
  if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
}, Xa = S && S.__classPrivateFieldSet || function(t, e, r, n, s) {
  if (n === "m") throw new TypeError("Private method is not writable");
  if (n === "a" && !s) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !s : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return n === "a" ? s.call(t, r) : s ? s.value = r : e.set(t, r), r;
}, Nt, yr;
Object.defineProperty(Pl, "__esModule", { value: !0 });
class VP {
  constructor() {
    Nt.set(this, !1), yr.set(this, /* @__PURE__ */ new Set());
  }
  /**
   * Whether the lock is currently acquired or not. Accessing this property does not affect the
   * status of the lock.
   */
  get acquired() {
    return Et(this, Nt, "f");
  }
  /**
   * Acquires the lock, waiting if necessary for it to become free if it is already locked. The
   * returned promise is fulfilled once the lock is acquired.
   *
   * A timeout (in milliseconds) may be optionally provided. If the lock cannot be acquired before
   * the timeout elapses, the returned promise is rejected with an error. The behavior of invalid
   * timeout values depends on how `setTimeout` handles those values.
   *
   * After acquiring the lock, you **must** call `release` when you are done with it.
   */
  acquireAsync({ timeout: e } = {}) {
    if (!Et(this, Nt, "f"))
      return Xa(this, Nt, !0, "f"), Promise.resolve();
    if (e == null)
      return new Promise((s) => {
        Et(this, yr, "f").add(s);
      });
    let r, n;
    return Promise.race([
      new Promise((s) => {
        r = () => {
          clearTimeout(n), s();
        }, Et(this, yr, "f").add(r);
      }),
      new Promise((s, u) => {
        n = setTimeout(() => {
          Et(this, yr, "f").delete(r), u(new Error("Timed out waiting for lock"));
        }, e);
      })
    ]);
  }
  /**
   * Acquires the lock if it is free and otherwise returns immediately without waiting. Returns
   * `true` if the lock was free and is now acquired, and `false` otherwise.
   *
   * This method differs from calling `acquireAsync` with a zero-millisecond timeout in that it runs
   * synchronously without waiting for the JavaScript task queue.
   */
  tryAcquire() {
    return Et(this, Nt, "f") ? !1 : (Xa(this, Nt, !0, "f"), !0);
  }
  /**
   * Releases the lock and gives it to the next waiting acquirer, if there is one. Each acquirer
   * must release the lock exactly once.
   */
  release() {
    if (!Et(this, Nt, "f"))
      throw new Error("Cannot release an unacquired lock");
    if (Et(this, yr, "f").size > 0) {
      const [e] = Et(this, yr, "f");
      Et(this, yr, "f").delete(e), e();
    } else
      Xa(this, Nt, !1, "f");
  }
}
Pl.default = VP;
Nt = /* @__PURE__ */ new WeakMap(), yr = /* @__PURE__ */ new WeakMap();
var IP = S && S.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(Ka, "__esModule", { value: !0 });
Ka.BskyAgent = void 0;
const yi = oi, mr = Vt, jP = IP(Pl), OP = Vi, B = l, MP = Cr, br = at, NP = Ll, $u = {
  hideReplies: !1,
  hideRepliesByUnfollowed: !0,
  hideRepliesByLikeCount: 0,
  hideReposts: !1,
  hideQuotePosts: !1
}, $P = {
  sort: "oldest",
  prioritizeFollowedUsers: !0
};
class bi extends OP.AtpAgent {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_prefsLock", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new jP.default()
    }), Object.defineProperty(this, "getTimeline", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getTimeline(e, r)
    }), Object.defineProperty(this, "getAuthorFeed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getAuthorFeed(e, r)
    }), Object.defineProperty(this, "getActorLikes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getActorLikes(e, r)
    }), Object.defineProperty(this, "getPostThread", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getPostThread(e, r)
    }), Object.defineProperty(this, "getPost", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e) => this.api.app.bsky.feed.post.get(e)
    }), Object.defineProperty(this, "getPosts", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getPosts(e, r)
    }), Object.defineProperty(this, "getLikes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getLikes(e, r)
    }), Object.defineProperty(this, "getRepostedBy", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getRepostedBy(e, r)
    }), Object.defineProperty(this, "getFollows", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.graph.getFollows(e, r)
    }), Object.defineProperty(this, "getFollowers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.graph.getFollowers(e, r)
    }), Object.defineProperty(this, "getProfile", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.actor.getProfile(e, r)
    }), Object.defineProperty(this, "getProfiles", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.actor.getProfiles(e, r)
    }), Object.defineProperty(this, "getSuggestions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.actor.getSuggestions(e, r)
    }), Object.defineProperty(this, "searchActors", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.actor.searchActors(e, r)
    }), Object.defineProperty(this, "searchActorsTypeahead", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.actor.searchActorsTypeahead(e, r)
    }), Object.defineProperty(this, "listNotifications", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.notification.listNotifications(e, r)
    }), Object.defineProperty(this, "countUnreadNotifications", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.notification.getUnreadCount(e, r)
    }), Object.defineProperty(this, "getLabelers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.labeler.getServices(e, r)
    });
  }
  clone() {
    const e = new bi({
      service: this.service
    });
    return this.copyInto(e), e;
  }
  get app() {
    return this.api.app;
  }
  async getLabelDefinitions(e) {
    let r = bi.appLabelers;
    FP(e) ? r = r.concat(e.moderationPrefs.labelers.map((u) => u.did)) : Jf(e) ? r = r.concat(e.labelers.map((u) => u.did)) : r = r.concat(e);
    const n = await this.getLabelers({
      dids: r,
      detailed: !0
    }), s = {};
    if (n.data)
      for (const u of n.data.views)
        s[u.creator.did] = (0, NP.interpretLabelValueDefinitions)(u);
    return s;
  }
  async post(e) {
    if (!this.session)
      throw new Error("Not logged in");
    return e.createdAt = e.createdAt || (/* @__PURE__ */ new Date()).toISOString(), this.api.app.bsky.feed.post.create({ repo: this.session.did }, e);
  }
  async deletePost(e) {
    if (!this.session)
      throw new Error("Not logged in");
    const r = new yi.AtUri(e);
    return await this.api.app.bsky.feed.post.delete({
      repo: r.hostname,
      rkey: r.rkey
    });
  }
  async like(e, r) {
    if (!this.session)
      throw new Error("Not logged in");
    return await this.api.app.bsky.feed.like.create({ repo: this.session.did }, {
      subject: { uri: e, cid: r },
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  async deleteLike(e) {
    if (!this.session)
      throw new Error("Not logged in");
    const r = new yi.AtUri(e);
    return await this.api.app.bsky.feed.like.delete({
      repo: r.hostname,
      rkey: r.rkey
    });
  }
  async repost(e, r) {
    if (!this.session)
      throw new Error("Not logged in");
    return await this.api.app.bsky.feed.repost.create({ repo: this.session.did }, {
      subject: { uri: e, cid: r },
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  async deleteRepost(e) {
    if (!this.session)
      throw new Error("Not logged in");
    const r = new yi.AtUri(e);
    return await this.api.app.bsky.feed.repost.delete({
      repo: r.hostname,
      rkey: r.rkey
    });
  }
  async follow(e) {
    if (!this.session)
      throw new Error("Not logged in");
    return await this.api.app.bsky.graph.follow.create({ repo: this.session.did }, {
      subject: e,
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  async deleteFollow(e) {
    if (!this.session)
      throw new Error("Not logged in");
    const r = new yi.AtUri(e);
    return await this.api.app.bsky.graph.follow.delete({
      repo: r.hostname,
      rkey: r.rkey
    });
  }
  async upsertProfile(e) {
    if (!this.session)
      throw new Error("Not logged in");
    let r = 5;
    for (; r >= 0; ) {
      const n = await this.com.atproto.repo.getRecord({
        repo: this.session.did,
        collection: "app.bsky.actor.profile",
        rkey: "self"
      }).catch((c) => {
      }), s = await e(n?.data.value);
      s && (s.$type = "app.bsky.actor.profile");
      const u = B.AppBskyActorProfile.validateRecord(s);
      if (!u.success)
        throw u.error;
      try {
        await this.com.atproto.repo.putRecord({
          repo: this.session.did,
          collection: "app.bsky.actor.profile",
          rkey: "self",
          record: s,
          swapRecord: n?.data.cid || null
        });
      } catch (c) {
        if (r > 0 && c instanceof B.ComAtprotoRepoPutRecord.InvalidSwapError) {
          r--;
          continue;
        } else
          throw c;
      }
      break;
    }
  }
  async mute(e) {
    return this.api.app.bsky.graph.muteActor({ actor: e });
  }
  async unmute(e) {
    return this.api.app.bsky.graph.unmuteActor({ actor: e });
  }
  async muteModList(e) {
    return this.api.app.bsky.graph.muteActorList({
      list: e
    });
  }
  async unmuteModList(e) {
    return this.api.app.bsky.graph.unmuteActorList({
      list: e
    });
  }
  async blockModList(e) {
    if (!this.session)
      throw new Error("Not logged in");
    return await this.api.app.bsky.graph.listblock.create({ repo: this.session.did }, {
      subject: e,
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  async unblockModList(e) {
    if (!this.session)
      throw new Error("Not logged in");
    const r = await this.api.app.bsky.graph.getList({
      list: e,
      limit: 1
    });
    if (!r.data.list.viewer?.blocked)
      return;
    const { rkey: n } = new yi.AtUri(r.data.list.viewer.blocked);
    return await this.api.app.bsky.graph.listblock.delete({
      repo: this.session.did,
      rkey: n
    });
  }
  async updateSeenNotifications(e) {
    return e = e || (/* @__PURE__ */ new Date()).toISOString(), this.api.app.bsky.notification.updateSeen({
      seenAt: e
    });
  }
  async getPreferences() {
    const e = {
      feeds: {
        saved: void 0,
        pinned: void 0
      },
      // @ts-ignore populating below
      savedFeeds: void 0,
      feedViewPrefs: {
        home: {
          ...$u
        }
      },
      threadViewPrefs: { ...$P },
      moderationPrefs: {
        adultContentEnabled: !1,
        labels: { ...MP.DEFAULT_LABEL_SETTINGS },
        labelers: bi.appLabelers.map((s) => ({ did: s, labels: {} })),
        mutedWords: [],
        hiddenPosts: []
      },
      birthDate: void 0,
      interests: {
        tags: []
      },
      bskyAppState: {
        queuedNudges: [],
        activeProgressGuide: void 0
      }
    }, r = await this.app.bsky.actor.getPreferences({}), n = [];
    for (const s of r.data.preferences)
      if (B.AppBskyActorDefs.isAdultContentPref(s) && B.AppBskyActorDefs.validateAdultContentPref(s).success)
        e.moderationPrefs.adultContentEnabled = s.enabled;
      else if (B.AppBskyActorDefs.isContentLabelPref(s) && B.AppBskyActorDefs.validateContentLabelPref(s).success) {
        const u = GP(s);
        n.push(u);
      } else if (B.AppBskyActorDefs.isLabelersPref(s) && B.AppBskyActorDefs.validateLabelersPref(s).success)
        e.moderationPrefs.labelers = bi.appLabelers.map((u) => ({ did: u, labels: {} })).concat(s.labelers.map((u) => ({
          ...u,
          labels: {}
        })));
      else if (B.AppBskyActorDefs.isSavedFeedsPrefV2(s) && B.AppBskyActorDefs.validateSavedFeedsPrefV2(s).success)
        e.savedFeeds = s.items;
      else if (B.AppBskyActorDefs.isSavedFeedsPref(s) && B.AppBskyActorDefs.validateSavedFeedsPref(s).success)
        e.feeds.saved = s.saved, e.feeds.pinned = s.pinned;
      else if (B.AppBskyActorDefs.isPersonalDetailsPref(s) && B.AppBskyActorDefs.validatePersonalDetailsPref(s).success)
        s.birthDate && (e.birthDate = new Date(s.birthDate));
      else if (B.AppBskyActorDefs.isFeedViewPref(s) && B.AppBskyActorDefs.validateFeedViewPref(s).success) {
        const { $type: u, feed: c, ...a } = s;
        e.feedViewPrefs[s.feed] = { ...$u, ...a };
      } else if (B.AppBskyActorDefs.isThreadViewPref(s) && B.AppBskyActorDefs.validateThreadViewPref(s).success) {
        const { $type: u, ...c } = s;
        e.threadViewPrefs = { ...e.threadViewPrefs, ...c };
      } else if (B.AppBskyActorDefs.isInterestsPref(s) && B.AppBskyActorDefs.validateInterestsPref(s).success) {
        const { $type: u, ...c } = s;
        e.interests = { ...e.interests, ...c };
      } else if (B.AppBskyActorDefs.isMutedWordsPref(s) && B.AppBskyActorDefs.validateMutedWordsPref(s).success) {
        const { $type: u, ...c } = s;
        e.moderationPrefs.mutedWords = c.items, e.moderationPrefs.mutedWords.length && (e.moderationPrefs.mutedWords = e.moderationPrefs.mutedWords.map((a) => (a.actorTarget = a.actorTarget || "all", a)));
      } else if (B.AppBskyActorDefs.isHiddenPostsPref(s) && B.AppBskyActorDefs.validateHiddenPostsPref(s).success) {
        const { $type: u, ...c } = s;
        e.moderationPrefs.hiddenPosts = c.items;
      } else if (B.AppBskyActorDefs.isBskyAppStatePref(s) && B.AppBskyActorDefs.validateBskyAppStatePref(s).success) {
        const { $type: u, ...c } = s;
        e.bskyAppState.queuedNudges = c.queuedNudges || [], e.bskyAppState.activeProgressGuide = c.activeProgressGuide;
      }
    if (e.savedFeeds === void 0) {
      const { saved: s, pinned: u } = e.feeds;
      if (s && u) {
        const c = /* @__PURE__ */ new Map();
        c.set("timeline", {
          id: mr.TID.nextStr(),
          type: "timeline",
          value: "following",
          pinned: !0
        });
        for (const a of u) {
          const y = (0, br.getSavedFeedType)(a);
          y !== "unknown" && c.set(a, {
            id: mr.TID.nextStr(),
            type: y,
            value: a,
            pinned: !0
          });
        }
        for (const a of s)
          if (!c.has(a)) {
            const y = (0, br.getSavedFeedType)(a);
            if (y === "unknown")
              continue;
            c.set(a, {
              id: mr.TID.nextStr(),
              type: y,
              value: a,
              pinned: !1
            });
          }
        e.savedFeeds = Array.from(c.values());
      } else
        e.savedFeeds = [
          {
            id: mr.TID.nextStr(),
            type: "timeline",
            value: "following",
            pinned: !0
          }
        ];
      await this.overwriteSavedFeeds(e.savedFeeds);
    }
    for (const s of n)
      if (s.labelerDid) {
        const u = e.moderationPrefs.labelers.find((c) => c.did === s.labelerDid);
        if (!u)
          continue;
        u.labels[s.label] = s.visibility;
      } else
        e.moderationPrefs.labels[s.label] = s.visibility;
    return e.moderationPrefs.labels = qP(e.moderationPrefs.labels), this.configureLabelersHeader(Za(r.data.preferences)), e;
  }
  async overwriteSavedFeeds(e) {
    e.forEach(br.validateSavedFeed);
    const r = /* @__PURE__ */ new Map();
    return e.forEach((n) => {
      r.has(n.id) && r.delete(n.id), r.set(n.id, n);
    }), Xo(this, () => Array.from(r.values()));
  }
  async updateSavedFeeds(e) {
    return e.map(br.validateSavedFeed), Xo(this, (r) => r.map((n) => {
      const s = e.find((u) => n.id === u.id);
      return s ? {
        ...n,
        // only update pinned
        pinned: s.pinned
      } : n;
    }));
  }
  async addSavedFeeds(e) {
    const r = e.map((n) => ({
      ...n,
      id: mr.TID.nextStr()
    }));
    return r.forEach(br.validateSavedFeed), Xo(this, (n) => [
      ...n,
      ...r
    ]);
  }
  async removeSavedFeeds(e) {
    return Xo(this, (r) => [
      ...r.filter((n) => !e.find((s) => n.id === s))
    ]);
  }
  /**
   * @deprecated use `overwriteSavedFeeds`
   */
  async setSavedFeeds(e, r) {
    return ln(this, () => ({
      saved: e,
      pinned: r
    }));
  }
  /**
   * @deprecated use `addSavedFeeds`
   */
  async addSavedFeed(e) {
    return ln(this, (r, n) => ({
      saved: [...r.filter((s) => s !== e), e],
      pinned: n
    }));
  }
  /**
   * @deprecated use `removeSavedFeeds`
   */
  async removeSavedFeed(e) {
    return ln(this, (r, n) => ({
      saved: r.filter((s) => s !== e),
      pinned: n.filter((s) => s !== e)
    }));
  }
  /**
   * @deprecated use `addSavedFeeds` or `updateSavedFeeds`
   */
  async addPinnedFeed(e) {
    return ln(this, (r, n) => ({
      saved: [...r.filter((s) => s !== e), e],
      pinned: [...n.filter((s) => s !== e), e]
    }));
  }
  /**
   * @deprecated use `updateSavedFeeds` or `removeSavedFeeds`
   */
  async removePinnedFeed(e) {
    return ln(this, (r, n) => ({
      saved: r,
      pinned: n.filter((s) => s !== e)
    }));
  }
  async setAdultContentEnabled(e) {
    await we(this, (r) => {
      let n = r.findLast((s) => B.AppBskyActorDefs.isAdultContentPref(s) && B.AppBskyActorDefs.validateAdultContentPref(s).success);
      return n ? n.enabled = e : n = {
        $type: "app.bsky.actor.defs#adultContentPref",
        enabled: e
      }, r.filter((s) => !B.AppBskyActorDefs.isAdultContentPref(s)).concat([n]);
    });
  }
  async setContentLabelPref(e, r, n) {
    n && (0, yi.ensureValidDid)(n), await we(this, (s) => {
      let u = s.findLast((a) => B.AppBskyActorDefs.isContentLabelPref(a) && B.AppBskyActorDefs.validateContentLabelPref(a).success && a.label === e && a.labelerDid === n), c;
      if (u ? u.visibility = r : u = {
        $type: "app.bsky.actor.defs#contentLabelPref",
        label: e,
        labelerDid: n,
        visibility: r
      }, B.AppBskyActorDefs.isContentLabelPref(u) && !u.labelerDid) {
        const a = {
          "graphic-media": "gore",
          porn: "nsfw",
          sexual: "suggestive"
        }[u.label];
        a && (c = s.findLast((y) => B.AppBskyActorDefs.isContentLabelPref(y) && B.AppBskyActorDefs.validateContentLabelPref(y).success && y.label === a && y.labelerDid === void 0), c ? c.visibility = r : c = {
          $type: "app.bsky.actor.defs#contentLabelPref",
          label: a,
          labelerDid: void 0,
          visibility: r
        });
      }
      return s.filter((a) => !B.AppBskyActorDefs.isContentLabelPref(a) || !(a.label === e && a.labelerDid === n)).concat([u]).filter((a) => c ? !B.AppBskyActorDefs.isContentLabelPref(a) || !(a.label === c.label && a.labelerDid === void 0) : !0).concat(c ? [c] : []);
    });
  }
  async addLabeler(e) {
    const r = await we(this, (n) => {
      let s = n.findLast((u) => B.AppBskyActorDefs.isLabelersPref(u) && B.AppBskyActorDefs.validateLabelersPref(u).success);
      if (s || (s = {
        $type: "app.bsky.actor.defs#labelersPref",
        labelers: []
      }), B.AppBskyActorDefs.isLabelersPref(s)) {
        let u = s.labelers.find((c) => c.did === e);
        u || (u = {
          did: e
        }, s.labelers.push(u));
      }
      return n.filter((u) => !B.AppBskyActorDefs.isLabelersPref(u)).concat([s]);
    });
    this.configureLabelersHeader(Za(r));
  }
  async removeLabeler(e) {
    const r = await we(this, (n) => {
      let s = n.findLast((u) => B.AppBskyActorDefs.isLabelersPref(u) && B.AppBskyActorDefs.validateLabelersPref(u).success);
      return s || (s = {
        $type: "app.bsky.actor.defs#labelersPref",
        labelers: []
      }), B.AppBskyActorDefs.isLabelersPref(s) && (s.labelers = s.labelers.filter((u) => u.did !== e)), n.filter((u) => !B.AppBskyActorDefs.isLabelersPref(u)).concat([s]);
    });
    this.configureLabelersHeader(Za(r));
  }
  async setPersonalDetails({ birthDate: e }) {
    e = e instanceof Date ? e.toISOString() : e, await we(this, (r) => {
      let n = r.findLast((s) => B.AppBskyActorDefs.isPersonalDetailsPref(s) && B.AppBskyActorDefs.validatePersonalDetailsPref(s).success);
      return n ? n.birthDate = e : n = {
        $type: "app.bsky.actor.defs#personalDetailsPref",
        birthDate: e
      }, r.filter((s) => !B.AppBskyActorDefs.isPersonalDetailsPref(s)).concat([n]);
    });
  }
  async setFeedViewPrefs(e, r) {
    await we(this, (n) => {
      const s = n.findLast((u) => B.AppBskyActorDefs.isFeedViewPref(u) && B.AppBskyActorDefs.validateFeedViewPref(u).success && u.feed === e);
      return s && (r = { ...s, ...r }), n.filter((u) => !B.AppBskyActorDefs.isFeedViewPref(r) || u.feed !== e).concat([{ ...r, $type: "app.bsky.actor.defs#feedViewPref", feed: e }]);
    });
  }
  async setThreadViewPrefs(e) {
    await we(this, (r) => {
      const n = r.findLast((s) => B.AppBskyActorDefs.isThreadViewPref(s) && B.AppBskyActorDefs.validateThreadViewPref(s).success);
      return n && (e = { ...n, ...e }), r.filter((s) => !B.AppBskyActorDefs.isThreadViewPref(s)).concat([{ ...e, $type: "app.bsky.actor.defs#threadViewPref" }]);
    });
  }
  async setInterestsPref(e) {
    await we(this, (r) => {
      const n = r.findLast((s) => B.AppBskyActorDefs.isInterestsPref(s) && B.AppBskyActorDefs.validateInterestsPref(s).success);
      return n && (e = { ...n, ...e }), r.filter((s) => !B.AppBskyActorDefs.isInterestsPref(s)).concat([{ ...e, $type: "app.bsky.actor.defs#interestsPref" }]);
    });
  }
  /**
   * Add a muted word to user preferences.
   */
  async addMutedWord(e) {
    const r = (0, br.sanitizeMutedWordValue)(e.value);
    r && await we(this, (n) => {
      let s = n.findLast((c) => B.AppBskyActorDefs.isMutedWordsPref(c) && B.AppBskyActorDefs.validateMutedWordsPref(c).success);
      const u = {
        id: mr.TID.nextStr(),
        value: r,
        targets: e.targets || [],
        actorTarget: e.actorTarget || "all",
        expiresAt: e.expiresAt || void 0
      };
      return s && B.AppBskyActorDefs.isMutedWordsPref(s) ? (s.items.push(u), s.items = Ha(s.items)) : s = {
        items: [u]
      }, n.filter((c) => !B.AppBskyActorDefs.isMutedWordsPref(c)).concat([
        { ...s, $type: "app.bsky.actor.defs#mutedWordsPref" }
      ]);
    });
  }
  /**
   * Convenience method to add muted words to user preferences
   */
  async addMutedWords(e) {
    await Promise.all(e.map((r) => this.addMutedWord(r)));
  }
  /**
   * @deprecated use `addMutedWords` or `addMutedWord` instead
   */
  async upsertMutedWords(e) {
    await this.addMutedWords(e);
  }
  /**
   * Update a muted word in user preferences.
   */
  async updateMutedWord(e) {
    await we(this, (r) => {
      const n = r.findLast((s) => B.AppBskyActorDefs.isMutedWordsPref(s) && B.AppBskyActorDefs.validateMutedWordsPref(s).success);
      return n && B.AppBskyActorDefs.isMutedWordsPref(n) ? (n.items = n.items.map((s) => {
        if (qu(s, e)) {
          const c = {
            ...s,
            ...e
          };
          return {
            id: s.id || mr.TID.nextStr(),
            value: (0, br.sanitizeMutedWordValue)(c.value) || s.value,
            targets: c.targets || [],
            actorTarget: c.actorTarget || "all",
            expiresAt: c.expiresAt || void 0
          };
        } else
          return s;
      }), n.items = Ha(n.items), r.filter((s) => !B.AppBskyActorDefs.isMutedWordsPref(s)).concat([
        { ...n, $type: "app.bsky.actor.defs#mutedWordsPref" }
      ])) : r;
    });
  }
  /**
   * Remove a muted word from user preferences.
   */
  async removeMutedWord(e) {
    await we(this, (r) => {
      const n = r.findLast((s) => B.AppBskyActorDefs.isMutedWordsPref(s) && B.AppBskyActorDefs.validateMutedWordsPref(s).success);
      if (n && B.AppBskyActorDefs.isMutedWordsPref(n)) {
        for (let s = 0; s < n.items.length; s++)
          if (qu(n.items[s], e)) {
            n.items.splice(s, 1);
            break;
          }
        return n.items = Ha(n.items), r.filter((s) => !B.AppBskyActorDefs.isMutedWordsPref(s)).concat([
          { ...n, $type: "app.bsky.actor.defs#mutedWordsPref" }
        ]);
      }
      return r;
    });
  }
  /**
   * Convenience method to remove muted words from user preferences
   */
  async removeMutedWords(e) {
    await Promise.all(e.map((r) => this.removeMutedWord(r)));
  }
  async hidePost(e) {
    await Gu(this, e, "hide");
  }
  async unhidePost(e) {
    await Gu(this, e, "unhide");
  }
  async bskyAppQueueNudges(e) {
    await we(this, (r) => {
      let n = r.findLast((s) => B.AppBskyActorDefs.isBskyAppStatePref(s) && B.AppBskyActorDefs.validateBskyAppStatePref(s).success);
      return n = n || {}, e = Array.isArray(e) ? e : [e], n.queuedNudges = (n.queuedNudges || []).concat(e), r.filter((s) => !B.AppBskyActorDefs.isBskyAppStatePref(s)).concat([
        {
          ...n,
          $type: "app.bsky.actor.defs#bskyAppStatePref"
        }
      ]);
    });
  }
  async bskyAppDismissNudges(e) {
    await we(this, (r) => {
      let n = r.findLast((s) => B.AppBskyActorDefs.isBskyAppStatePref(s) && B.AppBskyActorDefs.validateBskyAppStatePref(s).success);
      return n = n || {}, e = Array.isArray(e) ? e : [e], n.queuedNudges = (n.queuedNudges || []).filter((s) => !e.includes(s)), r.filter((s) => !B.AppBskyActorDefs.isBskyAppStatePref(s)).concat([
        {
          ...n,
          $type: "app.bsky.actor.defs#bskyAppStatePref"
        }
      ]);
    });
  }
  async bskyAppSetActiveProgressGuide(e) {
    if (e && !B.AppBskyActorDefs.validateBskyAppProgressGuide(e).success)
      throw new Error("Invalid progress guide");
    await we(this, (r) => {
      let n = r.findLast((s) => B.AppBskyActorDefs.isBskyAppStatePref(s) && B.AppBskyActorDefs.validateBskyAppStatePref(s).success);
      return n = n || {}, n.activeProgressGuide = e, r.filter((s) => !B.AppBskyActorDefs.isBskyAppStatePref(s)).concat([
        {
          ...n,
          $type: "app.bsky.actor.defs#bskyAppStatePref"
        }
      ]);
    });
  }
}
Ka.BskyAgent = bi;
async function we(t, e) {
  try {
    await t._prefsLock.acquireAsync();
    const r = await t.app.bsky.actor.getPreferences({}), n = e(r.data.preferences);
    return n === !1 ? r.data.preferences : (await t.app.bsky.actor.putPreferences({
      preferences: n
    }), n);
  } finally {
    t._prefsLock.release();
  }
}
async function ln(t, e) {
  let r;
  return await we(t, (n) => {
    let s = n.findLast((u) => B.AppBskyActorDefs.isSavedFeedsPref(u) && B.AppBskyActorDefs.validateSavedFeedsPref(u).success);
    return s ? (r = e(s.saved, s.pinned), s.saved = r.saved, s.pinned = r.pinned) : (r = e([], []), s = {
      $type: "app.bsky.actor.defs#savedFeedsPref",
      saved: r.saved,
      pinned: r.pinned
    }), n.filter((u) => !B.AppBskyActorDefs.isSavedFeedsPref(u)).concat([s]);
  }), r;
}
async function Xo(t, e) {
  let r = [];
  return await we(t, (n) => {
    let s = n.findLast((d) => B.AppBskyActorDefs.isSavedFeedsPrefV2(d) && B.AppBskyActorDefs.validateSavedFeedsPrefV2(d).success), u = n.findLast((d) => B.AppBskyActorDefs.isSavedFeedsPref(d) && B.AppBskyActorDefs.validateSavedFeedsPref(d).success);
    s ? (r = e(s.items), s = {
      ...s,
      items: r
    }) : (r = e([]), s = {
      $type: "app.bsky.actor.defs#savedFeedsPrefV2",
      items: r
    });
    const c = s.items.filter((d) => d.pinned), a = s.items.filter((d) => !d.pinned);
    s.items = c.concat(a);
    let y = n.filter((d) => !B.AppBskyActorDefs.isSavedFeedsPrefV2(d)).concat(s);
    if (u) {
      const { saved: d, pinned: b } = u, g = (0, br.savedFeedsToUriArrays)(
        // v1 only supports feeds and lists
        s.items.filter((R) => ["feed", "list"].includes(R.type))
      );
      u = {
        ...u,
        saved: Array.from(/* @__PURE__ */ new Set([...d, ...g.saved])),
        pinned: Array.from(/* @__PURE__ */ new Set([...b, ...g.pinned]))
      }, y = y.filter((R) => !B.AppBskyActorDefs.isSavedFeedsPref(R)).concat(u);
    }
    return y;
  }), r;
}
function GP(t) {
  let e = t.visibility;
  return e === "show" && (e = "ignore"), { ...t, visibility: e };
}
function qP(t) {
  const e = { ...t }, r = {
    gore: "graphic-media",
    nsfw: "porn",
    suggestive: "sexual"
  };
  for (const n in e) {
    const s = r[n];
    s && (e[s] = e[n]);
  }
  return e;
}
function Za(t) {
  const e = t.findLast((n) => B.AppBskyActorDefs.isLabelersPref(n) && B.AppBskyActorDefs.validateLabelersPref(n).success);
  let r = [];
  return e && (r = e.labelers.map((n) => n.did)), r;
}
async function Gu(t, e, r) {
  await we(t, (n) => {
    let s = n.findLast((u) => B.AppBskyActorDefs.isHiddenPostsPref(u) && B.AppBskyActorDefs.validateHiddenPostsPref(u).success);
    return s && B.AppBskyActorDefs.isHiddenPostsPref(s) ? s.items = r === "hide" ? Array.from(/* @__PURE__ */ new Set([...s.items, e])) : s.items.filter((u) => u !== e) : r === "hide" && (s = {
      $type: "app.bsky.actor.defs#hiddenPostsPref",
      items: [e]
    }), n.filter((u) => !B.AppBskyActorDefs.isInterestsPref(u)).concat([{ ...s, $type: "app.bsky.actor.defs#hiddenPostsPref" }]);
  });
}
function FP(t) {
  return t && typeof t == "object" && "moderationPrefs" in t && Jf(t.moderationPrefs);
}
function Jf(t) {
  return t && typeof t == "object" && "labelers" in t;
}
function Ha(t) {
  return t.map((e) => ({
    ...e,
    id: e.id || mr.TID.nextStr()
  }));
}
function qu(t, e) {
  const r = t.id, n = r && r === e.id, s = !r && t.value === e.value;
  return n || s;
}
(function(t) {
  var e = S && S.__createBinding || (Object.create ? function(d, b, g, R) {
    R === void 0 && (R = g);
    var C = Object.getOwnPropertyDescriptor(b, g);
    (!C || ("get" in C ? !b.__esModule : C.writable || C.configurable)) && (C = { enumerable: !0, get: function() {
      return b[g];
    } }), Object.defineProperty(d, R, C);
  } : function(d, b, g, R) {
    R === void 0 && (R = g), d[R] = b[g];
  }), r = S && S.__exportStar || function(d, b) {
    for (var g in d) g !== "default" && !Object.prototype.hasOwnProperty.call(b, g) && e(b, d, g);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.default = t.BskyAgent = t.DEFAULT_LABEL_SETTINGS = t.LABELS = t.parseLanguage = t.jsonStringToLex = t.jsonToLex = t.stringifyLex = t.lexToJson = t.BlobRef = t.AtUri = void 0;
  var n = oi;
  Object.defineProperty(t, "AtUri", { enumerable: !0, get: function() {
    return n.AtUri;
  } });
  var s = mn;
  Object.defineProperty(t, "BlobRef", { enumerable: !0, get: function() {
    return s.BlobRef;
  } }), Object.defineProperty(t, "lexToJson", { enumerable: !0, get: function() {
    return s.lexToJson;
  } }), Object.defineProperty(t, "stringifyLex", { enumerable: !0, get: function() {
    return s.stringifyLex;
  } }), Object.defineProperty(t, "jsonToLex", { enumerable: !0, get: function() {
    return s.jsonToLex;
  } }), Object.defineProperty(t, "jsonStringToLex", { enumerable: !0, get: function() {
    return s.jsonStringToLex;
  } });
  var u = Vt;
  Object.defineProperty(t, "parseLanguage", { enumerable: !0, get: function() {
    return u.parseLanguage;
  } }), r(zc, t), r(xn, t), r(at, t), r(l, t), r(Vi, t), r(Ii, t), r(ko, t), r(Gi, t), r(pt, t), r(Ll, t), r(Oe, t), r(Da, t);
  var c = Cr;
  Object.defineProperty(t, "LABELS", { enumerable: !0, get: function() {
    return c.LABELS;
  } }), Object.defineProperty(t, "DEFAULT_LABEL_SETTINGS", { enumerable: !0, get: function() {
    return c.DEFAULT_LABEL_SETTINGS;
  } });
  var a = Ka;
  Object.defineProperty(t, "BskyAgent", { enumerable: !0, get: function() {
    return a.BskyAgent;
  } });
  var y = Vi;
  Object.defineProperty(t, "default", { enumerable: !0, get: function() {
    return y.AtpAgent;
  } });
})(al);
const Wa = new al.BskyAgent({
  service: "https://api.bsky.app"
}), Qf = ({
  post: t,
  reason: e,
  isRoot: r
}) => {
  if (t.$type === "app.bsky.graph.defs#listView")
    return {
      username: t.creator.displayName,
      handle: t.creator.handle,
      avatar: t.creator.avatar,
      text: [{
        val: t.description,
        setInnerHtml: !1
      }],
      createdAt: t.indexedAt,
      uri: t.uri,
      images: [],
      card: null,
      replyPost: null,
      isRepost: !1,
      repostBy: null,
      isList: !0,
      listName: t.name,
      listPurpose: t.purpose,
      listItemCount: t.listItemCount
    };
  const n = t.record.facets || [], s = t.record.text, u = new al.RichText({
    text: s,
    facets: n
  }), c = [];
  for (const d of u.segments())
    d.isLink() ? c.push({
      val: `<a href="${d.link?.uri}" target="_blank" rel="noopener" class="text-blue-500 underline">${d.text}</a>`,
      setInnerHtml: !0
    }) : d.isMention() ? c.push({
      val: `<a href="https://bsky.app/profile/${d.mention?.did}" target="_blank" rel="noopener" class="text-blue-500 underline">${d.text}</a>`,
      setInnerHtml: !0
    }) : d.isTag() ? c.push({
      val: `<a href="https://bsky.app/hashtag/${d.tag?.tag}" target="_blank" rel="noopener" class="text-blue-500 underline">${d.text}</a>`,
      setInnerHtml: !0
    }) : c.push({
      val: d.text,
      setInnerHtml: !1
    });
  const a = t.embed?.$type === "app.bsky.embed.record#view" ? t.embed.record : t.embed?.record?.record?.$type === "app.bsky.embed.record#viewRecord" && t.embed.record.record, y = a && {
    ...a,
    record: a.value,
    embed: (a?.embeds || [])[0]
  };
  return {
    username: t.author.displayName,
    handle: t.author.handle,
    avatar: t.author.avatar,
    // todo fallback
    text: c,
    createdAt: t.record.createdAt,
    uri: t.uri,
    images: [...t.embed?.images || [], ...t.embed?.media?.images || []],
    card: t.embed?.$type === "app.bsky.embed.external#view" && t.embed?.external,
    replyPost: r && y && Qf({
      post: y,
      reason: {
        $type: "",
        by: {
          displayName: ""
        }
      },
      isRoot: !1
    }),
    isRepost: e?.$type === "app.bsky.feed.defs#reasonRepost",
    repostBy: e?.by?.displayName
  };
}, Ja = (t) => (t.feed || []).map((e) => Qf({
  post: e.post || e,
  reason: e.reason,
  isRoot: !0
})), Fu = (t) => {
  const e = t.lastIndexOf("/");
  return e !== -1 ? t.substring(e + 1) : t;
}, zP = (t) => {
  const e = /* @__PURE__ */ new Date(), r = 60 * 1e3, n = r * 60, s = n * 24, u = s * 30, c = s * 365, a = e.getTime() - t.getTime();
  return a < r ? Math.floor(a / 1e3) + "s" : a < n ? Math.floor(a / r) + "m" : a < s ? Math.floor(a / n) + "h" : a < u ? Math.floor(a / s) + "d" : a < c ? Math.floor(a / u) + " mo" : Math.floor(a / c) + " yr";
};
var XP = /* @__PURE__ */ Ge('<article class="p-4 border-b border-slate-300 dark:border-slate-800"><div class="flex gap-2"><div><div class="flex max-w-[calc(100vw-96px)] items-center"><a class="text-ellipsis overflow-hidden whitespace-nowrap hover:underline dark:text-white"><span class="font-bold dark:text-white"></span><span> </span><span class="text-slate-500 dark:text-slate-400 text-sm">@</span></a><span class="text-slate-500 dark:text-slate-400 text-sm"><span class=mx-1></span><a class=hover:underline></a></span></div><p class="whitespace-pre-wrap dark:text-white">'), ZP = /* @__PURE__ */ Ge('<p class="flex gap-1 items-center ml-10 text-slate-600 dark:text-slate-400"><svg viewBox="0 0 576 512"height=16 width=16 tabindex=-1 class=mr-1><path fill=currentColor d="M272 416c17.7 0 32-14.3 32-32s-14.3-32-32-32H160c-17.7 0-32-14.3-32-32V192h32c12.9 0 24.6-7.8 29.6-19.8s2.2-25.7-6.9-34.9l-64-64c-12.5-12.5-32.8-12.5-45.3 0l-64 64c-9.2 9.2-11.9 22.9-6.9 34.9s16.6 19.8 29.6 19.8l32 0 0 128c0 53 43 96 96 96H272zM304 96c-17.7 0-32 14.3-32 32s14.3 32 32 32l112 0c17.7 0 32 14.3 32 32l0 128H416c-12.9 0-24.6 7.8-29.6 19.8s-2.2 25.7 6.9 34.9l64 64c12.5 12.5 32.8 12.5 45.3 0l64-64c9.2-9.2 11.9-22.9 6.9-34.9s-16.6-19.8-29.6-19.8l-32 0V192c0-53-43-96-96-96L304 96z"></path></svg><span class="text-sm text-slate-500 font-semibold">Reposted by '), HP = /* @__PURE__ */ Ge('<img alt="profile picture"class="w-14 h-14 rounded-full">'), WP = /* @__PURE__ */ Ge('<img alt="profile picture"class="w-4 h-4 mr-1 rounded-full">'), zu = /* @__PURE__ */ Ge("<span>"), JP = /* @__PURE__ */ Ge("<div>"), QP = /* @__PURE__ */ Ge("<a><img class=rounded-md>"), YP = /* @__PURE__ */ Ge('<a target=_blank rel=noopener class="mt-4 rounded-md border border-slate-300 block"><img class=rounded-t-md alt="Post Thumbnail"><div class=p-3><p class="text-slate-500 dark:text-slate-400 text-sm"></p><p class="font-bold dark:text-white mb-1"></p><p class="whitespace-pre-wrap dark:text-white">'), eD = /* @__PURE__ */ Ge('<a target=_blank rel=noopener class="mt-4 rounded-md border border-slate-300 block">');
const Yf = ({
  linkTarget: t = "_self",
  post: e,
  handleModalContent: r,
  isCard: n = !1
}) => (() => {
  var s = XP(), u = s.firstChild, c = u.firstChild, a = c.firstChild, y = a.firstChild, d = y.firstChild, b = d.nextSibling, g = b.nextSibling;
  g.firstChild;
  var R = y.nextSibling, C = R.firstChild, D = C.nextSibling, U = a.nextSibling;
  return ie(s, (() => {
    var K = Ir(() => !!e.isRepost);
    return () => K() && (() => {
      var A = ZP(), T = A.firstChild, V = T.nextSibling;
      return V.firstChild, ie(V, () => e.repostBy, null), A;
    })();
  })(), u), ie(u, !n && (() => {
    var K = HP();
    return ot(() => Ae(K, "src", e.avatar)), K;
  })(), c), ie(a, n && (() => {
    var K = WP();
    return ot(() => Ae(K, "src", e.avatar)), K;
  })(), y), Ae(y, "target", t), Ae(y, "rel", t === "_blank" ? "noopeener" : ""), ie(d, () => e.username), ie(g, () => e.handle, null), Ae(D, "target", t), Ae(D, "rel", t === "_blank" ? "noopeener" : ""), ie(D, () => zP(new Date(e.createdAt))), ie(U, () => e.text.map((K) => K.setInnerHtml ? (() => {
    var A = zu();
    return ot(() => A.innerHTML = K.val), A;
  })() : (() => {
    var A = zu();
    return ie(A, () => K.val), A;
  })())), ie(c, (() => {
    var K = Ir(() => e.images.length > 0);
    return () => K() && (() => {
      var A = JP();
      return ie(A, () => e.images.map((T) => (() => {
        var V = QP(), I = V.firstChild;
        return V.$$click = (X) => r(X, T), Ae(V, "target", t), Ae(V, "rel", t === "_blank" ? "noopeener" : ""), ot((X) => {
          var q = `https://bsky.app/profile/${e.handle}/post/${Fu(e.uri)}`, W = T.thumb, ee = T.alt;
          return q !== X.e && Ae(V, "href", X.e = q), W !== X.t && Ae(I, "src", X.t = W), ee !== X.a && Ae(I, "alt", X.a = ee), X;
        }, {
          e: void 0,
          t: void 0,
          a: void 0
        }), V;
      })())), ot(() => nc(A, e.images.length > 1 ? "mt-4 grid grid-cols-2 gap-2" : "mt-4")), A;
    })();
  })(), null), ie(c, (() => {
    var K = Ir(() => !!e.card);
    return () => K() && (() => {
      var A = YP(), T = A.firstChild, V = T.nextSibling, I = V.firstChild, X = I.nextSibling, q = X.nextSibling;
      return ie(I, () => new URL(e.card.uri).hostname), ie(X, () => e.card.title), ie(q, () => e.card.description), ot((W) => {
        var ee = e.card.uri, ve = e.card.thumb;
        return ee !== W.e && Ae(A, "href", W.e = ee), ve !== W.t && Ae(T, "src", W.t = ve), W;
      }, {
        e: void 0,
        t: void 0
      }), A;
    })();
  })(), null), ie(c, (() => {
    var K = Ir(() => !!e.replyPost);
    return () => K() && (() => {
      var A = eD();
      return ie(A, rc(Yf, tm({
        linkTarget: t,
        handleModalContent: r
      }, {
        get post() {
          return e.replyPost;
        },
        isCard: !0
      }))), ot(() => Ae(A, "href", e.card.uri)), A;
    })();
  })(), null), ot((K) => {
    var A = `https://bsky.app/profile/${e.handle}`, T = `https://bsky.app/profile/${e.handle}/post/${Fu(e.uri)}`;
    return A !== K.e && Ae(y, "href", K.e = A), T !== K.t && Ae(D, "href", K.t = T), K;
  }, {
    e: void 0,
    t: void 0
  }), s;
})();
ic(["click"]);
var tD = /* @__PURE__ */ Ge("<style>"), rD = /* @__PURE__ */ Ge('<section><dialog class="backdrop:bg-gray-800 backdrop:opacity-90"><form class="fixed top-5 right-5"><button type=submit aria-label=close formmethod=dialog formnovalidate class="bg-gray-900 rounded-full w-10 h-10 text-white flex items-center justify-center">X</button></form><img src=""alt=""class=max-h-[90vh]>'), iD = /* @__PURE__ */ Ge("<div>"), nD = /* @__PURE__ */ Ge('<article class="w-full flex gap-2 p-4 border-b border-slate-300 dark:border-slate-800 animate-pulse"><div class="bg-slate-200 w-14 h-14 rounded-full dark:bg-slate-800"></div><div class="flex-1 space-y-2 py-1"><div class="grid grid-cols-4 gap-4"><div class="h-2 bg-slate-200 rounded col-span-2 dark:bg-slate-800"></div></div><div class="h-2 bg-slate-200 rounded dark:bg-slate-800"></div><div class="h-2 bg-slate-200 rounded dark:bg-slate-800"></div><div class="h-2 bg-slate-200 rounded dark:bg-slate-800">'), sD = /* @__PURE__ */ Ge('<div class="mt-8 mb-16"><button id=bsky-load-more class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Load More Posts');
const oD = ({
  username: t,
  feed: e,
  limit: r = 10,
  mode: n = "",
  linkTarget: s = "_self",
  linkImage: u = !1,
  customStyles: c = "",
  search: a,
  loadMore: y = !1
}) => {
  let d = null, b = null;
  const [g, R] = un(!1), [C, D] = un([]), [U] = un(r), [K, A] = un(void 0);
  Zy(() => {
    R(!0), T();
  }, [t, e, a, U]);
  const T = async (q) => {
    t ? Wa.app.bsky.feed.getAuthorFeed({
      limit: U(),
      actor: t,
      filter: "posts_no_replies",
      cursor: q
    }).then(({
      success: W,
      data: ee
    }) => {
      if (W) {
        const ve = Ja(ee);
        X(ve), R(!1), A(ee.cursor);
      }
    }) : e ? Wa.app.bsky.feed.getFeed({
      limit: U(),
      feed: e,
      cursor: q
    }).then(({
      success: W,
      data: ee
    }) => {
      if (W) {
        const ve = Ja(ee);
        X(ve), R(!1), A(ee.cursor);
      }
    }) : a && Wa.app.bsky.feed.searchPosts({
      limit: U(),
      q: a,
      cursor: q
    }).then(({
      success: W,
      data: ee
    }) => {
      if (W) {
        const ve = {
          ...ee,
          feed: ee.posts.map((Br) => ({
            post: Br
          }))
        }, Ke = Ja(ve);
        X(Ke), R(!1), A(ee.cursor);
      }
    });
  }, V = (q, W) => {
    !u && d && b && (q.preventDefault(), b.src = W.fullsize, b.alt = W.alt, d.showModal());
  }, I = () => {
    R(!0), T(K());
  }, X = (q) => {
    const W = [...C(), ...q];
    D(W);
  };
  return [(() => {
    var q = tD();
    return ie(q, lm, null), ie(q, c, null), q;
  })(), (() => {
    var q = rD(), W = q.firstChild, ee = W.firstChild, ve = ee.nextSibling;
    return nc(q, `${n} max-w-screen-sm mx-auto flex flex-col items-center`), ie(q, (() => {
      var Ke = Ir(() => C().length > 0);
      return () => Ke() && C().map((Br, Do) => (() => {
        var qi = iD();
        return Ae(qi, "id", `post-${Do}`), ie(qi, rc(Yf, {
          post: Br,
          handleModalContent: V,
          linkTarget: s
        })), qi;
      })());
    })(), W), ie(q, (() => {
      var Ke = Ir(() => !!g());
      return () => Ke() && Array.from(Array(r)).map(() => nD());
    })(), W), Gl((Ke) => d = Ke, W), Gl((Ke) => b = Ke, ve), ie(q, y && (() => {
      var Ke = sD(), Br = Ke.firstChild;
      return Br.$$click = I, Ke;
    })(), null), q;
  })()];
};
ic(["click"]);
am("bsky-embed", {
  username: "",
  feed: "",
  limit: 10,
  mode: "",
  linkTarget: "_self",
  linkImage: !1,
  customStyles: "",
  search: "",
  loadMore: !1
}, oD);
