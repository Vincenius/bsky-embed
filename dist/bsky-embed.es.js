function tb(t) {
  return Object.keys(t).reduce((r, i) => {
    const a = t[i];
    return r[i] = Object.assign({}, a), Uf(a.value) && !ab(a.value) && !Array.isArray(a.value) && (r[i].value = Object.assign({}, a.value)), Array.isArray(a.value) && (r[i].value = a.value.slice(0)), r;
  }, {});
}
function rb(t) {
  return t ? Object.keys(t).reduce((r, i) => {
    const a = t[i];
    return r[i] = Uf(a) && "value" in a ? a : {
      value: a
    }, r[i].attribute || (r[i].attribute = sb(i)), r[i].parse = "parse" in r[i] ? r[i].parse : typeof r[i].value != "string", r;
  }, {}) : {};
}
function ib(t) {
  return Object.keys(t).reduce((r, i) => (r[i] = t[i].value, r), {});
}
function nb(t, e) {
  const r = tb(e);
  return Object.keys(e).forEach((a) => {
    const c = r[a], h = t.getAttribute(c.attribute), m = t[a];
    h != null && (c.value = c.parse ? If(h) : h), m != null && (c.value = Array.isArray(m) ? m.slice(0) : m), c.reflect && _d(t, c.attribute, c.value, !!c.parse), Object.defineProperty(t, a, {
      get() {
        return c.value;
      },
      set(p) {
        const b = c.value;
        c.value = p, c.reflect && _d(this, c.attribute, c.value, !!c.parse);
        for (let d = 0, v = this.__propertyChangedCallbacks.length; d < v; d++)
          this.__propertyChangedCallbacks[d](a, p, b);
      },
      enumerable: !0,
      configurable: !0
    });
  }), r;
}
function If(t) {
  if (t)
    try {
      return JSON.parse(t);
    } catch {
      return t;
    }
}
function _d(t, e, r, i) {
  if (r == null || r === !1) return t.removeAttribute(e);
  let a = i ? JSON.stringify(r) : r;
  t.__updating[e] = !0, a === "true" && (a = ""), t.setAttribute(e, a), Promise.resolve().then(() => delete t.__updating[e]);
}
function sb(t) {
  return t.replace(/\.?([A-Z]+)/g, (e, r) => "-" + r.toLowerCase()).replace("_", "-").replace(/^-/, "");
}
function Uf(t) {
  return t != null && (typeof t == "object" || typeof t == "function");
}
function ab(t) {
  return Object.prototype.toString.call(t) === "[object Function]";
}
function ob(t) {
  return typeof t == "function" && t.toString().indexOf("class") === 0;
}
let ac;
function lb(t, e) {
  const r = Object.keys(e);
  return class extends t {
    static get observedAttributes() {
      return r.map((a) => e[a].attribute);
    }
    constructor() {
      super(), this.__initialized = !1, this.__released = !1, this.__releaseCallbacks = [], this.__propertyChangedCallbacks = [], this.__updating = {}, this.props = {};
    }
    connectedCallback() {
      if (this.__initialized) return;
      this.__releaseCallbacks = [], this.__propertyChangedCallbacks = [], this.__updating = {}, this.props = nb(this, e);
      const a = ib(this.props), c = this.Component, h = ac;
      try {
        ac = this, this.__initialized = !0, ob(c) ? new c(a, {
          element: this
        }) : c(a, {
          element: this
        });
      } finally {
        ac = h;
      }
    }
    async disconnectedCallback() {
      if (await Promise.resolve(), this.isConnected) return;
      this.__propertyChangedCallbacks.length = 0;
      let a = null;
      for (; a = this.__releaseCallbacks.pop(); ) a(this);
      delete this.__initialized, this.__released = !0;
    }
    attributeChangedCallback(a, c, h) {
      if (this.__initialized && !this.__updating[a] && (a = this.lookupProp(a), a in e)) {
        if (h == null && !this[a]) return;
        this[a] = e[a].parse ? If(h) : h;
      }
    }
    lookupProp(a) {
      if (e)
        return r.find((c) => a === c || a === e[c].attribute);
    }
    get renderRoot() {
      return this.shadowRoot || this.attachShadow({
        mode: "open"
      });
    }
    addReleaseCallback(a) {
      this.__releaseCallbacks.push(a);
    }
    addPropertyChangedCallback(a) {
      this.__propertyChangedCallbacks.push(a);
    }
  };
}
function ub(t, e = {}, r = {}) {
  const {
    BaseElement: i = HTMLElement,
    extension: a,
    customElements: c = window.customElements
  } = r;
  return (h) => {
    let m = c.get(t);
    return m ? (m.prototype.Component = h, m) : (m = lb(i, rb(e)), m.prototype.Component = h, m.prototype.registeredTag = t, c.define(t, m, a), m);
  };
}
const cb = (t, e) => t === e, Rc = Symbol("solid-proxy"), db = typeof Proxy == "function", ou = {
  equals: cb
};
let Of = jf;
const vn = 1, lu = 2, Kf = {
  owned: null,
  cleanups: null,
  context: null,
  owner: null
};
var sr = null;
let oc = null, fb = null, wt = null, Jt = null, Oi = null, Lu = 0;
function pb(t, e) {
  const r = wt, i = sr, a = t.length === 0, c = e === void 0 ? i : e, h = a ? Kf : {
    owned: null,
    cleanups: null,
    context: c ? c.context : null,
    owner: c
  }, m = a ? t : () => t(() => Ra(() => oa(h)));
  sr = h, wt = null;
  try {
    return _a(m, !0);
  } finally {
    wt = r, sr = i;
  }
}
function ia(t, e) {
  e = e ? Object.assign({}, ou, e) : ou;
  const r = {
    value: t,
    observers: null,
    observerSlots: null,
    comparator: e.equals || void 0
  }, i = (a) => (typeof a == "function" && (a = a(r.value)), Vf(r, a));
  return [Nf.bind(r), i];
}
function Er(t, e, r) {
  const i = Pc(t, e, !1, vn);
  Aa(i);
}
function Mf(t, e, r) {
  Of = bb;
  const i = Pc(t, e, !1, vn);
  i.user = !0, Oi ? Oi.push(i) : Aa(i);
}
function Kr(t, e, r) {
  r = r ? Object.assign({}, ou, r) : ou;
  const i = Pc(t, e, !0, 0);
  return i.observers = null, i.observerSlots = null, i.comparator = r.equals || void 0, Aa(i), Nf.bind(i);
}
function Ra(t) {
  if (wt === null) return t();
  const e = wt;
  wt = null;
  try {
    return t();
  } finally {
    wt = e;
  }
}
function hb(t) {
  Mf(() => Ra(t));
}
function Nf() {
  if (this.sources && this.state)
    if (this.state === vn) Aa(this);
    else {
      const t = Jt;
      Jt = null, _a(() => cu(this), !1), Jt = t;
    }
  if (wt) {
    const t = this.observers ? this.observers.length : 0;
    wt.sources ? (wt.sources.push(this), wt.sourceSlots.push(t)) : (wt.sources = [this], wt.sourceSlots = [t]), this.observers ? (this.observers.push(wt), this.observerSlots.push(wt.sources.length - 1)) : (this.observers = [wt], this.observerSlots = [wt.sources.length - 1]);
  }
  return this.value;
}
function Vf(t, e, r) {
  let i = t.value;
  return (!t.comparator || !t.comparator(i, e)) && (t.value = e, t.observers && t.observers.length && _a(() => {
    for (let a = 0; a < t.observers.length; a += 1) {
      const c = t.observers[a], h = oc && oc.running;
      h && oc.disposed.has(c), (h ? !c.tState : !c.state) && (c.pure ? Jt.push(c) : Oi.push(c), c.observers && Ff(c)), h || (c.state = vn);
    }
    if (Jt.length > 1e6)
      throw Jt = [], new Error();
  }, !1)), e;
}
function Aa(t) {
  if (!t.fn) return;
  oa(t);
  const e = Lu;
  mb(
    t,
    t.value,
    e
  );
}
function mb(t, e, r) {
  let i;
  const a = sr, c = wt;
  wt = sr = t;
  try {
    i = t.fn(e);
  } catch (h) {
    return t.pure && (t.state = vn, t.owned && t.owned.forEach(oa), t.owned = null), t.updatedAt = r + 1, $f(h);
  } finally {
    wt = c, sr = a;
  }
  (!t.updatedAt || t.updatedAt <= r) && (t.updatedAt != null && "observers" in t ? Vf(t, i) : t.value = i, t.updatedAt = r);
}
function Pc(t, e, r, i = vn, a) {
  const c = {
    fn: t,
    state: i,
    updatedAt: null,
    owned: null,
    sources: null,
    sourceSlots: null,
    cleanups: null,
    value: e,
    owner: sr,
    context: sr ? sr.context : null,
    pure: r
  };
  return sr === null || sr !== Kf && (sr.owned ? sr.owned.push(c) : sr.owned = [c]), c;
}
function uu(t) {
  if (t.state === 0) return;
  if (t.state === lu) return cu(t);
  if (t.suspense && Ra(t.suspense.inFallback)) return t.suspense.effects.push(t);
  const e = [t];
  for (; (t = t.owner) && (!t.updatedAt || t.updatedAt < Lu); )
    t.state && e.push(t);
  for (let r = e.length - 1; r >= 0; r--)
    if (t = e[r], t.state === vn)
      Aa(t);
    else if (t.state === lu) {
      const i = Jt;
      Jt = null, _a(() => cu(t, e[0]), !1), Jt = i;
    }
}
function _a(t, e) {
  if (Jt) return t();
  let r = !1;
  e || (Jt = []), Oi ? r = !0 : Oi = [], Lu++;
  try {
    const i = t();
    return yb(r), i;
  } catch (i) {
    r || (Oi = null), Jt = null, $f(i);
  }
}
function yb(t) {
  if (Jt && (jf(Jt), Jt = null), t) return;
  const e = Oi;
  Oi = null, e.length && _a(() => Of(e), !1);
}
function jf(t) {
  for (let e = 0; e < t.length; e++) uu(t[e]);
}
function bb(t) {
  let e, r = 0;
  for (e = 0; e < t.length; e++) {
    const i = t[e];
    i.user ? t[r++] = i : uu(i);
  }
  for (e = 0; e < r; e++) uu(t[e]);
}
function cu(t, e) {
  t.state = 0;
  for (let r = 0; r < t.sources.length; r += 1) {
    const i = t.sources[r];
    if (i.sources) {
      const a = i.state;
      a === vn ? i !== e && (!i.updatedAt || i.updatedAt < Lu) && uu(i) : a === lu && cu(i, e);
    }
  }
}
function Ff(t) {
  for (let e = 0; e < t.observers.length; e += 1) {
    const r = t.observers[e];
    r.state || (r.state = lu, r.pure ? Jt.push(r) : Oi.push(r), r.observers && Ff(r));
  }
}
function oa(t) {
  let e;
  if (t.sources)
    for (; t.sources.length; ) {
      const r = t.sources.pop(), i = t.sourceSlots.pop(), a = r.observers;
      if (a && a.length) {
        const c = a.pop(), h = r.observerSlots.pop();
        i < a.length && (c.sourceSlots[h] = i, a[i] = c, r.observerSlots[i] = h);
      }
    }
  if (t.tOwned) {
    for (e = t.tOwned.length - 1; e >= 0; e--) oa(t.tOwned[e]);
    delete t.tOwned;
  }
  if (t.owned) {
    for (e = t.owned.length - 1; e >= 0; e--) oa(t.owned[e]);
    t.owned = null;
  }
  if (t.cleanups) {
    for (e = t.cleanups.length - 1; e >= 0; e--) t.cleanups[e]();
    t.cleanups = null;
  }
  t.state = 0;
}
function gb(t) {
  return t instanceof Error ? t : new Error(typeof t == "string" ? t : "Unknown error", {
    cause: t
  });
}
function $f(t, e = sr) {
  throw gb(t);
}
function Gf(t, e) {
  return Ra(() => t(e || {}));
}
function Yl() {
  return !0;
}
const xb = {
  get(t, e, r) {
    return e === Rc ? r : t.get(e);
  },
  has(t, e) {
    return e === Rc ? !0 : t.has(e);
  },
  set: Yl,
  deleteProperty: Yl,
  getOwnPropertyDescriptor(t, e) {
    return {
      configurable: !0,
      enumerable: !0,
      get() {
        return t.get(e);
      },
      set: Yl,
      deleteProperty: Yl
    };
  },
  ownKeys(t) {
    return t.keys();
  }
};
function lc(t) {
  return (t = typeof t == "function" ? t() : t) ? t : {};
}
function Eb() {
  for (let t = 0, e = this.length; t < e; ++t) {
    const r = this[t]();
    if (r !== void 0) return r;
  }
}
function vb(...t) {
  let e = !1;
  for (let h = 0; h < t.length; h++) {
    const m = t[h];
    e = e || !!m && Rc in m, t[h] = typeof m == "function" ? (e = !0, Kr(m)) : m;
  }
  if (db && e)
    return new Proxy(
      {
        get(h) {
          for (let m = t.length - 1; m >= 0; m--) {
            const p = lc(t[m])[h];
            if (p !== void 0) return p;
          }
        },
        has(h) {
          for (let m = t.length - 1; m >= 0; m--)
            if (h in lc(t[m])) return !0;
          return !1;
        },
        keys() {
          const h = [];
          for (let m = 0; m < t.length; m++)
            h.push(...Object.keys(lc(t[m])));
          return [...new Set(h)];
        }
      },
      xb
    );
  const r = {}, i = /* @__PURE__ */ Object.create(null);
  for (let h = t.length - 1; h >= 0; h--) {
    const m = t[h];
    if (!m) continue;
    const p = Object.getOwnPropertyNames(m);
    for (let b = p.length - 1; b >= 0; b--) {
      const d = p[b];
      if (d === "__proto__" || d === "constructor") continue;
      const v = Object.getOwnPropertyDescriptor(m, d);
      if (!i[d])
        i[d] = v.get ? {
          enumerable: !0,
          configurable: !0,
          get: Eb.bind(r[d] = [v.get.bind(m)])
        } : v.value !== void 0 ? v : void 0;
      else {
        const P = r[d];
        P && (v.get ? P.push(v.get.bind(m)) : v.value !== void 0 && P.push(() => v.value));
      }
    }
  }
  const a = {}, c = Object.keys(i);
  for (let h = c.length - 1; h >= 0; h--) {
    const m = c[h], p = i[m];
    p && p.get ? Object.defineProperty(a, m, p) : a[m] = p ? p.value : void 0;
  }
  return a;
}
function Rb(t, e, r) {
  let i = r.length, a = e.length, c = i, h = 0, m = 0, p = e[a - 1].nextSibling, b = null;
  for (; h < a || m < c; ) {
    if (e[h] === r[m]) {
      h++, m++;
      continue;
    }
    for (; e[a - 1] === r[c - 1]; )
      a--, c--;
    if (a === h) {
      const d = c < i ? m ? r[m - 1].nextSibling : r[c - m] : p;
      for (; m < c; ) t.insertBefore(r[m++], d);
    } else if (c === m)
      for (; h < a; )
        (!b || !b.has(e[h])) && e[h].remove(), h++;
    else if (e[h] === r[c - 1] && r[m] === e[a - 1]) {
      const d = e[--a].nextSibling;
      t.insertBefore(r[m++], e[h++].nextSibling), t.insertBefore(r[--c], d), e[a] = r[c];
    } else {
      if (!b) {
        b = /* @__PURE__ */ new Map();
        let v = m;
        for (; v < c; ) b.set(r[v], v++);
      }
      const d = b.get(e[h]);
      if (d != null)
        if (m < d && d < c) {
          let v = h, P = 1, M;
          for (; ++v < a && v < c && !((M = b.get(e[v])) == null || M !== d + P); )
            P++;
          if (P > d - m) {
            const K = e[h];
            for (; m < d; ) t.insertBefore(r[m++], K);
          } else t.replaceChild(r[m++], e[h++]);
        } else h++;
      else e[h++].remove();
    }
  }
}
const wd = "_$DX_DELEGATE";
function tr(t, e, r) {
  let i;
  const a = () => {
    const h = document.createElement("template");
    return h.innerHTML = t, h.content.firstChild;
  }, c = () => (i || (i = a())).cloneNode(!0);
  return c.cloneNode = c, c;
}
function qf(t, e = window.document) {
  const r = e[wd] || (e[wd] = /* @__PURE__ */ new Set());
  for (let i = 0, a = t.length; i < a; i++) {
    const c = t[i];
    r.has(c) || (r.add(c), e.addEventListener(c, Ab));
  }
}
function It(t, e, r) {
  r == null ? t.removeAttribute(e) : t.setAttribute(e, r);
}
function zf(t, e) {
  e == null ? t.removeAttribute("class") : t.className = e;
}
function Ac(t, e, r) {
  return Ra(() => t(e, r));
}
function it(t, e, r, i) {
  if (r !== void 0 && !i && (i = []), typeof e != "function") return du(t, e, i, r);
  Er((a) => du(t, e(), a, r), i);
}
function Ab(t) {
  let e = t.target;
  const r = `$$${t.type}`, i = t.target, a = t.currentTarget, c = (p) => Object.defineProperty(t, "target", {
    configurable: !0,
    value: p
  }), h = () => {
    const p = e[r];
    if (p && !e.disabled) {
      const b = e[`${r}Data`];
      if (b !== void 0 ? p.call(e, b, t) : p.call(e, t), t.cancelBubble) return;
    }
    return e.host && typeof e.host != "string" && !e.host._$host && e.contains(t.target) && c(e.host), !0;
  }, m = () => {
    for (; h() && (e = e._$host || e.parentNode || e.host); ) ;
  };
  if (Object.defineProperty(t, "currentTarget", {
    configurable: !0,
    get() {
      return e || document;
    }
  }), t.composedPath) {
    const p = t.composedPath();
    c(p[0]);
    for (let b = 0; b < p.length - 2 && (e = p[b], !!h()); b++) {
      if (e._$host) {
        e = e._$host, m();
        break;
      }
      if (e.parentNode === a)
        break;
    }
  } else m();
  c(i);
}
function du(t, e, r, i, a) {
  for (; typeof r == "function"; ) r = r();
  if (e === r) return r;
  const c = typeof e, h = i !== void 0;
  if (t = h && r[0] && r[0].parentNode || t, c === "string" || c === "number") {
    if (c === "number" && (e = e.toString(), e === r))
      return r;
    if (h) {
      let m = r[0];
      m && m.nodeType === 3 ? m.data !== e && (m.data = e) : m = document.createTextNode(e), r = ps(t, r, i, m);
    } else
      r !== "" && typeof r == "string" ? r = t.firstChild.data = e : r = t.textContent = e;
  } else if (e == null || c === "boolean")
    r = ps(t, r, i);
  else {
    if (c === "function")
      return Er(() => {
        let m = e();
        for (; typeof m == "function"; ) m = m();
        r = du(t, m, r, i);
      }), () => r;
    if (Array.isArray(e)) {
      const m = [], p = r && Array.isArray(r);
      if (_c(m, e, r, a))
        return Er(() => r = du(t, m, r, i, !0)), () => r;
      if (m.length === 0) {
        if (r = ps(t, r, i), h) return r;
      } else p ? r.length === 0 ? Td(t, m, i) : Rb(t, r, m) : (r && ps(t), Td(t, m));
      r = m;
    } else if (e.nodeType) {
      if (Array.isArray(r)) {
        if (h) return r = ps(t, r, i, e);
        ps(t, r, null, e);
      } else r == null || r === "" || !t.firstChild ? t.appendChild(e) : t.replaceChild(e, t.firstChild);
      r = e;
    }
  }
  return r;
}
function _c(t, e, r, i) {
  let a = !1;
  for (let c = 0, h = e.length; c < h; c++) {
    let m = e[c], p = r && r[t.length], b;
    if (!(m == null || m === !0 || m === !1)) if ((b = typeof m) == "object" && m.nodeType)
      t.push(m);
    else if (Array.isArray(m))
      a = _c(t, m, p) || a;
    else if (b === "function")
      if (i) {
        for (; typeof m == "function"; ) m = m();
        a = _c(
          t,
          Array.isArray(m) ? m : [m],
          Array.isArray(p) ? p : [p]
        ) || a;
      } else
        t.push(m), a = !0;
    else {
      const d = String(m);
      p && p.nodeType === 3 && p.data === d ? t.push(p) : t.push(document.createTextNode(d));
    }
  }
  return a;
}
function Td(t, e, r = null) {
  for (let i = 0, a = e.length; i < a; i++) t.insertBefore(e[i], r);
}
function ps(t, e, r, i) {
  if (r === void 0) return t.textContent = "";
  const a = i || document.createTextNode("");
  if (e.length) {
    let c = !1;
    for (let h = e.length - 1; h >= 0; h--) {
      const m = e[h];
      if (a !== m) {
        const p = m.parentNode === t;
        !c && !h ? p ? t.replaceChild(a, m) : t.insertBefore(a, r) : p && m.remove();
      } else c = !0;
    }
  } else t.insertBefore(a, r);
  return [a];
}
function _b(t) {
  const e = Object.keys(t), r = {};
  for (let i = 0; i < e.length; i++) {
    const [a, c] = ia(t[e[i]]);
    Object.defineProperty(r, e[i], {
      get: a,
      set(h) {
        c(() => h);
      }
    });
  }
  return r;
}
function wb(t) {
  if (t.assignedSlot && t.assignedSlot._$owner) return t.assignedSlot._$owner;
  let e = t.parentNode;
  for (; e && !e._$owner && !(e.assignedSlot && e.assignedSlot._$owner); )
    e = e.parentNode;
  return e && e.assignedSlot ? e.assignedSlot._$owner : t._$owner;
}
function Tb(t) {
  return (e, r) => {
    const { element: i } = r;
    return pb((a) => {
      const c = _b(e);
      i.addPropertyChangedCallback((m, p) => c[m] = p), i.addReleaseCallback(() => {
        i.renderRoot.textContent = "", a();
      });
      const h = t(c, r);
      return it(i.renderRoot, h);
    }, wb(i));
  };
}
function Sb(t, e, r) {
  return arguments.length === 2 && (r = e, e = {}), ub(t, e)(Tb(r));
}
const Cb = '*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}:before,:after{--tw-content: ""}html,:host{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.visible{visibility:visible}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.right-5{right:1.25rem}.top-5{top:1.25rem}.col-span-2{grid-column:span 2 / span 2}.mx-1{margin-left:.25rem;margin-right:.25rem}.mx-auto{margin-left:auto;margin-right:auto}.mb-1{margin-bottom:.25rem}.mb-16{margin-bottom:4rem}.ml-10{margin-left:2.5rem}.mr-1{margin-right:.25rem}.mt-4{margin-top:1rem}.mt-8{margin-top:2rem}.block{display:block}.inline{display:inline}.flex{display:flex}.grid{display:grid}.h-10{height:2.5rem}.h-14{height:3.5rem}.h-2{height:.5rem}.h-4{height:1rem}.h-full{height:100%}.max-h-\\[90vh\\]{max-height:90vh}.w-10{width:2.5rem}.w-14{width:3.5rem}.w-4{width:1rem}.w-full{width:100%}.max-w-\\[calc\\(100vw-96px\\)\\]{max-width:calc(100vw - 96px)}.max-w-screen-sm{max-width:640px}.flex-1{flex:1 1 0%}@keyframes pulse{50%{opacity:.5}}.animate-pulse{animation:pulse 2s cubic-bezier(.4,0,.6,1) infinite}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.grid-cols-4{grid-template-columns:repeat(4,minmax(0,1fr))}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-center{justify-content:center}.gap-1{gap:.25rem}.gap-2{gap:.5rem}.gap-4{gap:1rem}.space-y-2>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.5rem * var(--tw-space-y-reverse))}.overflow-hidden{overflow:hidden}.text-ellipsis{text-overflow:ellipsis}.whitespace-nowrap{white-space:nowrap}.whitespace-pre-wrap{white-space:pre-wrap}.rounded{border-radius:.25rem}.rounded-full{border-radius:9999px}.rounded-md{border-radius:.375rem}.rounded-t-md{border-top-left-radius:.375rem;border-top-right-radius:.375rem}.border{border-width:1px}.border-b{border-bottom-width:1px}.border-slate-300{--tw-border-opacity: 1;border-color:rgb(203 213 225 / var(--tw-border-opacity, 1))}.bg-blue-500{--tw-bg-opacity: 1;background-color:rgb(59 130 246 / var(--tw-bg-opacity, 1))}.bg-gray-900{--tw-bg-opacity: 1;background-color:rgb(17 24 39 / var(--tw-bg-opacity, 1))}.bg-slate-100{--tw-bg-opacity: 1;background-color:rgb(241 245 249 / var(--tw-bg-opacity, 1))}.bg-slate-200{--tw-bg-opacity: 1;background-color:rgb(226 232 240 / var(--tw-bg-opacity, 1))}.bg-slate-900{--tw-bg-opacity: 1;background-color:rgb(15 23 42 / var(--tw-bg-opacity, 1))}.object-cover{-o-object-fit:cover;object-fit:cover}.p-3{padding:.75rem}.p-4{padding:1rem}.px-4{padding-left:1rem;padding-right:1rem}.py-1{padding-top:.25rem;padding-bottom:.25rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.text-sm{font-size:.875rem;line-height:1.25rem}.font-bold{font-weight:700}.font-semibold{font-weight:600}.text-blue-500{--tw-text-opacity: 1;color:rgb(59 130 246 / var(--tw-text-opacity, 1))}.text-slate-500{--tw-text-opacity: 1;color:rgb(100 116 139 / var(--tw-text-opacity, 1))}.text-slate-600{--tw-text-opacity: 1;color:rgb(71 85 105 / var(--tw-text-opacity, 1))}.text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}.underline{text-decoration-line:underline}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.backdrop\\:bg-gray-800::backdrop{--tw-bg-opacity: 1;background-color:rgb(31 41 55 / var(--tw-bg-opacity, 1))}.backdrop\\:opacity-90::backdrop{opacity:.9}.hover\\:bg-blue-700:hover{--tw-bg-opacity: 1;background-color:rgb(29 78 216 / var(--tw-bg-opacity, 1))}.hover\\:underline:hover{text-decoration-line:underline}.dark\\:border-slate-800:where(.dark,.dark *){--tw-border-opacity: 1;border-color:rgb(30 41 59 / var(--tw-border-opacity, 1))}.dark\\:bg-slate-800:where(.dark,.dark *){--tw-bg-opacity: 1;background-color:rgb(30 41 59 / var(--tw-bg-opacity, 1))}.dark\\:text-slate-400:where(.dark,.dark *){--tw-text-opacity: 1;color:rgb(148 163 184 / var(--tw-text-opacity, 1))}.dark\\:text-white:where(.dark,.dark *){--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}';
var ne = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Lb(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function Xf(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var r = function i() {
      return this instanceof i ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    r.prototype = e.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(t).forEach(function(i) {
    var a = Object.getOwnPropertyDescriptor(t, i);
    Object.defineProperty(r, i, a.get ? a : {
      enumerable: !0,
      get: function() {
        return t[i];
      }
    });
  }), r;
}
var Bc = {}, as = {}, Ic = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.DisallowedDomainError = t.UnsupportedDomainError = t.ReservedHandleError = t.InvalidHandleError = t.isValidTld = t.isValidHandle = t.normalizeAndEnsureValidHandle = t.normalizeHandle = t.ensureValidHandleRegex = t.ensureValidHandle = t.DISALLOWED_TLDS = t.INVALID_HANDLE = void 0, t.INVALID_HANDLE = "handle.invalid", t.DISALLOWED_TLDS = [
    ".local",
    ".arpa",
    ".invalid",
    ".localhost",
    ".internal",
    ".example",
    ".alt",
    // policy could concievably change on ".onion" some day
    ".onion"
    // NOTE: .test is allowed in testing and devopment. In practical terms
    // "should" "never" actually resolve and get registered in production
  ];
  const e = (v) => {
    if (!/^[a-zA-Z0-9.-]*$/.test(v))
      throw new m("Disallowed characters in handle (ASCII letters, digits, dashes, periods only)");
    if (v.length > 253)
      throw new m("Handle is too long (253 chars max)");
    const P = v.split(".");
    if (P.length < 2)
      throw new m("Handle domain needs at least two parts");
    for (let M = 0; M < P.length; M++) {
      const K = P[M];
      if (K.length < 1)
        throw new m("Handle parts can not be empty");
      if (K.length > 63)
        throw new m("Handle part too long (max 63 chars)");
      if (K.endsWith("-") || K.startsWith("-"))
        throw new m("Handle parts can not start or end with hyphens");
      if (M + 1 === P.length && !/^[a-zA-Z]/.test(K))
        throw new m("Handle final component (TLD) must start with ASCII letter");
    }
  };
  t.ensureValidHandle = e;
  const r = (v) => {
    if (!/^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$/.test(v))
      throw new m("Handle didn't validate via regex");
    if (v.length > 253)
      throw new m("Handle is too long (253 chars max)");
  };
  t.ensureValidHandleRegex = r;
  const i = (v) => v.toLowerCase();
  t.normalizeHandle = i;
  const a = (v) => {
    const P = (0, t.normalizeHandle)(v);
    return (0, t.ensureValidHandle)(P), P;
  };
  t.normalizeAndEnsureValidHandle = a;
  const c = (v) => {
    try {
      (0, t.ensureValidHandle)(v);
    } catch (P) {
      if (P instanceof m)
        return !1;
      throw P;
    }
    return !0;
  };
  t.isValidHandle = c;
  const h = (v) => !t.DISALLOWED_TLDS.some((P) => v.endsWith(P));
  t.isValidTld = h;
  class m extends Error {
  }
  t.InvalidHandleError = m;
  class p extends Error {
  }
  t.ReservedHandleError = p;
  class b extends Error {
  }
  t.UnsupportedDomainError = b;
  class d extends Error {
  }
  t.DisallowedDomainError = d;
})(Ic);
var Ki = {};
Object.defineProperty(Ki, "__esModule", { value: !0 });
Ki.InvalidDidError = Ki.ensureValidDidRegex = Ki.ensureValidDid = void 0;
const kb = (t) => {
  if (!t.startsWith("did:"))
    throw new Bi('DID requires "did:" prefix');
  if (!/^[a-zA-Z0-9._:%-]*$/.test(t))
    throw new Bi("Disallowed characters in DID (ASCII letters, digits, and a couple other characters only)");
  const { length: e, 1: r } = t.split(":");
  if (e < 3)
    throw new Bi("DID requires prefix, method, and method-specific content");
  if (!/^[a-z]+$/.test(r))
    throw new Bi("DID method must be lower-case letters");
  if (t.endsWith(":") || t.endsWith("%"))
    throw new Bi('DID can not end with ":" or "%"');
  if (t.length > 2 * 1024)
    throw new Bi("DID is too long (2048 chars max)");
};
Ki.ensureValidDid = kb;
const Db = (t) => {
  if (!/^did:[a-z]+:[a-zA-Z0-9._:%-]*[a-zA-Z0-9._-]$/.test(t))
    throw new Bi("DID didn't validate via regex");
  if (t.length > 2 * 1024)
    throw new Bi("DID is too long (2048 chars max)");
};
Ki.ensureValidDidRegex = Db;
class Bi extends Error {
}
Ki.InvalidDidError = Bi;
var Uc = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.InvalidNsidError = t.ensureValidNsidRegex = t.ensureValidNsid = t.NSID = void 0;
  class e {
    static parse(h) {
      return new e(h);
    }
    static create(h, m) {
      const p = [...h.split(".").reverse(), m].join(".");
      return new e(p);
    }
    static isValid(h) {
      try {
        return e.parse(h), !0;
      } catch {
        return !1;
      }
    }
    constructor(h) {
      Object.defineProperty(this, "segments", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: []
      }), (0, t.ensureValidNsid)(h), this.segments = h.split(".");
    }
    get authority() {
      return this.segments.slice(0, this.segments.length - 1).reverse().join(".");
    }
    get name() {
      return this.segments.at(this.segments.length - 1);
    }
    toString() {
      return this.segments.join(".");
    }
  }
  t.NSID = e;
  const r = (c) => {
    const h = c;
    if (!/^[a-zA-Z0-9.-]*$/.test(h))
      throw new a("Disallowed characters in NSID (ASCII letters, digits, dashes, periods only)");
    if (h.length > 317)
      throw new a("NSID is too long (317 chars max)");
    const m = h.split(".");
    if (m.length < 3)
      throw new a("NSID needs at least three parts");
    for (let p = 0; p < m.length; p++) {
      const b = m[p];
      if (b.length < 1)
        throw new a("NSID parts can not be empty");
      if (b.length > 63)
        throw new a("NSID part too long (max 63 chars)");
      if (b.endsWith("-") || b.startsWith("-"))
        throw new a("NSID parts can not start or end with hyphen");
      if (/^[0-9]/.test(b) && p === 0)
        throw new a("NSID first part may not start with a digit");
      if (!/^[a-zA-Z]+$/.test(b) && p + 1 === m.length)
        throw new a("NSID name part must be only letters");
    }
  };
  t.ensureValidNsid = r;
  const i = (c) => {
    if (!/^[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(\.[a-zA-Z]([a-zA-Z]{0,61}[a-zA-Z])?)$/.test(c))
      throw new a("NSID didn't validate via regex");
    if (c.length > 317)
      throw new a("NSID is too long (317 chars max)");
  };
  t.ensureValidNsidRegex = i;
  class a extends Error {
  }
  t.InvalidNsidError = a;
})(Uc);
var Hf = {}, Es = {};
Object.defineProperty(Es, "__esModule", { value: !0 });
Es.ensureValidAtUriRegex = Es.ensureValidAtUri = void 0;
const Zf = Ic, Wf = Ki, Yf = Uc, Pb = (t) => {
  const e = t.split("#");
  if (e.length > 2)
    throw new Error('ATURI can have at most one "#", separating fragment out');
  const r = e[1] || null;
  if (t = e[0], !/^[a-zA-Z0-9._~:@!$&')(*+,;=%/-]*$/.test(t))
    throw new Error("Disallowed characters in ATURI (ASCII)");
  const i = t.split("/");
  if (i.length >= 3 && (i[0] !== "at:" || i[1].length !== 0))
    throw new Error('ATURI must start with "at://"');
  if (i.length < 3)
    throw new Error("ATURI requires at least method and authority sections");
  try {
    i[2].startsWith("did:") ? (0, Wf.ensureValidDid)(i[2]) : (0, Zf.ensureValidHandle)(i[2]);
  } catch {
    throw new Error("ATURI authority must be a valid handle or DID");
  }
  if (i.length >= 4) {
    if (i[3].length === 0)
      throw new Error("ATURI can not have a slash after authority without a path segment");
    try {
      (0, Yf.ensureValidNsid)(i[3]);
    } catch {
      throw new Error("ATURI requires first path segment (if supplied) to be valid NSID");
    }
  }
  if (i.length >= 5 && i[4].length === 0)
    throw new Error("ATURI can not have a slash after collection, unless record key is provided");
  if (i.length >= 6)
    throw new Error("ATURI path can have at most two parts, and no trailing slash");
  if (e.length >= 2 && r == null)
    throw new Error("ATURI fragment must be non-empty and start with slash");
  if (r != null) {
    if (r.length === 0 || r[0] !== "/")
      throw new Error("ATURI fragment must be non-empty and start with slash");
    if (!/^\/[a-zA-Z0-9._~:@!$&')(*+,;=%[\]/-]*$/.test(r))
      throw new Error("Disallowed characters in ATURI fragment (ASCII)");
  }
  if (t.length > 8 * 1024)
    throw new Error("ATURI is far too long");
};
Es.ensureValidAtUri = Pb;
const Bb = (t) => {
  const e = /^at:\/\/(?<authority>[a-zA-Z0-9._:%-]+)(\/(?<collection>[a-zA-Z0-9-.]+)(\/(?<rkey>[a-zA-Z0-9._~:@!$&%')(*+,;=-]+))?)?(#(?<fragment>\/[a-zA-Z0-9._~:@!$&%')(*+,;=\-[\]/\\]*))?$/, r = t.match(e);
  if (!r || !r.groups)
    throw new Error("ATURI didn't validate via regex");
  const i = r.groups;
  try {
    (0, Zf.ensureValidHandleRegex)(i.authority);
  } catch {
    try {
      (0, Wf.ensureValidDidRegex)(i.authority);
    } catch {
      throw new Error("ATURI authority must be a valid handle or DID");
    }
  }
  if (i.collection)
    try {
      (0, Yf.ensureValidNsidRegex)(i.collection);
    } catch {
      throw new Error("ATURI collection path segment must be a valid NSID");
    }
  if (t.length > 8 * 1024)
    throw new Error("ATURI is far too long");
};
Es.ensureValidAtUriRegex = Bb;
(function(t) {
  var e = ne && ne.__createBinding || (Object.create ? function(m, p, b, d) {
    d === void 0 && (d = b);
    var v = Object.getOwnPropertyDescriptor(p, b);
    (!v || ("get" in v ? !p.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
      return p[b];
    } }), Object.defineProperty(m, d, v);
  } : function(m, p, b, d) {
    d === void 0 && (d = b), m[d] = p[b];
  }), r = ne && ne.__exportStar || function(m, p) {
    for (var b in m) b !== "default" && !Object.prototype.hasOwnProperty.call(p, b) && e(p, m, b);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.AtUri = t.ATP_URI_REGEX = void 0, r(Es, t), t.ATP_URI_REGEX = // proto-    --did--------------   --name----------------   --path----   --query--   --hash--
  /^(at:\/\/)?((?:did:[a-z0-9:%-]+)|(?:[a-z0-9][a-z0-9.:-]*))(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
  const i = /^(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
  class a {
    constructor(p, b) {
      Object.defineProperty(this, "hash", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "host", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "pathname", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "searchParams", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      });
      let d;
      if (b) {
        if (d = c(b), !d)
          throw new Error(`Invalid at uri: ${b}`);
        const v = h(p);
        if (!v)
          throw new Error(`Invalid path: ${p}`);
        Object.assign(d, v);
      } else if (d = c(p), !d)
        throw new Error(`Invalid at uri: ${p}`);
      this.hash = d.hash, this.host = d.host, this.pathname = d.pathname, this.searchParams = d.searchParams;
    }
    static make(p, b, d) {
      let v = p;
      return b && (v += "/" + b), d && (v += "/" + d), new a(v);
    }
    get protocol() {
      return "at:";
    }
    get origin() {
      return `at://${this.host}`;
    }
    get hostname() {
      return this.host;
    }
    set hostname(p) {
      this.host = p;
    }
    get search() {
      return this.searchParams.toString();
    }
    set search(p) {
      this.searchParams = new URLSearchParams(p);
    }
    get collection() {
      return this.pathname.split("/").filter(Boolean)[0] || "";
    }
    set collection(p) {
      const b = this.pathname.split("/").filter(Boolean);
      b[0] = p, this.pathname = b.join("/");
    }
    get rkey() {
      return this.pathname.split("/").filter(Boolean)[1] || "";
    }
    set rkey(p) {
      const b = this.pathname.split("/").filter(Boolean);
      b[0] || (b[0] = "undefined"), b[1] = p, this.pathname = b.join("/");
    }
    get href() {
      return this.toString();
    }
    toString() {
      let p = this.pathname || "/";
      p.startsWith("/") || (p = `/${p}`);
      let b = this.searchParams.toString();
      b && !b.startsWith("?") && (b = `?${b}`);
      let d = this.hash;
      return d && !d.startsWith("#") && (d = `#${d}`), `at://${this.host}${p}${b}${d}`;
    }
  }
  t.AtUri = a;
  function c(m) {
    const p = t.ATP_URI_REGEX.exec(m);
    if (p)
      return {
        hash: p[5] || "",
        host: p[2] || "",
        pathname: p[3] || "",
        searchParams: new URLSearchParams(p[4] || "")
      };
  }
  function h(m) {
    const p = i.exec(m);
    if (p)
      return {
        hash: p[3] || "",
        pathname: p[1] || "",
        searchParams: new URLSearchParams(p[2] || "")
      };
  }
})(Hf);
var Jf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.InvalidTidError = t.isValidTid = t.ensureValidTid = void 0;
  const e = (a) => {
    if (a.length !== 13)
      throw new i("TID must be 13 characters");
    if (!/^[234567abcdefghij][234567abcdefghijklmnopqrstuvwxyz]{12}$/.test(a))
      throw new i("TID syntax not valid (regex)");
  };
  t.ensureValidTid = e;
  const r = (a) => {
    try {
      (0, t.ensureValidTid)(a);
    } catch (c) {
      if (c instanceof i)
        return !1;
      throw c;
    }
    return !0;
  };
  t.isValidTid = r;
  class i extends Error {
  }
  t.InvalidTidError = i;
})(Jf);
var Qf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.InvalidRecordKeyError = t.isValidRecordKey = t.ensureValidRecordKey = void 0;
  const e = (a) => {
    if (a.length > 512 || a.length < 1)
      throw new i("record key must be 1 to 512 characters");
    if (!/^[a-zA-Z0-9_~.:-]{1,512}$/.test(a))
      throw new i("record key syntax not valid (regex)");
    if (a === "." || a === "..")
      throw new i('record key can not be "." or ".."');
  };
  t.ensureValidRecordKey = e;
  const r = (a) => {
    try {
      (0, t.ensureValidRecordKey)(a);
    } catch (c) {
      if (c instanceof i)
        return !1;
      throw c;
    }
    return !0;
  };
  t.isValidRecordKey = r;
  class i extends Error {
  }
  t.InvalidRecordKeyError = i;
})(Qf);
var ep = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.InvalidDatetimeError = t.normalizeDatetimeAlways = t.normalizeDatetime = t.isValidDatetime = t.ensureValidDatetime = void 0;
  const e = (h) => {
    const m = new Date(h);
    if (isNaN(m.getTime()))
      throw new c("datetime did not parse as ISO 8601");
    if (m.toISOString().startsWith("-"))
      throw new c("datetime normalized to a negative time");
    if (!/^[0-9]{4}-[01][0-9]-[0-3][0-9]T[0-2][0-9]:[0-6][0-9]:[0-6][0-9](.[0-9]{1,20})?(Z|([+-][0-2][0-9]:[0-5][0-9]))$/.test(h))
      throw new c("datetime didn't validate via regex");
    if (h.length > 64)
      throw new c("datetime is too long (64 chars max)");
    if (h.endsWith("-00:00"))
      throw new c('datetime can not use "-00:00" for UTC timezone');
    if (h.startsWith("000"))
      throw new c("datetime so close to year zero not allowed");
  };
  t.ensureValidDatetime = e;
  const r = (h) => {
    try {
      (0, t.ensureValidDatetime)(h);
    } catch (m) {
      if (m instanceof c)
        return !1;
      throw m;
    }
    return !0;
  };
  t.isValidDatetime = r;
  const i = (h) => {
    if ((0, t.isValidDatetime)(h)) {
      const b = new Date(h).toISOString();
      if ((0, t.isValidDatetime)(b))
        return b;
    }
    if (!/.*(([+-]\d\d:?\d\d)|[a-zA-Z])$/.test(h)) {
      const b = /* @__PURE__ */ new Date(h + "Z");
      if (!isNaN(b.getTime())) {
        const d = b.toISOString();
        if ((0, t.isValidDatetime)(d))
          return d;
      }
    }
    const m = new Date(h);
    if (isNaN(m.getTime()))
      throw new c("datetime did not parse as any timestamp format");
    const p = m.toISOString();
    if ((0, t.isValidDatetime)(p))
      return p;
    throw new c("datetime normalized to invalid timestamp string");
  };
  t.normalizeDatetime = i;
  const a = (h) => {
    try {
      return (0, t.normalizeDatetime)(h);
    } catch (m) {
      if (m instanceof c)
        return (/* @__PURE__ */ new Date(0)).toISOString();
      throw m;
    }
  };
  t.normalizeDatetimeAlways = a;
  class c extends Error {
  }
  t.InvalidDatetimeError = c;
})(ep);
(function(t) {
  var e = ne && ne.__createBinding || (Object.create ? function(i, a, c, h) {
    h === void 0 && (h = c);
    var m = Object.getOwnPropertyDescriptor(a, c);
    (!m || ("get" in m ? !a.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
      return a[c];
    } }), Object.defineProperty(i, h, m);
  } : function(i, a, c, h) {
    h === void 0 && (h = c), i[h] = a[c];
  }), r = ne && ne.__exportStar || function(i, a) {
    for (var c in i) c !== "default" && !Object.prototype.hasOwnProperty.call(a, c) && e(a, i, c);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), r(Ic, t), r(Ki, t), r(Uc, t), r(Hf, t), r(Jf, t), r(Qf, t), r(ep, t);
})(as);
var wa = {}, Rn = {}, os = {}, wc = {}, ci = {}, ku = {}, Ta = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.getParsedType = t.ZodParsedType = t.objectUtil = t.util = void 0;
  var e;
  (function(a) {
    a.assertEqual = (p) => p;
    function c(p) {
    }
    a.assertIs = c;
    function h(p) {
      throw new Error();
    }
    a.assertNever = h, a.arrayToEnum = (p) => {
      const b = {};
      for (const d of p)
        b[d] = d;
      return b;
    }, a.getValidEnumValues = (p) => {
      const b = a.objectKeys(p).filter((v) => typeof p[p[v]] != "number"), d = {};
      for (const v of b)
        d[v] = p[v];
      return a.objectValues(d);
    }, a.objectValues = (p) => a.objectKeys(p).map(function(b) {
      return p[b];
    }), a.objectKeys = typeof Object.keys == "function" ? (p) => Object.keys(p) : (p) => {
      const b = [];
      for (const d in p)
        Object.prototype.hasOwnProperty.call(p, d) && b.push(d);
      return b;
    }, a.find = (p, b) => {
      for (const d of p)
        if (b(d))
          return d;
    }, a.isInteger = typeof Number.isInteger == "function" ? (p) => Number.isInteger(p) : (p) => typeof p == "number" && isFinite(p) && Math.floor(p) === p;
    function m(p, b = " | ") {
      return p.map((d) => typeof d == "string" ? `'${d}'` : d).join(b);
    }
    a.joinValues = m, a.jsonStringifyReplacer = (p, b) => typeof b == "bigint" ? b.toString() : b;
  })(e || (t.util = e = {}));
  var r;
  (function(a) {
    a.mergeShapes = (c, h) => ({
      ...c,
      ...h
      // second overwrites first
    });
  })(r || (t.objectUtil = r = {})), t.ZodParsedType = e.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  const i = (a) => {
    switch (typeof a) {
      case "undefined":
        return t.ZodParsedType.undefined;
      case "string":
        return t.ZodParsedType.string;
      case "number":
        return isNaN(a) ? t.ZodParsedType.nan : t.ZodParsedType.number;
      case "boolean":
        return t.ZodParsedType.boolean;
      case "function":
        return t.ZodParsedType.function;
      case "bigint":
        return t.ZodParsedType.bigint;
      case "symbol":
        return t.ZodParsedType.symbol;
      case "object":
        return Array.isArray(a) ? t.ZodParsedType.array : a === null ? t.ZodParsedType.null : a.then && typeof a.then == "function" && a.catch && typeof a.catch == "function" ? t.ZodParsedType.promise : typeof Map < "u" && a instanceof Map ? t.ZodParsedType.map : typeof Set < "u" && a instanceof Set ? t.ZodParsedType.set : typeof Date < "u" && a instanceof Date ? t.ZodParsedType.date : t.ZodParsedType.object;
      default:
        return t.ZodParsedType.unknown;
    }
  };
  t.getParsedType = i;
})(Ta);
var di = {};
Object.defineProperty(di, "__esModule", { value: !0 });
di.ZodError = di.quotelessJson = di.ZodIssueCode = void 0;
const tp = Ta;
di.ZodIssueCode = tp.util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const Ib = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
di.quotelessJson = Ib;
class la extends Error {
  get errors() {
    return this.issues;
  }
  constructor(e) {
    super(), this.issues = [], this.addIssue = (i) => {
      this.issues = [...this.issues, i];
    }, this.addIssues = (i = []) => {
      this.issues = [...this.issues, ...i];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = e;
  }
  format(e) {
    const r = e || function(c) {
      return c.message;
    }, i = { _errors: [] }, a = (c) => {
      for (const h of c.issues)
        if (h.code === "invalid_union")
          h.unionErrors.map(a);
        else if (h.code === "invalid_return_type")
          a(h.returnTypeError);
        else if (h.code === "invalid_arguments")
          a(h.argumentsError);
        else if (h.path.length === 0)
          i._errors.push(r(h));
        else {
          let m = i, p = 0;
          for (; p < h.path.length; ) {
            const b = h.path[p];
            p === h.path.length - 1 ? (m[b] = m[b] || { _errors: [] }, m[b]._errors.push(r(h))) : m[b] = m[b] || { _errors: [] }, m = m[b], p++;
          }
        }
    };
    return a(this), i;
  }
  static assert(e) {
    if (!(e instanceof la))
      throw new Error(`Not a ZodError: ${e}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, tp.util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (r) => r.message) {
    const r = {}, i = [];
    for (const a of this.issues)
      a.path.length > 0 ? (r[a.path[0]] = r[a.path[0]] || [], r[a.path[0]].push(e(a))) : i.push(e(a));
    return { formErrors: i, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
}
di.ZodError = la;
la.create = (t) => new la(t);
Object.defineProperty(ku, "__esModule", { value: !0 });
const Bn = Ta, Ht = di, Ub = (t, e) => {
  let r;
  switch (t.code) {
    case Ht.ZodIssueCode.invalid_type:
      t.received === Bn.ZodParsedType.undefined ? r = "Required" : r = `Expected ${t.expected}, received ${t.received}`;
      break;
    case Ht.ZodIssueCode.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(t.expected, Bn.util.jsonStringifyReplacer)}`;
      break;
    case Ht.ZodIssueCode.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${Bn.util.joinValues(t.keys, ", ")}`;
      break;
    case Ht.ZodIssueCode.invalid_union:
      r = "Invalid input";
      break;
    case Ht.ZodIssueCode.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${Bn.util.joinValues(t.options)}`;
      break;
    case Ht.ZodIssueCode.invalid_enum_value:
      r = `Invalid enum value. Expected ${Bn.util.joinValues(t.options)}, received '${t.received}'`;
      break;
    case Ht.ZodIssueCode.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case Ht.ZodIssueCode.invalid_return_type:
      r = "Invalid function return type";
      break;
    case Ht.ZodIssueCode.invalid_date:
      r = "Invalid date";
      break;
    case Ht.ZodIssueCode.invalid_string:
      typeof t.validation == "object" ? "includes" in t.validation ? (r = `Invalid input: must include "${t.validation.includes}"`, typeof t.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? r = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? r = `Invalid input: must end with "${t.validation.endsWith}"` : Bn.util.assertNever(t.validation) : t.validation !== "regex" ? r = `Invalid ${t.validation}` : r = "Invalid";
      break;
    case Ht.ZodIssueCode.too_small:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : r = "Invalid input";
      break;
    case Ht.ZodIssueCode.too_big:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? r = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : r = "Invalid input";
      break;
    case Ht.ZodIssueCode.custom:
      r = "Invalid input";
      break;
    case Ht.ZodIssueCode.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case Ht.ZodIssueCode.not_multiple_of:
      r = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case Ht.ZodIssueCode.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = e.defaultError, Bn.util.assertNever(t);
  }
  return { message: r };
};
ku.default = Ub;
var Ob = ne && ne.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(ci, "__esModule", { value: !0 });
ci.getErrorMap = ci.setErrorMap = ci.defaultErrorMap = void 0;
const rp = Ob(ku);
ci.defaultErrorMap = rp.default;
let ip = rp.default;
function Kb(t) {
  ip = t;
}
ci.setErrorMap = Kb;
function Mb() {
  return ip;
}
ci.getErrorMap = Mb;
var Oc = {};
(function(t) {
  var e = ne && ne.__importDefault || function(M) {
    return M && M.__esModule ? M : { default: M };
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.isAsync = t.isValid = t.isDirty = t.isAborted = t.OK = t.DIRTY = t.INVALID = t.ParseStatus = t.addIssueToContext = t.EMPTY_PATH = t.makeIssue = void 0;
  const r = ci, i = e(ku), a = (M) => {
    const { data: K, path: W, errorMaps: J, issueData: z } = M, U = [...W, ...z.path || []], F = {
      ...z,
      path: U
    };
    if (z.message !== void 0)
      return {
        ...z,
        path: U,
        message: z.message
      };
    let Z = "";
    const de = J.filter((xe) => !!xe).slice().reverse();
    for (const xe of de)
      Z = xe(F, { data: K, defaultError: Z }).message;
    return {
      ...z,
      path: U,
      message: Z
    };
  };
  t.makeIssue = a, t.EMPTY_PATH = [];
  function c(M, K) {
    const W = (0, r.getErrorMap)(), J = (0, t.makeIssue)({
      issueData: K,
      data: M.data,
      path: M.path,
      errorMaps: [
        M.common.contextualErrorMap,
        // contextual error map is first priority
        M.schemaErrorMap,
        // then schema-bound map if available
        W,
        // then global override map
        W === i.default ? void 0 : i.default
        // then global default map
      ].filter((z) => !!z)
    });
    M.common.issues.push(J);
  }
  t.addIssueToContext = c;
  class h {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      this.value === "valid" && (this.value = "dirty");
    }
    abort() {
      this.value !== "aborted" && (this.value = "aborted");
    }
    static mergeArray(K, W) {
      const J = [];
      for (const z of W) {
        if (z.status === "aborted")
          return t.INVALID;
        z.status === "dirty" && K.dirty(), J.push(z.value);
      }
      return { status: K.value, value: J };
    }
    static async mergeObjectAsync(K, W) {
      const J = [];
      for (const z of W) {
        const U = await z.key, F = await z.value;
        J.push({
          key: U,
          value: F
        });
      }
      return h.mergeObjectSync(K, J);
    }
    static mergeObjectSync(K, W) {
      const J = {};
      for (const z of W) {
        const { key: U, value: F } = z;
        if (U.status === "aborted" || F.status === "aborted")
          return t.INVALID;
        U.status === "dirty" && K.dirty(), F.status === "dirty" && K.dirty(), U.value !== "__proto__" && (typeof F.value < "u" || z.alwaysSet) && (J[U.value] = F.value);
      }
      return { status: K.value, value: J };
    }
  }
  t.ParseStatus = h, t.INVALID = Object.freeze({
    status: "aborted"
  });
  const m = (M) => ({ status: "dirty", value: M });
  t.DIRTY = m;
  const p = (M) => ({ status: "valid", value: M });
  t.OK = p;
  const b = (M) => M.status === "aborted";
  t.isAborted = b;
  const d = (M) => M.status === "dirty";
  t.isDirty = d;
  const v = (M) => M.status === "valid";
  t.isValid = v;
  const P = (M) => typeof Promise < "u" && M instanceof Promise;
  t.isAsync = P;
})(Oc);
var np = {};
Object.defineProperty(np, "__esModule", { value: !0 });
var j = {}, Du = {};
Object.defineProperty(Du, "__esModule", { value: !0 });
Du.errorUtil = void 0;
var Sd;
(function(t) {
  t.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, t.toString = (e) => typeof e == "string" ? e : e?.message;
})(Sd || (Du.errorUtil = Sd = {}));
var fu = ne && ne.__classPrivateFieldGet || function(t, e, r, i) {
  if (r === "a" && !i) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? i : r === "a" ? i.call(t) : i ? i.value : e.get(t);
}, sp = ne && ne.__classPrivateFieldSet || function(t, e, r, i, a) {
  if (i === "m") throw new TypeError("Private method is not writable");
  if (i === "a" && !a) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return i === "a" ? a.call(t, r) : a ? a.value = r : e.set(t, r), r;
}, na, sa;
Object.defineProperty(j, "__esModule", { value: !0 });
j.boolean = j.bigint = j.array = j.any = j.coerce = j.ZodFirstPartyTypeKind = j.late = j.ZodSchema = j.Schema = j.custom = j.ZodReadonly = j.ZodPipeline = j.ZodBranded = j.BRAND = j.ZodNaN = j.ZodCatch = j.ZodDefault = j.ZodNullable = j.ZodOptional = j.ZodTransformer = j.ZodEffects = j.ZodPromise = j.ZodNativeEnum = j.ZodEnum = j.ZodLiteral = j.ZodLazy = j.ZodFunction = j.ZodSet = j.ZodMap = j.ZodRecord = j.ZodTuple = j.ZodIntersection = j.ZodDiscriminatedUnion = j.ZodUnion = j.ZodObject = j.ZodArray = j.ZodVoid = j.ZodNever = j.ZodUnknown = j.ZodAny = j.ZodNull = j.ZodUndefined = j.ZodSymbol = j.ZodDate = j.ZodBoolean = j.ZodBigInt = j.ZodNumber = j.ZodString = j.datetimeRegex = j.ZodType = void 0;
j.NEVER = j.void = j.unknown = j.union = j.undefined = j.tuple = j.transformer = j.symbol = j.string = j.strictObject = j.set = j.record = j.promise = j.preprocess = j.pipeline = j.ostring = j.optional = j.onumber = j.oboolean = j.object = j.number = j.nullable = j.null = j.never = j.nativeEnum = j.nan = j.map = j.literal = j.lazy = j.intersection = j.instanceof = j.function = j.enum = j.effect = j.discriminatedUnion = j.date = void 0;
const Jl = ci, Re = Du, G = Oc, he = Ta, ce = di;
class pi {
  constructor(e, r, i, a) {
    this._cachedPath = [], this.parent = e, this.data = r, this._path = i, this._key = a;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const Cd = (t, e) => {
  if ((0, G.isValid)(e))
    return { success: !0, data: e.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const r = new ce.ZodError(t.common.issues);
      return this._error = r, this._error;
    }
  };
};
function Oe(t) {
  if (!t)
    return {};
  const { errorMap: e, invalid_type_error: r, required_error: i, description: a } = t;
  if (e && (r || i))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: a } : { errorMap: (h, m) => {
    var p, b;
    const { message: d } = t;
    return h.code === "invalid_enum_value" ? { message: d ?? m.defaultError } : typeof m.data > "u" ? { message: (p = d ?? i) !== null && p !== void 0 ? p : m.defaultError } : h.code !== "invalid_type" ? { message: m.defaultError } : { message: (b = d ?? r) !== null && b !== void 0 ? b : m.defaultError };
  }, description: a };
}
class Ve {
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return (0, he.getParsedType)(e.data);
  }
  _getOrReturnCtx(e, r) {
    return r || {
      common: e.parent.common,
      data: e.data,
      parsedType: (0, he.getParsedType)(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new G.ParseStatus(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: (0, he.getParsedType)(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const r = this._parse(e);
    if ((0, G.isAsync)(r))
      throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(e) {
    const r = this._parse(e);
    return Promise.resolve(r);
  }
  parse(e, r) {
    const i = this.safeParse(e, r);
    if (i.success)
      return i.data;
    throw i.error;
  }
  safeParse(e, r) {
    var i;
    const a = {
      common: {
        issues: [],
        async: (i = r?.async) !== null && i !== void 0 ? i : !1,
        contextualErrorMap: r?.errorMap
      },
      path: r?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: (0, he.getParsedType)(e)
    }, c = this._parseSync({ data: e, path: a.path, parent: a });
    return Cd(a, c);
  }
  "~validate"(e) {
    var r, i;
    const a = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: (0, he.getParsedType)(e)
    };
    if (!this["~standard"].async)
      try {
        const c = this._parseSync({ data: e, path: [], parent: a });
        return (0, G.isValid)(c) ? {
          value: c.value
        } : {
          issues: a.common.issues
        };
      } catch (c) {
        !((i = (r = c?.message) === null || r === void 0 ? void 0 : r.toLowerCase()) === null || i === void 0) && i.includes("encountered") && (this["~standard"].async = !0), a.common = {
          issues: [],
          async: !0
        };
      }
    return this._parseAsync({ data: e, path: [], parent: a }).then((c) => (0, G.isValid)(c) ? {
      value: c.value
    } : {
      issues: a.common.issues
    });
  }
  async parseAsync(e, r) {
    const i = await this.safeParseAsync(e, r);
    if (i.success)
      return i.data;
    throw i.error;
  }
  async safeParseAsync(e, r) {
    const i = {
      common: {
        issues: [],
        contextualErrorMap: r?.errorMap,
        async: !0
      },
      path: r?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: (0, he.getParsedType)(e)
    }, a = this._parse({ data: e, path: i.path, parent: i }), c = await ((0, G.isAsync)(a) ? a : Promise.resolve(a));
    return Cd(i, c);
  }
  refine(e, r) {
    const i = (a) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(a) : r;
    return this._refinement((a, c) => {
      const h = e(a), m = () => c.addIssue({
        code: ce.ZodIssueCode.custom,
        ...i(a)
      });
      return typeof Promise < "u" && h instanceof Promise ? h.then((p) => p ? !0 : (m(), !1)) : h ? !0 : (m(), !1);
    });
  }
  refinement(e, r) {
    return this._refinement((i, a) => e(i) ? !0 : (a.addIssue(typeof r == "function" ? r(i, a) : r), !1));
  }
  _refinement(e) {
    return new qr({
      schema: this,
      typeName: ke.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (r) => this["~validate"](r)
    };
  }
  optional() {
    return fi.create(this, this._def);
  }
  nullable() {
    return hn.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Gr.create(this);
  }
  promise() {
    return Rs.create(this, this._def);
  }
  or(e) {
    return fa.create([this, e], this._def);
  }
  and(e) {
    return pa.create(this, e, this._def);
  }
  transform(e) {
    return new qr({
      ...Oe(this._def),
      schema: this,
      typeName: ke.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const r = typeof e == "function" ? e : () => e;
    return new ga({
      ...Oe(this._def),
      innerType: this,
      defaultValue: r,
      typeName: ke.ZodDefault
    });
  }
  brand() {
    return new Kc({
      typeName: ke.ZodBranded,
      type: this,
      ...Oe(this._def)
    });
  }
  catch(e) {
    const r = typeof e == "function" ? e : () => e;
    return new xa({
      ...Oe(this._def),
      innerType: this,
      catchValue: r,
      typeName: ke.ZodCatch
    });
  }
  describe(e) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return Sa.create(this, e);
  }
  readonly() {
    return Ea.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
j.ZodType = Ve;
j.Schema = Ve;
j.ZodSchema = Ve;
const Nb = /^c[^\s-]{8,}$/i, Vb = /^[0-9a-z]+$/, jb = /^[0-9A-HJKMNP-TV-Z]{26}$/i, Fb = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, $b = /^[a-z0-9_-]{21}$/i, Gb = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, qb = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, zb = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, Xb = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let uc;
const Hb = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, Zb = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, Wb = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, Yb = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, Jb = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, Qb = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, ap = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", eg = new RegExp(`^${ap}$`);
function op(t) {
  let e = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return t.precision ? e = `${e}\\.\\d{${t.precision}}` : t.precision == null && (e = `${e}(\\.\\d+)?`), e;
}
function tg(t) {
  return new RegExp(`^${op(t)}$`);
}
function lp(t) {
  let e = `${ap}T${op(t)}`;
  const r = [];
  return r.push(t.local ? "Z?" : "Z"), t.offset && r.push("([+-]\\d{2}:?\\d{2})"), e = `${e}(${r.join("|")})`, new RegExp(`^${e}$`);
}
j.datetimeRegex = lp;
function rg(t, e) {
  return !!((e === "v4" || !e) && Hb.test(t) || (e === "v6" || !e) && Wb.test(t));
}
function ig(t, e) {
  if (!Gb.test(t))
    return !1;
  try {
    const [r] = t.split("."), i = r.replace(/-/g, "+").replace(/_/g, "/").padEnd(r.length + (4 - r.length % 4) % 4, "="), a = JSON.parse(atob(i));
    return !(typeof a != "object" || a === null || !a.typ || !a.alg || e && a.alg !== e);
  } catch {
    return !1;
  }
}
function ng(t, e) {
  return !!((e === "v4" || !e) && Zb.test(t) || (e === "v6" || !e) && Yb.test(t));
}
class Mr extends Ve {
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== he.ZodParsedType.string) {
      const c = this._getOrReturnCtx(e);
      return (0, G.addIssueToContext)(c, {
        code: ce.ZodIssueCode.invalid_type,
        expected: he.ZodParsedType.string,
        received: c.parsedType
      }), G.INVALID;
    }
    const i = new G.ParseStatus();
    let a;
    for (const c of this._def.checks)
      if (c.kind === "min")
        e.data.length < c.value && (a = this._getOrReturnCtx(e, a), (0, G.addIssueToContext)(a, {
          code: ce.ZodIssueCode.too_small,
          minimum: c.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: c.message
        }), i.dirty());
      else if (c.kind === "max")
        e.data.length > c.value && (a = this._getOrReturnCtx(e, a), (0, G.addIssueToContext)(a, {
          code: ce.ZodIssueCode.too_big,
          maximum: c.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: c.message
        }), i.dirty());
      else if (c.kind === "length") {
        const h = e.data.length > c.value, m = e.data.length < c.value;
        (h || m) && (a = this._getOrReturnCtx(e, a), h ? (0, G.addIssueToContext)(a, {
          code: ce.ZodIssueCode.too_big,
          maximum: c.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: c.message
        }) : m && (0, G.addIssueToContext)(a, {
          code: ce.ZodIssueCode.too_small,
          minimum: c.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: c.message
        }), i.dirty());
      } else if (c.kind === "email")
        zb.test(e.data) || (a = this._getOrReturnCtx(e, a), (0, G.addIssueToContext)(a, {
          validation: "email",
          code: ce.ZodIssueCode.invalid_string,
          message: c.message
        }), i.dirty());
      else if (c.kind === "emoji")
        uc || (uc = new RegExp(Xb, "u")), uc.test(e.data) || (a = this._getOrReturnCtx(e, a), (0, G.addIssueToContext)(a, {
          validation: "emoji",
          code: ce.ZodIssueCode.invalid_string,
          message: c.message
        }), i.dirty());
      else if (c.kind === "uuid")
        Fb.test(e.data) || (a = this._getOrReturnCtx(e, a), (0, G.addIssueToContext)(a, {
          validation: "uuid",
          code: ce.ZodIssueCode.invalid_string,
          message: c.message
        }), i.dirty());
      else if (c.kind === "nanoid")
        $b.test(e.data) || (a = this._getOrReturnCtx(e, a), (0, G.addIssueToContext)(a, {
          validation: "nanoid",
          code: ce.ZodIssueCode.invalid_string,
          message: c.message
        }), i.dirty());
      else if (c.kind === "cuid")
        Nb.test(e.data) || (a = this._getOrReturnCtx(e, a), (0, G.addIssueToContext)(a, {
          validation: "cuid",
          code: ce.ZodIssueCode.invalid_string,
          message: c.message
        }), i.dirty());
      else if (c.kind === "cuid2")
        Vb.test(e.data) || (a = this._getOrReturnCtx(e, a), (0, G.addIssueToContext)(a, {
          validation: "cuid2",
          code: ce.ZodIssueCode.invalid_string,
          message: c.message
        }), i.dirty());
      else if (c.kind === "ulid")
        jb.test(e.data) || (a = this._getOrReturnCtx(e, a), (0, G.addIssueToContext)(a, {
          validation: "ulid",
          code: ce.ZodIssueCode.invalid_string,
          message: c.message
        }), i.dirty());
      else if (c.kind === "url")
        try {
          new URL(e.data);
        } catch {
          a = this._getOrReturnCtx(e, a), (0, G.addIssueToContext)(a, {
            validation: "url",
            code: ce.ZodIssueCode.invalid_string,
            message: c.message
          }), i.dirty();
        }
      else c.kind === "regex" ? (c.regex.lastIndex = 0, c.regex.test(e.data) || (a = this._getOrReturnCtx(e, a), (0, G.addIssueToContext)(a, {
        validation: "regex",
        code: ce.ZodIssueCode.invalid_string,
        message: c.message
      }), i.dirty())) : c.kind === "trim" ? e.data = e.data.trim() : c.kind === "includes" ? e.data.includes(c.value, c.position) || (a = this._getOrReturnCtx(e, a), (0, G.addIssueToContext)(a, {
        code: ce.ZodIssueCode.invalid_string,
        validation: { includes: c.value, position: c.position },
        message: c.message
      }), i.dirty()) : c.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : c.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : c.kind === "startsWith" ? e.data.startsWith(c.value) || (a = this._getOrReturnCtx(e, a), (0, G.addIssueToContext)(a, {
        code: ce.ZodIssueCode.invalid_string,
        validation: { startsWith: c.value },
        message: c.message
      }), i.dirty()) : c.kind === "endsWith" ? e.data.endsWith(c.value) || (a = this._getOrReturnCtx(e, a), (0, G.addIssueToContext)(a, {
        code: ce.ZodIssueCode.invalid_string,
        validation: { endsWith: c.value },
        message: c.message
      }), i.dirty()) : c.kind === "datetime" ? lp(c).test(e.data) || (a = this._getOrReturnCtx(e, a), (0, G.addIssueToContext)(a, {
        code: ce.ZodIssueCode.invalid_string,
        validation: "datetime",
        message: c.message
      }), i.dirty()) : c.kind === "date" ? eg.test(e.data) || (a = this._getOrReturnCtx(e, a), (0, G.addIssueToContext)(a, {
        code: ce.ZodIssueCode.invalid_string,
        validation: "date",
        message: c.message
      }), i.dirty()) : c.kind === "time" ? tg(c).test(e.data) || (a = this._getOrReturnCtx(e, a), (0, G.addIssueToContext)(a, {
        code: ce.ZodIssueCode.invalid_string,
        validation: "time",
        message: c.message
      }), i.dirty()) : c.kind === "duration" ? qb.test(e.data) || (a = this._getOrReturnCtx(e, a), (0, G.addIssueToContext)(a, {
        validation: "duration",
        code: ce.ZodIssueCode.invalid_string,
        message: c.message
      }), i.dirty()) : c.kind === "ip" ? rg(e.data, c.version) || (a = this._getOrReturnCtx(e, a), (0, G.addIssueToContext)(a, {
        validation: "ip",
        code: ce.ZodIssueCode.invalid_string,
        message: c.message
      }), i.dirty()) : c.kind === "jwt" ? ig(e.data, c.alg) || (a = this._getOrReturnCtx(e, a), (0, G.addIssueToContext)(a, {
        validation: "jwt",
        code: ce.ZodIssueCode.invalid_string,
        message: c.message
      }), i.dirty()) : c.kind === "cidr" ? ng(e.data, c.version) || (a = this._getOrReturnCtx(e, a), (0, G.addIssueToContext)(a, {
        validation: "cidr",
        code: ce.ZodIssueCode.invalid_string,
        message: c.message
      }), i.dirty()) : c.kind === "base64" ? Jb.test(e.data) || (a = this._getOrReturnCtx(e, a), (0, G.addIssueToContext)(a, {
        validation: "base64",
        code: ce.ZodIssueCode.invalid_string,
        message: c.message
      }), i.dirty()) : c.kind === "base64url" ? Qb.test(e.data) || (a = this._getOrReturnCtx(e, a), (0, G.addIssueToContext)(a, {
        validation: "base64url",
        code: ce.ZodIssueCode.invalid_string,
        message: c.message
      }), i.dirty()) : he.util.assertNever(c);
    return { status: i.value, value: e.data };
  }
  _regex(e, r, i) {
    return this.refinement((a) => e.test(a), {
      validation: r,
      code: ce.ZodIssueCode.invalid_string,
      ...Re.errorUtil.errToObj(i)
    });
  }
  _addCheck(e) {
    return new Mr({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...Re.errorUtil.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...Re.errorUtil.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...Re.errorUtil.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...Re.errorUtil.errToObj(e) });
  }
  nanoid(e) {
    return this._addCheck({ kind: "nanoid", ...Re.errorUtil.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...Re.errorUtil.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...Re.errorUtil.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...Re.errorUtil.errToObj(e) });
  }
  base64(e) {
    return this._addCheck({ kind: "base64", ...Re.errorUtil.errToObj(e) });
  }
  base64url(e) {
    return this._addCheck({
      kind: "base64url",
      ...Re.errorUtil.errToObj(e)
    });
  }
  jwt(e) {
    return this._addCheck({ kind: "jwt", ...Re.errorUtil.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...Re.errorUtil.errToObj(e) });
  }
  cidr(e) {
    return this._addCheck({ kind: "cidr", ...Re.errorUtil.errToObj(e) });
  }
  datetime(e) {
    var r, i;
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof e?.precision > "u" ? null : e?.precision,
      offset: (r = e?.offset) !== null && r !== void 0 ? r : !1,
      local: (i = e?.local) !== null && i !== void 0 ? i : !1,
      ...Re.errorUtil.errToObj(e?.message)
    });
  }
  date(e) {
    return this._addCheck({ kind: "date", message: e });
  }
  time(e) {
    return typeof e == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: e
    }) : this._addCheck({
      kind: "time",
      precision: typeof e?.precision > "u" ? null : e?.precision,
      ...Re.errorUtil.errToObj(e?.message)
    });
  }
  duration(e) {
    return this._addCheck({ kind: "duration", ...Re.errorUtil.errToObj(e) });
  }
  regex(e, r) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...Re.errorUtil.errToObj(r)
    });
  }
  includes(e, r) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: r?.position,
      ...Re.errorUtil.errToObj(r?.message)
    });
  }
  startsWith(e, r) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...Re.errorUtil.errToObj(r)
    });
  }
  endsWith(e, r) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...Re.errorUtil.errToObj(r)
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...Re.errorUtil.errToObj(r)
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...Re.errorUtil.errToObj(r)
    });
  }
  length(e, r) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...Re.errorUtil.errToObj(r)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(e) {
    return this.min(1, Re.errorUtil.errToObj(e));
  }
  trim() {
    return new Mr({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new Mr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new Mr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((e) => e.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((e) => e.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((e) => e.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((e) => e.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((e) => e.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((e) => e.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((e) => e.kind === "base64url");
  }
  get minLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
}
j.ZodString = Mr;
Mr.create = (t) => {
  var e;
  return new Mr({
    checks: [],
    typeName: ke.ZodString,
    coerce: (e = t?.coerce) !== null && e !== void 0 ? e : !1,
    ...Oe(t)
  });
};
function sg(t, e) {
  const r = (t.toString().split(".")[1] || "").length, i = (e.toString().split(".")[1] || "").length, a = r > i ? r : i, c = parseInt(t.toFixed(a).replace(".", "")), h = parseInt(e.toFixed(a).replace(".", ""));
  return c % h / Math.pow(10, a);
}
class dn extends Ve {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== he.ZodParsedType.number) {
      const c = this._getOrReturnCtx(e);
      return (0, G.addIssueToContext)(c, {
        code: ce.ZodIssueCode.invalid_type,
        expected: he.ZodParsedType.number,
        received: c.parsedType
      }), G.INVALID;
    }
    let i;
    const a = new G.ParseStatus();
    for (const c of this._def.checks)
      c.kind === "int" ? he.util.isInteger(e.data) || (i = this._getOrReturnCtx(e, i), (0, G.addIssueToContext)(i, {
        code: ce.ZodIssueCode.invalid_type,
        expected: "integer",
        received: "float",
        message: c.message
      }), a.dirty()) : c.kind === "min" ? (c.inclusive ? e.data < c.value : e.data <= c.value) && (i = this._getOrReturnCtx(e, i), (0, G.addIssueToContext)(i, {
        code: ce.ZodIssueCode.too_small,
        minimum: c.value,
        type: "number",
        inclusive: c.inclusive,
        exact: !1,
        message: c.message
      }), a.dirty()) : c.kind === "max" ? (c.inclusive ? e.data > c.value : e.data >= c.value) && (i = this._getOrReturnCtx(e, i), (0, G.addIssueToContext)(i, {
        code: ce.ZodIssueCode.too_big,
        maximum: c.value,
        type: "number",
        inclusive: c.inclusive,
        exact: !1,
        message: c.message
      }), a.dirty()) : c.kind === "multipleOf" ? sg(e.data, c.value) !== 0 && (i = this._getOrReturnCtx(e, i), (0, G.addIssueToContext)(i, {
        code: ce.ZodIssueCode.not_multiple_of,
        multipleOf: c.value,
        message: c.message
      }), a.dirty()) : c.kind === "finite" ? Number.isFinite(e.data) || (i = this._getOrReturnCtx(e, i), (0, G.addIssueToContext)(i, {
        code: ce.ZodIssueCode.not_finite,
        message: c.message
      }), a.dirty()) : he.util.assertNever(c);
    return { status: a.value, value: e.data };
  }
  gte(e, r) {
    return this.setLimit("min", e, !0, Re.errorUtil.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, !1, Re.errorUtil.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, !0, Re.errorUtil.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, !1, Re.errorUtil.toString(r));
  }
  setLimit(e, r, i, a) {
    return new dn({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: r,
          inclusive: i,
          message: Re.errorUtil.toString(a)
        }
      ]
    });
  }
  _addCheck(e) {
    return new dn({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: Re.errorUtil.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: Re.errorUtil.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: Re.errorUtil.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: Re.errorUtil.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: Re.errorUtil.toString(e)
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: Re.errorUtil.toString(r)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: Re.errorUtil.toString(e)
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: Re.errorUtil.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: Re.errorUtil.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && he.util.isInteger(e.value));
  }
  get isFinite() {
    let e = null, r = null;
    for (const i of this._def.checks) {
      if (i.kind === "finite" || i.kind === "int" || i.kind === "multipleOf")
        return !0;
      i.kind === "min" ? (r === null || i.value > r) && (r = i.value) : i.kind === "max" && (e === null || i.value < e) && (e = i.value);
    }
    return Number.isFinite(r) && Number.isFinite(e);
  }
}
j.ZodNumber = dn;
dn.create = (t) => new dn({
  checks: [],
  typeName: ke.ZodNumber,
  coerce: t?.coerce || !1,
  ...Oe(t)
});
class fn extends Ve {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce)
      try {
        e.data = BigInt(e.data);
      } catch {
        return this._getInvalidInput(e);
      }
    if (this._getType(e) !== he.ZodParsedType.bigint)
      return this._getInvalidInput(e);
    let i;
    const a = new G.ParseStatus();
    for (const c of this._def.checks)
      c.kind === "min" ? (c.inclusive ? e.data < c.value : e.data <= c.value) && (i = this._getOrReturnCtx(e, i), (0, G.addIssueToContext)(i, {
        code: ce.ZodIssueCode.too_small,
        type: "bigint",
        minimum: c.value,
        inclusive: c.inclusive,
        message: c.message
      }), a.dirty()) : c.kind === "max" ? (c.inclusive ? e.data > c.value : e.data >= c.value) && (i = this._getOrReturnCtx(e, i), (0, G.addIssueToContext)(i, {
        code: ce.ZodIssueCode.too_big,
        type: "bigint",
        maximum: c.value,
        inclusive: c.inclusive,
        message: c.message
      }), a.dirty()) : c.kind === "multipleOf" ? e.data % c.value !== BigInt(0) && (i = this._getOrReturnCtx(e, i), (0, G.addIssueToContext)(i, {
        code: ce.ZodIssueCode.not_multiple_of,
        multipleOf: c.value,
        message: c.message
      }), a.dirty()) : he.util.assertNever(c);
    return { status: a.value, value: e.data };
  }
  _getInvalidInput(e) {
    const r = this._getOrReturnCtx(e);
    return (0, G.addIssueToContext)(r, {
      code: ce.ZodIssueCode.invalid_type,
      expected: he.ZodParsedType.bigint,
      received: r.parsedType
    }), G.INVALID;
  }
  gte(e, r) {
    return this.setLimit("min", e, !0, Re.errorUtil.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, !1, Re.errorUtil.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, !0, Re.errorUtil.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, !1, Re.errorUtil.toString(r));
  }
  setLimit(e, r, i, a) {
    return new fn({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: r,
          inclusive: i,
          message: Re.errorUtil.toString(a)
        }
      ]
    });
  }
  _addCheck(e) {
    return new fn({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: Re.errorUtil.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: Re.errorUtil.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: Re.errorUtil.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: Re.errorUtil.toString(e)
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: Re.errorUtil.toString(r)
    });
  }
  get minValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
}
j.ZodBigInt = fn;
fn.create = (t) => {
  var e;
  return new fn({
    checks: [],
    typeName: ke.ZodBigInt,
    coerce: (e = t?.coerce) !== null && e !== void 0 ? e : !1,
    ...Oe(t)
  });
};
class ua extends Ve {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== he.ZodParsedType.boolean) {
      const i = this._getOrReturnCtx(e);
      return (0, G.addIssueToContext)(i, {
        code: ce.ZodIssueCode.invalid_type,
        expected: he.ZodParsedType.boolean,
        received: i.parsedType
      }), G.INVALID;
    }
    return (0, G.OK)(e.data);
  }
}
j.ZodBoolean = ua;
ua.create = (t) => new ua({
  typeName: ke.ZodBoolean,
  coerce: t?.coerce || !1,
  ...Oe(t)
});
class Kn extends Ve {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== he.ZodParsedType.date) {
      const c = this._getOrReturnCtx(e);
      return (0, G.addIssueToContext)(c, {
        code: ce.ZodIssueCode.invalid_type,
        expected: he.ZodParsedType.date,
        received: c.parsedType
      }), G.INVALID;
    }
    if (isNaN(e.data.getTime())) {
      const c = this._getOrReturnCtx(e);
      return (0, G.addIssueToContext)(c, {
        code: ce.ZodIssueCode.invalid_date
      }), G.INVALID;
    }
    const i = new G.ParseStatus();
    let a;
    for (const c of this._def.checks)
      c.kind === "min" ? e.data.getTime() < c.value && (a = this._getOrReturnCtx(e, a), (0, G.addIssueToContext)(a, {
        code: ce.ZodIssueCode.too_small,
        message: c.message,
        inclusive: !0,
        exact: !1,
        minimum: c.value,
        type: "date"
      }), i.dirty()) : c.kind === "max" ? e.data.getTime() > c.value && (a = this._getOrReturnCtx(e, a), (0, G.addIssueToContext)(a, {
        code: ce.ZodIssueCode.too_big,
        message: c.message,
        inclusive: !0,
        exact: !1,
        maximum: c.value,
        type: "date"
      }), i.dirty()) : he.util.assertNever(c);
    return {
      status: i.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new Kn({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: Re.errorUtil.toString(r)
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: Re.errorUtil.toString(r)
    });
  }
  get minDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
}
j.ZodDate = Kn;
Kn.create = (t) => new Kn({
  checks: [],
  coerce: t?.coerce || !1,
  typeName: ke.ZodDate,
  ...Oe(t)
});
class pu extends Ve {
  _parse(e) {
    if (this._getType(e) !== he.ZodParsedType.symbol) {
      const i = this._getOrReturnCtx(e);
      return (0, G.addIssueToContext)(i, {
        code: ce.ZodIssueCode.invalid_type,
        expected: he.ZodParsedType.symbol,
        received: i.parsedType
      }), G.INVALID;
    }
    return (0, G.OK)(e.data);
  }
}
j.ZodSymbol = pu;
pu.create = (t) => new pu({
  typeName: ke.ZodSymbol,
  ...Oe(t)
});
class ca extends Ve {
  _parse(e) {
    if (this._getType(e) !== he.ZodParsedType.undefined) {
      const i = this._getOrReturnCtx(e);
      return (0, G.addIssueToContext)(i, {
        code: ce.ZodIssueCode.invalid_type,
        expected: he.ZodParsedType.undefined,
        received: i.parsedType
      }), G.INVALID;
    }
    return (0, G.OK)(e.data);
  }
}
j.ZodUndefined = ca;
ca.create = (t) => new ca({
  typeName: ke.ZodUndefined,
  ...Oe(t)
});
class da extends Ve {
  _parse(e) {
    if (this._getType(e) !== he.ZodParsedType.null) {
      const i = this._getOrReturnCtx(e);
      return (0, G.addIssueToContext)(i, {
        code: ce.ZodIssueCode.invalid_type,
        expected: he.ZodParsedType.null,
        received: i.parsedType
      }), G.INVALID;
    }
    return (0, G.OK)(e.data);
  }
}
j.ZodNull = da;
da.create = (t) => new da({
  typeName: ke.ZodNull,
  ...Oe(t)
});
class vs extends Ve {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return (0, G.OK)(e.data);
  }
}
j.ZodAny = vs;
vs.create = (t) => new vs({
  typeName: ke.ZodAny,
  ...Oe(t)
});
class On extends Ve {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return (0, G.OK)(e.data);
  }
}
j.ZodUnknown = On;
On.create = (t) => new On({
  typeName: ke.ZodUnknown,
  ...Oe(t)
});
class en extends Ve {
  _parse(e) {
    const r = this._getOrReturnCtx(e);
    return (0, G.addIssueToContext)(r, {
      code: ce.ZodIssueCode.invalid_type,
      expected: he.ZodParsedType.never,
      received: r.parsedType
    }), G.INVALID;
  }
}
j.ZodNever = en;
en.create = (t) => new en({
  typeName: ke.ZodNever,
  ...Oe(t)
});
class hu extends Ve {
  _parse(e) {
    if (this._getType(e) !== he.ZodParsedType.undefined) {
      const i = this._getOrReturnCtx(e);
      return (0, G.addIssueToContext)(i, {
        code: ce.ZodIssueCode.invalid_type,
        expected: he.ZodParsedType.void,
        received: i.parsedType
      }), G.INVALID;
    }
    return (0, G.OK)(e.data);
  }
}
j.ZodVoid = hu;
hu.create = (t) => new hu({
  typeName: ke.ZodVoid,
  ...Oe(t)
});
class Gr extends Ve {
  _parse(e) {
    const { ctx: r, status: i } = this._processInputParams(e), a = this._def;
    if (r.parsedType !== he.ZodParsedType.array)
      return (0, G.addIssueToContext)(r, {
        code: ce.ZodIssueCode.invalid_type,
        expected: he.ZodParsedType.array,
        received: r.parsedType
      }), G.INVALID;
    if (a.exactLength !== null) {
      const h = r.data.length > a.exactLength.value, m = r.data.length < a.exactLength.value;
      (h || m) && ((0, G.addIssueToContext)(r, {
        code: h ? ce.ZodIssueCode.too_big : ce.ZodIssueCode.too_small,
        minimum: m ? a.exactLength.value : void 0,
        maximum: h ? a.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: a.exactLength.message
      }), i.dirty());
    }
    if (a.minLength !== null && r.data.length < a.minLength.value && ((0, G.addIssueToContext)(r, {
      code: ce.ZodIssueCode.too_small,
      minimum: a.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: a.minLength.message
    }), i.dirty()), a.maxLength !== null && r.data.length > a.maxLength.value && ((0, G.addIssueToContext)(r, {
      code: ce.ZodIssueCode.too_big,
      maximum: a.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: a.maxLength.message
    }), i.dirty()), r.common.async)
      return Promise.all([...r.data].map((h, m) => a.type._parseAsync(new pi(r, h, r.path, m)))).then((h) => G.ParseStatus.mergeArray(i, h));
    const c = [...r.data].map((h, m) => a.type._parseSync(new pi(r, h, r.path, m)));
    return G.ParseStatus.mergeArray(i, c);
  }
  get element() {
    return this._def.type;
  }
  min(e, r) {
    return new Gr({
      ...this._def,
      minLength: { value: e, message: Re.errorUtil.toString(r) }
    });
  }
  max(e, r) {
    return new Gr({
      ...this._def,
      maxLength: { value: e, message: Re.errorUtil.toString(r) }
    });
  }
  length(e, r) {
    return new Gr({
      ...this._def,
      exactLength: { value: e, message: Re.errorUtil.toString(r) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
j.ZodArray = Gr;
Gr.create = (t, e) => new Gr({
  type: t,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: ke.ZodArray,
  ...Oe(e)
});
function ys(t) {
  if (t instanceof pt) {
    const e = {};
    for (const r in t.shape) {
      const i = t.shape[r];
      e[r] = fi.create(ys(i));
    }
    return new pt({
      ...t._def,
      shape: () => e
    });
  } else return t instanceof Gr ? new Gr({
    ...t._def,
    type: ys(t.element)
  }) : t instanceof fi ? fi.create(ys(t.unwrap())) : t instanceof hn ? hn.create(ys(t.unwrap())) : t instanceof hi ? hi.create(t.items.map((e) => ys(e))) : t;
}
class pt extends Ve {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), r = he.util.objectKeys(e);
    return this._cached = { shape: e, keys: r };
  }
  _parse(e) {
    if (this._getType(e) !== he.ZodParsedType.object) {
      const b = this._getOrReturnCtx(e);
      return (0, G.addIssueToContext)(b, {
        code: ce.ZodIssueCode.invalid_type,
        expected: he.ZodParsedType.object,
        received: b.parsedType
      }), G.INVALID;
    }
    const { status: i, ctx: a } = this._processInputParams(e), { shape: c, keys: h } = this._getCached(), m = [];
    if (!(this._def.catchall instanceof en && this._def.unknownKeys === "strip"))
      for (const b in a.data)
        h.includes(b) || m.push(b);
    const p = [];
    for (const b of h) {
      const d = c[b], v = a.data[b];
      p.push({
        key: { status: "valid", value: b },
        value: d._parse(new pi(a, v, a.path, b)),
        alwaysSet: b in a.data
      });
    }
    if (this._def.catchall instanceof en) {
      const b = this._def.unknownKeys;
      if (b === "passthrough")
        for (const d of m)
          p.push({
            key: { status: "valid", value: d },
            value: { status: "valid", value: a.data[d] }
          });
      else if (b === "strict")
        m.length > 0 && ((0, G.addIssueToContext)(a, {
          code: ce.ZodIssueCode.unrecognized_keys,
          keys: m
        }), i.dirty());
      else if (b !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const b = this._def.catchall;
      for (const d of m) {
        const v = a.data[d];
        p.push({
          key: { status: "valid", value: d },
          value: b._parse(
            new pi(a, v, a.path, d)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: d in a.data
        });
      }
    }
    return a.common.async ? Promise.resolve().then(async () => {
      const b = [];
      for (const d of p) {
        const v = await d.key, P = await d.value;
        b.push({
          key: v,
          value: P,
          alwaysSet: d.alwaysSet
        });
      }
      return b;
    }).then((b) => G.ParseStatus.mergeObjectSync(i, b)) : G.ParseStatus.mergeObjectSync(i, p);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return Re.errorUtil.errToObj, new pt({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (r, i) => {
          var a, c, h, m;
          const p = (h = (c = (a = this._def).errorMap) === null || c === void 0 ? void 0 : c.call(a, r, i).message) !== null && h !== void 0 ? h : i.defaultError;
          return r.code === "unrecognized_keys" ? {
            message: (m = Re.errorUtil.errToObj(e).message) !== null && m !== void 0 ? m : p
          } : {
            message: p
          };
        }
      } : {}
    });
  }
  strip() {
    return new pt({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new pt({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new pt({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new pt({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: ke.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, r) {
    return this.augment({ [e]: r });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new pt({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const r = {};
    return he.util.objectKeys(e).forEach((i) => {
      e[i] && this.shape[i] && (r[i] = this.shape[i]);
    }), new pt({
      ...this._def,
      shape: () => r
    });
  }
  omit(e) {
    const r = {};
    return he.util.objectKeys(this.shape).forEach((i) => {
      e[i] || (r[i] = this.shape[i]);
    }), new pt({
      ...this._def,
      shape: () => r
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return ys(this);
  }
  partial(e) {
    const r = {};
    return he.util.objectKeys(this.shape).forEach((i) => {
      const a = this.shape[i];
      e && !e[i] ? r[i] = a : r[i] = a.optional();
    }), new pt({
      ...this._def,
      shape: () => r
    });
  }
  required(e) {
    const r = {};
    return he.util.objectKeys(this.shape).forEach((i) => {
      if (e && !e[i])
        r[i] = this.shape[i];
      else {
        let c = this.shape[i];
        for (; c instanceof fi; )
          c = c._def.innerType;
        r[i] = c;
      }
    }), new pt({
      ...this._def,
      shape: () => r
    });
  }
  keyof() {
    return up(he.util.objectKeys(this.shape));
  }
}
j.ZodObject = pt;
pt.create = (t, e) => new pt({
  shape: () => t,
  unknownKeys: "strip",
  catchall: en.create(),
  typeName: ke.ZodObject,
  ...Oe(e)
});
pt.strictCreate = (t, e) => new pt({
  shape: () => t,
  unknownKeys: "strict",
  catchall: en.create(),
  typeName: ke.ZodObject,
  ...Oe(e)
});
pt.lazycreate = (t, e) => new pt({
  shape: t,
  unknownKeys: "strip",
  catchall: en.create(),
  typeName: ke.ZodObject,
  ...Oe(e)
});
class fa extends Ve {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), i = this._def.options;
    function a(c) {
      for (const m of c)
        if (m.result.status === "valid")
          return m.result;
      for (const m of c)
        if (m.result.status === "dirty")
          return r.common.issues.push(...m.ctx.common.issues), m.result;
      const h = c.map((m) => new ce.ZodError(m.ctx.common.issues));
      return (0, G.addIssueToContext)(r, {
        code: ce.ZodIssueCode.invalid_union,
        unionErrors: h
      }), G.INVALID;
    }
    if (r.common.async)
      return Promise.all(i.map(async (c) => {
        const h = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await c._parseAsync({
            data: r.data,
            path: r.path,
            parent: h
          }),
          ctx: h
        };
      })).then(a);
    {
      let c;
      const h = [];
      for (const p of i) {
        const b = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        }, d = p._parseSync({
          data: r.data,
          path: r.path,
          parent: b
        });
        if (d.status === "valid")
          return d;
        d.status === "dirty" && !c && (c = { result: d, ctx: b }), b.common.issues.length && h.push(b.common.issues);
      }
      if (c)
        return r.common.issues.push(...c.ctx.common.issues), c.result;
      const m = h.map((p) => new ce.ZodError(p));
      return (0, G.addIssueToContext)(r, {
        code: ce.ZodIssueCode.invalid_union,
        unionErrors: m
      }), G.INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
j.ZodUnion = fa;
fa.create = (t, e) => new fa({
  options: t,
  typeName: ke.ZodUnion,
  ...Oe(e)
});
const ki = (t) => t instanceof ma ? ki(t.schema) : t instanceof qr ? ki(t.innerType()) : t instanceof ya ? [t.value] : t instanceof pn ? t.options : t instanceof ba ? he.util.objectValues(t.enum) : t instanceof ga ? ki(t._def.innerType) : t instanceof ca ? [void 0] : t instanceof da ? [null] : t instanceof fi ? [void 0, ...ki(t.unwrap())] : t instanceof hn ? [null, ...ki(t.unwrap())] : t instanceof Kc || t instanceof Ea ? ki(t.unwrap()) : t instanceof xa ? ki(t._def.innerType) : [];
class Pu extends Ve {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== he.ZodParsedType.object)
      return (0, G.addIssueToContext)(r, {
        code: ce.ZodIssueCode.invalid_type,
        expected: he.ZodParsedType.object,
        received: r.parsedType
      }), G.INVALID;
    const i = this.discriminator, a = r.data[i], c = this.optionsMap.get(a);
    return c ? r.common.async ? c._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }) : c._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }) : ((0, G.addIssueToContext)(r, {
      code: ce.ZodIssueCode.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [i]
    }), G.INVALID);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(e, r, i) {
    const a = /* @__PURE__ */ new Map();
    for (const c of r) {
      const h = ki(c.shape[e]);
      if (!h.length)
        throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
      for (const m of h) {
        if (a.has(m))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(m)}`);
        a.set(m, c);
      }
    }
    return new Pu({
      typeName: ke.ZodDiscriminatedUnion,
      discriminator: e,
      options: r,
      optionsMap: a,
      ...Oe(i)
    });
  }
}
j.ZodDiscriminatedUnion = Pu;
function Tc(t, e) {
  const r = (0, he.getParsedType)(t), i = (0, he.getParsedType)(e);
  if (t === e)
    return { valid: !0, data: t };
  if (r === he.ZodParsedType.object && i === he.ZodParsedType.object) {
    const a = he.util.objectKeys(e), c = he.util.objectKeys(t).filter((m) => a.indexOf(m) !== -1), h = { ...t, ...e };
    for (const m of c) {
      const p = Tc(t[m], e[m]);
      if (!p.valid)
        return { valid: !1 };
      h[m] = p.data;
    }
    return { valid: !0, data: h };
  } else if (r === he.ZodParsedType.array && i === he.ZodParsedType.array) {
    if (t.length !== e.length)
      return { valid: !1 };
    const a = [];
    for (let c = 0; c < t.length; c++) {
      const h = t[c], m = e[c], p = Tc(h, m);
      if (!p.valid)
        return { valid: !1 };
      a.push(p.data);
    }
    return { valid: !0, data: a };
  } else return r === he.ZodParsedType.date && i === he.ZodParsedType.date && +t == +e ? { valid: !0, data: t } : { valid: !1 };
}
class pa extends Ve {
  _parse(e) {
    const { status: r, ctx: i } = this._processInputParams(e), a = (c, h) => {
      if ((0, G.isAborted)(c) || (0, G.isAborted)(h))
        return G.INVALID;
      const m = Tc(c.value, h.value);
      return m.valid ? (((0, G.isDirty)(c) || (0, G.isDirty)(h)) && r.dirty(), { status: r.value, value: m.data }) : ((0, G.addIssueToContext)(i, {
        code: ce.ZodIssueCode.invalid_intersection_types
      }), G.INVALID);
    };
    return i.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: i.data,
        path: i.path,
        parent: i
      }),
      this._def.right._parseAsync({
        data: i.data,
        path: i.path,
        parent: i
      })
    ]).then(([c, h]) => a(c, h)) : a(this._def.left._parseSync({
      data: i.data,
      path: i.path,
      parent: i
    }), this._def.right._parseSync({
      data: i.data,
      path: i.path,
      parent: i
    }));
  }
}
j.ZodIntersection = pa;
pa.create = (t, e, r) => new pa({
  left: t,
  right: e,
  typeName: ke.ZodIntersection,
  ...Oe(r)
});
class hi extends Ve {
  _parse(e) {
    const { status: r, ctx: i } = this._processInputParams(e);
    if (i.parsedType !== he.ZodParsedType.array)
      return (0, G.addIssueToContext)(i, {
        code: ce.ZodIssueCode.invalid_type,
        expected: he.ZodParsedType.array,
        received: i.parsedType
      }), G.INVALID;
    if (i.data.length < this._def.items.length)
      return (0, G.addIssueToContext)(i, {
        code: ce.ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), G.INVALID;
    !this._def.rest && i.data.length > this._def.items.length && ((0, G.addIssueToContext)(i, {
      code: ce.ZodIssueCode.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), r.dirty());
    const c = [...i.data].map((h, m) => {
      const p = this._def.items[m] || this._def.rest;
      return p ? p._parse(new pi(i, h, i.path, m)) : null;
    }).filter((h) => !!h);
    return i.common.async ? Promise.all(c).then((h) => G.ParseStatus.mergeArray(r, h)) : G.ParseStatus.mergeArray(r, c);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new hi({
      ...this._def,
      rest: e
    });
  }
}
j.ZodTuple = hi;
hi.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new hi({
    items: t,
    typeName: ke.ZodTuple,
    rest: null,
    ...Oe(e)
  });
};
class ha extends Ve {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: r, ctx: i } = this._processInputParams(e);
    if (i.parsedType !== he.ZodParsedType.object)
      return (0, G.addIssueToContext)(i, {
        code: ce.ZodIssueCode.invalid_type,
        expected: he.ZodParsedType.object,
        received: i.parsedType
      }), G.INVALID;
    const a = [], c = this._def.keyType, h = this._def.valueType;
    for (const m in i.data)
      a.push({
        key: c._parse(new pi(i, m, i.path, m)),
        value: h._parse(new pi(i, i.data[m], i.path, m)),
        alwaysSet: m in i.data
      });
    return i.common.async ? G.ParseStatus.mergeObjectAsync(r, a) : G.ParseStatus.mergeObjectSync(r, a);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, r, i) {
    return r instanceof Ve ? new ha({
      keyType: e,
      valueType: r,
      typeName: ke.ZodRecord,
      ...Oe(i)
    }) : new ha({
      keyType: Mr.create(),
      valueType: e,
      typeName: ke.ZodRecord,
      ...Oe(r)
    });
  }
}
j.ZodRecord = ha;
class mu extends Ve {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: r, ctx: i } = this._processInputParams(e);
    if (i.parsedType !== he.ZodParsedType.map)
      return (0, G.addIssueToContext)(i, {
        code: ce.ZodIssueCode.invalid_type,
        expected: he.ZodParsedType.map,
        received: i.parsedType
      }), G.INVALID;
    const a = this._def.keyType, c = this._def.valueType, h = [...i.data.entries()].map(([m, p], b) => ({
      key: a._parse(new pi(i, m, i.path, [b, "key"])),
      value: c._parse(new pi(i, p, i.path, [b, "value"]))
    }));
    if (i.common.async) {
      const m = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const p of h) {
          const b = await p.key, d = await p.value;
          if (b.status === "aborted" || d.status === "aborted")
            return G.INVALID;
          (b.status === "dirty" || d.status === "dirty") && r.dirty(), m.set(b.value, d.value);
        }
        return { status: r.value, value: m };
      });
    } else {
      const m = /* @__PURE__ */ new Map();
      for (const p of h) {
        const b = p.key, d = p.value;
        if (b.status === "aborted" || d.status === "aborted")
          return G.INVALID;
        (b.status === "dirty" || d.status === "dirty") && r.dirty(), m.set(b.value, d.value);
      }
      return { status: r.value, value: m };
    }
  }
}
j.ZodMap = mu;
mu.create = (t, e, r) => new mu({
  valueType: e,
  keyType: t,
  typeName: ke.ZodMap,
  ...Oe(r)
});
class Mn extends Ve {
  _parse(e) {
    const { status: r, ctx: i } = this._processInputParams(e);
    if (i.parsedType !== he.ZodParsedType.set)
      return (0, G.addIssueToContext)(i, {
        code: ce.ZodIssueCode.invalid_type,
        expected: he.ZodParsedType.set,
        received: i.parsedType
      }), G.INVALID;
    const a = this._def;
    a.minSize !== null && i.data.size < a.minSize.value && ((0, G.addIssueToContext)(i, {
      code: ce.ZodIssueCode.too_small,
      minimum: a.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: a.minSize.message
    }), r.dirty()), a.maxSize !== null && i.data.size > a.maxSize.value && ((0, G.addIssueToContext)(i, {
      code: ce.ZodIssueCode.too_big,
      maximum: a.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: a.maxSize.message
    }), r.dirty());
    const c = this._def.valueType;
    function h(p) {
      const b = /* @__PURE__ */ new Set();
      for (const d of p) {
        if (d.status === "aborted")
          return G.INVALID;
        d.status === "dirty" && r.dirty(), b.add(d.value);
      }
      return { status: r.value, value: b };
    }
    const m = [...i.data.values()].map((p, b) => c._parse(new pi(i, p, i.path, b)));
    return i.common.async ? Promise.all(m).then((p) => h(p)) : h(m);
  }
  min(e, r) {
    return new Mn({
      ...this._def,
      minSize: { value: e, message: Re.errorUtil.toString(r) }
    });
  }
  max(e, r) {
    return new Mn({
      ...this._def,
      maxSize: { value: e, message: Re.errorUtil.toString(r) }
    });
  }
  size(e, r) {
    return this.min(e, r).max(e, r);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
j.ZodSet = Mn;
Mn.create = (t, e) => new Mn({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: ke.ZodSet,
  ...Oe(e)
});
class xs extends Ve {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== he.ZodParsedType.function)
      return (0, G.addIssueToContext)(r, {
        code: ce.ZodIssueCode.invalid_type,
        expected: he.ZodParsedType.function,
        received: r.parsedType
      }), G.INVALID;
    function i(m, p) {
      return (0, G.makeIssue)({
        data: m,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          (0, Jl.getErrorMap)(),
          Jl.defaultErrorMap
        ].filter((b) => !!b),
        issueData: {
          code: ce.ZodIssueCode.invalid_arguments,
          argumentsError: p
        }
      });
    }
    function a(m, p) {
      return (0, G.makeIssue)({
        data: m,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          (0, Jl.getErrorMap)(),
          Jl.defaultErrorMap
        ].filter((b) => !!b),
        issueData: {
          code: ce.ZodIssueCode.invalid_return_type,
          returnTypeError: p
        }
      });
    }
    const c = { errorMap: r.common.contextualErrorMap }, h = r.data;
    if (this._def.returns instanceof Rs) {
      const m = this;
      return (0, G.OK)(async function(...p) {
        const b = new ce.ZodError([]), d = await m._def.args.parseAsync(p, c).catch((M) => {
          throw b.addIssue(i(p, M)), b;
        }), v = await Reflect.apply(h, this, d);
        return await m._def.returns._def.type.parseAsync(v, c).catch((M) => {
          throw b.addIssue(a(v, M)), b;
        });
      });
    } else {
      const m = this;
      return (0, G.OK)(function(...p) {
        const b = m._def.args.safeParse(p, c);
        if (!b.success)
          throw new ce.ZodError([i(p, b.error)]);
        const d = Reflect.apply(h, this, b.data), v = m._def.returns.safeParse(d, c);
        if (!v.success)
          throw new ce.ZodError([a(d, v.error)]);
        return v.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new xs({
      ...this._def,
      args: hi.create(e).rest(On.create())
    });
  }
  returns(e) {
    return new xs({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, r, i) {
    return new xs({
      args: e || hi.create([]).rest(On.create()),
      returns: r || On.create(),
      typeName: ke.ZodFunction,
      ...Oe(i)
    });
  }
}
j.ZodFunction = xs;
class ma extends Ve {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
  }
}
j.ZodLazy = ma;
ma.create = (t, e) => new ma({
  getter: t,
  typeName: ke.ZodLazy,
  ...Oe(e)
});
class ya extends Ve {
  _parse(e) {
    if (e.data !== this._def.value) {
      const r = this._getOrReturnCtx(e);
      return (0, G.addIssueToContext)(r, {
        received: r.data,
        code: ce.ZodIssueCode.invalid_literal,
        expected: this._def.value
      }), G.INVALID;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
j.ZodLiteral = ya;
ya.create = (t, e) => new ya({
  value: t,
  typeName: ke.ZodLiteral,
  ...Oe(e)
});
function up(t, e) {
  return new pn({
    values: t,
    typeName: ke.ZodEnum,
    ...Oe(e)
  });
}
class pn extends Ve {
  constructor() {
    super(...arguments), na.set(this, void 0);
  }
  _parse(e) {
    if (typeof e.data != "string") {
      const r = this._getOrReturnCtx(e), i = this._def.values;
      return (0, G.addIssueToContext)(r, {
        expected: he.util.joinValues(i),
        received: r.parsedType,
        code: ce.ZodIssueCode.invalid_type
      }), G.INVALID;
    }
    if (fu(this, na, "f") || sp(this, na, new Set(this._def.values), "f"), !fu(this, na, "f").has(e.data)) {
      const r = this._getOrReturnCtx(e), i = this._def.values;
      return (0, G.addIssueToContext)(r, {
        received: r.data,
        code: ce.ZodIssueCode.invalid_enum_value,
        options: i
      }), G.INVALID;
    }
    return (0, G.OK)(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  get Values() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  get Enum() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  extract(e, r = this._def) {
    return pn.create(e, {
      ...this._def,
      ...r
    });
  }
  exclude(e, r = this._def) {
    return pn.create(this.options.filter((i) => !e.includes(i)), {
      ...this._def,
      ...r
    });
  }
}
j.ZodEnum = pn;
na = /* @__PURE__ */ new WeakMap();
pn.create = up;
class ba extends Ve {
  constructor() {
    super(...arguments), sa.set(this, void 0);
  }
  _parse(e) {
    const r = he.util.getValidEnumValues(this._def.values), i = this._getOrReturnCtx(e);
    if (i.parsedType !== he.ZodParsedType.string && i.parsedType !== he.ZodParsedType.number) {
      const a = he.util.objectValues(r);
      return (0, G.addIssueToContext)(i, {
        expected: he.util.joinValues(a),
        received: i.parsedType,
        code: ce.ZodIssueCode.invalid_type
      }), G.INVALID;
    }
    if (fu(this, sa, "f") || sp(this, sa, new Set(he.util.getValidEnumValues(this._def.values)), "f"), !fu(this, sa, "f").has(e.data)) {
      const a = he.util.objectValues(r);
      return (0, G.addIssueToContext)(i, {
        received: i.data,
        code: ce.ZodIssueCode.invalid_enum_value,
        options: a
      }), G.INVALID;
    }
    return (0, G.OK)(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
j.ZodNativeEnum = ba;
sa = /* @__PURE__ */ new WeakMap();
ba.create = (t, e) => new ba({
  values: t,
  typeName: ke.ZodNativeEnum,
  ...Oe(e)
});
class Rs extends Ve {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== he.ZodParsedType.promise && r.common.async === !1)
      return (0, G.addIssueToContext)(r, {
        code: ce.ZodIssueCode.invalid_type,
        expected: he.ZodParsedType.promise,
        received: r.parsedType
      }), G.INVALID;
    const i = r.parsedType === he.ZodParsedType.promise ? r.data : Promise.resolve(r.data);
    return (0, G.OK)(i.then((a) => this._def.type.parseAsync(a, {
      path: r.path,
      errorMap: r.common.contextualErrorMap
    })));
  }
}
j.ZodPromise = Rs;
Rs.create = (t, e) => new Rs({
  type: t,
  typeName: ke.ZodPromise,
  ...Oe(e)
});
class qr extends Ve {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ke.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: r, ctx: i } = this._processInputParams(e), a = this._def.effect || null, c = {
      addIssue: (h) => {
        (0, G.addIssueToContext)(i, h), h.fatal ? r.abort() : r.dirty();
      },
      get path() {
        return i.path;
      }
    };
    if (c.addIssue = c.addIssue.bind(c), a.type === "preprocess") {
      const h = a.transform(i.data, c);
      if (i.common.async)
        return Promise.resolve(h).then(async (m) => {
          if (r.value === "aborted")
            return G.INVALID;
          const p = await this._def.schema._parseAsync({
            data: m,
            path: i.path,
            parent: i
          });
          return p.status === "aborted" ? G.INVALID : p.status === "dirty" || r.value === "dirty" ? (0, G.DIRTY)(p.value) : p;
        });
      {
        if (r.value === "aborted")
          return G.INVALID;
        const m = this._def.schema._parseSync({
          data: h,
          path: i.path,
          parent: i
        });
        return m.status === "aborted" ? G.INVALID : m.status === "dirty" || r.value === "dirty" ? (0, G.DIRTY)(m.value) : m;
      }
    }
    if (a.type === "refinement") {
      const h = (m) => {
        const p = a.refinement(m, c);
        if (i.common.async)
          return Promise.resolve(p);
        if (p instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return m;
      };
      if (i.common.async === !1) {
        const m = this._def.schema._parseSync({
          data: i.data,
          path: i.path,
          parent: i
        });
        return m.status === "aborted" ? G.INVALID : (m.status === "dirty" && r.dirty(), h(m.value), { status: r.value, value: m.value });
      } else
        return this._def.schema._parseAsync({ data: i.data, path: i.path, parent: i }).then((m) => m.status === "aborted" ? G.INVALID : (m.status === "dirty" && r.dirty(), h(m.value).then(() => ({ status: r.value, value: m.value }))));
    }
    if (a.type === "transform")
      if (i.common.async === !1) {
        const h = this._def.schema._parseSync({
          data: i.data,
          path: i.path,
          parent: i
        });
        if (!(0, G.isValid)(h))
          return h;
        const m = a.transform(h.value, c);
        if (m instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: r.value, value: m };
      } else
        return this._def.schema._parseAsync({ data: i.data, path: i.path, parent: i }).then((h) => (0, G.isValid)(h) ? Promise.resolve(a.transform(h.value, c)).then((m) => ({ status: r.value, value: m })) : h);
    he.util.assertNever(a);
  }
}
j.ZodEffects = qr;
j.ZodTransformer = qr;
qr.create = (t, e, r) => new qr({
  schema: t,
  typeName: ke.ZodEffects,
  effect: e,
  ...Oe(r)
});
qr.createWithPreprocess = (t, e, r) => new qr({
  schema: e,
  effect: { type: "preprocess", transform: t },
  typeName: ke.ZodEffects,
  ...Oe(r)
});
class fi extends Ve {
  _parse(e) {
    return this._getType(e) === he.ZodParsedType.undefined ? (0, G.OK)(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
j.ZodOptional = fi;
fi.create = (t, e) => new fi({
  innerType: t,
  typeName: ke.ZodOptional,
  ...Oe(e)
});
class hn extends Ve {
  _parse(e) {
    return this._getType(e) === he.ZodParsedType.null ? (0, G.OK)(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
j.ZodNullable = hn;
hn.create = (t, e) => new hn({
  innerType: t,
  typeName: ke.ZodNullable,
  ...Oe(e)
});
class ga extends Ve {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    let i = r.data;
    return r.parsedType === he.ZodParsedType.undefined && (i = this._def.defaultValue()), this._def.innerType._parse({
      data: i,
      path: r.path,
      parent: r
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
j.ZodDefault = ga;
ga.create = (t, e) => new ga({
  innerType: t,
  typeName: ke.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...Oe(e)
});
class xa extends Ve {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), i = {
      ...r,
      common: {
        ...r.common,
        issues: []
      }
    }, a = this._def.innerType._parse({
      data: i.data,
      path: i.path,
      parent: {
        ...i
      }
    });
    return (0, G.isAsync)(a) ? a.then((c) => ({
      status: "valid",
      value: c.status === "valid" ? c.value : this._def.catchValue({
        get error() {
          return new ce.ZodError(i.common.issues);
        },
        input: i.data
      })
    })) : {
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new ce.ZodError(i.common.issues);
        },
        input: i.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
j.ZodCatch = xa;
xa.create = (t, e) => new xa({
  innerType: t,
  typeName: ke.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...Oe(e)
});
class yu extends Ve {
  _parse(e) {
    if (this._getType(e) !== he.ZodParsedType.nan) {
      const i = this._getOrReturnCtx(e);
      return (0, G.addIssueToContext)(i, {
        code: ce.ZodIssueCode.invalid_type,
        expected: he.ZodParsedType.nan,
        received: i.parsedType
      }), G.INVALID;
    }
    return { status: "valid", value: e.data };
  }
}
j.ZodNaN = yu;
yu.create = (t) => new yu({
  typeName: ke.ZodNaN,
  ...Oe(t)
});
j.BRAND = Symbol("zod_brand");
class Kc extends Ve {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), i = r.data;
    return this._def.type._parse({
      data: i,
      path: r.path,
      parent: r
    });
  }
  unwrap() {
    return this._def.type;
  }
}
j.ZodBranded = Kc;
class Sa extends Ve {
  _parse(e) {
    const { status: r, ctx: i } = this._processInputParams(e);
    if (i.common.async)
      return (async () => {
        const c = await this._def.in._parseAsync({
          data: i.data,
          path: i.path,
          parent: i
        });
        return c.status === "aborted" ? G.INVALID : c.status === "dirty" ? (r.dirty(), (0, G.DIRTY)(c.value)) : this._def.out._parseAsync({
          data: c.value,
          path: i.path,
          parent: i
        });
      })();
    {
      const a = this._def.in._parseSync({
        data: i.data,
        path: i.path,
        parent: i
      });
      return a.status === "aborted" ? G.INVALID : a.status === "dirty" ? (r.dirty(), {
        status: "dirty",
        value: a.value
      }) : this._def.out._parseSync({
        data: a.value,
        path: i.path,
        parent: i
      });
    }
  }
  static create(e, r) {
    return new Sa({
      in: e,
      out: r,
      typeName: ke.ZodPipeline
    });
  }
}
j.ZodPipeline = Sa;
class Ea extends Ve {
  _parse(e) {
    const r = this._def.innerType._parse(e), i = (a) => ((0, G.isValid)(a) && (a.value = Object.freeze(a.value)), a);
    return (0, G.isAsync)(r) ? r.then((a) => i(a)) : i(r);
  }
  unwrap() {
    return this._def.innerType;
  }
}
j.ZodReadonly = Ea;
Ea.create = (t, e) => new Ea({
  innerType: t,
  typeName: ke.ZodReadonly,
  ...Oe(e)
});
function cp(t, e = {}, r) {
  return t ? vs.create().superRefine((i, a) => {
    var c, h;
    if (!t(i)) {
      const m = typeof e == "function" ? e(i) : typeof e == "string" ? { message: e } : e, p = (h = (c = m.fatal) !== null && c !== void 0 ? c : r) !== null && h !== void 0 ? h : !0, b = typeof m == "string" ? { message: m } : m;
      a.addIssue({ code: "custom", ...b, fatal: p });
    }
  }) : vs.create();
}
j.custom = cp;
j.late = {
  object: pt.lazycreate
};
var ke;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline", t.ZodReadonly = "ZodReadonly";
})(ke || (j.ZodFirstPartyTypeKind = ke = {}));
const ag = (t, e = {
  message: `Input not instance of ${t.name}`
}) => cp((r) => r instanceof t, e);
j.instanceof = ag;
const dp = Mr.create;
j.string = dp;
const fp = dn.create;
j.number = fp;
const og = yu.create;
j.nan = og;
const lg = fn.create;
j.bigint = lg;
const pp = ua.create;
j.boolean = pp;
const ug = Kn.create;
j.date = ug;
const cg = pu.create;
j.symbol = cg;
const dg = ca.create;
j.undefined = dg;
const fg = da.create;
j.null = fg;
const pg = vs.create;
j.any = pg;
const hg = On.create;
j.unknown = hg;
const mg = en.create;
j.never = mg;
const yg = hu.create;
j.void = yg;
const bg = Gr.create;
j.array = bg;
const gg = pt.create;
j.object = gg;
const xg = pt.strictCreate;
j.strictObject = xg;
const Eg = fa.create;
j.union = Eg;
const vg = Pu.create;
j.discriminatedUnion = vg;
const Rg = pa.create;
j.intersection = Rg;
const Ag = hi.create;
j.tuple = Ag;
const _g = ha.create;
j.record = _g;
const wg = mu.create;
j.map = wg;
const Tg = Mn.create;
j.set = Tg;
const Sg = xs.create;
j.function = Sg;
const Cg = ma.create;
j.lazy = Cg;
const Lg = ya.create;
j.literal = Lg;
const kg = pn.create;
j.enum = kg;
const Dg = ba.create;
j.nativeEnum = Dg;
const Pg = Rs.create;
j.promise = Pg;
const hp = qr.create;
j.effect = hp;
j.transformer = hp;
const Bg = fi.create;
j.optional = Bg;
const Ig = hn.create;
j.nullable = Ig;
const Ug = qr.createWithPreprocess;
j.preprocess = Ug;
const Og = Sa.create;
j.pipeline = Og;
const Kg = () => dp().optional();
j.ostring = Kg;
const Mg = () => fp().optional();
j.onumber = Mg;
const Ng = () => pp().optional();
j.oboolean = Ng;
j.coerce = {
  string: (t) => Mr.create({ ...t, coerce: !0 }),
  number: (t) => dn.create({ ...t, coerce: !0 }),
  boolean: (t) => ua.create({
    ...t,
    coerce: !0
  }),
  bigint: (t) => fn.create({ ...t, coerce: !0 }),
  date: (t) => Kn.create({ ...t, coerce: !0 })
};
j.NEVER = G.INVALID;
(function(t) {
  var e = ne && ne.__createBinding || (Object.create ? function(i, a, c, h) {
    h === void 0 && (h = c);
    var m = Object.getOwnPropertyDescriptor(a, c);
    (!m || ("get" in m ? !a.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
      return a[c];
    } }), Object.defineProperty(i, h, m);
  } : function(i, a, c, h) {
    h === void 0 && (h = c), i[h] = a[c];
  }), r = ne && ne.__exportStar || function(i, a) {
    for (var c in i) c !== "default" && !Object.prototype.hasOwnProperty.call(a, c) && e(a, i, c);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), r(ci, t), r(Oc, t), r(np, t), r(Ta, t), r(j, t), r(di, t);
})(wc);
(function(t) {
  var e = ne && ne.__createBinding || (Object.create ? function(h, m, p, b) {
    b === void 0 && (b = p);
    var d = Object.getOwnPropertyDescriptor(m, p);
    (!d || ("get" in d ? !m.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return m[p];
    } }), Object.defineProperty(h, b, d);
  } : function(h, m, p, b) {
    b === void 0 && (b = p), h[b] = m[p];
  }), r = ne && ne.__setModuleDefault || (Object.create ? function(h, m) {
    Object.defineProperty(h, "default", { enumerable: !0, value: m });
  } : function(h, m) {
    h.default = m;
  }), i = ne && ne.__importStar || function(h) {
    if (h && h.__esModule) return h;
    var m = {};
    if (h != null) for (var p in h) p !== "default" && Object.prototype.hasOwnProperty.call(h, p) && e(m, h, p);
    return r(m, h), m;
  }, a = ne && ne.__exportStar || function(h, m) {
    for (var p in h) p !== "default" && !Object.prototype.hasOwnProperty.call(m, p) && e(m, h, p);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.z = void 0;
  const c = i(wc);
  t.z = c, a(wc, t), t.default = c;
})(os);
var ls = {};
Object.defineProperty(ls, "__esModule", { value: !0 });
ls.toLexUri = Vg;
ls.toConcreteTypes = jg;
ls.requiredPropertiesRefinement = Fg;
const cc = os;
function Vg(t, e) {
  if (t.split("#").length > 2)
    throw new Error("Uri can only have one hash segment");
  if (t.startsWith("lex:"))
    return t;
  if (t.startsWith("#")) {
    if (!e)
      throw new Error(`Unable to resolve uri without anchor: ${t}`);
    return `${e}${t}`;
  }
  return `lex:${t}`;
}
function jg(t, e) {
  return e.type === "ref" ? [t.getDefOrThrow(e.ref)] : e.type === "union" ? e.refs.map((r) => t.getDefOrThrow(r)).flat() : [e];
}
function Fg(t, e) {
  if (t.required !== void 0) {
    if (!Array.isArray(t.required)) {
      e.addIssue({
        code: cc.z.ZodIssueCode.invalid_type,
        received: typeof t.required,
        expected: "array"
      });
      return;
    }
    if (t.properties === void 0) {
      t.required.length > 0 && e.addIssue({
        code: cc.z.ZodIssueCode.custom,
        message: "Required fields defined but no properties defined"
      });
      return;
    }
    for (const r of t.required)
      t.properties[r] === void 0 && e.addIssue({
        code: cc.z.ZodIssueCode.custom,
        message: `Required field "${r}" not defined`
      });
  }
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.LexiconDefNotFoundError = t.InvalidLexiconError = t.ValidationError = t.discriminatedObject = t.lexiconDoc = t.lexUserType = t.lexRecord = t.lexXrpcSubscription = t.lexXrpcProcedure = t.lexXrpcQuery = t.lexXrpcError = t.lexXrpcSubscriptionMessage = t.lexXrpcBody = t.lexXrpcParameters = t.lexObject = t.lexToken = t.lexPrimitiveArray = t.lexArray = t.lexBlob = t.lexRefVariant = t.lexRefUnion = t.lexRef = t.lexIpldType = t.lexCidLink = t.lexBytes = t.lexPrimitive = t.lexUnknown = t.lexString = t.lexStringFormat = t.lexInteger = t.lexBoolean = void 0, t.isValidLexiconDoc = a, t.isObj = c, t.hasProp = h, t.isDiscriminatedObject = m, t.parseLexiconDoc = p;
  const e = os, r = as, i = ls;
  t.lexBoolean = e.z.object({
    type: e.z.literal("boolean"),
    description: e.z.string().optional(),
    default: e.z.boolean().optional(),
    const: e.z.boolean().optional()
  }).strict(), t.lexInteger = e.z.object({
    type: e.z.literal("integer"),
    description: e.z.string().optional(),
    default: e.z.number().int().optional(),
    minimum: e.z.number().int().optional(),
    maximum: e.z.number().int().optional(),
    enum: e.z.number().int().array().optional(),
    const: e.z.number().int().optional()
  }).strict(), t.lexStringFormat = e.z.enum([
    "datetime",
    "uri",
    "at-uri",
    "did",
    "handle",
    "at-identifier",
    "nsid",
    "cid",
    "language",
    "tid",
    "record-key"
  ]), t.lexString = e.z.object({
    type: e.z.literal("string"),
    format: t.lexStringFormat.optional(),
    description: e.z.string().optional(),
    default: e.z.string().optional(),
    minLength: e.z.number().int().optional(),
    maxLength: e.z.number().int().optional(),
    minGraphemes: e.z.number().int().optional(),
    maxGraphemes: e.z.number().int().optional(),
    enum: e.z.string().array().optional(),
    const: e.z.string().optional(),
    knownValues: e.z.string().array().optional()
  }).strict(), t.lexUnknown = e.z.object({
    type: e.z.literal("unknown"),
    description: e.z.string().optional()
  }).strict(), t.lexPrimitive = e.z.discriminatedUnion("type", [
    t.lexBoolean,
    t.lexInteger,
    t.lexString,
    t.lexUnknown
  ]), t.lexBytes = e.z.object({
    type: e.z.literal("bytes"),
    description: e.z.string().optional(),
    maxLength: e.z.number().optional(),
    minLength: e.z.number().optional()
  }).strict(), t.lexCidLink = e.z.object({
    type: e.z.literal("cid-link"),
    description: e.z.string().optional()
  }).strict(), t.lexIpldType = e.z.discriminatedUnion("type", [t.lexBytes, t.lexCidLink]), t.lexRef = e.z.object({
    type: e.z.literal("ref"),
    description: e.z.string().optional(),
    ref: e.z.string()
  }).strict(), t.lexRefUnion = e.z.object({
    type: e.z.literal("union"),
    description: e.z.string().optional(),
    refs: e.z.string().array(),
    closed: e.z.boolean().optional()
  }).strict(), t.lexRefVariant = e.z.discriminatedUnion("type", [t.lexRef, t.lexRefUnion]), t.lexBlob = e.z.object({
    type: e.z.literal("blob"),
    description: e.z.string().optional(),
    accept: e.z.string().array().optional(),
    maxSize: e.z.number().optional()
  }).strict(), t.lexArray = e.z.object({
    type: e.z.literal("array"),
    description: e.z.string().optional(),
    items: e.z.discriminatedUnion("type", [
      // lexPrimitive
      t.lexBoolean,
      t.lexInteger,
      t.lexString,
      t.lexUnknown,
      // lexIpldType
      t.lexBytes,
      t.lexCidLink,
      // lexRefVariant
      t.lexRef,
      t.lexRefUnion,
      // other
      t.lexBlob
    ]),
    minLength: e.z.number().int().optional(),
    maxLength: e.z.number().int().optional()
  }).strict(), t.lexPrimitiveArray = t.lexArray.merge(e.z.object({
    items: t.lexPrimitive
  }).strict()), t.lexToken = e.z.object({
    type: e.z.literal("token"),
    description: e.z.string().optional()
  }).strict(), t.lexObject = e.z.object({
    type: e.z.literal("object"),
    description: e.z.string().optional(),
    required: e.z.string().array().optional(),
    nullable: e.z.string().array().optional(),
    properties: e.z.record(e.z.discriminatedUnion("type", [
      t.lexArray,
      // lexPrimitive
      t.lexBoolean,
      t.lexInteger,
      t.lexString,
      t.lexUnknown,
      // lexIpldType
      t.lexBytes,
      t.lexCidLink,
      // lexRefVariant
      t.lexRef,
      t.lexRefUnion,
      // other
      t.lexBlob
    ]))
  }).strict().superRefine(i.requiredPropertiesRefinement), t.lexXrpcParameters = e.z.object({
    type: e.z.literal("params"),
    description: e.z.string().optional(),
    required: e.z.string().array().optional(),
    properties: e.z.record(e.z.discriminatedUnion("type", [
      t.lexPrimitiveArray,
      // lexPrimitive
      t.lexBoolean,
      t.lexInteger,
      t.lexString,
      t.lexUnknown
    ]))
  }).strict().superRefine(i.requiredPropertiesRefinement), t.lexXrpcBody = e.z.object({
    description: e.z.string().optional(),
    encoding: e.z.string(),
    // @NOTE using discriminatedUnion with a refined schema requires zod >= 4
    schema: e.z.union([t.lexRefVariant, t.lexObject]).optional()
  }).strict(), t.lexXrpcSubscriptionMessage = e.z.object({
    description: e.z.string().optional(),
    // @NOTE using discriminatedUnion with a refined schema requires zod >= 4
    schema: e.z.union([t.lexRefVariant, t.lexObject]).optional()
  }).strict(), t.lexXrpcError = e.z.object({
    name: e.z.string(),
    description: e.z.string().optional()
  }).strict(), t.lexXrpcQuery = e.z.object({
    type: e.z.literal("query"),
    description: e.z.string().optional(),
    parameters: t.lexXrpcParameters.optional(),
    output: t.lexXrpcBody.optional(),
    errors: t.lexXrpcError.array().optional()
  }).strict(), t.lexXrpcProcedure = e.z.object({
    type: e.z.literal("procedure"),
    description: e.z.string().optional(),
    parameters: t.lexXrpcParameters.optional(),
    input: t.lexXrpcBody.optional(),
    output: t.lexXrpcBody.optional(),
    errors: t.lexXrpcError.array().optional()
  }).strict(), t.lexXrpcSubscription = e.z.object({
    type: e.z.literal("subscription"),
    description: e.z.string().optional(),
    parameters: t.lexXrpcParameters.optional(),
    message: t.lexXrpcSubscriptionMessage.optional(),
    errors: t.lexXrpcError.array().optional()
  }).strict(), t.lexRecord = e.z.object({
    type: e.z.literal("record"),
    description: e.z.string().optional(),
    key: e.z.string().optional(),
    record: t.lexObject
  }).strict(), t.lexUserType = e.z.custom((P) => {
    if (!(!P || typeof P != "object") && P.type !== void 0)
      switch (P.type) {
        case "record":
          return t.lexRecord.parse(P);
        case "query":
          return t.lexXrpcQuery.parse(P);
        case "procedure":
          return t.lexXrpcProcedure.parse(P);
        case "subscription":
          return t.lexXrpcSubscription.parse(P);
        case "blob":
          return t.lexBlob.parse(P);
        case "array":
          return t.lexArray.parse(P);
        case "token":
          return t.lexToken.parse(P);
        case "object":
          return t.lexObject.parse(P);
        case "boolean":
          return t.lexBoolean.parse(P);
        case "integer":
          return t.lexInteger.parse(P);
        case "string":
          return t.lexString.parse(P);
        case "bytes":
          return t.lexBytes.parse(P);
        case "cid-link":
          return t.lexCidLink.parse(P);
        case "unknown":
          return t.lexUnknown.parse(P);
      }
  }, (P) => !P || typeof P != "object" ? {
    message: "Must be an object",
    fatal: !0
  } : P.type === void 0 ? {
    message: "Must have a type",
    fatal: !0
  } : typeof P.type != "string" ? {
    message: "Type property must be a string",
    fatal: !0
  } : {
    message: `Invalid type: ${P.type} must be one of: record, query, procedure, subscription, blob, array, token, object, boolean, integer, string, bytes, cid-link, unknown`,
    fatal: !0
  }), t.lexiconDoc = e.z.object({
    lexicon: e.z.literal(1),
    id: e.z.string().refine((P) => r.NSID.isValid(P), {
      message: "Must be a valid NSID"
    }),
    revision: e.z.number().optional(),
    description: e.z.string().optional(),
    defs: e.z.record(t.lexUserType)
  }).strict().superRefine((P, M) => {
    for (const K in P.defs) {
      const W = P.defs[K];
      K !== "main" && (W.type === "record" || W.type === "procedure" || W.type === "query" || W.type === "subscription") && M.addIssue({
        code: e.z.ZodIssueCode.custom,
        message: "Records, procedures, queries, and subscriptions must be the main definition."
      });
    }
  });
  function a(P) {
    return t.lexiconDoc.safeParse(P).success;
  }
  function c(P) {
    return P !== null && typeof P == "object";
  }
  function h(P, M) {
    return M in P;
  }
  t.discriminatedObject = e.z.object({ $type: e.z.string() });
  function m(P) {
    return t.discriminatedObject.safeParse(P).success;
  }
  function p(P) {
    return t.lexiconDoc.parse(P), P;
  }
  class b extends Error {
  }
  t.ValidationError = b;
  class d extends Error {
  }
  t.InvalidLexiconError = d;
  class v extends Error {
  }
  t.LexiconDefNotFoundError = v;
})(Rn);
var Bu = {}, us = {}, An = {}, Mc = {}, Iu = {}, vi = {}, ri = {};
Object.defineProperty(ri, "__esModule", { value: !0 });
ri.isObject = ri.assure = ri.create = ri.is = void 0;
const $g = (t, e) => e.safeParse(t).success;
ri.is = $g;
const Gg = (t) => (e) => t.safeParse(e).success;
ri.create = Gg;
const qg = (t, e) => t.parse(e);
ri.assure = qg;
const zg = (t) => typeof t == "object" && t !== null;
ri.isObject = zg;
var As = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.parseIntWithFallback = t.dedupeStrs = t.range = t.chunkArray = t.errHasMsg = t.isErrnoException = t.asyncFilter = t.s32decode = t.s32encode = t.streamToBuffer = t.flattenUint8Arrays = t.bailableWait = t.wait = t.jitter = t.omit = t.noUndefinedVals = void 0;
  const e = (U) => (Object.keys(U).forEach((F) => {
    U[F] === void 0 && delete U[F];
  }), U);
  t.noUndefinedVals = e;
  function r(U, F) {
    return U && Object.fromEntries(Object.entries(U).filter((Z) => !F.includes(Z[0])));
  }
  t.omit = r;
  const i = (U) => Math.round((Math.random() - 0.5) * U * 2);
  t.jitter = i;
  const a = (U) => new Promise((F) => setTimeout(F, U));
  t.wait = a;
  const c = (U) => {
    let F;
    const Z = new Promise((de) => {
      const xe = setTimeout(de, U);
      F = () => {
        clearTimeout(xe), de();
      };
    });
    return { bail: F, wait: () => Z };
  };
  t.bailableWait = c;
  const h = (U) => {
    const F = U.reduce((xe, ge) => xe + ge.length, 0), Z = new Uint8Array(F);
    let de = 0;
    return U.forEach((xe) => {
      Z.set(xe, de), de += xe.length;
    }), Z;
  };
  t.flattenUint8Arrays = h;
  const m = async (U) => {
    const F = [];
    for await (const Z of U)
      F.push(Z);
    return (0, t.flattenUint8Arrays)(F);
  };
  t.streamToBuffer = m;
  const p = "234567abcdefghijklmnopqrstuvwxyz", b = (U) => {
    let F = "";
    for (; U; ) {
      const Z = U % 32;
      U = Math.floor(U / 32), F = p.charAt(Z) + F;
    }
    return F;
  };
  t.s32encode = b;
  const d = (U) => {
    let F = 0;
    for (const Z of U)
      F = F * 32 + p.indexOf(Z);
    return F;
  };
  t.s32decode = d;
  const v = async (U, F) => {
    const Z = await Promise.all(U.map((de) => F(de)));
    return U.filter((de, xe) => Z[xe]);
  };
  t.asyncFilter = v;
  const P = (U) => !!U && U.code;
  t.isErrnoException = P;
  const M = (U, F) => !!U && typeof U == "object" && U.message === F;
  t.errHasMsg = M;
  const K = (U, F) => U.reduce((Z, de, xe) => {
    const ge = Math.floor(xe / F);
    return Z[ge] || (Z[ge] = []), Z[ge].push(de), Z;
  }, []);
  t.chunkArray = K;
  const W = (U) => {
    const F = [];
    for (let Z = 0; Z < U; Z++)
      F.push(Z);
    return F;
  };
  t.range = W;
  const J = (U) => [...new Set(U)];
  t.dedupeStrs = J;
  const z = (U, F) => {
    const Z = parseInt(U || "", 10);
    return isNaN(Z) ? F : Z;
  };
  t.parseIntWithFallback = z;
})(As);
var _s = {};
Object.defineProperty(_s, "__esModule", { value: !0 });
_s.mapDefined = _s.keyBy = void 0;
const Xg = (t, e) => t.reduce((r, i) => (r[i[e]] = i, r), {});
_s.keyBy = Xg;
const Hg = (t, e) => {
  const r = [];
  for (const i of t) {
    const a = e(i);
    a !== void 0 && r.push(a);
  }
  return r;
};
_s.mapDefined = Hg;
var mp = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.handleAllSettledErrors = t.AsyncBufferFullError = t.AsyncBuffer = t.allComplete = t.createDeferrables = t.createDeferrable = t.readFromGenerator = void 0;
  const e = As, r = async (d, v, P = Promise.resolve(), M = Number.MAX_SAFE_INTEGER) => {
    const K = [];
    let W, J = !1;
    const z = async () => {
      if (await v(K.at(-1)))
        return !0;
      const F = (0, e.bailableWait)(20);
      return await F.wait(), W = F.bail, J ? !1 : await z();
    }, U = new Promise((F) => {
      P.then(() => {
        z().then(() => F());
      });
    });
    try {
      for (; K.length < M; ) {
        const F = await Promise.race([d.next(), U]);
        if (!F)
          break;
        const Z = F;
        if (Z.done)
          break;
        K.push(Z.value);
      }
    } finally {
      J = !0, W && W();
    }
    return K;
  };
  t.readFromGenerator = r;
  const i = () => {
    let d;
    const v = new Promise((P) => {
      d = () => P();
    });
    return { resolve: d, complete: v };
  };
  t.createDeferrable = i;
  const a = (d) => {
    const v = [];
    for (let P = 0; P < d; P++)
      v.push((0, t.createDeferrable)());
    return v;
  };
  t.createDeferrables = a;
  const c = async (d) => {
    await Promise.all(d.map((v) => v.complete));
  };
  t.allComplete = c;
  class h {
    constructor(v) {
      Object.defineProperty(this, "maxSize", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: v
      }), Object.defineProperty(this, "buffer", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: []
      }), Object.defineProperty(this, "promise", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "resolve", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "closed", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: !1
      }), Object.defineProperty(this, "toThrow", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), this.promise = Promise.resolve(), this.resolve = () => null, this.resetPromise();
    }
    get curr() {
      return this.buffer;
    }
    get size() {
      return this.buffer.length;
    }
    get isClosed() {
      return this.closed;
    }
    resetPromise() {
      this.promise = new Promise((v) => this.resolve = v);
    }
    push(v) {
      this.buffer.push(v), this.resolve();
    }
    pushMany(v) {
      v.forEach((P) => this.buffer.push(P)), this.resolve();
    }
    async *events() {
      for (; ; ) {
        if (this.closed && this.buffer.length === 0) {
          if (this.toThrow)
            throw this.toThrow;
          return;
        }
        if (await this.promise, this.toThrow)
          throw this.toThrow;
        if (this.maxSize && this.size > this.maxSize)
          throw new m(this.maxSize);
        const [v, ...P] = this.buffer;
        v ? (this.buffer = P, yield v) : this.resetPromise();
      }
    }
    throw(v) {
      this.toThrow = v, this.closed = !0, this.resolve();
    }
    close() {
      this.closed = !0, this.resolve();
    }
  }
  t.AsyncBuffer = h;
  class m extends Error {
    constructor(v) {
      super(`ReachedMaxBufferSize: ${v}`);
    }
  }
  t.AsyncBufferFullError = m;
  const p = (d) => {
    const v = d.filter(b).map((P) => P.reason);
    if (v.length !== 0)
      throw v.length === 1 ? v[0] : new AggregateError(v, "Multiple errors: " + v.map((P) => P?.message).join(`
`));
  };
  t.handleAllSettledErrors = p;
  const b = (d) => d.status === "rejected";
})(mp);
var Ca = {};
Object.defineProperty(Ca, "__esModule", { value: !0 });
Ca.TID = void 0;
const Ql = As, Ld = 13;
let dc = 0, kd = 0, eu = null;
function Dd(t) {
  return t.replaceAll("-", "");
}
class Ii {
  constructor(e) {
    Object.defineProperty(this, "str", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const r = Dd(e);
    if (r.length !== Ld)
      throw new Error(`Poorly formatted TID: ${r.length} length`);
    this.str = r;
  }
  static next(e) {
    const r = Math.max(Date.now(), dc);
    r === dc && kd++, dc = r;
    const i = r * 1e3 + kd;
    eu === null && (eu = Math.floor(Math.random() * 32));
    const a = Ii.fromTime(i, eu);
    return !e || a.newerThan(e) ? a : Ii.fromTime(e.timestamp() + 1, eu);
  }
  static nextStr(e) {
    return Ii.next(e ? new Ii(e) : void 0).toString();
  }
  static fromTime(e, r) {
    const i = `${(0, Ql.s32encode)(e)}${(0, Ql.s32encode)(r).padStart(2, "2")}`;
    return new Ii(i);
  }
  static fromStr(e) {
    return new Ii(e);
  }
  static oldestFirst(e, r) {
    return e.compareTo(r);
  }
  static newestFirst(e, r) {
    return r.compareTo(e);
  }
  static is(e) {
    return Dd(e).length === Ld;
  }
  timestamp() {
    return (0, Ql.s32decode)(this.str.slice(0, 11));
  }
  clockid() {
    return (0, Ql.s32decode)(this.str.slice(11, 13));
  }
  formatted() {
    const e = this.toString();
    return `${e.slice(0, 4)}-${e.slice(4, 7)}-${e.slice(7, 11)}-${e.slice(11, 13)}`;
  }
  toString() {
    return this.str;
  }
  // newer > older
  compareTo(e) {
    return this.str > e.str ? 1 : this.str < e.str ? -1 : 0;
  }
  equals(e) {
    return this.str === e.str;
  }
  newerThan(e) {
    return this.compareTo(e) > 0;
  }
  olderThan(e) {
    return this.compareTo(e) < 0;
  }
}
Ca.TID = Ii;
Ca.default = Ii;
var yp = {}, Zg = bp, Pd = 128, Wg = 127, Yg = ~Wg, Jg = Math.pow(2, 31);
function bp(t, e, r) {
  e = e || [], r = r || 0;
  for (var i = r; t >= Jg; )
    e[r++] = t & 255 | Pd, t /= 128;
  for (; t & Yg; )
    e[r++] = t & 255 | Pd, t >>>= 7;
  return e[r] = t | 0, bp.bytes = r - i + 1, e;
}
var Qg = Sc, ex = 128, Bd = 127;
function Sc(t, i) {
  var r = 0, i = i || 0, a = 0, c = i, h, m = t.length;
  do {
    if (c >= m)
      throw Sc.bytes = 0, new RangeError("Could not decode varint");
    h = t[c++], r += a < 28 ? (h & Bd) << a : (h & Bd) * Math.pow(2, a), a += 7;
  } while (h >= ex);
  return Sc.bytes = c - i, r;
}
var tx = Math.pow(2, 7), rx = Math.pow(2, 14), ix = Math.pow(2, 21), nx = Math.pow(2, 28), sx = Math.pow(2, 35), ax = Math.pow(2, 42), ox = Math.pow(2, 49), lx = Math.pow(2, 56), ux = Math.pow(2, 63), cx = function(t) {
  return t < tx ? 1 : t < rx ? 2 : t < ix ? 3 : t < nx ? 4 : t < sx ? 5 : t < ax ? 6 : t < ox ? 7 : t < lx ? 8 : t < ux ? 9 : 10;
}, dx = {
  encode: Zg,
  decode: Qg,
  encodingLength: cx
}, bu = dx;
const Cc = (t, e = 0) => [
  bu.decode(t, e),
  bu.decode.bytes
], gu = (t, e, r = 0) => (bu.encode(t, e, r), e), xu = (t) => bu.encodingLength(t), fx = (t, e) => {
  if (t === e)
    return !0;
  if (t.byteLength !== e.byteLength)
    return !1;
  for (let r = 0; r < t.byteLength; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}, Nc = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
    return t;
  if (t instanceof ArrayBuffer)
    return new Uint8Array(t);
  if (ArrayBuffer.isView(t))
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, px = (t) => new TextEncoder().encode(t), hx = (t) => new TextDecoder().decode(t), mx = (t, e) => {
  const r = e.byteLength, i = xu(t), a = i + xu(r), c = new Uint8Array(a + r);
  return gu(t, c, 0), gu(r, c, i), c.set(e, a), new Vc(t, r, e, c);
}, yx = (t) => {
  const e = Nc(t), [r, i] = Cc(e), [a, c] = Cc(e.subarray(i)), h = e.subarray(i + c);
  if (h.byteLength !== a)
    throw new Error("Incorrect length");
  return new Vc(r, a, h, e);
}, bx = (t, e) => t === e ? !0 : t.code === e.code && t.size === e.size && fx(t.bytes, e.bytes);
class Vc {
  constructor(e, r, i, a) {
    this.code = e, this.size = r, this.digest = i, this.bytes = a;
  }
}
function gx(t, e) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), i = 0; i < r.length; i++)
    r[i] = 255;
  for (var a = 0; a < t.length; a++) {
    var c = t.charAt(a), h = c.charCodeAt(0);
    if (r[h] !== 255)
      throw new TypeError(c + " is ambiguous");
    r[h] = a;
  }
  var m = t.length, p = t.charAt(0), b = Math.log(m) / Math.log(256), d = Math.log(256) / Math.log(m);
  function v(K) {
    if (K instanceof Uint8Array || (ArrayBuffer.isView(K) ? K = new Uint8Array(K.buffer, K.byteOffset, K.byteLength) : Array.isArray(K) && (K = Uint8Array.from(K))), !(K instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (K.length === 0)
      return "";
    for (var W = 0, J = 0, z = 0, U = K.length; z !== U && K[z] === 0; )
      z++, W++;
    for (var F = (U - z) * d + 1 >>> 0, Z = new Uint8Array(F); z !== U; ) {
      for (var de = K[z], xe = 0, ge = F - 1; (de !== 0 || xe < J) && ge !== -1; ge--, xe++)
        de += 256 * Z[ge] >>> 0, Z[ge] = de % m >>> 0, de = de / m >>> 0;
      if (de !== 0)
        throw new Error("Non-zero carry");
      J = xe, z++;
    }
    for (var me = F - J; me !== F && Z[me] === 0; )
      me++;
    for (var Ee = p.repeat(W); me < F; ++me)
      Ee += t.charAt(Z[me]);
    return Ee;
  }
  function P(K) {
    if (typeof K != "string")
      throw new TypeError("Expected String");
    if (K.length === 0)
      return new Uint8Array();
    var W = 0;
    if (K[W] !== " ") {
      for (var J = 0, z = 0; K[W] === p; )
        J++, W++;
      for (var U = (K.length - W) * b + 1 >>> 0, F = new Uint8Array(U); K[W]; ) {
        var Z = r[K.charCodeAt(W)];
        if (Z === 255)
          return;
        for (var de = 0, xe = U - 1; (Z !== 0 || de < z) && xe !== -1; xe--, de++)
          Z += m * F[xe] >>> 0, F[xe] = Z % 256 >>> 0, Z = Z / 256 >>> 0;
        if (Z !== 0)
          throw new Error("Non-zero carry");
        z = de, W++;
      }
      if (K[W] !== " ") {
        for (var ge = U - z; ge !== U && F[ge] === 0; )
          ge++;
        for (var me = new Uint8Array(J + (U - ge)), Ee = J; ge !== U; )
          me[Ee++] = F[ge++];
        return me;
      }
    }
  }
  function M(K) {
    var W = P(K);
    if (W)
      return W;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: v,
    decodeUnsafe: P,
    decode: M
  };
}
var xx = gx, Ex = xx;
class vx {
  constructor(e, r, i) {
    this.name = e, this.prefix = r, this.baseEncode = i;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Rx {
  constructor(e, r, i) {
    if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = r.codePointAt(0), this.baseDecode = i;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return gp(this, e);
  }
}
class Ax {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return gp(this, e);
  }
  decode(e) {
    const r = e[0], i = this.decoders[r];
    if (i)
      return i.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const gp = (t, e) => new Ax({
  ...t.decoders || { [t.prefix]: t },
  ...e.decoders || { [e.prefix]: e }
});
class _x {
  constructor(e, r, i, a) {
    this.name = e, this.prefix = r, this.baseEncode = i, this.baseDecode = a, this.encoder = new vx(e, r, i), this.decoder = new Rx(e, r, a);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const Uu = ({ name: t, prefix: e, encode: r, decode: i }) => new _x(t, e, r, i), La = ({ prefix: t, name: e, alphabet: r }) => {
  const { encode: i, decode: a } = Ex(r, e);
  return Uu({
    prefix: t,
    name: e,
    encode: i,
    decode: (c) => Nc(a(c))
  });
}, wx = (t, e, r, i) => {
  const a = {};
  for (let d = 0; d < e.length; ++d)
    a[e[d]] = d;
  let c = t.length;
  for (; t[c - 1] === "="; )
    --c;
  const h = new Uint8Array(c * r / 8 | 0);
  let m = 0, p = 0, b = 0;
  for (let d = 0; d < c; ++d) {
    const v = a[t[d]];
    if (v === void 0)
      throw new SyntaxError(`Non-${i} character`);
    p = p << r | v, m += r, m >= 8 && (m -= 8, h[b++] = 255 & p >> m);
  }
  if (m >= r || 255 & p << 8 - m)
    throw new SyntaxError("Unexpected end of data");
  return h;
}, Tx = (t, e, r) => {
  const i = e[e.length - 1] === "=", a = (1 << r) - 1;
  let c = "", h = 0, m = 0;
  for (let p = 0; p < t.length; ++p)
    for (m = m << 8 | t[p], h += 8; h > r; )
      h -= r, c += e[a & m >> h];
  if (h && (c += e[a & m << r - h]), i)
    for (; c.length * r & 7; )
      c += "=";
  return c;
}, qt = ({ name: t, prefix: e, bitsPerChar: r, alphabet: i }) => Uu({
  prefix: e,
  name: t,
  encode(a) {
    return Tx(a, i, r);
  },
  decode(a) {
    return wx(a, i, r, t);
  }
}), Ui = La({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), Sx = La({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), Cx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: Ui,
  base58flickr: Sx
}, Symbol.toStringTag, { value: "Module" })), aa = qt({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), Lx = qt({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), kx = qt({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), Dx = qt({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), Px = qt({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), Bx = qt({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), Ix = qt({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), Ux = qt({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), Ox = qt({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), Kx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: aa,
  base32hex: Px,
  base32hexpad: Ix,
  base32hexpadupper: Ux,
  base32hexupper: Bx,
  base32pad: kx,
  base32padupper: Dx,
  base32upper: Lx,
  base32z: Ox
}, Symbol.toStringTag, { value: "Module" }));
class Zt {
  constructor(e, r, i, a) {
    this.code = r, this.version = e, this.multihash = i, this.bytes = a, this.byteOffset = a.byteOffset, this.byteLength = a.byteLength, this.asCID = this, this._baseCache = /* @__PURE__ */ new Map(), Object.defineProperties(this, {
      byteOffset: ru,
      byteLength: ru,
      code: tu,
      version: tu,
      multihash: tu,
      bytes: tu,
      _baseCache: ru,
      asCID: ru
    });
  }
  toV0() {
    switch (this.version) {
      case 0:
        return this;
      default: {
        const { code: e, multihash: r } = this;
        if (e !== Qs)
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        if (r.code !== jx)
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        return Zt.createV0(r);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: e, digest: r } = this.multihash, i = mx(e, r);
        return Zt.createV1(this.code, i);
      }
      case 1:
        return this;
      default:
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
    }
  }
  equals(e) {
    return e && this.code === e.code && this.version === e.version && bx(this.multihash, e.multihash);
  }
  toString(e) {
    const { bytes: r, version: i, _baseCache: a } = this;
    switch (i) {
      case 0:
        return Nx(r, a, e || Ui.encoder);
      default:
        return Vx(r, a, e || aa.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(e) {
    return $x(/^0\.0/, Gx), !!(e && (e[Ud] || e.asCID === e));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(e) {
    if (e instanceof Zt)
      return e;
    if (e != null && e.asCID === e) {
      const { version: r, code: i, multihash: a, bytes: c } = e;
      return new Zt(r, i, a, c || Id(r, i, a.bytes));
    } else if (e != null && e[Ud] === !0) {
      const { version: r, multihash: i, code: a } = e, c = yx(i);
      return Zt.create(r, a, c);
    } else
      return null;
  }
  static create(e, r, i) {
    if (typeof r != "number")
      throw new Error("String codecs are no longer supported");
    switch (e) {
      case 0: {
        if (r !== Qs)
          throw new Error(`Version 0 CID must use dag-pb (code: ${Qs}) block encoding`);
        return new Zt(e, r, i, i.bytes);
      }
      case 1: {
        const a = Id(e, r, i.bytes);
        return new Zt(e, r, i, a);
      }
      default:
        throw new Error("Invalid version");
    }
  }
  static createV0(e) {
    return Zt.create(0, Qs, e);
  }
  static createV1(e, r) {
    return Zt.create(1, e, r);
  }
  static decode(e) {
    const [r, i] = Zt.decodeFirst(e);
    if (i.length)
      throw new Error("Incorrect length");
    return r;
  }
  static decodeFirst(e) {
    const r = Zt.inspectBytes(e), i = r.size - r.multihashSize, a = Nc(e.subarray(i, i + r.multihashSize));
    if (a.byteLength !== r.multihashSize)
      throw new Error("Incorrect length");
    const c = a.subarray(r.multihashSize - r.digestSize), h = new Vc(r.multihashCode, r.digestSize, c, a);
    return [
      r.version === 0 ? Zt.createV0(h) : Zt.createV1(r.codec, h),
      e.subarray(r.size)
    ];
  }
  static inspectBytes(e) {
    let r = 0;
    const i = () => {
      const [v, P] = Cc(e.subarray(r));
      return r += P, v;
    };
    let a = i(), c = Qs;
    if (a === 18 ? (a = 0, r = 0) : a === 1 && (c = i()), a !== 0 && a !== 1)
      throw new RangeError(`Invalid CID version ${a}`);
    const h = r, m = i(), p = i(), b = r + p, d = b - h;
    return {
      version: a,
      codec: c,
      multihashCode: m,
      digestSize: p,
      multihashSize: d,
      size: b
    };
  }
  static parse(e, r) {
    const [i, a] = Mx(e, r), c = Zt.decode(a);
    return c._baseCache.set(i, e), c;
  }
}
const Mx = (t, e) => {
  switch (t[0]) {
    case "Q": {
      const r = e || Ui;
      return [
        Ui.prefix,
        r.decode(`${Ui.prefix}${t}`)
      ];
    }
    case Ui.prefix: {
      const r = e || Ui;
      return [
        Ui.prefix,
        r.decode(t)
      ];
    }
    case aa.prefix: {
      const r = e || aa;
      return [
        aa.prefix,
        r.decode(t)
      ];
    }
    default: {
      if (e == null)
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      return [
        t[0],
        e.decode(t)
      ];
    }
  }
}, Nx = (t, e, r) => {
  const { prefix: i } = r;
  if (i !== Ui.prefix)
    throw Error(`Cannot string encode V0 in ${r.name} encoding`);
  const a = e.get(i);
  if (a == null) {
    const c = r.encode(t).slice(1);
    return e.set(i, c), c;
  } else
    return a;
}, Vx = (t, e, r) => {
  const { prefix: i } = r, a = e.get(i);
  if (a == null) {
    const c = r.encode(t);
    return e.set(i, c), c;
  } else
    return a;
}, Qs = 112, jx = 18, Id = (t, e, r) => {
  const i = xu(t), a = i + xu(e), c = new Uint8Array(a + r.byteLength);
  return gu(t, c, 0), gu(e, c, i), c.set(r, a), c;
}, Ud = Symbol.for("@ipld/js-cid/CID"), tu = {
  writable: !1,
  configurable: !1,
  enumerable: !0
}, ru = {
  writable: !1,
  enumerable: !1,
  configurable: !1
}, Fx = "0.0.0-dev", $x = (t, e) => {
  if (t.test(Fx))
    console.warn(e);
  else
    throw new Error(e);
}, Gx = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`, qx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CID: Zt
}, Symbol.toStringTag, { value: "Module" })), $s = /* @__PURE__ */ Xf(qx);
function zx(t, e) {
  for (let r = 0; r < t.byteLength; r++) {
    if (t[r] < e[r])
      return -1;
    if (t[r] > e[r])
      return 1;
  }
  return t.byteLength > e.byteLength ? 1 : t.byteLength < e.byteLength ? -1 : 0;
}
function Xx(t, e) {
  e || (e = t.reduce((a, c) => a + c.length, 0));
  const r = new Uint8Array(e);
  let i = 0;
  for (const a of t)
    r.set(a, i), i += a.length;
  return r;
}
function Hx(t, e) {
  if (t === e)
    return !0;
  if (t.byteLength !== e.byteLength)
    return !1;
  for (let r = 0; r < t.byteLength; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
const Zx = Uu({
  prefix: "\0",
  name: "identity",
  encode: (t) => hx(t),
  decode: (t) => px(t)
}), Wx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: Zx
}, Symbol.toStringTag, { value: "Module" })), Yx = qt({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), Jx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: Yx
}, Symbol.toStringTag, { value: "Module" })), Qx = qt({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), eE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: Qx
}, Symbol.toStringTag, { value: "Module" })), tE = La({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), rE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: tE
}, Symbol.toStringTag, { value: "Module" })), iE = qt({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), nE = qt({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), sE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: iE,
  base16upper: nE
}, Symbol.toStringTag, { value: "Module" })), aE = La({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), oE = La({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), lE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: aE,
  base36upper: oE
}, Symbol.toStringTag, { value: "Module" })), uE = qt({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), cE = qt({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), dE = qt({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), fE = qt({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), pE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: uE,
  base64pad: cE,
  base64url: dE,
  base64urlpad: fE
}, Symbol.toStringTag, { value: "Module" })), xp = Array.from(""), hE = xp.reduce((t, e, r) => (t[r] = e, t), []), mE = xp.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);
function yE(t) {
  return t.reduce((e, r) => (e += hE[r], e), "");
}
function bE(t) {
  const e = [];
  for (const r of t) {
    const i = mE[r.codePointAt(0)];
    if (i === void 0)
      throw new Error(`Non-base256emoji character: ${r}`);
    e.push(i);
  }
  return new Uint8Array(e);
}
const gE = Uu({
  prefix: "",
  name: "base256emoji",
  encode: yE,
  decode: bE
}), xE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: gE
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const Od = {
  ...Wx,
  ...Jx,
  ...eE,
  ...rE,
  ...sE,
  ...Kx,
  ...lE,
  ...Cx,
  ...pE,
  ...xE
};
function Ep(t, e, r, i) {
  return {
    name: t,
    prefix: e,
    encoder: {
      name: t,
      prefix: e,
      encode: r
    },
    decoder: { decode: i }
  };
}
const Kd = Ep("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), fc = Ep("ascii", "a", (t) => {
  let e = "a";
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = new Uint8Array(t.length);
  for (let r = 0; r < t.length; r++)
    e[r] = t.charCodeAt(r);
  return e;
}), vp = {
  utf8: Kd,
  "utf-8": Kd,
  hex: Od.base16,
  latin1: fc,
  ascii: fc,
  binary: fc,
  ...Od
};
function EE(t, e = "utf8") {
  const r = vp[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return r.decoder.decode(`${r.prefix}${t}`);
}
function vE(t, e = "utf8") {
  const r = vp[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return r.encoder.encode(t).substring(1);
}
function RE(t, e) {
  if (t.length !== e.length)
    throw new Error("Inputs should have the same length");
  const r = new Uint8Array(t.length);
  for (let i = 0; i < t.length; i++)
    r[i] = t[i] ^ e[i];
  return r;
}
const AE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  compare: zx,
  concat: Xx,
  equals: Hx,
  fromString: EE,
  toString: vE,
  xor: RE
}, Symbol.toStringTag, { value: "Module" })), Rp = /* @__PURE__ */ Xf(AE);
(function(t) {
  var e = ne && ne.__createBinding || (Object.create ? function(b, d, v, P) {
    P === void 0 && (P = v);
    var M = Object.getOwnPropertyDescriptor(d, v);
    (!M || ("get" in M ? !d.__esModule : M.writable || M.configurable)) && (M = { enumerable: !0, get: function() {
      return d[v];
    } }), Object.defineProperty(b, P, M);
  } : function(b, d, v, P) {
    P === void 0 && (P = v), b[P] = d[v];
  }), r = ne && ne.__setModuleDefault || (Object.create ? function(b, d) {
    Object.defineProperty(b, "default", { enumerable: !0, value: d });
  } : function(b, d) {
    b.default = d;
  }), i = ne && ne.__importStar || function(b) {
    if (b && b.__esModule) return b;
    var d = {};
    if (b != null) for (var v in b) v !== "default" && Object.prototype.hasOwnProperty.call(b, v) && e(d, b, v);
    return r(d, b), d;
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ipldEquals = t.ipldToJson = t.jsonToIpld = void 0;
  const a = $s, c = i(Rp), h = (b) => {
    if (Array.isArray(b))
      return b.map((d) => (0, t.jsonToIpld)(d));
    if (b && typeof b == "object") {
      if (typeof b.$link == "string" && Object.keys(b).length === 1)
        return a.CID.parse(b.$link);
      if (typeof b.$bytes == "string" && Object.keys(b).length === 1)
        return c.fromString(b.$bytes, "base64");
      const d = {};
      for (const v of Object.keys(b))
        d[v] = (0, t.jsonToIpld)(b[v]);
      return d;
    }
    return b;
  };
  t.jsonToIpld = h;
  const m = (b) => {
    if (Array.isArray(b))
      return b.map((d) => (0, t.ipldToJson)(d));
    if (b && typeof b == "object") {
      if (b instanceof Uint8Array)
        return {
          $bytes: c.toString(b, "base64")
        };
      if (a.CID.asCID(b))
        return {
          $link: b.toString()
        };
      const d = {};
      for (const v of Object.keys(b))
        d[v] = (0, t.ipldToJson)(b[v]);
      return d;
    }
    return b;
  };
  t.ipldToJson = m;
  const p = (b, d) => {
    if (Array.isArray(b) && Array.isArray(d)) {
      if (b.length !== d.length)
        return !1;
      for (let v = 0; v < b.length; v++)
        if (!(0, t.ipldEquals)(b[v], d[v]))
          return !1;
      return !0;
    }
    if (b && d && typeof b == "object" && typeof d == "object") {
      if (b instanceof Uint8Array && d instanceof Uint8Array)
        return c.equals(b, d);
      if (a.CID.asCID(b) && a.CID.asCID(d))
        return a.CID.asCID(b)?.equals(a.CID.asCID(d));
      if (Object.keys(b).length !== Object.keys(d).length)
        return !1;
      for (const v of Object.keys(b))
        if (!(0, t.ipldEquals)(b[v], d[v]))
          return !1;
      return !0;
    }
    return b === d;
  };
  t.ipldEquals = p;
})(yp);
var ws = {};
Object.defineProperty(ws, "__esModule", { value: !0 });
ws.backoffMs = ws.retry = void 0;
const _E = As;
async function wE(t, e = {}) {
  const { maxRetries: r = 3, retryable: i = () => !0, getWaitMs: a = Ap } = e;
  let c = 0, h;
  for (; !h; )
    try {
      return await t();
    } catch (m) {
      const p = a(c);
      c < r && p !== null && i(m) ? (c += 1, p !== 0 && await (0, _E.wait)(p)) : h = m;
    }
  throw h;
}
ws.retry = wE;
function Ap(t, e = 100, r = 1e3) {
  const i = Math.pow(2, t) * e, a = Math.min(i, r);
  return TE(a);
}
ws.backoffMs = Ap;
function TE(t) {
  const e = t * 0.15;
  return t + SE(-e, e);
}
function SE(t, e) {
  return Math.random() * (e - t) + t;
}
var _p = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.def = t.schema = void 0;
  const e = $s, r = os, i = r.z.any().refine((a) => e.CID.asCID(a) !== null, {
    message: "Not a CID"
  }).transform((a) => e.CID.asCID(a));
  t.schema = {
    cid: i,
    bytes: r.z.instanceof(Uint8Array),
    string: r.z.string(),
    array: r.z.array(r.z.unknown()),
    map: r.z.record(r.z.string(), r.z.unknown()),
    unknown: r.z.unknown()
  }, t.def = {
    cid: {
      name: "cid",
      schema: t.schema.cid
    },
    bytes: {
      name: "bytes",
      schema: t.schema.bytes
    },
    string: {
      name: "string",
      schema: t.schema.string
    },
    map: {
      name: "map",
      schema: t.schema.map
    },
    unknown: {
      name: "unknown",
      schema: t.schema.unknown
    }
  };
})(_p);
var wp = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.addHoursToDate = t.lessThanAgoMs = t.DAY = t.HOUR = t.MINUTE = t.SECOND = void 0, t.SECOND = 1e3, t.MINUTE = t.SECOND * 60, t.HOUR = t.MINUTE * 60, t.DAY = t.HOUR * 24;
  const e = (i, a) => Date.now() < i.getTime() + a;
  t.lessThanAgoMs = e;
  const r = (i, a) => {
    const c = a ? new Date(a) : /* @__PURE__ */ new Date();
    return c.setHours(c.getHours() + i), c;
  };
  t.addHoursToDate = r;
})(wp);
var yr = {}, jc = {}, Fc = {}, $c = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.EXTENDED_PICTOGRAPHIC = t.CLUSTER_BREAK = void 0, function(e) {
    e[e.CR = 0] = "CR", e[e.LF = 1] = "LF", e[e.CONTROL = 2] = "CONTROL", e[e.EXTEND = 3] = "EXTEND", e[e.REGIONAL_INDICATOR = 4] = "REGIONAL_INDICATOR", e[e.SPACINGMARK = 5] = "SPACINGMARK", e[e.L = 6] = "L", e[e.V = 7] = "V", e[e.T = 8] = "T", e[e.LV = 9] = "LV", e[e.LVT = 10] = "LVT", e[e.OTHER = 11] = "OTHER", e[e.PREPEND = 12] = "PREPEND", e[e.E_BASE = 13] = "E_BASE", e[e.E_MODIFIER = 14] = "E_MODIFIER", e[e.ZWJ = 15] = "ZWJ", e[e.GLUE_AFTER_ZWJ = 16] = "GLUE_AFTER_ZWJ", e[e.E_BASE_GAZ = 17] = "E_BASE_GAZ";
  }(t.CLUSTER_BREAK || (t.CLUSTER_BREAK = {})), t.EXTENDED_PICTOGRAPHIC = 101;
})($c);
var Gc = {};
Object.defineProperty(Gc, "__esModule", { value: !0 });
const $e = $c, Li = 0, pc = 1, CE = 2, LE = 3, kE = 4;
class DE {
  /**
   * Check if the the character at the position {pos} of the string is surrogate
   * @param str {string}
   * @param pos {number}
   * @returns {boolean}
   */
  static isSurrogate(e, r) {
    return 55296 <= e.charCodeAt(r) && e.charCodeAt(r) <= 56319 && 56320 <= e.charCodeAt(r + 1) && e.charCodeAt(r + 1) <= 57343;
  }
  /**
   * The String.prototype.codePointAt polyfill
   * Private function, gets a Unicode code point from a JavaScript UTF-16 string
   * handling surrogate pairs appropriately
   * @param str {string}
   * @param idx {number}
   * @returns {number}
   */
  static codePointAt(e, r) {
    r === void 0 && (r = 0);
    const i = e.charCodeAt(r);
    if (55296 <= i && i <= 56319 && r < e.length - 1) {
      const a = i, c = e.charCodeAt(r + 1);
      return 56320 <= c && c <= 57343 ? (a - 55296) * 1024 + (c - 56320) + 65536 : a;
    }
    if (56320 <= i && i <= 57343 && r >= 1) {
      const a = e.charCodeAt(r - 1), c = i;
      return 55296 <= a && a <= 56319 ? (a - 55296) * 1024 + (c - 56320) + 65536 : c;
    }
    return i;
  }
  //
  /**
   * Private function, returns whether a break is allowed between the two given grapheme breaking classes
   * Implemented the UAX #29 3.1.1 Grapheme Cluster Boundary Rules on extended grapheme clusters
   * @param start {number}
   * @param mid {Array<number>}
   * @param end {number}
   * @param startEmoji {number}
   * @param midEmoji {Array<number>}
   * @param endEmoji {number}
   * @returns {number}
   */
  static shouldBreak(e, r, i, a, c, h) {
    const m = [e].concat(r).concat([i]), p = [a].concat(c).concat([h]), b = m[m.length - 2], d = i, v = h, P = m.lastIndexOf($e.CLUSTER_BREAK.REGIONAL_INDICATOR);
    if (P > 0 && m.slice(1, P).every(function(K) {
      return K === $e.CLUSTER_BREAK.REGIONAL_INDICATOR;
    }) && [$e.CLUSTER_BREAK.PREPEND, $e.CLUSTER_BREAK.REGIONAL_INDICATOR].indexOf(b) === -1)
      return m.filter(function(K) {
        return K === $e.CLUSTER_BREAK.REGIONAL_INDICATOR;
      }).length % 2 === 1 ? LE : kE;
    if (b === $e.CLUSTER_BREAK.CR && d === $e.CLUSTER_BREAK.LF)
      return Li;
    if (b === $e.CLUSTER_BREAK.CONTROL || b === $e.CLUSTER_BREAK.CR || b === $e.CLUSTER_BREAK.LF)
      return pc;
    if (d === $e.CLUSTER_BREAK.CONTROL || d === $e.CLUSTER_BREAK.CR || d === $e.CLUSTER_BREAK.LF)
      return pc;
    if (b === $e.CLUSTER_BREAK.L && (d === $e.CLUSTER_BREAK.L || d === $e.CLUSTER_BREAK.V || d === $e.CLUSTER_BREAK.LV || d === $e.CLUSTER_BREAK.LVT))
      return Li;
    if ((b === $e.CLUSTER_BREAK.LV || b === $e.CLUSTER_BREAK.V) && (d === $e.CLUSTER_BREAK.V || d === $e.CLUSTER_BREAK.T))
      return Li;
    if ((b === $e.CLUSTER_BREAK.LVT || b === $e.CLUSTER_BREAK.T) && d === $e.CLUSTER_BREAK.T)
      return Li;
    if (d === $e.CLUSTER_BREAK.EXTEND || d === $e.CLUSTER_BREAK.ZWJ)
      return Li;
    if (d === $e.CLUSTER_BREAK.SPACINGMARK)
      return Li;
    if (b === $e.CLUSTER_BREAK.PREPEND)
      return Li;
    const M = p.slice(0, -1).lastIndexOf($e.EXTENDED_PICTOGRAPHIC);
    return M !== -1 && p[M] === $e.EXTENDED_PICTOGRAPHIC && m.slice(M + 1, -2).every(function(K) {
      return K === $e.CLUSTER_BREAK.EXTEND;
    }) && b === $e.CLUSTER_BREAK.ZWJ && v === $e.EXTENDED_PICTOGRAPHIC ? Li : r.indexOf($e.CLUSTER_BREAK.REGIONAL_INDICATOR) !== -1 ? CE : b === $e.CLUSTER_BREAK.REGIONAL_INDICATOR && d === $e.CLUSTER_BREAK.REGIONAL_INDICATOR ? Li : pc;
  }
}
Gc.default = DE;
var qc = {};
Object.defineProperty(qc, "__esModule", { value: !0 });
class PE {
  constructor(e, r) {
    this._index = 0, this._str = e, this._nextBreak = r;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    let e;
    if ((e = this._nextBreak(this._str, this._index)) < this._str.length) {
      const r = this._str.slice(this._index, e);
      return this._index = e, { value: r, done: !1 };
    }
    if (this._index < this._str.length) {
      const r = this._str.slice(this._index);
      return this._index = this._str.length, { value: r, done: !1 };
    }
    return { value: void 0, done: !0 };
  }
}
qc.default = PE;
var Tp = ne && ne.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(Fc, "__esModule", { value: !0 });
const n = $c, iu = Tp(Gc), BE = Tp(qc);
class Pi {
  /**
   * Returns the next grapheme break in the string after the given index
   * @param string {string}
   * @param index {number}
   * @returns {number}
   */
  static nextBreak(e, r) {
    if (r === void 0 && (r = 0), r < 0)
      return 0;
    if (r >= e.length - 1)
      return e.length;
    const i = iu.default.codePointAt(e, r), a = Pi.getGraphemeBreakProperty(i), c = Pi.getEmojiProperty(i), h = [], m = [];
    for (let p = r + 1; p < e.length; p++) {
      if (iu.default.isSurrogate(e, p - 1))
        continue;
      const b = iu.default.codePointAt(e, p), d = Pi.getGraphemeBreakProperty(b), v = Pi.getEmojiProperty(b);
      if (iu.default.shouldBreak(a, h, d, c, m, v))
        return p;
      h.push(d), m.push(v);
    }
    return e.length;
  }
  /**
   * Breaks the given string into an array of grapheme clusters
   * @param str {string}
   * @returns {string[]}
   */
  splitGraphemes(e) {
    const r = [];
    let i = 0, a;
    for (; (a = Pi.nextBreak(e, i)) < e.length; )
      r.push(e.slice(i, a)), i = a;
    return i < e.length && r.push(e.slice(i)), r;
  }
  /**
   * Returns an iterator of grapheme clusters in the given string
   * @param str {string}
   * @returns {GraphemerIterator}
   */
  iterateGraphemes(e) {
    return new BE.default(e, Pi.nextBreak);
  }
  /**
   * Returns the number of grapheme clusters in the given string
   * @param str {string}
   * @returns {number}
   */
  countGraphemes(e) {
    let r = 0, i = 0, a;
    for (; (a = Pi.nextBreak(e, i)) < e.length; )
      i = a, r++;
    return i < e.length && r++, r;
  }
  /**
   * Given a Unicode code point, determines this symbol's grapheme break property
   * @param code {number} Unicode code point
   * @returns {number}
   */
  static getGraphemeBreakProperty(e) {
    if (e < 48905) {
      if (e < 44116) {
        if (e < 4141) {
          if (e < 2818) {
            if (e < 2363)
              if (e < 1759) {
                if (e < 1471) {
                  if (e < 127) {
                    if (e < 11) {
                      if (e < 10) {
                        if (0 <= e && e <= 9)
                          return n.CLUSTER_BREAK.CONTROL;
                      } else if (e === 10)
                        return n.CLUSTER_BREAK.LF;
                    } else if (e < 13) {
                      if (11 <= e && e <= 12)
                        return n.CLUSTER_BREAK.CONTROL;
                    } else if (e < 14) {
                      if (e === 13)
                        return n.CLUSTER_BREAK.CR;
                    } else if (14 <= e && e <= 31)
                      return n.CLUSTER_BREAK.CONTROL;
                  } else if (e < 768) {
                    if (e < 173) {
                      if (127 <= e && e <= 159)
                        return n.CLUSTER_BREAK.CONTROL;
                    } else if (e === 173)
                      return n.CLUSTER_BREAK.CONTROL;
                  } else if (e < 1155) {
                    if (768 <= e && e <= 879)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1425) {
                    if (1155 <= e && e <= 1161)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (1425 <= e && e <= 1469)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 1552) {
                  if (e < 1476) {
                    if (e < 1473) {
                      if (e === 1471)
                        return n.CLUSTER_BREAK.EXTEND;
                    } else if (1473 <= e && e <= 1474)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1479) {
                    if (1476 <= e && e <= 1477)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1536) {
                    if (e === 1479)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (1536 <= e && e <= 1541)
                    return n.CLUSTER_BREAK.PREPEND;
                } else if (e < 1648) {
                  if (e < 1564) {
                    if (1552 <= e && e <= 1562)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1611) {
                    if (e === 1564)
                      return n.CLUSTER_BREAK.CONTROL;
                  } else if (1611 <= e && e <= 1631)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 1750) {
                  if (e === 1648)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 1757) {
                  if (1750 <= e && e <= 1756)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e === 1757)
                  return n.CLUSTER_BREAK.PREPEND;
              } else if (e < 2075) {
                if (e < 1840)
                  if (e < 1770) {
                    if (e < 1767) {
                      if (1759 <= e && e <= 1764)
                        return n.CLUSTER_BREAK.EXTEND;
                    } else if (1767 <= e && e <= 1768)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1807) {
                    if (1770 <= e && e <= 1773)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else {
                    if (e === 1807)
                      return n.CLUSTER_BREAK.PREPEND;
                    if (e === 1809)
                      return n.CLUSTER_BREAK.EXTEND;
                  }
                else if (e < 2027) {
                  if (e < 1958) {
                    if (1840 <= e && e <= 1866)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (1958 <= e && e <= 1968)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 2045) {
                  if (2027 <= e && e <= 2035)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 2070) {
                  if (e === 2045)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (2070 <= e && e <= 2073)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 2200) {
                if (e < 2089) {
                  if (e < 2085) {
                    if (2075 <= e && e <= 2083)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (2085 <= e && e <= 2087)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 2137) {
                  if (2089 <= e && e <= 2093)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 2192) {
                  if (2137 <= e && e <= 2139)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (2192 <= e && e <= 2193)
                  return n.CLUSTER_BREAK.PREPEND;
              } else if (e < 2275) {
                if (e < 2250) {
                  if (2200 <= e && e <= 2207)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 2274) {
                  if (2250 <= e && e <= 2273)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e === 2274)
                  return n.CLUSTER_BREAK.PREPEND;
              } else if (e < 2307) {
                if (2275 <= e && e <= 2306)
                  return n.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 2307)
                  return n.CLUSTER_BREAK.SPACINGMARK;
                if (e === 2362)
                  return n.CLUSTER_BREAK.EXTEND;
              }
            else if (e < 2561) {
              if (e < 2434) {
                if (e < 2381) {
                  if (e < 2366) {
                    if (e === 2363)
                      return n.CLUSTER_BREAK.SPACINGMARK;
                    if (e === 2364)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2369) {
                    if (2366 <= e && e <= 2368)
                      return n.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 2377) {
                    if (2369 <= e && e <= 2376)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (2377 <= e && e <= 2380)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2385) {
                  if (e < 2382) {
                    if (e === 2381)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (2382 <= e && e <= 2383)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2402) {
                  if (2385 <= e && e <= 2391)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 2433) {
                  if (2402 <= e && e <= 2403)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e === 2433)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 2503) {
                if (e < 2494) {
                  if (e < 2492) {
                    if (2434 <= e && e <= 2435)
                      return n.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e === 2492)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 2495) {
                  if (e === 2494)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 2497) {
                  if (2495 <= e && e <= 2496)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (2497 <= e && e <= 2500)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 2519) {
                if (e < 2507) {
                  if (2503 <= e && e <= 2504)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2509) {
                  if (2507 <= e && e <= 2508)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e === 2509)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 2530) {
                if (e === 2519)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 2558) {
                if (2530 <= e && e <= 2531)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e === 2558)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 2691) {
              if (e < 2631) {
                if (e < 2620) {
                  if (e < 2563) {
                    if (2561 <= e && e <= 2562)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (e === 2563)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2622) {
                  if (e === 2620)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 2625) {
                  if (2622 <= e && e <= 2624)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (2625 <= e && e <= 2626)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 2672) {
                if (e < 2635) {
                  if (2631 <= e && e <= 2632)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 2641) {
                  if (2635 <= e && e <= 2637)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e === 2641)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 2677) {
                if (2672 <= e && e <= 2673)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 2689) {
                if (e === 2677)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (2689 <= e && e <= 2690)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 2761) {
              if (e < 2750) {
                if (e === 2691)
                  return n.CLUSTER_BREAK.SPACINGMARK;
                if (e === 2748)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 2753) {
                if (2750 <= e && e <= 2752)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 2759) {
                if (2753 <= e && e <= 2757)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (2759 <= e && e <= 2760)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 2786) {
              if (e < 2763) {
                if (e === 2761)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 2765) {
                if (2763 <= e && e <= 2764)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e === 2765)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 2810) {
              if (2786 <= e && e <= 2787)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 2817) {
              if (2810 <= e && e <= 2815)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e === 2817)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 3315) {
            if (e < 3076) {
              if (e < 2946) {
                if (e < 2887) {
                  if (e < 2878) {
                    if (e < 2876) {
                      if (2818 <= e && e <= 2819)
                        return n.CLUSTER_BREAK.SPACINGMARK;
                    } else if (e === 2876)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2880) {
                    if (2878 <= e && e <= 2879)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2881) {
                    if (e === 2880)
                      return n.CLUSTER_BREAK.SPACINGMARK;
                  } else if (2881 <= e && e <= 2884)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 2893) {
                  if (e < 2891) {
                    if (2887 <= e && e <= 2888)
                      return n.CLUSTER_BREAK.SPACINGMARK;
                  } else if (2891 <= e && e <= 2892)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2901) {
                  if (e === 2893)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 2914) {
                  if (2901 <= e && e <= 2903)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (2914 <= e && e <= 2915)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3014) {
                if (e < 3007) {
                  if (e === 2946 || e === 3006)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 3008) {
                  if (e === 3007)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 3009) {
                  if (e === 3008)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (3009 <= e && e <= 3010)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3031) {
                if (e < 3018) {
                  if (3014 <= e && e <= 3016)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 3021) {
                  if (3018 <= e && e <= 3020)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e === 3021)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3072) {
                if (e === 3031)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3073) {
                if (e === 3072)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (3073 <= e && e <= 3075)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3262) {
              if (e < 3146) {
                if (e < 3134) {
                  if (e === 3076 || e === 3132)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 3137) {
                  if (3134 <= e && e <= 3136)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 3142) {
                  if (3137 <= e && e <= 3140)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (3142 <= e && e <= 3144)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3201) {
                if (e < 3157) {
                  if (3146 <= e && e <= 3149)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 3170) {
                  if (3157 <= e && e <= 3158)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (3170 <= e && e <= 3171)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3202) {
                if (e === 3201)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3260) {
                if (3202 <= e && e <= 3203)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e === 3260)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 3270) {
              if (e < 3264) {
                if (e === 3262)
                  return n.CLUSTER_BREAK.SPACINGMARK;
                if (e === 3263)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3266) {
                if (3264 <= e && e <= 3265)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3267) {
                if (e === 3266)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (3267 <= e && e <= 3268)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3276) {
              if (e < 3271) {
                if (e === 3270)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3274) {
                if (3271 <= e && e <= 3272)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (3274 <= e && e <= 3275)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3285) {
              if (3276 <= e && e <= 3277)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 3298) {
              if (3285 <= e && e <= 3286)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (3298 <= e && e <= 3299)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 3551) {
            if (e < 3406) {
              if (e < 3391) {
                if (e < 3330) {
                  if (e < 3328) {
                    if (e === 3315)
                      return n.CLUSTER_BREAK.SPACINGMARK;
                  } else if (3328 <= e && e <= 3329)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 3387) {
                  if (3330 <= e && e <= 3331)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 3390) {
                  if (3387 <= e && e <= 3388)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e === 3390)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3398) {
                if (e < 3393) {
                  if (3391 <= e && e <= 3392)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (3393 <= e && e <= 3396)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3402) {
                if (3398 <= e && e <= 3400)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3405) {
                if (3402 <= e && e <= 3404)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e === 3405)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 3530) {
              if (e < 3426) {
                if (e === 3406)
                  return n.CLUSTER_BREAK.PREPEND;
                if (e === 3415)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3457) {
                if (3426 <= e && e <= 3427)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3458) {
                if (e === 3457)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (3458 <= e && e <= 3459)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3538) {
              if (e < 3535) {
                if (e === 3530)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3536) {
                if (e === 3535)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (3536 <= e && e <= 3537)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3542) {
              if (3538 <= e && e <= 3540)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 3544) {
              if (e === 3542)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (3544 <= e && e <= 3550)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 3893) {
            if (e < 3655) {
              if (e < 3633) {
                if (e < 3570) {
                  if (e === 3551)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (3570 <= e && e <= 3571)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3635) {
                if (e === 3633)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 3636) {
                if (e === 3635)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (3636 <= e && e <= 3642)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 3764)
              if (e < 3761) {
                if (3655 <= e && e <= 3662)
                  return n.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 3761)
                  return n.CLUSTER_BREAK.EXTEND;
                if (e === 3763)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              }
            else if (e < 3784) {
              if (3764 <= e && e <= 3772)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 3864) {
              if (3784 <= e && e <= 3790)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (3864 <= e && e <= 3865)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 3967) {
            if (e < 3897) {
              if (e === 3893 || e === 3895)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 3902) {
              if (e === 3897)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 3953) {
              if (3902 <= e && e <= 3903)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (3953 <= e && e <= 3966)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 3981) {
            if (e < 3968) {
              if (e === 3967)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3974) {
              if (3968 <= e && e <= 3972)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (3974 <= e && e <= 3975)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 3993) {
            if (3981 <= e && e <= 3991)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 4038) {
            if (3993 <= e && e <= 4028)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e === 4038)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 7204) {
          if (e < 6448) {
            if (e < 5938) {
              if (e < 4226) {
                if (e < 4157) {
                  if (e < 4146) {
                    if (e < 4145) {
                      if (4141 <= e && e <= 4144)
                        return n.CLUSTER_BREAK.EXTEND;
                    } else if (e === 4145)
                      return n.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 4153) {
                    if (4146 <= e && e <= 4151)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (e < 4155) {
                    if (4153 <= e && e <= 4154)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (4155 <= e && e <= 4156)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 4184) {
                  if (e < 4182) {
                    if (4157 <= e && e <= 4158)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (4182 <= e && e <= 4183)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 4190) {
                  if (4184 <= e && e <= 4185)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 4209) {
                  if (4190 <= e && e <= 4192)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (4209 <= e && e <= 4212)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 4352) {
                if (e < 4229) {
                  if (e === 4226)
                    return n.CLUSTER_BREAK.EXTEND;
                  if (e === 4228)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 4237) {
                  if (4229 <= e && e <= 4230)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e === 4237 || e === 4253)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 4957) {
                if (e < 4448) {
                  if (4352 <= e && e <= 4447)
                    return n.CLUSTER_BREAK.L;
                } else if (e < 4520) {
                  if (4448 <= e && e <= 4519)
                    return n.CLUSTER_BREAK.V;
                } else if (4520 <= e && e <= 4607)
                  return n.CLUSTER_BREAK.T;
              } else if (e < 5906) {
                if (4957 <= e && e <= 4959)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 5909) {
                if (5906 <= e && e <= 5908)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e === 5909)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 6089) {
              if (e < 6070) {
                if (e < 5970) {
                  if (e < 5940) {
                    if (5938 <= e && e <= 5939)
                      return n.CLUSTER_BREAK.EXTEND;
                  } else if (e === 5940)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 6002) {
                  if (5970 <= e && e <= 5971)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 6068) {
                  if (6002 <= e && e <= 6003)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (6068 <= e && e <= 6069)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 6078) {
                if (e < 6071) {
                  if (e === 6070)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (6071 <= e && e <= 6077)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 6086) {
                if (6078 <= e && e <= 6085)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 6087) {
                if (e === 6086)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (6087 <= e && e <= 6088)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 6277)
              if (e < 6155) {
                if (e < 6109) {
                  if (6089 <= e && e <= 6099)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e === 6109)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 6158) {
                if (6155 <= e && e <= 6157)
                  return n.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 6158)
                  return n.CLUSTER_BREAK.CONTROL;
                if (e === 6159)
                  return n.CLUSTER_BREAK.EXTEND;
              }
            else if (e < 6435) {
              if (e < 6313) {
                if (6277 <= e && e <= 6278)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 6432) {
                if (e === 6313)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (6432 <= e && e <= 6434)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 6439) {
              if (6435 <= e && e <= 6438)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 6441) {
              if (6439 <= e && e <= 6440)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (6441 <= e && e <= 6443)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 6971) {
            if (e < 6744)
              if (e < 6681) {
                if (e < 6451) {
                  if (e < 6450) {
                    if (6448 <= e && e <= 6449)
                      return n.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e === 6450)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 6457) {
                  if (6451 <= e && e <= 6456)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 6679) {
                  if (6457 <= e && e <= 6459)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (6679 <= e && e <= 6680)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 6741) {
                if (e < 6683) {
                  if (6681 <= e && e <= 6682)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e === 6683)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 6742) {
                if (e === 6741)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else {
                if (e === 6742)
                  return n.CLUSTER_BREAK.EXTEND;
                if (e === 6743)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              }
            else if (e < 6771) {
              if (e < 6754) {
                if (e < 6752) {
                  if (6744 <= e && e <= 6750)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e === 6752)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 6757) {
                if (e === 6754)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 6765) {
                if (6757 <= e && e <= 6764)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (6765 <= e && e <= 6770)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 6912) {
              if (e < 6783) {
                if (6771 <= e && e <= 6780)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 6832) {
                if (e === 6783)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (6832 <= e && e <= 6862)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 6916) {
              if (6912 <= e && e <= 6915)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 6964) {
              if (e === 6916)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (6964 <= e && e <= 6970)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 7080) {
            if (e < 7019) {
              if (e < 6973) {
                if (e === 6971)
                  return n.CLUSTER_BREAK.SPACINGMARK;
                if (e === 6972)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 6978) {
                if (6973 <= e && e <= 6977)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 6979) {
                if (e === 6978)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (6979 <= e && e <= 6980)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 7073) {
              if (e < 7040) {
                if (7019 <= e && e <= 7027)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 7042) {
                if (7040 <= e && e <= 7041)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e === 7042)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 7074) {
              if (e === 7073)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 7078) {
              if (7074 <= e && e <= 7077)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (7078 <= e && e <= 7079)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 7144)
            if (e < 7083) {
              if (e < 7082) {
                if (7080 <= e && e <= 7081)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e === 7082)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 7142) {
              if (7083 <= e && e <= 7085)
                return n.CLUSTER_BREAK.EXTEND;
            } else {
              if (e === 7142)
                return n.CLUSTER_BREAK.EXTEND;
              if (e === 7143)
                return n.CLUSTER_BREAK.SPACINGMARK;
            }
          else if (e < 7150) {
            if (e < 7146) {
              if (7144 <= e && e <= 7145)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 7149) {
              if (7146 <= e && e <= 7148)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 7149)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 7151) {
            if (e === 7150)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 7154) {
            if (7151 <= e && e <= 7153)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (7154 <= e && e <= 7155)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 43346) {
          if (e < 11647) {
            if (e < 7415) {
              if (e < 7380) {
                if (e < 7220) {
                  if (e < 7212) {
                    if (7204 <= e && e <= 7211)
                      return n.CLUSTER_BREAK.SPACINGMARK;
                  } else if (7212 <= e && e <= 7219)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e < 7222) {
                  if (7220 <= e && e <= 7221)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 7376) {
                  if (7222 <= e && e <= 7223)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (7376 <= e && e <= 7378)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 7394) {
                if (e < 7393) {
                  if (7380 <= e && e <= 7392)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e === 7393)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 7405) {
                if (7394 <= e && e <= 7400)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e === 7405 || e === 7412)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 8205)
              if (e < 7616) {
                if (e < 7416) {
                  if (e === 7415)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (7416 <= e && e <= 7417)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 8203) {
                if (7616 <= e && e <= 7679)
                  return n.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 8203)
                  return n.CLUSTER_BREAK.CONTROL;
                if (e === 8204)
                  return n.CLUSTER_BREAK.EXTEND;
              }
            else if (e < 8288) {
              if (e < 8206) {
                if (e === 8205)
                  return n.CLUSTER_BREAK.ZWJ;
              } else if (e < 8232) {
                if (8206 <= e && e <= 8207)
                  return n.CLUSTER_BREAK.CONTROL;
              } else if (8232 <= e && e <= 8238)
                return n.CLUSTER_BREAK.CONTROL;
            } else if (e < 8400) {
              if (8288 <= e && e <= 8303)
                return n.CLUSTER_BREAK.CONTROL;
            } else if (e < 11503) {
              if (8400 <= e && e <= 8432)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (11503 <= e && e <= 11505)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 43043) {
            if (e < 42612) {
              if (e < 12330) {
                if (e < 11744) {
                  if (e === 11647)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (11744 <= e && e <= 11775)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 12441) {
                if (12330 <= e && e <= 12335)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 42607) {
                if (12441 <= e && e <= 12442)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (42607 <= e && e <= 42610)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 43010) {
              if (e < 42654) {
                if (42612 <= e && e <= 42621)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 42736) {
                if (42654 <= e && e <= 42655)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (42736 <= e && e <= 42737)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 43014) {
              if (e === 43010)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e === 43014 || e === 43019)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 43188) {
            if (e < 43047) {
              if (e < 43045) {
                if (43043 <= e && e <= 43044)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (43045 <= e && e <= 43046)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 43052) {
              if (e === 43047)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43136) {
              if (e === 43052)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (43136 <= e && e <= 43137)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 43263) {
            if (e < 43204) {
              if (43188 <= e && e <= 43203)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43232) {
              if (43204 <= e && e <= 43205)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (43232 <= e && e <= 43249)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 43302) {
            if (e === 43263)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 43335) {
            if (43302 <= e && e <= 43309)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (43335 <= e && e <= 43345)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 43698) {
          if (e < 43493) {
            if (e < 43444)
              if (e < 43392) {
                if (e < 43360) {
                  if (43346 <= e && e <= 43347)
                    return n.CLUSTER_BREAK.SPACINGMARK;
                } else if (43360 <= e && e <= 43388)
                  return n.CLUSTER_BREAK.L;
              } else if (e < 43395) {
                if (43392 <= e && e <= 43394)
                  return n.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 43395)
                  return n.CLUSTER_BREAK.SPACINGMARK;
                if (e === 43443)
                  return n.CLUSTER_BREAK.EXTEND;
              }
            else if (e < 43450) {
              if (e < 43446) {
                if (43444 <= e && e <= 43445)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (43446 <= e && e <= 43449)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 43452) {
              if (43450 <= e && e <= 43451)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43454) {
              if (43452 <= e && e <= 43453)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (43454 <= e && e <= 43456)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 43573) {
            if (e < 43567) {
              if (e < 43561) {
                if (e === 43493)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (43561 <= e && e <= 43566)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 43569) {
              if (43567 <= e && e <= 43568)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43571) {
              if (43569 <= e && e <= 43570)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (43571 <= e && e <= 43572)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 43597) {
            if (e < 43587) {
              if (43573 <= e && e <= 43574)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e === 43587 || e === 43596)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 43644) {
            if (e === 43597)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e === 43644 || e === 43696)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 44006) {
          if (e < 43756)
            if (e < 43710) {
              if (e < 43703) {
                if (43698 <= e && e <= 43700)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (43703 <= e && e <= 43704)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 43713) {
              if (43710 <= e && e <= 43711)
                return n.CLUSTER_BREAK.EXTEND;
            } else {
              if (e === 43713)
                return n.CLUSTER_BREAK.EXTEND;
              if (e === 43755)
                return n.CLUSTER_BREAK.SPACINGMARK;
            }
          else if (e < 43766) {
            if (e < 43758) {
              if (43756 <= e && e <= 43757)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 43765) {
              if (43758 <= e && e <= 43759)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 43765)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 44003) {
            if (e === 43766)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 44005) {
            if (44003 <= e && e <= 44004)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e === 44005)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 44032)
          if (e < 44009) {
            if (e < 44008) {
              if (44006 <= e && e <= 44007)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 44008)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 44012) {
            if (44009 <= e && e <= 44010)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else {
            if (e === 44012)
              return n.CLUSTER_BREAK.SPACINGMARK;
            if (e === 44013)
              return n.CLUSTER_BREAK.EXTEND;
          }
        else if (e < 44061) {
          if (e < 44033) {
            if (e === 44032)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 44060) {
            if (44033 <= e && e <= 44059)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 44060)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 44088) {
          if (44061 <= e && e <= 44087)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 44089) {
          if (e === 44088)
            return n.CLUSTER_BREAK.LV;
        } else if (44089 <= e && e <= 44115)
          return n.CLUSTER_BREAK.LVT;
      } else if (e < 46497) {
        if (e < 45293) {
          if (e < 44704) {
            if (e < 44397) {
              if (e < 44256) {
                if (e < 44173) {
                  if (e < 44144) {
                    if (e < 44117) {
                      if (e === 44116)
                        return n.CLUSTER_BREAK.LV;
                    } else if (44117 <= e && e <= 44143)
                      return n.CLUSTER_BREAK.LVT;
                  } else if (e < 44145) {
                    if (e === 44144)
                      return n.CLUSTER_BREAK.LV;
                  } else if (e < 44172) {
                    if (44145 <= e && e <= 44171)
                      return n.CLUSTER_BREAK.LVT;
                  } else if (e === 44172)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 44201) {
                  if (e < 44200) {
                    if (44173 <= e && e <= 44199)
                      return n.CLUSTER_BREAK.LVT;
                  } else if (e === 44200)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 44228) {
                  if (44201 <= e && e <= 44227)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 44229) {
                  if (e === 44228)
                    return n.CLUSTER_BREAK.LV;
                } else if (44229 <= e && e <= 44255)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 44313) {
                if (e < 44284) {
                  if (e < 44257) {
                    if (e === 44256)
                      return n.CLUSTER_BREAK.LV;
                  } else if (44257 <= e && e <= 44283)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 44285) {
                  if (e === 44284)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 44312) {
                  if (44285 <= e && e <= 44311)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 44312)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 44368) {
                if (e < 44340) {
                  if (44313 <= e && e <= 44339)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 44341) {
                  if (e === 44340)
                    return n.CLUSTER_BREAK.LV;
                } else if (44341 <= e && e <= 44367)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 44369) {
                if (e === 44368)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 44396) {
                if (44369 <= e && e <= 44395)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 44396)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 44537) {
              if (e < 44480) {
                if (e < 44425) {
                  if (e < 44424) {
                    if (44397 <= e && e <= 44423)
                      return n.CLUSTER_BREAK.LVT;
                  } else if (e === 44424)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 44452) {
                  if (44425 <= e && e <= 44451)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 44453) {
                  if (e === 44452)
                    return n.CLUSTER_BREAK.LV;
                } else if (44453 <= e && e <= 44479)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 44508) {
                if (e < 44481) {
                  if (e === 44480)
                    return n.CLUSTER_BREAK.LV;
                } else if (44481 <= e && e <= 44507)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 44509) {
                if (e === 44508)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 44536) {
                if (44509 <= e && e <= 44535)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 44536)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 44620) {
              if (e < 44565) {
                if (e < 44564) {
                  if (44537 <= e && e <= 44563)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 44564)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 44592) {
                if (44565 <= e && e <= 44591)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 44593) {
                if (e === 44592)
                  return n.CLUSTER_BREAK.LV;
              } else if (44593 <= e && e <= 44619)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 44649) {
              if (e < 44621) {
                if (e === 44620)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 44648) {
                if (44621 <= e && e <= 44647)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 44648)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 44676) {
              if (44649 <= e && e <= 44675)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 44677) {
              if (e === 44676)
                return n.CLUSTER_BREAK.LV;
            } else if (44677 <= e && e <= 44703)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 44985) {
            if (e < 44844) {
              if (e < 44761) {
                if (e < 44732) {
                  if (e < 44705) {
                    if (e === 44704)
                      return n.CLUSTER_BREAK.LV;
                  } else if (44705 <= e && e <= 44731)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 44733) {
                  if (e === 44732)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 44760) {
                  if (44733 <= e && e <= 44759)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 44760)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 44789) {
                if (e < 44788) {
                  if (44761 <= e && e <= 44787)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 44788)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 44816) {
                if (44789 <= e && e <= 44815)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 44817) {
                if (e === 44816)
                  return n.CLUSTER_BREAK.LV;
              } else if (44817 <= e && e <= 44843)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 44901) {
              if (e < 44872) {
                if (e < 44845) {
                  if (e === 44844)
                    return n.CLUSTER_BREAK.LV;
                } else if (44845 <= e && e <= 44871)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 44873) {
                if (e === 44872)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 44900) {
                if (44873 <= e && e <= 44899)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 44900)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 44956) {
              if (e < 44928) {
                if (44901 <= e && e <= 44927)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 44929) {
                if (e === 44928)
                  return n.CLUSTER_BREAK.LV;
              } else if (44929 <= e && e <= 44955)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 44957) {
              if (e === 44956)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 44984) {
              if (44957 <= e && e <= 44983)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 44984)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 45152) {
            if (e < 45068) {
              if (e < 45013) {
                if (e < 45012) {
                  if (44985 <= e && e <= 45011)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 45012)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 45040) {
                if (45013 <= e && e <= 45039)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 45041) {
                if (e === 45040)
                  return n.CLUSTER_BREAK.LV;
              } else if (45041 <= e && e <= 45067)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 45097) {
              if (e < 45069) {
                if (e === 45068)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 45096) {
                if (45069 <= e && e <= 45095)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 45096)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 45124) {
              if (45097 <= e && e <= 45123)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 45125) {
              if (e === 45124)
                return n.CLUSTER_BREAK.LV;
            } else if (45125 <= e && e <= 45151)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 45209) {
            if (e < 45180) {
              if (e < 45153) {
                if (e === 45152)
                  return n.CLUSTER_BREAK.LV;
              } else if (45153 <= e && e <= 45179)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 45181) {
              if (e === 45180)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 45208) {
              if (45181 <= e && e <= 45207)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 45208)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 45264) {
            if (e < 45236) {
              if (45209 <= e && e <= 45235)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 45237) {
              if (e === 45236)
                return n.CLUSTER_BREAK.LV;
            } else if (45237 <= e && e <= 45263)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 45265) {
            if (e === 45264)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 45292) {
            if (45265 <= e && e <= 45291)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 45292)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 45908) {
          if (e < 45600) {
            if (e < 45433) {
              if (e < 45376) {
                if (e < 45321) {
                  if (e < 45320) {
                    if (45293 <= e && e <= 45319)
                      return n.CLUSTER_BREAK.LVT;
                  } else if (e === 45320)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 45348) {
                  if (45321 <= e && e <= 45347)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 45349) {
                  if (e === 45348)
                    return n.CLUSTER_BREAK.LV;
                } else if (45349 <= e && e <= 45375)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 45404) {
                if (e < 45377) {
                  if (e === 45376)
                    return n.CLUSTER_BREAK.LV;
                } else if (45377 <= e && e <= 45403)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 45405) {
                if (e === 45404)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 45432) {
                if (45405 <= e && e <= 45431)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 45432)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 45516) {
              if (e < 45461) {
                if (e < 45460) {
                  if (45433 <= e && e <= 45459)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 45460)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 45488) {
                if (45461 <= e && e <= 45487)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 45489) {
                if (e === 45488)
                  return n.CLUSTER_BREAK.LV;
              } else if (45489 <= e && e <= 45515)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 45545) {
              if (e < 45517) {
                if (e === 45516)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 45544) {
                if (45517 <= e && e <= 45543)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 45544)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 45572) {
              if (45545 <= e && e <= 45571)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 45573) {
              if (e === 45572)
                return n.CLUSTER_BREAK.LV;
            } else if (45573 <= e && e <= 45599)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 45741) {
            if (e < 45657) {
              if (e < 45628) {
                if (e < 45601) {
                  if (e === 45600)
                    return n.CLUSTER_BREAK.LV;
                } else if (45601 <= e && e <= 45627)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 45629) {
                if (e === 45628)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 45656) {
                if (45629 <= e && e <= 45655)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 45656)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 45712) {
              if (e < 45684) {
                if (45657 <= e && e <= 45683)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 45685) {
                if (e === 45684)
                  return n.CLUSTER_BREAK.LV;
              } else if (45685 <= e && e <= 45711)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 45713) {
              if (e === 45712)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 45740) {
              if (45713 <= e && e <= 45739)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 45740)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 45824) {
            if (e < 45769) {
              if (e < 45768) {
                if (45741 <= e && e <= 45767)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 45768)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 45796) {
              if (45769 <= e && e <= 45795)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 45797) {
              if (e === 45796)
                return n.CLUSTER_BREAK.LV;
            } else if (45797 <= e && e <= 45823)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 45853) {
            if (e < 45825) {
              if (e === 45824)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 45852) {
              if (45825 <= e && e <= 45851)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 45852)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 45880) {
            if (45853 <= e && e <= 45879)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 45881) {
            if (e === 45880)
              return n.CLUSTER_BREAK.LV;
          } else if (45881 <= e && e <= 45907)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 46189) {
          if (e < 46048) {
            if (e < 45965) {
              if (e < 45936) {
                if (e < 45909) {
                  if (e === 45908)
                    return n.CLUSTER_BREAK.LV;
                } else if (45909 <= e && e <= 45935)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 45937) {
                if (e === 45936)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 45964) {
                if (45937 <= e && e <= 45963)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 45964)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 45993) {
              if (e < 45992) {
                if (45965 <= e && e <= 45991)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 45992)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 46020) {
              if (45993 <= e && e <= 46019)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 46021) {
              if (e === 46020)
                return n.CLUSTER_BREAK.LV;
            } else if (46021 <= e && e <= 46047)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 46105) {
            if (e < 46076) {
              if (e < 46049) {
                if (e === 46048)
                  return n.CLUSTER_BREAK.LV;
              } else if (46049 <= e && e <= 46075)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 46077) {
              if (e === 46076)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 46104) {
              if (46077 <= e && e <= 46103)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 46104)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 46160) {
            if (e < 46132) {
              if (46105 <= e && e <= 46131)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 46133) {
              if (e === 46132)
                return n.CLUSTER_BREAK.LV;
            } else if (46133 <= e && e <= 46159)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 46161) {
            if (e === 46160)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 46188) {
            if (46161 <= e && e <= 46187)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 46188)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 46356) {
          if (e < 46272) {
            if (e < 46217) {
              if (e < 46216) {
                if (46189 <= e && e <= 46215)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 46216)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 46244) {
              if (46217 <= e && e <= 46243)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 46245) {
              if (e === 46244)
                return n.CLUSTER_BREAK.LV;
            } else if (46245 <= e && e <= 46271)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 46301) {
            if (e < 46273) {
              if (e === 46272)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 46300) {
              if (46273 <= e && e <= 46299)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 46300)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 46328) {
            if (46301 <= e && e <= 46327)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 46329) {
            if (e === 46328)
              return n.CLUSTER_BREAK.LV;
          } else if (46329 <= e && e <= 46355)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 46413) {
          if (e < 46384) {
            if (e < 46357) {
              if (e === 46356)
                return n.CLUSTER_BREAK.LV;
            } else if (46357 <= e && e <= 46383)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 46385) {
            if (e === 46384)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 46412) {
            if (46385 <= e && e <= 46411)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 46412)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 46468) {
          if (e < 46440) {
            if (46413 <= e && e <= 46439)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 46441) {
            if (e === 46440)
              return n.CLUSTER_BREAK.LV;
          } else if (46441 <= e && e <= 46467)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 46469) {
          if (e === 46468)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 46496) {
          if (46469 <= e && e <= 46495)
            return n.CLUSTER_BREAK.LVT;
        } else if (e === 46496)
          return n.CLUSTER_BREAK.LV;
      } else if (e < 47701) {
        if (e < 47112) {
          if (e < 46804) {
            if (e < 46637) {
              if (e < 46580) {
                if (e < 46525) {
                  if (e < 46524) {
                    if (46497 <= e && e <= 46523)
                      return n.CLUSTER_BREAK.LVT;
                  } else if (e === 46524)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 46552) {
                  if (46525 <= e && e <= 46551)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 46553) {
                  if (e === 46552)
                    return n.CLUSTER_BREAK.LV;
                } else if (46553 <= e && e <= 46579)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 46608) {
                if (e < 46581) {
                  if (e === 46580)
                    return n.CLUSTER_BREAK.LV;
                } else if (46581 <= e && e <= 46607)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 46609) {
                if (e === 46608)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 46636) {
                if (46609 <= e && e <= 46635)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 46636)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 46720) {
              if (e < 46665) {
                if (e < 46664) {
                  if (46637 <= e && e <= 46663)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 46664)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 46692) {
                if (46665 <= e && e <= 46691)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 46693) {
                if (e === 46692)
                  return n.CLUSTER_BREAK.LV;
              } else if (46693 <= e && e <= 46719)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 46749) {
              if (e < 46721) {
                if (e === 46720)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 46748) {
                if (46721 <= e && e <= 46747)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 46748)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 46776) {
              if (46749 <= e && e <= 46775)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 46777) {
              if (e === 46776)
                return n.CLUSTER_BREAK.LV;
            } else if (46777 <= e && e <= 46803)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 46945) {
            if (e < 46861) {
              if (e < 46832) {
                if (e < 46805) {
                  if (e === 46804)
                    return n.CLUSTER_BREAK.LV;
                } else if (46805 <= e && e <= 46831)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 46833) {
                if (e === 46832)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 46860) {
                if (46833 <= e && e <= 46859)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 46860)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 46916) {
              if (e < 46888) {
                if (46861 <= e && e <= 46887)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 46889) {
                if (e === 46888)
                  return n.CLUSTER_BREAK.LV;
              } else if (46889 <= e && e <= 46915)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 46917) {
              if (e === 46916)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 46944) {
              if (46917 <= e && e <= 46943)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 46944)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 47028) {
            if (e < 46973) {
              if (e < 46972) {
                if (46945 <= e && e <= 46971)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 46972)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 47e3) {
              if (46973 <= e && e <= 46999)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 47001) {
              if (e === 47e3)
                return n.CLUSTER_BREAK.LV;
            } else if (47001 <= e && e <= 47027)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 47057) {
            if (e < 47029) {
              if (e === 47028)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 47056) {
              if (47029 <= e && e <= 47055)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 47056)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 47084) {
            if (47057 <= e && e <= 47083)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 47085) {
            if (e === 47084)
              return n.CLUSTER_BREAK.LV;
          } else if (47085 <= e && e <= 47111)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 47393) {
          if (e < 47252) {
            if (e < 47169) {
              if (e < 47140) {
                if (e < 47113) {
                  if (e === 47112)
                    return n.CLUSTER_BREAK.LV;
                } else if (47113 <= e && e <= 47139)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 47141) {
                if (e === 47140)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 47168) {
                if (47141 <= e && e <= 47167)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 47168)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 47197) {
              if (e < 47196) {
                if (47169 <= e && e <= 47195)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 47196)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 47224) {
              if (47197 <= e && e <= 47223)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 47225) {
              if (e === 47224)
                return n.CLUSTER_BREAK.LV;
            } else if (47225 <= e && e <= 47251)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 47309) {
            if (e < 47280) {
              if (e < 47253) {
                if (e === 47252)
                  return n.CLUSTER_BREAK.LV;
              } else if (47253 <= e && e <= 47279)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 47281) {
              if (e === 47280)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 47308) {
              if (47281 <= e && e <= 47307)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 47308)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 47364) {
            if (e < 47336) {
              if (47309 <= e && e <= 47335)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 47337) {
              if (e === 47336)
                return n.CLUSTER_BREAK.LV;
            } else if (47337 <= e && e <= 47363)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 47365) {
            if (e === 47364)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 47392) {
            if (47365 <= e && e <= 47391)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 47392)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 47560) {
          if (e < 47476) {
            if (e < 47421) {
              if (e < 47420) {
                if (47393 <= e && e <= 47419)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 47420)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 47448) {
              if (47421 <= e && e <= 47447)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 47449) {
              if (e === 47448)
                return n.CLUSTER_BREAK.LV;
            } else if (47449 <= e && e <= 47475)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 47505) {
            if (e < 47477) {
              if (e === 47476)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 47504) {
              if (47477 <= e && e <= 47503)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 47504)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 47532) {
            if (47505 <= e && e <= 47531)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 47533) {
            if (e === 47532)
              return n.CLUSTER_BREAK.LV;
          } else if (47533 <= e && e <= 47559)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 47617) {
          if (e < 47588) {
            if (e < 47561) {
              if (e === 47560)
                return n.CLUSTER_BREAK.LV;
            } else if (47561 <= e && e <= 47587)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 47589) {
            if (e === 47588)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 47616) {
            if (47589 <= e && e <= 47615)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 47616)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 47672) {
          if (e < 47644) {
            if (47617 <= e && e <= 47643)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 47645) {
            if (e === 47644)
              return n.CLUSTER_BREAK.LV;
          } else if (47645 <= e && e <= 47671)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 47673) {
          if (e === 47672)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 47700) {
          if (47673 <= e && e <= 47699)
            return n.CLUSTER_BREAK.LVT;
        } else if (e === 47700)
          return n.CLUSTER_BREAK.LV;
      } else if (e < 48316) {
        if (e < 48008) {
          if (e < 47841) {
            if (e < 47784) {
              if (e < 47729) {
                if (e < 47728) {
                  if (47701 <= e && e <= 47727)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 47728)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 47756) {
                if (47729 <= e && e <= 47755)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 47757) {
                if (e === 47756)
                  return n.CLUSTER_BREAK.LV;
              } else if (47757 <= e && e <= 47783)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 47812) {
              if (e < 47785) {
                if (e === 47784)
                  return n.CLUSTER_BREAK.LV;
              } else if (47785 <= e && e <= 47811)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 47813) {
              if (e === 47812)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 47840) {
              if (47813 <= e && e <= 47839)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 47840)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 47924) {
            if (e < 47869) {
              if (e < 47868) {
                if (47841 <= e && e <= 47867)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 47868)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 47896) {
              if (47869 <= e && e <= 47895)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 47897) {
              if (e === 47896)
                return n.CLUSTER_BREAK.LV;
            } else if (47897 <= e && e <= 47923)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 47953) {
            if (e < 47925) {
              if (e === 47924)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 47952) {
              if (47925 <= e && e <= 47951)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 47952)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 47980) {
            if (47953 <= e && e <= 47979)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 47981) {
            if (e === 47980)
              return n.CLUSTER_BREAK.LV;
          } else if (47981 <= e && e <= 48007)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 48149) {
          if (e < 48065) {
            if (e < 48036) {
              if (e < 48009) {
                if (e === 48008)
                  return n.CLUSTER_BREAK.LV;
              } else if (48009 <= e && e <= 48035)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 48037) {
              if (e === 48036)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 48064) {
              if (48037 <= e && e <= 48063)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 48064)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 48120) {
            if (e < 48092) {
              if (48065 <= e && e <= 48091)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 48093) {
              if (e === 48092)
                return n.CLUSTER_BREAK.LV;
            } else if (48093 <= e && e <= 48119)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 48121) {
            if (e === 48120)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 48148) {
            if (48121 <= e && e <= 48147)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 48148)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 48232) {
          if (e < 48177) {
            if (e < 48176) {
              if (48149 <= e && e <= 48175)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 48176)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 48204) {
            if (48177 <= e && e <= 48203)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 48205) {
            if (e === 48204)
              return n.CLUSTER_BREAK.LV;
          } else if (48205 <= e && e <= 48231)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 48261) {
          if (e < 48233) {
            if (e === 48232)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 48260) {
            if (48233 <= e && e <= 48259)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 48260)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 48288) {
          if (48261 <= e && e <= 48287)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 48289) {
          if (e === 48288)
            return n.CLUSTER_BREAK.LV;
        } else if (48289 <= e && e <= 48315)
          return n.CLUSTER_BREAK.LVT;
      } else if (e < 48597) {
        if (e < 48456) {
          if (e < 48373) {
            if (e < 48344) {
              if (e < 48317) {
                if (e === 48316)
                  return n.CLUSTER_BREAK.LV;
              } else if (48317 <= e && e <= 48343)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 48345) {
              if (e === 48344)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 48372) {
              if (48345 <= e && e <= 48371)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 48372)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 48401) {
            if (e < 48400) {
              if (48373 <= e && e <= 48399)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 48400)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 48428) {
            if (48401 <= e && e <= 48427)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 48429) {
            if (e === 48428)
              return n.CLUSTER_BREAK.LV;
          } else if (48429 <= e && e <= 48455)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 48513) {
          if (e < 48484) {
            if (e < 48457) {
              if (e === 48456)
                return n.CLUSTER_BREAK.LV;
            } else if (48457 <= e && e <= 48483)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 48485) {
            if (e === 48484)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 48512) {
            if (48485 <= e && e <= 48511)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 48512)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 48568) {
          if (e < 48540) {
            if (48513 <= e && e <= 48539)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 48541) {
            if (e === 48540)
              return n.CLUSTER_BREAK.LV;
          } else if (48541 <= e && e <= 48567)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 48569) {
          if (e === 48568)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 48596) {
          if (48569 <= e && e <= 48595)
            return n.CLUSTER_BREAK.LVT;
        } else if (e === 48596)
          return n.CLUSTER_BREAK.LV;
      } else if (e < 48764) {
        if (e < 48680) {
          if (e < 48625) {
            if (e < 48624) {
              if (48597 <= e && e <= 48623)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 48624)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 48652) {
            if (48625 <= e && e <= 48651)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 48653) {
            if (e === 48652)
              return n.CLUSTER_BREAK.LV;
          } else if (48653 <= e && e <= 48679)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 48709) {
          if (e < 48681) {
            if (e === 48680)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 48708) {
            if (48681 <= e && e <= 48707)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 48708)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 48736) {
          if (48709 <= e && e <= 48735)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 48737) {
          if (e === 48736)
            return n.CLUSTER_BREAK.LV;
        } else if (48737 <= e && e <= 48763)
          return n.CLUSTER_BREAK.LVT;
      } else if (e < 48821) {
        if (e < 48792) {
          if (e < 48765) {
            if (e === 48764)
              return n.CLUSTER_BREAK.LV;
          } else if (48765 <= e && e <= 48791)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 48793) {
          if (e === 48792)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 48820) {
          if (48793 <= e && e <= 48819)
            return n.CLUSTER_BREAK.LVT;
        } else if (e === 48820)
          return n.CLUSTER_BREAK.LV;
      } else if (e < 48876) {
        if (e < 48848) {
          if (48821 <= e && e <= 48847)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 48849) {
          if (e === 48848)
            return n.CLUSTER_BREAK.LV;
        } else if (48849 <= e && e <= 48875)
          return n.CLUSTER_BREAK.LVT;
      } else if (e < 48877) {
        if (e === 48876)
          return n.CLUSTER_BREAK.LV;
      } else if (e < 48904) {
        if (48877 <= e && e <= 48903)
          return n.CLUSTER_BREAK.LVT;
      } else if (e === 48904)
        return n.CLUSTER_BREAK.LV;
    } else if (e < 53720) {
      if (e < 51312) {
        if (e < 50108) {
          if (e < 49493) {
            if (e < 49212) {
              if (e < 49045) {
                if (e < 48988) {
                  if (e < 48933) {
                    if (e < 48932) {
                      if (48905 <= e && e <= 48931)
                        return n.CLUSTER_BREAK.LVT;
                    } else if (e === 48932)
                      return n.CLUSTER_BREAK.LV;
                  } else if (e < 48960) {
                    if (48933 <= e && e <= 48959)
                      return n.CLUSTER_BREAK.LVT;
                  } else if (e < 48961) {
                    if (e === 48960)
                      return n.CLUSTER_BREAK.LV;
                  } else if (48961 <= e && e <= 48987)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 49016) {
                  if (e < 48989) {
                    if (e === 48988)
                      return n.CLUSTER_BREAK.LV;
                  } else if (48989 <= e && e <= 49015)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 49017) {
                  if (e === 49016)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 49044) {
                  if (49017 <= e && e <= 49043)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 49044)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 49128) {
                if (e < 49073) {
                  if (e < 49072) {
                    if (49045 <= e && e <= 49071)
                      return n.CLUSTER_BREAK.LVT;
                  } else if (e === 49072)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 49100) {
                  if (49073 <= e && e <= 49099)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 49101) {
                  if (e === 49100)
                    return n.CLUSTER_BREAK.LV;
                } else if (49101 <= e && e <= 49127)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 49157) {
                if (e < 49129) {
                  if (e === 49128)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 49156) {
                  if (49129 <= e && e <= 49155)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 49156)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 49184) {
                if (49157 <= e && e <= 49183)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 49185) {
                if (e === 49184)
                  return n.CLUSTER_BREAK.LV;
              } else if (49185 <= e && e <= 49211)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 49352) {
              if (e < 49269) {
                if (e < 49240) {
                  if (e < 49213) {
                    if (e === 49212)
                      return n.CLUSTER_BREAK.LV;
                  } else if (49213 <= e && e <= 49239)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 49241) {
                  if (e === 49240)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 49268) {
                  if (49241 <= e && e <= 49267)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 49268)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 49297) {
                if (e < 49296) {
                  if (49269 <= e && e <= 49295)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 49296)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 49324) {
                if (49297 <= e && e <= 49323)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 49325) {
                if (e === 49324)
                  return n.CLUSTER_BREAK.LV;
              } else if (49325 <= e && e <= 49351)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 49409) {
              if (e < 49380) {
                if (e < 49353) {
                  if (e === 49352)
                    return n.CLUSTER_BREAK.LV;
                } else if (49353 <= e && e <= 49379)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 49381) {
                if (e === 49380)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 49408) {
                if (49381 <= e && e <= 49407)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 49408)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 49464) {
              if (e < 49436) {
                if (49409 <= e && e <= 49435)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 49437) {
                if (e === 49436)
                  return n.CLUSTER_BREAK.LV;
              } else if (49437 <= e && e <= 49463)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 49465) {
              if (e === 49464)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 49492) {
              if (49465 <= e && e <= 49491)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 49492)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 49800) {
            if (e < 49633) {
              if (e < 49576) {
                if (e < 49521) {
                  if (e < 49520) {
                    if (49493 <= e && e <= 49519)
                      return n.CLUSTER_BREAK.LVT;
                  } else if (e === 49520)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 49548) {
                  if (49521 <= e && e <= 49547)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 49549) {
                  if (e === 49548)
                    return n.CLUSTER_BREAK.LV;
                } else if (49549 <= e && e <= 49575)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 49604) {
                if (e < 49577) {
                  if (e === 49576)
                    return n.CLUSTER_BREAK.LV;
                } else if (49577 <= e && e <= 49603)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 49605) {
                if (e === 49604)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 49632) {
                if (49605 <= e && e <= 49631)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 49632)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 49716) {
              if (e < 49661) {
                if (e < 49660) {
                  if (49633 <= e && e <= 49659)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 49660)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 49688) {
                if (49661 <= e && e <= 49687)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 49689) {
                if (e === 49688)
                  return n.CLUSTER_BREAK.LV;
              } else if (49689 <= e && e <= 49715)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 49745) {
              if (e < 49717) {
                if (e === 49716)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 49744) {
                if (49717 <= e && e <= 49743)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 49744)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 49772) {
              if (49745 <= e && e <= 49771)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 49773) {
              if (e === 49772)
                return n.CLUSTER_BREAK.LV;
            } else if (49773 <= e && e <= 49799)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 49941) {
            if (e < 49857) {
              if (e < 49828) {
                if (e < 49801) {
                  if (e === 49800)
                    return n.CLUSTER_BREAK.LV;
                } else if (49801 <= e && e <= 49827)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 49829) {
                if (e === 49828)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 49856) {
                if (49829 <= e && e <= 49855)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 49856)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 49912) {
              if (e < 49884) {
                if (49857 <= e && e <= 49883)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 49885) {
                if (e === 49884)
                  return n.CLUSTER_BREAK.LV;
              } else if (49885 <= e && e <= 49911)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 49913) {
              if (e === 49912)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 49940) {
              if (49913 <= e && e <= 49939)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 49940)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 50024) {
            if (e < 49969) {
              if (e < 49968) {
                if (49941 <= e && e <= 49967)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 49968)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 49996) {
              if (49969 <= e && e <= 49995)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 49997) {
              if (e === 49996)
                return n.CLUSTER_BREAK.LV;
            } else if (49997 <= e && e <= 50023)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 50053) {
            if (e < 50025) {
              if (e === 50024)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 50052) {
              if (50025 <= e && e <= 50051)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 50052)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 50080) {
            if (50053 <= e && e <= 50079)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 50081) {
            if (e === 50080)
              return n.CLUSTER_BREAK.LV;
          } else if (50081 <= e && e <= 50107)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 50697) {
          if (e < 50389) {
            if (e < 50248) {
              if (e < 50165) {
                if (e < 50136) {
                  if (e < 50109) {
                    if (e === 50108)
                      return n.CLUSTER_BREAK.LV;
                  } else if (50109 <= e && e <= 50135)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 50137) {
                  if (e === 50136)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 50164) {
                  if (50137 <= e && e <= 50163)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 50164)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 50193) {
                if (e < 50192) {
                  if (50165 <= e && e <= 50191)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 50192)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 50220) {
                if (50193 <= e && e <= 50219)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 50221) {
                if (e === 50220)
                  return n.CLUSTER_BREAK.LV;
              } else if (50221 <= e && e <= 50247)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 50305) {
              if (e < 50276) {
                if (e < 50249) {
                  if (e === 50248)
                    return n.CLUSTER_BREAK.LV;
                } else if (50249 <= e && e <= 50275)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 50277) {
                if (e === 50276)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 50304) {
                if (50277 <= e && e <= 50303)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 50304)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 50360) {
              if (e < 50332) {
                if (50305 <= e && e <= 50331)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 50333) {
                if (e === 50332)
                  return n.CLUSTER_BREAK.LV;
              } else if (50333 <= e && e <= 50359)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 50361) {
              if (e === 50360)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 50388) {
              if (50361 <= e && e <= 50387)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 50388)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 50556) {
            if (e < 50472) {
              if (e < 50417) {
                if (e < 50416) {
                  if (50389 <= e && e <= 50415)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 50416)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 50444) {
                if (50417 <= e && e <= 50443)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 50445) {
                if (e === 50444)
                  return n.CLUSTER_BREAK.LV;
              } else if (50445 <= e && e <= 50471)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 50501) {
              if (e < 50473) {
                if (e === 50472)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 50500) {
                if (50473 <= e && e <= 50499)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 50500)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 50528) {
              if (50501 <= e && e <= 50527)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 50529) {
              if (e === 50528)
                return n.CLUSTER_BREAK.LV;
            } else if (50529 <= e && e <= 50555)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 50613) {
            if (e < 50584) {
              if (e < 50557) {
                if (e === 50556)
                  return n.CLUSTER_BREAK.LV;
              } else if (50557 <= e && e <= 50583)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 50585) {
              if (e === 50584)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 50612) {
              if (50585 <= e && e <= 50611)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 50612)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 50668) {
            if (e < 50640) {
              if (50613 <= e && e <= 50639)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 50641) {
              if (e === 50640)
                return n.CLUSTER_BREAK.LV;
            } else if (50641 <= e && e <= 50667)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 50669) {
            if (e === 50668)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 50696) {
            if (50669 <= e && e <= 50695)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 50696)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 51004) {
          if (e < 50837) {
            if (e < 50780) {
              if (e < 50725) {
                if (e < 50724) {
                  if (50697 <= e && e <= 50723)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 50724)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 50752) {
                if (50725 <= e && e <= 50751)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 50753) {
                if (e === 50752)
                  return n.CLUSTER_BREAK.LV;
              } else if (50753 <= e && e <= 50779)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 50808) {
              if (e < 50781) {
                if (e === 50780)
                  return n.CLUSTER_BREAK.LV;
              } else if (50781 <= e && e <= 50807)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 50809) {
              if (e === 50808)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 50836) {
              if (50809 <= e && e <= 50835)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 50836)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 50920) {
            if (e < 50865) {
              if (e < 50864) {
                if (50837 <= e && e <= 50863)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 50864)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 50892) {
              if (50865 <= e && e <= 50891)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 50893) {
              if (e === 50892)
                return n.CLUSTER_BREAK.LV;
            } else if (50893 <= e && e <= 50919)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 50949) {
            if (e < 50921) {
              if (e === 50920)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 50948) {
              if (50921 <= e && e <= 50947)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 50948)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 50976) {
            if (50949 <= e && e <= 50975)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 50977) {
            if (e === 50976)
              return n.CLUSTER_BREAK.LV;
          } else if (50977 <= e && e <= 51003)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 51145) {
          if (e < 51061) {
            if (e < 51032) {
              if (e < 51005) {
                if (e === 51004)
                  return n.CLUSTER_BREAK.LV;
              } else if (51005 <= e && e <= 51031)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 51033) {
              if (e === 51032)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 51060) {
              if (51033 <= e && e <= 51059)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 51060)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 51116) {
            if (e < 51088) {
              if (51061 <= e && e <= 51087)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 51089) {
              if (e === 51088)
                return n.CLUSTER_BREAK.LV;
            } else if (51089 <= e && e <= 51115)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 51117) {
            if (e === 51116)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 51144) {
            if (51117 <= e && e <= 51143)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 51144)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 51228) {
          if (e < 51173) {
            if (e < 51172) {
              if (51145 <= e && e <= 51171)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 51172)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 51200) {
            if (51173 <= e && e <= 51199)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 51201) {
            if (e === 51200)
              return n.CLUSTER_BREAK.LV;
          } else if (51201 <= e && e <= 51227)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 51257) {
          if (e < 51229) {
            if (e === 51228)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 51256) {
            if (51229 <= e && e <= 51255)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 51256)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 51284) {
          if (51257 <= e && e <= 51283)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 51285) {
          if (e === 51284)
            return n.CLUSTER_BREAK.LV;
        } else if (51285 <= e && e <= 51311)
          return n.CLUSTER_BREAK.LVT;
      } else if (e < 52516) {
        if (e < 51901) {
          if (e < 51593) {
            if (e < 51452) {
              if (e < 51369) {
                if (e < 51340) {
                  if (e < 51313) {
                    if (e === 51312)
                      return n.CLUSTER_BREAK.LV;
                  } else if (51313 <= e && e <= 51339)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 51341) {
                  if (e === 51340)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 51368) {
                  if (51341 <= e && e <= 51367)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 51368)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 51397) {
                if (e < 51396) {
                  if (51369 <= e && e <= 51395)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 51396)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 51424) {
                if (51397 <= e && e <= 51423)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 51425) {
                if (e === 51424)
                  return n.CLUSTER_BREAK.LV;
              } else if (51425 <= e && e <= 51451)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 51509) {
              if (e < 51480) {
                if (e < 51453) {
                  if (e === 51452)
                    return n.CLUSTER_BREAK.LV;
                } else if (51453 <= e && e <= 51479)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 51481) {
                if (e === 51480)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 51508) {
                if (51481 <= e && e <= 51507)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 51508)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 51564) {
              if (e < 51536) {
                if (51509 <= e && e <= 51535)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 51537) {
                if (e === 51536)
                  return n.CLUSTER_BREAK.LV;
              } else if (51537 <= e && e <= 51563)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 51565) {
              if (e === 51564)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 51592) {
              if (51565 <= e && e <= 51591)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 51592)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 51760) {
            if (e < 51676) {
              if (e < 51621) {
                if (e < 51620) {
                  if (51593 <= e && e <= 51619)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 51620)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 51648) {
                if (51621 <= e && e <= 51647)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 51649) {
                if (e === 51648)
                  return n.CLUSTER_BREAK.LV;
              } else if (51649 <= e && e <= 51675)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 51705) {
              if (e < 51677) {
                if (e === 51676)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 51704) {
                if (51677 <= e && e <= 51703)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 51704)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 51732) {
              if (51705 <= e && e <= 51731)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 51733) {
              if (e === 51732)
                return n.CLUSTER_BREAK.LV;
            } else if (51733 <= e && e <= 51759)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 51817) {
            if (e < 51788) {
              if (e < 51761) {
                if (e === 51760)
                  return n.CLUSTER_BREAK.LV;
              } else if (51761 <= e && e <= 51787)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 51789) {
              if (e === 51788)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 51816) {
              if (51789 <= e && e <= 51815)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 51816)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 51872) {
            if (e < 51844) {
              if (51817 <= e && e <= 51843)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 51845) {
              if (e === 51844)
                return n.CLUSTER_BREAK.LV;
            } else if (51845 <= e && e <= 51871)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 51873) {
            if (e === 51872)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 51900) {
            if (51873 <= e && e <= 51899)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 51900)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 52208) {
          if (e < 52041) {
            if (e < 51984) {
              if (e < 51929) {
                if (e < 51928) {
                  if (51901 <= e && e <= 51927)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 51928)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 51956) {
                if (51929 <= e && e <= 51955)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 51957) {
                if (e === 51956)
                  return n.CLUSTER_BREAK.LV;
              } else if (51957 <= e && e <= 51983)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 52012) {
              if (e < 51985) {
                if (e === 51984)
                  return n.CLUSTER_BREAK.LV;
              } else if (51985 <= e && e <= 52011)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 52013) {
              if (e === 52012)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 52040) {
              if (52013 <= e && e <= 52039)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 52040)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 52124) {
            if (e < 52069) {
              if (e < 52068) {
                if (52041 <= e && e <= 52067)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 52068)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 52096) {
              if (52069 <= e && e <= 52095)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 52097) {
              if (e === 52096)
                return n.CLUSTER_BREAK.LV;
            } else if (52097 <= e && e <= 52123)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 52153) {
            if (e < 52125) {
              if (e === 52124)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 52152) {
              if (52125 <= e && e <= 52151)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 52152)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 52180) {
            if (52153 <= e && e <= 52179)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 52181) {
            if (e === 52180)
              return n.CLUSTER_BREAK.LV;
          } else if (52181 <= e && e <= 52207)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 52349) {
          if (e < 52265) {
            if (e < 52236) {
              if (e < 52209) {
                if (e === 52208)
                  return n.CLUSTER_BREAK.LV;
              } else if (52209 <= e && e <= 52235)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 52237) {
              if (e === 52236)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 52264) {
              if (52237 <= e && e <= 52263)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 52264)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 52320) {
            if (e < 52292) {
              if (52265 <= e && e <= 52291)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 52293) {
              if (e === 52292)
                return n.CLUSTER_BREAK.LV;
            } else if (52293 <= e && e <= 52319)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 52321) {
            if (e === 52320)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 52348) {
            if (52321 <= e && e <= 52347)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 52348)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 52432) {
          if (e < 52377) {
            if (e < 52376) {
              if (52349 <= e && e <= 52375)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 52376)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 52404) {
            if (52377 <= e && e <= 52403)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 52405) {
            if (e === 52404)
              return n.CLUSTER_BREAK.LV;
          } else if (52405 <= e && e <= 52431)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 52461) {
          if (e < 52433) {
            if (e === 52432)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 52460) {
            if (52433 <= e && e <= 52459)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 52460)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 52488) {
          if (52461 <= e && e <= 52487)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 52489) {
          if (e === 52488)
            return n.CLUSTER_BREAK.LV;
        } else if (52489 <= e && e <= 52515)
          return n.CLUSTER_BREAK.LVT;
      } else if (e < 53105) {
        if (e < 52797) {
          if (e < 52656) {
            if (e < 52573) {
              if (e < 52544) {
                if (e < 52517) {
                  if (e === 52516)
                    return n.CLUSTER_BREAK.LV;
                } else if (52517 <= e && e <= 52543)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 52545) {
                if (e === 52544)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 52572) {
                if (52545 <= e && e <= 52571)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 52572)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 52601) {
              if (e < 52600) {
                if (52573 <= e && e <= 52599)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 52600)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 52628) {
              if (52601 <= e && e <= 52627)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 52629) {
              if (e === 52628)
                return n.CLUSTER_BREAK.LV;
            } else if (52629 <= e && e <= 52655)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 52713) {
            if (e < 52684) {
              if (e < 52657) {
                if (e === 52656)
                  return n.CLUSTER_BREAK.LV;
              } else if (52657 <= e && e <= 52683)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 52685) {
              if (e === 52684)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 52712) {
              if (52685 <= e && e <= 52711)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 52712)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 52768) {
            if (e < 52740) {
              if (52713 <= e && e <= 52739)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 52741) {
              if (e === 52740)
                return n.CLUSTER_BREAK.LV;
            } else if (52741 <= e && e <= 52767)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 52769) {
            if (e === 52768)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 52796) {
            if (52769 <= e && e <= 52795)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 52796)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 52964) {
          if (e < 52880) {
            if (e < 52825) {
              if (e < 52824) {
                if (52797 <= e && e <= 52823)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 52824)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 52852) {
              if (52825 <= e && e <= 52851)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 52853) {
              if (e === 52852)
                return n.CLUSTER_BREAK.LV;
            } else if (52853 <= e && e <= 52879)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 52909) {
            if (e < 52881) {
              if (e === 52880)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 52908) {
              if (52881 <= e && e <= 52907)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 52908)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 52936) {
            if (52909 <= e && e <= 52935)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 52937) {
            if (e === 52936)
              return n.CLUSTER_BREAK.LV;
          } else if (52937 <= e && e <= 52963)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 53021) {
          if (e < 52992) {
            if (e < 52965) {
              if (e === 52964)
                return n.CLUSTER_BREAK.LV;
            } else if (52965 <= e && e <= 52991)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 52993) {
            if (e === 52992)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 53020) {
            if (52993 <= e && e <= 53019)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 53020)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 53076) {
          if (e < 53048) {
            if (53021 <= e && e <= 53047)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 53049) {
            if (e === 53048)
              return n.CLUSTER_BREAK.LV;
          } else if (53049 <= e && e <= 53075)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 53077) {
          if (e === 53076)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 53104) {
          if (53077 <= e && e <= 53103)
            return n.CLUSTER_BREAK.LVT;
        } else if (e === 53104)
          return n.CLUSTER_BREAK.LV;
      } else if (e < 53412) {
        if (e < 53245) {
          if (e < 53188) {
            if (e < 53133) {
              if (e < 53132) {
                if (53105 <= e && e <= 53131)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 53132)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 53160) {
              if (53133 <= e && e <= 53159)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 53161) {
              if (e === 53160)
                return n.CLUSTER_BREAK.LV;
            } else if (53161 <= e && e <= 53187)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 53216) {
            if (e < 53189) {
              if (e === 53188)
                return n.CLUSTER_BREAK.LV;
            } else if (53189 <= e && e <= 53215)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 53217) {
            if (e === 53216)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 53244) {
            if (53217 <= e && e <= 53243)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 53244)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 53328) {
          if (e < 53273) {
            if (e < 53272) {
              if (53245 <= e && e <= 53271)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 53272)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 53300) {
            if (53273 <= e && e <= 53299)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 53301) {
            if (e === 53300)
              return n.CLUSTER_BREAK.LV;
          } else if (53301 <= e && e <= 53327)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 53357) {
          if (e < 53329) {
            if (e === 53328)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 53356) {
            if (53329 <= e && e <= 53355)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 53356)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 53384) {
          if (53357 <= e && e <= 53383)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 53385) {
          if (e === 53384)
            return n.CLUSTER_BREAK.LV;
        } else if (53385 <= e && e <= 53411)
          return n.CLUSTER_BREAK.LVT;
      } else if (e < 53553) {
        if (e < 53469) {
          if (e < 53440) {
            if (e < 53413) {
              if (e === 53412)
                return n.CLUSTER_BREAK.LV;
            } else if (53413 <= e && e <= 53439)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 53441) {
            if (e === 53440)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 53468) {
            if (53441 <= e && e <= 53467)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 53468)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 53524) {
          if (e < 53496) {
            if (53469 <= e && e <= 53495)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 53497) {
            if (e === 53496)
              return n.CLUSTER_BREAK.LV;
          } else if (53497 <= e && e <= 53523)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 53525) {
          if (e === 53524)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 53552) {
          if (53525 <= e && e <= 53551)
            return n.CLUSTER_BREAK.LVT;
        } else if (e === 53552)
          return n.CLUSTER_BREAK.LV;
      } else if (e < 53636) {
        if (e < 53581) {
          if (e < 53580) {
            if (53553 <= e && e <= 53579)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 53580)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 53608) {
          if (53581 <= e && e <= 53607)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 53609) {
          if (e === 53608)
            return n.CLUSTER_BREAK.LV;
        } else if (53609 <= e && e <= 53635)
          return n.CLUSTER_BREAK.LVT;
      } else if (e < 53665) {
        if (e < 53637) {
          if (e === 53636)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 53664) {
          if (53637 <= e && e <= 53663)
            return n.CLUSTER_BREAK.LVT;
        } else if (e === 53664)
          return n.CLUSTER_BREAK.LV;
      } else if (e < 53692) {
        if (53665 <= e && e <= 53691)
          return n.CLUSTER_BREAK.LVT;
      } else if (e < 53693) {
        if (e === 53692)
          return n.CLUSTER_BREAK.LV;
      } else if (53693 <= e && e <= 53719)
        return n.CLUSTER_BREAK.LVT;
    } else if (e < 70459) {
      if (e < 54897) {
        if (e < 54308) {
          if (e < 54001) {
            if (e < 53860) {
              if (e < 53777) {
                if (e < 53748) {
                  if (e < 53721) {
                    if (e === 53720)
                      return n.CLUSTER_BREAK.LV;
                  } else if (53721 <= e && e <= 53747)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e < 53749) {
                  if (e === 53748)
                    return n.CLUSTER_BREAK.LV;
                } else if (e < 53776) {
                  if (53749 <= e && e <= 53775)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 53776)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 53805) {
                if (e < 53804) {
                  if (53777 <= e && e <= 53803)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 53804)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 53832) {
                if (53805 <= e && e <= 53831)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 53833) {
                if (e === 53832)
                  return n.CLUSTER_BREAK.LV;
              } else if (53833 <= e && e <= 53859)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 53917) {
              if (e < 53888) {
                if (e < 53861) {
                  if (e === 53860)
                    return n.CLUSTER_BREAK.LV;
                } else if (53861 <= e && e <= 53887)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 53889) {
                if (e === 53888)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 53916) {
                if (53889 <= e && e <= 53915)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 53916)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 53972) {
              if (e < 53944) {
                if (53917 <= e && e <= 53943)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 53945) {
                if (e === 53944)
                  return n.CLUSTER_BREAK.LV;
              } else if (53945 <= e && e <= 53971)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 53973) {
              if (e === 53972)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 54e3) {
              if (53973 <= e && e <= 53999)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 54e3)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 54141) {
            if (e < 54084) {
              if (e < 54029) {
                if (e < 54028) {
                  if (54001 <= e && e <= 54027)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 54028)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 54056) {
                if (54029 <= e && e <= 54055)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 54057) {
                if (e === 54056)
                  return n.CLUSTER_BREAK.LV;
              } else if (54057 <= e && e <= 54083)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 54112) {
              if (e < 54085) {
                if (e === 54084)
                  return n.CLUSTER_BREAK.LV;
              } else if (54085 <= e && e <= 54111)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 54113) {
              if (e === 54112)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 54140) {
              if (54113 <= e && e <= 54139)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 54140)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 54224) {
            if (e < 54169) {
              if (e < 54168) {
                if (54141 <= e && e <= 54167)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 54168)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 54196) {
              if (54169 <= e && e <= 54195)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 54197) {
              if (e === 54196)
                return n.CLUSTER_BREAK.LV;
            } else if (54197 <= e && e <= 54223)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 54253) {
            if (e < 54225) {
              if (e === 54224)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 54252) {
              if (54225 <= e && e <= 54251)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 54252)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 54280) {
            if (54253 <= e && e <= 54279)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 54281) {
            if (e === 54280)
              return n.CLUSTER_BREAK.LV;
          } else if (54281 <= e && e <= 54307)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 54589) {
          if (e < 54448) {
            if (e < 54365) {
              if (e < 54336) {
                if (e < 54309) {
                  if (e === 54308)
                    return n.CLUSTER_BREAK.LV;
                } else if (54309 <= e && e <= 54335)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 54337) {
                if (e === 54336)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 54364) {
                if (54337 <= e && e <= 54363)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 54364)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 54393) {
              if (e < 54392) {
                if (54365 <= e && e <= 54391)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 54392)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 54420) {
              if (54393 <= e && e <= 54419)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 54421) {
              if (e === 54420)
                return n.CLUSTER_BREAK.LV;
            } else if (54421 <= e && e <= 54447)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 54505) {
            if (e < 54476) {
              if (e < 54449) {
                if (e === 54448)
                  return n.CLUSTER_BREAK.LV;
              } else if (54449 <= e && e <= 54475)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 54477) {
              if (e === 54476)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 54504) {
              if (54477 <= e && e <= 54503)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 54504)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 54560) {
            if (e < 54532) {
              if (54505 <= e && e <= 54531)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 54533) {
              if (e === 54532)
                return n.CLUSTER_BREAK.LV;
            } else if (54533 <= e && e <= 54559)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 54561) {
            if (e === 54560)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 54588) {
            if (54561 <= e && e <= 54587)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 54588)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 54756) {
          if (e < 54672) {
            if (e < 54617) {
              if (e < 54616) {
                if (54589 <= e && e <= 54615)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 54616)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 54644) {
              if (54617 <= e && e <= 54643)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 54645) {
              if (e === 54644)
                return n.CLUSTER_BREAK.LV;
            } else if (54645 <= e && e <= 54671)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 54701) {
            if (e < 54673) {
              if (e === 54672)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 54700) {
              if (54673 <= e && e <= 54699)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 54700)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 54728) {
            if (54701 <= e && e <= 54727)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 54729) {
            if (e === 54728)
              return n.CLUSTER_BREAK.LV;
          } else if (54729 <= e && e <= 54755)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 54813) {
          if (e < 54784) {
            if (e < 54757) {
              if (e === 54756)
                return n.CLUSTER_BREAK.LV;
            } else if (54757 <= e && e <= 54783)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 54785) {
            if (e === 54784)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 54812) {
            if (54785 <= e && e <= 54811)
              return n.CLUSTER_BREAK.LVT;
          } else if (e === 54812)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 54868) {
          if (e < 54840) {
            if (54813 <= e && e <= 54839)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 54841) {
            if (e === 54840)
              return n.CLUSTER_BREAK.LV;
          } else if (54841 <= e && e <= 54867)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 54869) {
          if (e === 54868)
            return n.CLUSTER_BREAK.LV;
        } else if (e < 54896) {
          if (54869 <= e && e <= 54895)
            return n.CLUSTER_BREAK.LVT;
        } else if (e === 54896)
          return n.CLUSTER_BREAK.LV;
      } else if (e < 69632) {
        if (e < 55216) {
          if (e < 55037) {
            if (e < 54980) {
              if (e < 54925) {
                if (e < 54924) {
                  if (54897 <= e && e <= 54923)
                    return n.CLUSTER_BREAK.LVT;
                } else if (e === 54924)
                  return n.CLUSTER_BREAK.LV;
              } else if (e < 54952) {
                if (54925 <= e && e <= 54951)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e < 54953) {
                if (e === 54952)
                  return n.CLUSTER_BREAK.LV;
              } else if (54953 <= e && e <= 54979)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 55008) {
              if (e < 54981) {
                if (e === 54980)
                  return n.CLUSTER_BREAK.LV;
              } else if (54981 <= e && e <= 55007)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 55009) {
              if (e === 55008)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 55036) {
              if (55009 <= e && e <= 55035)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 55036)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 55120) {
            if (e < 55065) {
              if (e < 55064) {
                if (55037 <= e && e <= 55063)
                  return n.CLUSTER_BREAK.LVT;
              } else if (e === 55064)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 55092) {
              if (55065 <= e && e <= 55091)
                return n.CLUSTER_BREAK.LVT;
            } else if (e < 55093) {
              if (e === 55092)
                return n.CLUSTER_BREAK.LV;
            } else if (55093 <= e && e <= 55119)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 55149) {
            if (e < 55121) {
              if (e === 55120)
                return n.CLUSTER_BREAK.LV;
            } else if (e < 55148) {
              if (55121 <= e && e <= 55147)
                return n.CLUSTER_BREAK.LVT;
            } else if (e === 55148)
              return n.CLUSTER_BREAK.LV;
          } else if (e < 55176) {
            if (55149 <= e && e <= 55175)
              return n.CLUSTER_BREAK.LVT;
          } else if (e < 55177) {
            if (e === 55176)
              return n.CLUSTER_BREAK.LV;
          } else if (55177 <= e && e <= 55203)
            return n.CLUSTER_BREAK.LVT;
        } else if (e < 68097) {
          if (e < 65279) {
            if (e < 64286) {
              if (e < 55243) {
                if (55216 <= e && e <= 55238)
                  return n.CLUSTER_BREAK.V;
              } else if (55243 <= e && e <= 55291)
                return n.CLUSTER_BREAK.T;
            } else if (e < 65024) {
              if (e === 64286)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 65056) {
              if (65024 <= e && e <= 65039)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (65056 <= e && e <= 65071)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 66045) {
            if (e < 65438) {
              if (e === 65279)
                return n.CLUSTER_BREAK.CONTROL;
            } else if (e < 65520) {
              if (65438 <= e && e <= 65439)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (65520 <= e && e <= 65531)
              return n.CLUSTER_BREAK.CONTROL;
          } else if (e < 66272) {
            if (e === 66045)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 66422) {
            if (e === 66272)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (66422 <= e && e <= 66426)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 68325) {
          if (e < 68108) {
            if (e < 68101) {
              if (68097 <= e && e <= 68099)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (68101 <= e && e <= 68102)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 68152) {
            if (68108 <= e && e <= 68111)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 68159) {
            if (68152 <= e && e <= 68154)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e === 68159)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 69373) {
          if (e < 68900) {
            if (68325 <= e && e <= 68326)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 69291) {
            if (68900 <= e && e <= 68903)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (69291 <= e && e <= 69292)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 69446) {
          if (69373 <= e && e <= 69375)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 69506) {
          if (69446 <= e && e <= 69456)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (69506 <= e && e <= 69509)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 70016) {
        if (e < 69815) {
          if (e < 69747) {
            if (e < 69634) {
              if (e === 69632)
                return n.CLUSTER_BREAK.SPACINGMARK;
              if (e === 69633)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 69688) {
              if (e === 69634)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 69744) {
              if (69688 <= e && e <= 69702)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e === 69744)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 69762) {
            if (e < 69759) {
              if (69747 <= e && e <= 69748)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (69759 <= e && e <= 69761)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 69808) {
            if (e === 69762)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 69811) {
            if (69808 <= e && e <= 69810)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (69811 <= e && e <= 69814)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 69888)
          if (e < 69821) {
            if (e < 69817) {
              if (69815 <= e && e <= 69816)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (69817 <= e && e <= 69818)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 69826) {
            if (e === 69821)
              return n.CLUSTER_BREAK.PREPEND;
          } else {
            if (e === 69826)
              return n.CLUSTER_BREAK.EXTEND;
            if (e === 69837)
              return n.CLUSTER_BREAK.PREPEND;
          }
        else if (e < 69933) {
          if (e < 69927) {
            if (69888 <= e && e <= 69890)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 69932) {
            if (69927 <= e && e <= 69931)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e === 69932)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 69957) {
          if (69933 <= e && e <= 69940)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 70003) {
          if (69957 <= e && e <= 69958)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (e === 70003)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 70194) {
        if (e < 70082) {
          if (e < 70067) {
            if (e < 70018) {
              if (70016 <= e && e <= 70017)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e === 70018)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 70070) {
            if (70067 <= e && e <= 70069)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 70079) {
            if (70070 <= e && e <= 70078)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (70079 <= e && e <= 70080)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 70095) {
          if (e < 70089) {
            if (70082 <= e && e <= 70083)
              return n.CLUSTER_BREAK.PREPEND;
          } else if (e < 70094) {
            if (70089 <= e && e <= 70092)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e === 70094)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 70188) {
          if (e === 70095)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 70191) {
          if (70188 <= e && e <= 70190)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (70191 <= e && e <= 70193)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 70209) {
        if (e < 70197) {
          if (e < 70196) {
            if (70194 <= e && e <= 70195)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e === 70196)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 70198) {
          if (e === 70197)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 70206) {
          if (70198 <= e && e <= 70199)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e === 70206)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 70371) {
        if (e < 70367) {
          if (e === 70209)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 70368) {
          if (e === 70367)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (70368 <= e && e <= 70370)
          return n.CLUSTER_BREAK.SPACINGMARK;
      } else if (e < 70400) {
        if (70371 <= e && e <= 70378)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 70402) {
        if (70400 <= e && e <= 70401)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (70402 <= e && e <= 70403)
        return n.CLUSTER_BREAK.SPACINGMARK;
    } else if (e < 72343) {
      if (e < 71339) {
        if (e < 70841) {
          if (e < 70512) {
            if (e < 70471) {
              if (e < 70463) {
                if (e < 70462) {
                  if (70459 <= e && e <= 70460)
                    return n.CLUSTER_BREAK.EXTEND;
                } else if (e === 70462)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (e < 70464) {
                if (e === 70463)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 70465) {
                if (e === 70464)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (70465 <= e && e <= 70468)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 70487) {
              if (e < 70475) {
                if (70471 <= e && e <= 70472)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (70475 <= e && e <= 70477)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 70498) {
              if (e === 70487)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 70502) {
              if (70498 <= e && e <= 70499)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (70502 <= e && e <= 70508)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 70725) {
            if (e < 70712) {
              if (e < 70709) {
                if (70512 <= e && e <= 70516)
                  return n.CLUSTER_BREAK.EXTEND;
              } else if (70709 <= e && e <= 70711)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 70720) {
              if (70712 <= e && e <= 70719)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 70722) {
              if (70720 <= e && e <= 70721)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (70722 <= e && e <= 70724)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 70832) {
            if (e < 70726) {
              if (e === 70725)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 70726 || e === 70750)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 70833) {
            if (e === 70832)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 70835) {
            if (70833 <= e && e <= 70834)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (70835 <= e && e <= 70840)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 71096) {
          if (e < 70847)
            if (e < 70843) {
              if (e === 70841)
                return n.CLUSTER_BREAK.SPACINGMARK;
              if (e === 70842)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 70845) {
              if (70843 <= e && e <= 70844)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else {
              if (e === 70845)
                return n.CLUSTER_BREAK.EXTEND;
              if (e === 70846)
                return n.CLUSTER_BREAK.SPACINGMARK;
            }
          else if (e < 71087) {
            if (e < 70849) {
              if (70847 <= e && e <= 70848)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 70850) {
              if (e === 70849)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (70850 <= e && e <= 70851)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 71088) {
            if (e === 71087)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 71090) {
            if (71088 <= e && e <= 71089)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (71090 <= e && e <= 71093)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 71216) {
          if (e < 71102) {
            if (e < 71100) {
              if (71096 <= e && e <= 71099)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (71100 <= e && e <= 71101)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 71103) {
            if (e === 71102)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 71132) {
            if (71103 <= e && e <= 71104)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (71132 <= e && e <= 71133)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 71229) {
          if (e < 71219) {
            if (71216 <= e && e <= 71218)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 71227) {
            if (71219 <= e && e <= 71226)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (71227 <= e && e <= 71228)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 71230) {
          if (e === 71229)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 71231) {
          if (e === 71230)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (71231 <= e && e <= 71232)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 71999)
        if (e < 71463) {
          if (e < 71350) {
            if (e < 71341) {
              if (e === 71339)
                return n.CLUSTER_BREAK.EXTEND;
              if (e === 71340)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 71342) {
              if (e === 71341)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 71344) {
              if (71342 <= e && e <= 71343)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (71344 <= e && e <= 71349)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 71453) {
            if (e === 71350)
              return n.CLUSTER_BREAK.SPACINGMARK;
            if (e === 71351)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 71458) {
            if (71453 <= e && e <= 71455)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 71462) {
            if (71458 <= e && e <= 71461)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e === 71462)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 71984) {
          if (e < 71727) {
            if (e < 71724) {
              if (71463 <= e && e <= 71467)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (71724 <= e && e <= 71726)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 71736) {
            if (71727 <= e && e <= 71735)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 71737) {
            if (e === 71736)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (71737 <= e && e <= 71738)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 71995) {
          if (e < 71985) {
            if (e === 71984)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 71991) {
            if (71985 <= e && e <= 71989)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (71991 <= e && e <= 71992)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 71997) {
          if (71995 <= e && e <= 71996)
            return n.CLUSTER_BREAK.EXTEND;
        } else {
          if (e === 71997)
            return n.CLUSTER_BREAK.SPACINGMARK;
          if (e === 71998)
            return n.CLUSTER_BREAK.EXTEND;
        }
      else if (e < 72193)
        if (e < 72145)
          if (e < 72001) {
            if (e === 71999)
              return n.CLUSTER_BREAK.PREPEND;
            if (e === 72e3)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 72002) {
            if (e === 72001)
              return n.CLUSTER_BREAK.PREPEND;
          } else {
            if (e === 72002)
              return n.CLUSTER_BREAK.SPACINGMARK;
            if (e === 72003)
              return n.CLUSTER_BREAK.EXTEND;
          }
        else if (e < 72156) {
          if (e < 72148) {
            if (72145 <= e && e <= 72147)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 72154) {
            if (72148 <= e && e <= 72151)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (72154 <= e && e <= 72155)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 72160) {
          if (72156 <= e && e <= 72159)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else {
          if (e === 72160)
            return n.CLUSTER_BREAK.EXTEND;
          if (e === 72164)
            return n.CLUSTER_BREAK.SPACINGMARK;
        }
      else if (e < 72263) {
        if (e < 72249) {
          if (e < 72243) {
            if (72193 <= e && e <= 72202)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (72243 <= e && e <= 72248)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 72250) {
          if (e === 72249)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 72251) {
          if (e === 72250)
            return n.CLUSTER_BREAK.PREPEND;
        } else if (72251 <= e && e <= 72254)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 72281) {
        if (e < 72273) {
          if (e === 72263)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 72279) {
          if (72273 <= e && e <= 72278)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (72279 <= e && e <= 72280)
          return n.CLUSTER_BREAK.SPACINGMARK;
      } else if (e < 72324) {
        if (72281 <= e && e <= 72283)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 72330) {
        if (72324 <= e && e <= 72329)
          return n.CLUSTER_BREAK.PREPEND;
      } else if (72330 <= e && e <= 72342)
        return n.CLUSTER_BREAK.EXTEND;
    } else if (e < 94033) {
      if (e < 73104) {
        if (e < 72881) {
          if (e < 72766) {
            if (e < 72751) {
              if (e < 72344) {
                if (e === 72343)
                  return n.CLUSTER_BREAK.SPACINGMARK;
              } else if (72344 <= e && e <= 72345)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (e < 72752) {
              if (e === 72751)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 72760) {
              if (72752 <= e && e <= 72758)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (72760 <= e && e <= 72765)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 72850) {
            if (e === 72766)
              return n.CLUSTER_BREAK.SPACINGMARK;
            if (e === 72767)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 72873) {
            if (72850 <= e && e <= 72871)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 72874) {
            if (e === 72873)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (72874 <= e && e <= 72880)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 73018) {
          if (e < 72884) {
            if (e < 72882) {
              if (e === 72881)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (72882 <= e && e <= 72883)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 72885) {
            if (e === 72884)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 73009) {
            if (72885 <= e && e <= 72886)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (73009 <= e && e <= 73014)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 73030) {
          if (e < 73020) {
            if (e === 73018)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 73023) {
            if (73020 <= e && e <= 73021)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (73023 <= e && e <= 73029)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 73031) {
          if (e === 73030)
            return n.CLUSTER_BREAK.PREPEND;
        } else if (e < 73098) {
          if (e === 73031)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (73098 <= e && e <= 73102)
          return n.CLUSTER_BREAK.SPACINGMARK;
      } else if (e < 73526) {
        if (e < 73459)
          if (e < 73109) {
            if (e < 73107) {
              if (73104 <= e && e <= 73105)
                return n.CLUSTER_BREAK.EXTEND;
            } else if (73107 <= e && e <= 73108)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 73110) {
            if (e === 73109)
              return n.CLUSTER_BREAK.EXTEND;
          } else {
            if (e === 73110)
              return n.CLUSTER_BREAK.SPACINGMARK;
            if (e === 73111)
              return n.CLUSTER_BREAK.EXTEND;
          }
        else if (e < 73474) {
          if (e < 73461) {
            if (73459 <= e && e <= 73460)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 73472) {
            if (73461 <= e && e <= 73462)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (73472 <= e && e <= 73473)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 73475) {
          if (e === 73474)
            return n.CLUSTER_BREAK.PREPEND;
        } else if (e < 73524) {
          if (e === 73475)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (73524 <= e && e <= 73525)
          return n.CLUSTER_BREAK.SPACINGMARK;
      } else if (e < 78896)
        if (e < 73536) {
          if (e < 73534) {
            if (73526 <= e && e <= 73530)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (73534 <= e && e <= 73535)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 73537) {
          if (e === 73536)
            return n.CLUSTER_BREAK.EXTEND;
        } else {
          if (e === 73537)
            return n.CLUSTER_BREAK.SPACINGMARK;
          if (e === 73538)
            return n.CLUSTER_BREAK.EXTEND;
        }
      else if (e < 92912) {
        if (e < 78912) {
          if (78896 <= e && e <= 78911)
            return n.CLUSTER_BREAK.CONTROL;
        } else if (e < 78919) {
          if (e === 78912)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (78919 <= e && e <= 78933)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 92976) {
        if (92912 <= e && e <= 92916)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 94031) {
        if (92976 <= e && e <= 92982)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e === 94031)
        return n.CLUSTER_BREAK.EXTEND;
    } else if (e < 121476) {
      if (e < 119143)
        if (e < 113824) {
          if (e < 94180) {
            if (e < 94095) {
              if (94033 <= e && e <= 94087)
                return n.CLUSTER_BREAK.SPACINGMARK;
            } else if (94095 <= e && e <= 94098)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 94192) {
            if (e === 94180)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e < 113821) {
            if (94192 <= e && e <= 94193)
              return n.CLUSTER_BREAK.SPACINGMARK;
          } else if (113821 <= e && e <= 113822)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 118576) {
          if (e < 118528) {
            if (113824 <= e && e <= 113827)
              return n.CLUSTER_BREAK.CONTROL;
          } else if (118528 <= e && e <= 118573)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 119141) {
          if (118576 <= e && e <= 118598)
            return n.CLUSTER_BREAK.EXTEND;
        } else {
          if (e === 119141)
            return n.CLUSTER_BREAK.EXTEND;
          if (e === 119142)
            return n.CLUSTER_BREAK.SPACINGMARK;
        }
      else if (e < 119173) {
        if (e < 119150) {
          if (e < 119149) {
            if (119143 <= e && e <= 119145)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (e === 119149)
            return n.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 119155) {
          if (119150 <= e && e <= 119154)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 119163) {
          if (119155 <= e && e <= 119162)
            return n.CLUSTER_BREAK.CONTROL;
        } else if (119163 <= e && e <= 119170)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 121344) {
        if (e < 119210) {
          if (119173 <= e && e <= 119179)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 119362) {
          if (119210 <= e && e <= 119213)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (119362 <= e && e <= 119364)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 121403) {
        if (121344 <= e && e <= 121398)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 121461) {
        if (121403 <= e && e <= 121452)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e === 121461)
        return n.CLUSTER_BREAK.EXTEND;
    } else if (e < 123628) {
      if (e < 122907) {
        if (e < 121505) {
          if (e < 121499) {
            if (e === 121476)
              return n.CLUSTER_BREAK.EXTEND;
          } else if (121499 <= e && e <= 121503)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 122880) {
          if (121505 <= e && e <= 121519)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 122888) {
          if (122880 <= e && e <= 122886)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (122888 <= e && e <= 122904)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 123023) {
        if (e < 122915) {
          if (122907 <= e && e <= 122913)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (e < 122918) {
          if (122915 <= e && e <= 122916)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (122918 <= e && e <= 122922)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 123184) {
        if (e === 123023)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 123566) {
        if (123184 <= e && e <= 123190)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e === 123566)
        return n.CLUSTER_BREAK.EXTEND;
    } else if (e < 127995) {
      if (e < 125136) {
        if (e < 124140) {
          if (123628 <= e && e <= 123631)
            return n.CLUSTER_BREAK.EXTEND;
        } else if (124140 <= e && e <= 124143)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 125252) {
        if (125136 <= e && e <= 125142)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 127462) {
        if (125252 <= e && e <= 125258)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (127462 <= e && e <= 127487)
        return n.CLUSTER_BREAK.REGIONAL_INDICATOR;
    } else if (e < 917632) {
      if (e < 917504) {
        if (127995 <= e && e <= 127999)
          return n.CLUSTER_BREAK.EXTEND;
      } else if (e < 917536) {
        if (917504 <= e && e <= 917535)
          return n.CLUSTER_BREAK.CONTROL;
      } else if (917536 <= e && e <= 917631)
        return n.CLUSTER_BREAK.EXTEND;
    } else if (e < 917760) {
      if (917632 <= e && e <= 917759)
        return n.CLUSTER_BREAK.CONTROL;
    } else if (e < 918e3) {
      if (917760 <= e && e <= 917999)
        return n.CLUSTER_BREAK.EXTEND;
    } else if (918e3 <= e && e <= 921599)
      return n.CLUSTER_BREAK.CONTROL;
    return n.CLUSTER_BREAK.OTHER;
  }
  /**
   * Given a Unicode code point, returns if symbol is an extended pictographic or some other break
   * @param code {number} Unicode code point
   * @returns {number}
   */
  static getEmojiProperty(e) {
    if (e < 10160) {
      if (e < 9728) {
        if (e < 9e3) {
          if (e < 8482) {
            if (e < 8252) {
              if (e === 169 || e === 174)
                return n.EXTENDED_PICTOGRAPHIC;
            } else if (e === 8252 || e === 8265)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (e < 8596) {
            if (e === 8482 || e === 8505)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (e < 8617) {
            if (8596 <= e && e <= 8601)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (e < 8986) {
            if (8617 <= e && e <= 8618)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (8986 <= e && e <= 8987)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 9410) {
          if (e < 9167) {
            if (e === 9e3 || e === 9096)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9193) {
            if (e === 9167)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9208) {
            if (9193 <= e && e <= 9203)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (9208 <= e && e <= 9210)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 9654) {
          if (e < 9642) {
            if (e === 9410)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (9642 <= e && e <= 9643)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 9664) {
          if (e === 9654)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 9723) {
          if (e === 9664)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (9723 <= e && e <= 9726)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 10035) {
        if (e < 10004) {
          if (e < 9748) {
            if (e < 9735) {
              if (9728 <= e && e <= 9733)
                return n.EXTENDED_PICTOGRAPHIC;
            } else if (9735 <= e && e <= 9746)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9872) {
            if (9748 <= e && e <= 9861)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9992) {
            if (9872 <= e && e <= 9989)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (9992 <= e && e <= 10002)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 10013) {
          if (e === 10004 || e === 10006)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 10017) {
          if (e === 10013)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e === 10017 || e === 10024)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 10067) {
        if (e < 10055) {
          if (e < 10052) {
            if (10035 <= e && e <= 10036)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (e === 10052)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 10060) {
          if (e === 10055)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e === 10060 || e === 10062)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 10083) {
        if (e < 10071) {
          if (10067 <= e && e <= 10069)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e === 10071)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 10133) {
        if (10083 <= e && e <= 10087)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 10145) {
        if (10133 <= e && e <= 10135)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e === 10145)
        return n.EXTENDED_PICTOGRAPHIC;
    } else if (e < 127489) {
      if (e < 12951) {
        if (e < 11035) {
          if (e < 10548) {
            if (e === 10160 || e === 10175)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (e < 11013) {
            if (10548 <= e && e <= 10549)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (11013 <= e && e <= 11015)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 11093) {
          if (e < 11088) {
            if (11035 <= e && e <= 11036)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (e === 11088)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 12336) {
          if (e === 11093)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e === 12336 || e === 12349)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 127340) {
        if (e < 126976) {
          if (e === 12951 || e === 12953)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127245) {
          if (126976 <= e && e <= 127231)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127279) {
          if (127245 <= e && e <= 127247)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e === 127279)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 127374) {
        if (e < 127358) {
          if (127340 <= e && e <= 127345)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (127358 <= e && e <= 127359)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 127377) {
        if (e === 127374)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 127405) {
        if (127377 <= e && e <= 127386)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (127405 <= e && e <= 127461)
        return n.EXTENDED_PICTOGRAPHIC;
    } else if (e < 128981) {
      if (e < 127561) {
        if (e < 127535) {
          if (e < 127514) {
            if (127489 <= e && e <= 127503)
              return n.EXTENDED_PICTOGRAPHIC;
          } else if (e === 127514)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127538) {
          if (e === 127535)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127548) {
          if (127538 <= e && e <= 127546)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (127548 <= e && e <= 127551)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 128326) {
        if (e < 128e3) {
          if (127561 <= e && e <= 127994)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (128e3 <= e && e <= 128317)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 128640) {
        if (128326 <= e && e <= 128591)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 128884) {
        if (128640 <= e && e <= 128767)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (128884 <= e && e <= 128895)
        return n.EXTENDED_PICTOGRAPHIC;
    } else if (e < 129198) {
      if (e < 129096) {
        if (e < 129036) {
          if (128981 <= e && e <= 129023)
            return n.EXTENDED_PICTOGRAPHIC;
        } else if (129036 <= e && e <= 129039)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 129114) {
        if (129096 <= e && e <= 129103)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (e < 129160) {
        if (129114 <= e && e <= 129119)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (129160 <= e && e <= 129167)
        return n.EXTENDED_PICTOGRAPHIC;
    } else if (e < 129340) {
      if (e < 129292) {
        if (129198 <= e && e <= 129279)
          return n.EXTENDED_PICTOGRAPHIC;
      } else if (129292 <= e && e <= 129338)
        return n.EXTENDED_PICTOGRAPHIC;
    } else if (e < 129351) {
      if (129340 <= e && e <= 129349)
        return n.EXTENDED_PICTOGRAPHIC;
    } else if (e < 130048) {
      if (129351 <= e && e <= 129791)
        return n.EXTENDED_PICTOGRAPHIC;
    } else if (130048 <= e && e <= 131069)
      return n.EXTENDED_PICTOGRAPHIC;
    return n.CLUSTER_BREAK.OTHER;
  }
}
Fc.default = Pi;
var IE = ne && ne.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(jc, "__esModule", { value: !0 });
const UE = IE(Fc);
jc.default = UE.default;
var OE = ne && ne.__createBinding || (Object.create ? function(t, e, r, i) {
  i === void 0 && (i = r);
  var a = Object.getOwnPropertyDescriptor(e, r);
  (!a || ("get" in a ? !e.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, i, a);
} : function(t, e, r, i) {
  i === void 0 && (i = r), t[i] = e[r];
}), KE = ne && ne.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), ME = ne && ne.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && OE(e, t, r);
  return KE(e, t), e;
}, NE = ne && ne.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(yr, "__esModule", { value: !0 });
yr.validateLanguage = yr.parseLanguage = yr.b64UrlToUtf8 = yr.utf8ToB64Url = yr.graphemeLen = yr.utf8Len = void 0;
const VE = NE(jc), Eu = ME(Rp), jE = (t) => new TextEncoder().encode(t).byteLength;
yr.utf8Len = jE;
const FE = (t) => new VE.default().countGraphemes(t);
yr.graphemeLen = FE;
const $E = (t) => Eu.toString(Eu.fromString(t, "utf8"), "base64url");
yr.utf8ToB64Url = $E;
const GE = (t) => Eu.toString(Eu.fromString(t, "base64url"), "utf8");
yr.b64UrlToUtf8 = GE;
const qE = (t) => {
  const e = t.match(Sp);
  if (!e?.groups)
    return null;
  const r = e.groups;
  return {
    grandfathered: r.grandfathered,
    language: r.language,
    extlang: r.extlang,
    script: r.script,
    region: r.region,
    variant: r.variant,
    extension: r.extension,
    privateUse: r.privateUseA || r.privateUseB
  };
};
yr.parseLanguage = qE;
const zE = (t) => Sp.test(t);
yr.validateLanguage = zE;
const Sp = /^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-(?<extension>[0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8})+))*(-(?<privateUseA>x(-[A-Za-z0-9]{1,8})+))?)|(?<privateUseB>x(-[A-Za-z0-9]{1,8})+))$/;
var Cp = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.didDocument = t.getServiceEndpoint = t.getNotifEndpoint = t.getFeedGenEndpoint = t.getPdsEndpoint = t.getSigningDidKey = t.getVerificationMaterial = t.getSigningKey = t.getHandle = t.getDid = t.isValidDidDoc = void 0;
  const e = os, r = (z) => t.didDocument.safeParse(z).success;
  t.isValidDidDoc = r;
  const i = (z) => {
    const U = z.id;
    if (typeof U != "string")
      throw new Error("No `id` on document");
    return U;
  };
  t.getDid = i;
  const a = (z) => {
    const U = z.alsoKnownAs;
    if (U)
      for (let F = 0; F < U.length; F++) {
        const Z = U[F];
        if (Z.startsWith("at://"))
          return Z.slice(5);
      }
  };
  t.getHandle = a;
  const c = (z) => (0, t.getVerificationMaterial)(z, "atproto");
  t.getSigningKey = c;
  const h = (z, U) => {
    const F = P(z, "verificationMethod", `#${U}`);
    if (F && F.publicKeyMultibase)
      return {
        type: F.type,
        publicKeyMultibase: F.publicKeyMultibase
      };
  };
  t.getVerificationMaterial = h;
  const m = (z) => {
    const U = (0, t.getSigningKey)(z);
    if (U)
      return `did:key:${U.publicKeyMultibase}`;
  };
  t.getSigningDidKey = m;
  const p = (z) => (0, t.getServiceEndpoint)(z, {
    id: "#atproto_pds",
    type: "AtprotoPersonalDataServer"
  });
  t.getPdsEndpoint = p;
  const b = (z) => (0, t.getServiceEndpoint)(z, {
    id: "#bsky_fg",
    type: "BskyFeedGenerator"
  });
  t.getFeedGenEndpoint = b;
  const d = (z) => (0, t.getServiceEndpoint)(z, {
    id: "#bsky_notif",
    type: "BskyNotificationService"
  });
  t.getNotifEndpoint = d;
  const v = (z, U) => {
    const F = P(z, "service", U.id);
    if (F && !(U.type && F.type !== U.type) && typeof F.serviceEndpoint == "string")
      return M(F.serviceEndpoint);
  };
  t.getServiceEndpoint = v;
  function P(z, U, F) {
    const Z = z[U];
    if (Z)
      for (let de = 0; de < Z.length; de++) {
        const xe = Z[de], ge = xe.id;
        if (ge[0] === "#" ? ge === F : (
          // Optimized version of: itemId === `${doc.id}${id}`
          ge.length === z.id.length + F.length && ge[z.id.length] === "#" && ge.endsWith(F) && ge.startsWith(z.id)
        ))
          return xe;
      }
  }
  const M = (z) => {
    if (!(!z.startsWith("http://") && !z.startsWith("https://")) && K(z))
      return z;
  }, K = URL.canParse ?? // URL.canParse is not available in Node.js < 18.17.0
  ((z) => {
    try {
      return new URL(z), !0;
    } catch {
      return !1;
    }
  }), W = e.z.object({
    id: e.z.string(),
    type: e.z.string(),
    controller: e.z.string(),
    publicKeyMultibase: e.z.string().optional()
  }), J = e.z.object({
    id: e.z.string(),
    type: e.z.string(),
    serviceEndpoint: e.z.union([e.z.string(), e.z.record(e.z.unknown())])
  });
  t.didDocument = e.z.object({
    id: e.z.string(),
    alsoKnownAs: e.z.array(e.z.string()).optional(),
    verificationMethod: e.z.array(W).optional(),
    service: e.z.array(J).optional()
  });
})(Cp);
(function(t) {
  var e = ne && ne.__createBinding || (Object.create ? function(c, h, m, p) {
    p === void 0 && (p = m);
    var b = Object.getOwnPropertyDescriptor(h, m);
    (!b || ("get" in b ? !h.__esModule : b.writable || b.configurable)) && (b = { enumerable: !0, get: function() {
      return h[m];
    } }), Object.defineProperty(c, p, b);
  } : function(c, h, m, p) {
    p === void 0 && (p = m), c[p] = h[m];
  }), r = ne && ne.__setModuleDefault || (Object.create ? function(c, h) {
    Object.defineProperty(c, "default", { enumerable: !0, value: h });
  } : function(c, h) {
    c.default = h;
  }), i = ne && ne.__importStar || function(c) {
    if (c && c.__esModule) return c;
    var h = {};
    if (c != null) for (var m in c) m !== "default" && Object.prototype.hasOwnProperty.call(c, m) && e(h, c, m);
    return r(h, c), h;
  }, a = ne && ne.__exportStar || function(c, h) {
    for (var m in c) m !== "default" && !Object.prototype.hasOwnProperty.call(h, m) && e(h, c, m);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.util = t.check = void 0, t.check = i(ri), t.util = i(As), a(_s, t), a(mp, t), a(As, t), a(Ca, t), a(yp, t), a(ws, t), a(_p, t), a(wp, t), a(yr, t), a(Cp, t);
})(vi);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.BlobRef = t.jsonBlobRef = t.untypedJsonBlobRef = t.typedJsonBlobRef = void 0;
  const e = vi, r = $s, i = os;
  t.typedJsonBlobRef = i.z.object({
    $type: i.z.literal("blob"),
    ref: e.schema.cid,
    mimeType: i.z.string(),
    size: i.z.number()
  }).strict(), t.untypedJsonBlobRef = i.z.object({
    cid: i.z.string(),
    mimeType: i.z.string()
  }).strict(), t.jsonBlobRef = i.z.union([t.typedJsonBlobRef, t.untypedJsonBlobRef]);
  class a {
    constructor(h, m, p, b) {
      Object.defineProperty(this, "ref", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: h
      }), Object.defineProperty(this, "mimeType", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: m
      }), Object.defineProperty(this, "size", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: p
      }), Object.defineProperty(this, "original", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), this.original = b ?? {
        $type: "blob",
        ref: h,
        mimeType: m,
        size: p
      };
    }
    static asBlobRef(h) {
      return e.check.is(h, t.jsonBlobRef) ? a.fromJsonRef(h) : null;
    }
    static fromJsonRef(h) {
      return e.check.is(h, t.typedJsonBlobRef) ? new a(h.ref, h.mimeType, h.size) : new a(r.CID.parse(h.cid), h.mimeType, -1, h);
    }
    ipld() {
      return {
        $type: "blob",
        ref: this.ref,
        mimeType: this.mimeType,
        size: this.size
      };
    }
    toJSON() {
      return (0, e.ipldToJson)(this.ipld());
    }
  }
  t.BlobRef = a;
})(Iu);
Object.defineProperty(Mc, "__esModule", { value: !0 });
Mc.blob = ZE;
const XE = Iu, HE = Rn;
function ZE(t, e, r, i) {
  return !i || !(i instanceof XE.BlobRef) ? {
    success: !1,
    error: new HE.ValidationError(`${e} should be a blob ref`)
  } : { success: !0, value: i };
}
var Ri = {}, Lr = {}, Lp = {};
(function(t) {
  (() => {
    var e = { d: (d, v) => {
      for (var P in v) e.o(v, P) && !e.o(d, P) && Object.defineProperty(d, P, { enumerable: !0, get: v[P] });
    }, o: (d, v) => Object.prototype.hasOwnProperty.call(d, v), r: (d) => {
      typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(d, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(d, "__esModule", { value: !0 });
    } }, r = {};
    function i(d, v) {
      return v === void 0 && (v = "-"), new RegExp("^(?!0{4}" + v + "0{2}" + v + "0{2})((?=[0-9]{4}" + v + "(((0[^2])|1[0-2])|02(?=" + v + "(([0-1][0-9])|2[0-8])))" + v + "[0-9]{2})|(?=((([13579][26])|([2468][048])|(0[48]))0{2})|([0-9]{2}((((0|[2468])[48])|[2468][048])|([13579][26])))" + v + "02" + v + "29))([0-9]{4})" + v + "(?!((0[469])|11)" + v + "31)((0[1,3-9]|1[0-2])|(02(?!" + v + "3)))" + v + "(0[1-9]|[1-2][0-9]|3[0-1])$").test(d);
    }
    function a(d) {
      var v = /\D/.exec(d);
      return v ? v[0] : "";
    }
    function c(d, v, P) {
      v === void 0 && (v = ":"), P === void 0 && (P = !1);
      var M = new RegExp("^([0-1]|2(?=([0-3])|4" + v + "00))[0-9]" + v + "[0-5][0-9](" + v + "([0-5]|6(?=0))[0-9])?(.[0-9]{1,9})?$");
      if (!P || !/[Z+\-]/.test(d)) return M.test(d);
      if (/Z$/.test(d)) return M.test(d.replace("Z", ""));
      var K = d.includes("+"), W = d.split(/[+-]/), J = W[0], z = W[1];
      return M.test(J) && function(U, F, Z) {
        return Z === void 0 && (Z = ":"), new RegExp(F ? "^(0(?!(2" + Z + "4)|0" + Z + "3)|1(?=([0-1]|2(?=" + Z + "[04])|[34](?=" + Z + "0))))([03469](?=" + Z + "[03])|[17](?=" + Z + "0)|2(?=" + Z + "[04])|5(?=" + Z + "[034])|8(?=" + Z + "[04]))" + Z + "([03](?=0)|4(?=5))[05]$" : "^(0(?=[^0])|1(?=[0-2]))([39](?=" + Z + "[03])|[0-24-8](?=" + Z + "00))" + Z + "[03]0$").test(U);
      }(z, K, a(z));
    }
    function h(d) {
      var v = d.split("T"), P = v[0], M = v[1], K = i(P, a(P));
      if (!M) return !1;
      var W, J = (W = M.match(/([^Z+\-\d])(?=\d+\1)/), Array.isArray(W) ? W[0] : "");
      return K && c(M, J, !0);
    }
    function m(d, v) {
      return v === void 0 && (v = "-"), new RegExp("^[0-9]{4}" + v + "(0(?=[^0])|1(?=[0-2]))[0-9]$").test(d);
    }
    e.r(r), e.d(r, { isValidDate: () => i, isValidISODateString: () => h, isValidTime: () => c, isValidYearMonth: () => m });
    var p = t;
    for (var b in r) p[b] = r[b];
    r.__esModule && Object.defineProperty(p, "__esModule", { value: !0 });
  })();
})(Lp);
Object.defineProperty(Lr, "__esModule", { value: !0 });
Lr.datetime = QE;
Lr.uri = ev;
Lr.atUri = tv;
Lr.did = kp;
Lr.handle = Dp;
Lr.atIdentifier = rv;
Lr.nsid = iv;
Lr.cid = nv;
Lr.language = sv;
Lr.tid = av;
Lr.recordKey = ov;
const WE = Lp, YE = $s, Xr = Rn, Gs = as, JE = vi;
function QE(t, e) {
  try {
    if (!(0, WE.isValidISODateString)(e))
      throw new Error();
  } catch {
    return {
      success: !1,
      error: new Xr.ValidationError(`${t} must be an valid atproto datetime (both RFC-3339 and ISO-8601)`)
    };
  }
  return { success: !0, value: e };
}
function ev(t, e) {
  return e.match(/^\w+:(?:\/\/)?[^\s/][^\s]*$/) !== null ? { success: !0, value: e } : {
    success: !1,
    error: new Xr.ValidationError(`${t} must be a uri`)
  };
}
function tv(t, e) {
  try {
    (0, Gs.ensureValidAtUri)(e);
  } catch {
    return {
      success: !1,
      error: new Xr.ValidationError(`${t} must be a valid at-uri`)
    };
  }
  return { success: !0, value: e };
}
function kp(t, e) {
  try {
    (0, Gs.ensureValidDid)(e);
  } catch {
    return {
      success: !1,
      error: new Xr.ValidationError(`${t} must be a valid did`)
    };
  }
  return { success: !0, value: e };
}
function Dp(t, e) {
  try {
    (0, Gs.ensureValidHandle)(e);
  } catch {
    return {
      success: !1,
      error: new Xr.ValidationError(`${t} must be a valid handle`)
    };
  }
  return { success: !0, value: e };
}
function rv(t, e) {
  if (e.startsWith("did:")) {
    const r = kp(t, e);
    if (r.success)
      return r;
  } else {
    const r = Dp(t, e);
    if (r.success)
      return r;
  }
  return {
    success: !1,
    error: new Xr.ValidationError(`${t} must be a valid did or a handle`)
  };
}
function iv(t, e) {
  try {
    (0, Gs.ensureValidNsid)(e);
  } catch {
    return {
      success: !1,
      error: new Xr.ValidationError(`${t} must be a valid nsid`)
    };
  }
  return { success: !0, value: e };
}
function nv(t, e) {
  try {
    YE.CID.parse(e);
  } catch {
    return {
      success: !1,
      error: new Xr.ValidationError(`${t} must be a cid string`)
    };
  }
  return { success: !0, value: e };
}
function sv(t, e) {
  return (0, JE.validateLanguage)(e) ? { success: !0, value: e } : {
    success: !1,
    error: new Xr.ValidationError(`${t} must be a well-formed BCP 47 language tag`)
  };
}
function av(t, e) {
  try {
    (0, Gs.ensureValidTid)(e);
  } catch {
    return {
      success: !1,
      error: new Xr.ValidationError(`${t} must be a valid TID (timestamp identifier)`)
    };
  }
  return { success: !0, value: e };
}
function ov(t, e) {
  try {
    (0, Gs.ensureValidRecordKey)(e);
  } catch {
    return {
      success: !1,
      error: new Xr.ValidationError(`${t} must be a valid Record Key`)
    };
  }
  return { success: !0, value: e };
}
var lv = ne && ne.__createBinding || (Object.create ? function(t, e, r, i) {
  i === void 0 && (i = r);
  var a = Object.getOwnPropertyDescriptor(e, r);
  (!a || ("get" in a ? !e.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, i, a);
} : function(t, e, r, i) {
  i === void 0 && (i = r), t[i] = e[r];
}), uv = ne && ne.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), cv = ne && ne.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && lv(e, t, r);
  return uv(e, t), e;
};
Object.defineProperty(Ri, "__esModule", { value: !0 });
Ri.validate = fv;
Ri.boolean = Pp;
Ri.integer = Bp;
Ri.string = Ip;
Ri.bytes = Up;
Ri.cidLink = Op;
Ri.unknown = Kp;
const Md = vi, dv = $s, Or = cv(Lr), lt = Rn;
function fv(t, e, r, i) {
  switch (r.type) {
    case "boolean":
      return Pp(t, e, r, i);
    case "integer":
      return Bp(t, e, r, i);
    case "string":
      return Ip(t, e, r, i);
    case "bytes":
      return Up(t, e, r, i);
    case "cid-link":
      return Op(t, e, r, i);
    case "unknown":
      return Kp(t, e, r, i);
    default:
      return {
        success: !1,
        error: new lt.ValidationError(`Unexpected lexicon type: ${r.type}`)
      };
  }
}
function Pp(t, e, r, i) {
  r = r;
  const a = typeof i;
  return a === "undefined" ? typeof r.default == "boolean" ? { success: !0, value: r.default } : {
    success: !1,
    error: new lt.ValidationError(`${e} must be a boolean`)
  } : a !== "boolean" ? {
    success: !1,
    error: new lt.ValidationError(`${e} must be a boolean`)
  } : typeof r.const == "boolean" && i !== r.const ? {
    success: !1,
    error: new lt.ValidationError(`${e} must be ${r.const}`)
  } : { success: !0, value: i };
}
function Bp(t, e, r, i) {
  return r = r, typeof i === "undefined" ? typeof r.default == "number" ? { success: !0, value: r.default } : {
    success: !1,
    error: new lt.ValidationError(`${e} must be an integer`)
  } : Number.isInteger(i) ? typeof r.const == "number" && i !== r.const ? {
    success: !1,
    error: new lt.ValidationError(`${e} must be ${r.const}`)
  } : Array.isArray(r.enum) && !r.enum.includes(i) ? {
    success: !1,
    error: new lt.ValidationError(`${e} must be one of (${r.enum.join("|")})`)
  } : typeof r.maximum == "number" && i > r.maximum ? {
    success: !1,
    error: new lt.ValidationError(`${e} can not be greater than ${r.maximum}`)
  } : typeof r.minimum == "number" && i < r.minimum ? {
    success: !1,
    error: new lt.ValidationError(`${e} can not be less than ${r.minimum}`)
  } : { success: !0, value: i } : {
    success: !1,
    error: new lt.ValidationError(`${e} must be an integer`)
  };
}
function Ip(t, e, r, i) {
  if (r = r, typeof i > "u")
    return typeof r.default == "string" ? { success: !0, value: r.default } : {
      success: !1,
      error: new lt.ValidationError(`${e} must be a string`)
    };
  if (typeof i != "string")
    return {
      success: !1,
      error: new lt.ValidationError(`${e} must be a string`)
    };
  if (typeof r.const == "string" && i !== r.const)
    return {
      success: !1,
      error: new lt.ValidationError(`${e} must be ${r.const}`)
    };
  if (Array.isArray(r.enum) && !r.enum.includes(i))
    return {
      success: !1,
      error: new lt.ValidationError(`${e} must be one of (${r.enum.join("|")})`)
    };
  if (typeof r.minLength == "number" || typeof r.maxLength == "number") {
    if (typeof r.minLength == "number" && i.length * 3 < r.minLength)
      return {
        success: !1,
        error: new lt.ValidationError(`${e} must not be shorter than ${r.minLength} characters`)
      };
    let a = !1;
    if (typeof r.minLength > "u" && typeof r.maxLength == "number" && i.length * 3 <= r.maxLength && (a = !0), !a) {
      const c = (0, Md.utf8Len)(i);
      if (typeof r.maxLength == "number" && c > r.maxLength)
        return {
          success: !1,
          error: new lt.ValidationError(`${e} must not be longer than ${r.maxLength} characters`)
        };
      if (typeof r.minLength == "number" && c < r.minLength)
        return {
          success: !1,
          error: new lt.ValidationError(`${e} must not be shorter than ${r.minLength} characters`)
        };
    }
  }
  if (typeof r.maxGraphemes == "number" || typeof r.minGraphemes == "number") {
    let a = !1, c = !1;
    if (typeof r.maxGraphemes == "number" && (i.length <= r.maxGraphemes ? a = !1 : a = !0), typeof r.minGraphemes == "number") {
      if (i.length < r.minGraphemes)
        return {
          success: !1,
          error: new lt.ValidationError(`${e} must not be shorter than ${r.minGraphemes} graphemes`)
        };
      c = !0;
    }
    if (a || c) {
      const h = (0, Md.graphemeLen)(i);
      if (typeof r.maxGraphemes == "number" && h > r.maxGraphemes)
        return {
          success: !1,
          error: new lt.ValidationError(`${e} must not be longer than ${r.maxGraphemes} graphemes`)
        };
      if (typeof r.minGraphemes == "number" && h < r.minGraphemes)
        return {
          success: !1,
          error: new lt.ValidationError(`${e} must not be shorter than ${r.minGraphemes} graphemes`)
        };
    }
  }
  if (typeof r.format == "string")
    switch (r.format) {
      case "datetime":
        return Or.datetime(e, i);
      case "uri":
        return Or.uri(e, i);
      case "at-uri":
        return Or.atUri(e, i);
      case "did":
        return Or.did(e, i);
      case "handle":
        return Or.handle(e, i);
      case "at-identifier":
        return Or.atIdentifier(e, i);
      case "nsid":
        return Or.nsid(e, i);
      case "cid":
        return Or.cid(e, i);
      case "language":
        return Or.language(e, i);
      case "tid":
        return Or.tid(e, i);
      case "record-key":
        return Or.recordKey(e, i);
    }
  return { success: !0, value: i };
}
function Up(t, e, r, i) {
  return r = r, !i || !(i instanceof Uint8Array) ? {
    success: !1,
    error: new lt.ValidationError(`${e} must be a byte array`)
  } : typeof r.maxLength == "number" && i.byteLength > r.maxLength ? {
    success: !1,
    error: new lt.ValidationError(`${e} must not be larger than ${r.maxLength} bytes`)
  } : typeof r.minLength == "number" && i.byteLength < r.minLength ? {
    success: !1,
    error: new lt.ValidationError(`${e} must not be smaller than ${r.minLength} bytes`)
  } : { success: !0, value: i };
}
function Op(t, e, r, i) {
  return dv.CID.asCID(i) === null ? {
    success: !1,
    error: new lt.ValidationError(`${e} must be a CID`)
  } : { success: !0, value: i };
}
function Kp(t, e, r, i) {
  return !i || typeof i != "object" ? {
    success: !1,
    error: new lt.ValidationError(`${e} must be an object`)
  } : { success: !0, value: i };
}
Object.defineProperty(An, "__esModule", { value: !0 });
An.validate = Mp;
An.array = Np;
An.object = zc;
An.validateOneOf = Xc;
const ii = Rn, Lc = ls, pv = Mc, hs = Ri;
function Mp(t, e, r, i) {
  switch (r.type) {
    case "boolean":
      return (0, hs.boolean)(t, e, r, i);
    case "integer":
      return (0, hs.integer)(t, e, r, i);
    case "string":
      return (0, hs.string)(t, e, r, i);
    case "bytes":
      return (0, hs.bytes)(t, e, r, i);
    case "cid-link":
      return (0, hs.cidLink)(t, e, r, i);
    case "unknown":
      return (0, hs.unknown)(t, e, r, i);
    case "object":
      return zc(t, e, r, i);
    case "array":
      return Np(t, e, r, i);
    case "blob":
      return (0, pv.blob)(t, e, r, i);
    default:
      return {
        success: !1,
        error: new ii.ValidationError(`Unexpected lexicon type: ${r.type}`)
      };
  }
}
function Np(t, e, r, i) {
  if (!Array.isArray(i))
    return {
      success: !1,
      error: new ii.ValidationError(`${e} must be an array`)
    };
  if (typeof r.maxLength == "number" && i.length > r.maxLength)
    return {
      success: !1,
      error: new ii.ValidationError(`${e} must not have more than ${r.maxLength} elements`)
    };
  if (typeof r.minLength == "number" && i.length < r.minLength)
    return {
      success: !1,
      error: new ii.ValidationError(`${e} must not have fewer than ${r.minLength} elements`)
    };
  const a = r.items;
  for (let c = 0; c < i.length; c++) {
    const h = i[c], m = `${e}/${c}`, p = Xc(t, m, a, h);
    if (!p.success)
      return p;
  }
  return { success: !0, value: i };
}
function zc(t, e, r, i) {
  if (r = r, !i || typeof i != "object")
    return {
      success: !1,
      error: new ii.ValidationError(`${e} must be an object`)
    };
  const a = new Set(r.required), c = new Set(r.nullable);
  let h = i;
  if (typeof r.properties == "object")
    for (const m in r.properties) {
      if (i[m] === null && c.has(m))
        continue;
      const p = r.properties[m];
      if (typeof i[m] > "u" && !a.has(m))
        if (p.type === "integer" || p.type === "boolean" || p.type === "string") {
          if (typeof p.default > "u")
            continue;
        } else
          continue;
      const b = `${e}/${m}`, d = Xc(t, b, p, i[m]), v = d.success ? d.value : i[m], P = typeof v > "u";
      if (P && a.has(m))
        return {
          success: !1,
          error: new ii.ValidationError(`${e} must have the property "${m}"`)
        };
      if (!P && !d.success)
        return d;
      v !== i[m] && (h === i && (h = { ...i }), h[m] = v);
    }
  return { success: !0, value: h };
}
function Xc(t, e, r, i, a = !1) {
  let c, h;
  if (r.type === "union") {
    if (!(0, ii.isDiscriminatedObject)(i))
      return {
        success: !1,
        error: new ii.ValidationError(`${e} must be an object which includes the "$type" property`)
      };
    if (hv(r.refs, i.$type))
      h = (0, Lc.toConcreteTypes)(t, {
        type: "ref",
        ref: i.$type
      });
    else
      return r.closed ? {
        success: !1,
        error: new ii.ValidationError(`${e} $type must be one of ${r.refs.join(", ")}`)
      } : { success: !0, value: i };
  } else
    h = (0, Lc.toConcreteTypes)(t, r);
  for (const m of h) {
    const p = a ? zc(t, e, m, i) : Mp(t, e, m, i);
    if (p.success)
      return p;
    c ?? (c = p.error);
  }
  return h.length > 1 ? {
    success: !1,
    error: new ii.ValidationError(`${e} did not match any of the expected definitions`)
  } : { success: !1, error: c };
}
const hv = (t, e) => {
  const r = (0, Lc.toLexUri)(e);
  return t.includes(r) ? !0 : r.endsWith("#main") ? t.includes(r.replace("#main", "")) : t.includes(r + "#main");
};
var Hc = {}, mv = ne && ne.__createBinding || (Object.create ? function(t, e, r, i) {
  i === void 0 && (i = r);
  var a = Object.getOwnPropertyDescriptor(e, r);
  (!a || ("get" in a ? !e.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, i, a);
} : function(t, e, r, i) {
  i === void 0 && (i = r), t[i] = e[r];
}), yv = ne && ne.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), bv = ne && ne.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && mv(e, t, r);
  return yv(e, t), e;
};
Object.defineProperty(Hc, "__esModule", { value: !0 });
Hc.params = vv;
const gv = Rn, xv = bv(Ri), Ev = An;
function vv(t, e, r, i) {
  const a = i && typeof i == "object" ? i : {}, c = new Set(r.required ?? []);
  let h = a;
  if (typeof r.properties == "object")
    for (const m in r.properties) {
      const p = r.properties[m], b = p.type === "array" ? (0, Ev.array)(t, m, p, a[m]) : xv.validate(t, m, p, a[m]), d = b.success ? b.value : a[m], v = typeof d > "u";
      if (v && c.has(m))
        return {
          success: !1,
          error: new gv.ValidationError(`${e} must have the property "${m}"`)
        };
      if (!v && !b.success)
        return b;
      d !== a[m] && (h === a && (h = { ...a }), h[m] = d);
    }
  return { success: !0, value: h };
}
Object.defineProperty(us, "__esModule", { value: !0 });
us.assertValidRecord = Av;
us.assertValidXrpcParams = _v;
us.assertValidXrpcInput = wv;
us.assertValidXrpcOutput = Tv;
us.assertValidXrpcMessage = Sv;
const Vp = An, Rv = Hc;
function Av(t, e, r) {
  const i = (0, Vp.object)(t, "Record", e.record, r);
  if (!i.success)
    throw i.error;
  return i.value;
}
function _v(t, e, r) {
  if (e.parameters) {
    const i = (0, Rv.params)(t, "Params", e.parameters, r);
    if (!i.success)
      throw i.error;
    return i.value;
  }
}
function wv(t, e, r) {
  if (e.input?.schema)
    return Zc(t, "Input", e.input.schema, r, !0);
}
function Tv(t, e, r) {
  if (e.output?.schema)
    return Zc(t, "Output", e.output.schema, r, !0);
}
function Sv(t, e, r) {
  if (e.message?.schema)
    return Zc(t, "Message", e.message.schema, r, !0);
}
function Zc(t, e, r, i, a = !1) {
  const c = (0, Vp.validateOneOf)(t, e, r, i, a);
  if (!c.success)
    throw c.error;
  return c.value;
}
var Cv = ne && ne.__createBinding || (Object.create ? function(t, e, r, i) {
  i === void 0 && (i = r);
  var a = Object.getOwnPropertyDescriptor(e, r);
  (!a || ("get" in a ? !e.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, i, a);
} : function(t, e, r, i) {
  i === void 0 && (i = r), t[i] = e[r];
}), Lv = ne && ne.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), kv = ne && ne.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && Cv(e, t, r);
  return Lv(e, t), e;
};
Object.defineProperty(Bu, "__esModule", { value: !0 });
Bu.Lexicons = void 0;
const Jr = Rn, ea = us, Wt = ls, Nd = kv(An);
class Dv {
  constructor(e) {
    if (Object.defineProperty(this, "docs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "defs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), e)
      for (const r of e)
        this.add(r);
  }
  /**
   * @example clone a lexicon:
   * ```ts
   * const clone = new Lexicons(originalLexicon)
   * ```
   *
   * @example get docs array:
   * ```ts
   * const docs = Array.from(lexicons)
   * ```
   */
  [Symbol.iterator]() {
    return this.docs.values();
  }
  /**
   * Add a lexicon doc.
   */
  add(e) {
    const r = (0, Wt.toLexUri)(e.id);
    if (this.docs.has(r))
      throw new Error(`${r} has already been registered`);
    kc(e, r), this.docs.set(r, e);
    for (const [i, a] of Vd(e))
      this.defs.set(i, a);
  }
  /**
   * Remove a lexicon doc.
   */
  remove(e) {
    e = (0, Wt.toLexUri)(e);
    const r = this.docs.get(e);
    if (!r)
      throw new Error(`Unable to remove "${e}": does not exist`);
    for (const [i, a] of Vd(r))
      this.defs.delete(i);
    this.docs.delete(e);
  }
  /**
   * Get a lexicon doc.
   */
  get(e) {
    return e = (0, Wt.toLexUri)(e), this.docs.get(e);
  }
  /**
   * Get a definition.
   */
  getDef(e) {
    return e = (0, Wt.toLexUri)(e), this.defs.get(e);
  }
  getDefOrThrow(e, r) {
    const i = this.getDef(e);
    if (!i)
      throw new Jr.LexiconDefNotFoundError(`Lexicon not found: ${e}`);
    if (r && !r.includes(i.type))
      throw new Jr.InvalidLexiconError(`Not a ${r.join(" or ")} lexicon: ${e}`);
    return i;
  }
  /**
   * Validate a record or object.
   */
  validate(e, r) {
    e = (0, Wt.toLexUri)(e);
    const i = this.getDefOrThrow(e, ["record", "object"]);
    if (!(0, Jr.isObj)(r))
      throw new Jr.ValidationError("Value must be an object");
    if (i.type === "record")
      return Nd.object(this, "Record", i.record, r);
    if (i.type === "object")
      return Nd.object(this, "Object", i, r);
    throw new Jr.InvalidLexiconError("Definition must be a record or object");
  }
  /**
   * Validate a record and throw on any error.
   */
  assertValidRecord(e, r) {
    e = (0, Wt.toLexUri)(e);
    const i = this.getDefOrThrow(e, ["record"]);
    if (!(0, Jr.isObj)(r))
      throw new Jr.ValidationError("Record must be an object");
    if (!(0, Jr.hasProp)(r, "$type") || typeof r.$type != "string")
      throw new Jr.ValidationError("Record/$type must be a string");
    const a = r.$type || "";
    if ((0, Wt.toLexUri)(a) !== e)
      throw new Jr.ValidationError(`Invalid $type: must be ${e}, got ${a}`);
    return (0, ea.assertValidRecord)(this, i, r);
  }
  /**
   * Validate xrpc query params and throw on any error.
   */
  assertValidXrpcParams(e, r) {
    e = (0, Wt.toLexUri)(e);
    const i = this.getDefOrThrow(e, [
      "query",
      "procedure",
      "subscription"
    ]);
    return (0, ea.assertValidXrpcParams)(this, i, r);
  }
  /**
   * Validate xrpc input body and throw on any error.
   */
  assertValidXrpcInput(e, r) {
    e = (0, Wt.toLexUri)(e);
    const i = this.getDefOrThrow(e, ["procedure"]);
    return (0, ea.assertValidXrpcInput)(this, i, r);
  }
  /**
   * Validate xrpc output body and throw on any error.
   */
  assertValidXrpcOutput(e, r) {
    e = (0, Wt.toLexUri)(e);
    const i = this.getDefOrThrow(e, ["query", "procedure"]);
    return (0, ea.assertValidXrpcOutput)(this, i, r);
  }
  /**
   * Validate xrpc subscription message and throw on any error.
   */
  assertValidXrpcMessage(e, r) {
    e = (0, Wt.toLexUri)(e);
    const i = this.getDefOrThrow(e, ["subscription"]);
    return (0, ea.assertValidXrpcMessage)(this, i, r);
  }
  /**
   * Resolve a lex uri given a ref
   */
  resolveLexUri(e, r) {
    return e = (0, Wt.toLexUri)(e), (0, Wt.toLexUri)(r, e);
  }
}
Bu.Lexicons = Dv;
function* Vd(t) {
  for (const e in t.defs)
    yield [`lex:${t.id}#${e}`, t.defs[e]], e === "main" && (yield [`lex:${t.id}`, t.defs[e]]);
}
function kc(t, e) {
  for (const r in t)
    t.type === "ref" ? t.ref = (0, Wt.toLexUri)(t.ref, e) : t.type === "union" ? t.refs = t.refs.map((i) => (0, Wt.toLexUri)(i, e)) : Array.isArray(t[r]) ? t[r] = t[r].map((i) => typeof i == "string" ? i.startsWith("#") ? (0, Wt.toLexUri)(i, e) : i : i && typeof i == "object" ? kc(i, e) : i) : t[r] && typeof t[r] == "object" && (t[r] = kc(t[r], e));
  return t;
}
var jp = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.jsonStringToLex = t.jsonToLex = t.stringifyLex = t.lexToJson = t.ipldToLex = t.lexToIpld = void 0;
  const e = vi, r = $s, i = Iu, a = (d) => {
    if (Array.isArray(d))
      return d.map((v) => (0, t.lexToIpld)(v));
    if (d && typeof d == "object") {
      if (d instanceof i.BlobRef)
        return d.original;
      if (r.CID.asCID(d) || d instanceof Uint8Array)
        return d;
      const v = {};
      for (const P of Object.keys(d))
        v[P] = (0, t.lexToIpld)(d[P]);
      return v;
    }
    return d;
  };
  t.lexToIpld = a;
  const c = (d) => {
    if (Array.isArray(d))
      return d.map((v) => (0, t.ipldToLex)(v));
    if (d && typeof d == "object") {
      if ((d.$type === "blob" || typeof d.cid == "string" && typeof d.mimeType == "string") && e.check.is(d, i.jsonBlobRef))
        return i.BlobRef.fromJsonRef(d);
      if (r.CID.asCID(d) || d instanceof Uint8Array)
        return d;
      const v = {};
      for (const P of Object.keys(d))
        v[P] = (0, t.ipldToLex)(d[P]);
      return v;
    }
    return d;
  };
  t.ipldToLex = c;
  const h = (d) => (0, e.ipldToJson)((0, t.lexToIpld)(d));
  t.lexToJson = h;
  const m = (d) => JSON.stringify((0, t.lexToJson)(d));
  t.stringifyLex = m;
  const p = (d) => (0, t.ipldToLex)((0, e.jsonToIpld)(d));
  t.jsonToLex = p;
  const b = (d) => (0, t.jsonToLex)(JSON.parse(d));
  t.jsonStringToLex = b;
})(jp);
(function(t) {
  var e = ne && ne.__createBinding || (Object.create ? function(i, a, c, h) {
    h === void 0 && (h = c);
    var m = Object.getOwnPropertyDescriptor(a, c);
    (!m || ("get" in m ? !a.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
      return a[c];
    } }), Object.defineProperty(i, h, m);
  } : function(i, a, c, h) {
    h === void 0 && (h = c), i[h] = a[c];
  }), r = ne && ne.__exportStar || function(i, a) {
    for (var c in i) c !== "default" && !Object.prototype.hasOwnProperty.call(a, c) && e(a, i, c);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), r(Rn, t), r(Bu, t), r(Iu, t), r(jp, t);
})(wa);
var Fp = {};
Object.defineProperty(Fp, "__esModule", { value: !0 });
var ka = {};
Object.defineProperty(ka, "__esModule", { value: !0 });
ka.BSKY_LABELER_DID = void 0;
ka.BSKY_LABELER_DID = "did:plc:ar7c4by46qjdydhdevvrndac";
var Nr = {};
Object.defineProperty(Nr, "__esModule", { value: !0 });
Nr.validateSavedFeed = Nr.getSavedFeedType = Nr.savedFeedsToUriArrays = Nr.sanitizeMutedWordValue = void 0;
const $p = as, Pv = vi;
function Bv(t) {
  return t.trim().replace(/^#(?!\ufe0f)/, "").replace(/[\r\n\u00AD\u2060\u200D\u200C\u200B]+/, "");
}
Nr.sanitizeMutedWordValue = Bv;
function Iv(t) {
  const e = [], r = [];
  for (const i of t)
    i.pinned && e.push(i.value), r.push(i.value);
  return {
    pinned: e,
    saved: r
  };
}
Nr.savedFeedsToUriArrays = Iv;
function Uv(t) {
  switch (new $p.AtUri(t).collection) {
    case "app.bsky.feed.generator":
      return "feed";
    case "app.bsky.graph.list":
      return "list";
    default:
      return "unknown";
  }
}
Nr.getSavedFeedType = Uv;
function Ov(t) {
  if (new Pv.TID(t.id), ["feed", "list"].includes(t.type)) {
    const e = new $p.AtUri(t.value), r = e.collection === "app.bsky.feed.generator", i = e.collection === "app.bsky.graph.list";
    if (t.type === "feed" && !r)
      throw new Error(`Saved feed of type 'feed' must be a feed, got ${e.collection}`);
    if (t.type === "list" && !i)
      throw new Error(`Saved feed of type 'list' must be a list, got ${e.collection}`);
  }
}
Nr.validateSavedFeed = Ov;
var x = {}, q = {}, Ou = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.XRPCInvalidResponseError = t.XRPCError = t.XRPCResponse = t.ResponseTypeStrings = t.ResponseTypeNames = t.ResponseType = t.errorResponseBody = void 0;
  const e = os;
  t.errorResponseBody = e.z.object({
    error: e.z.string().optional(),
    message: e.z.string().optional()
  });
  var r;
  (function(h) {
    h[h.Unknown = 1] = "Unknown", h[h.InvalidResponse = 2] = "InvalidResponse", h[h.Success = 200] = "Success", h[h.InvalidRequest = 400] = "InvalidRequest", h[h.AuthRequired = 401] = "AuthRequired", h[h.Forbidden = 403] = "Forbidden", h[h.XRPCNotSupported = 404] = "XRPCNotSupported", h[h.PayloadTooLarge = 413] = "PayloadTooLarge", h[h.RateLimitExceeded = 429] = "RateLimitExceeded", h[h.InternalServerError = 500] = "InternalServerError", h[h.MethodNotImplemented = 501] = "MethodNotImplemented", h[h.UpstreamFailure = 502] = "UpstreamFailure", h[h.NotEnoughResources = 503] = "NotEnoughResources", h[h.UpstreamTimeout = 504] = "UpstreamTimeout";
  })(r || (t.ResponseType = r = {})), t.ResponseTypeNames = {
    [r.InvalidResponse]: "InvalidResponse",
    [r.Success]: "Success",
    [r.InvalidRequest]: "InvalidRequest",
    [r.AuthRequired]: "AuthenticationRequired",
    [r.Forbidden]: "Forbidden",
    [r.XRPCNotSupported]: "XRPCNotSupported",
    [r.PayloadTooLarge]: "PayloadTooLarge",
    [r.RateLimitExceeded]: "RateLimitExceeded",
    [r.InternalServerError]: "InternalServerError",
    [r.MethodNotImplemented]: "MethodNotImplemented",
    [r.UpstreamFailure]: "UpstreamFailure",
    [r.NotEnoughResources]: "NotEnoughResources",
    [r.UpstreamTimeout]: "UpstreamTimeout"
  }, t.ResponseTypeStrings = {
    [r.InvalidResponse]: "Invalid Response",
    [r.Success]: "Success",
    [r.InvalidRequest]: "Invalid Request",
    [r.AuthRequired]: "Authentication Required",
    [r.Forbidden]: "Forbidden",
    [r.XRPCNotSupported]: "XRPC Not Supported",
    [r.PayloadTooLarge]: "Payload Too Large",
    [r.RateLimitExceeded]: "Rate Limit Exceeded",
    [r.InternalServerError]: "Internal Server Error",
    [r.MethodNotImplemented]: "Method Not Implemented",
    [r.UpstreamFailure]: "Upstream Failure",
    [r.NotEnoughResources]: "Not Enough Resources",
    [r.UpstreamTimeout]: "Upstream Timeout"
  };
  class i {
    constructor(m, p) {
      Object.defineProperty(this, "data", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: m
      }), Object.defineProperty(this, "headers", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: p
      }), Object.defineProperty(this, "success", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: !0
      });
    }
  }
  t.XRPCResponse = i;
  class a extends Error {
    constructor(m, p, b, d) {
      super(b || p || t.ResponseTypeStrings[m]), Object.defineProperty(this, "status", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: m
      }), Object.defineProperty(this, "error", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: p
      }), Object.defineProperty(this, "success", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: !1
      }), Object.defineProperty(this, "headers", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), this.error || (this.error = t.ResponseTypeNames[m]), this.headers = d;
    }
  }
  t.XRPCError = a;
  class c extends a {
    constructor(m, p, b) {
      super(r.InvalidResponse, t.ResponseTypeStrings[r.InvalidResponse], "The server gave an invalid response and may be out of date."), Object.defineProperty(this, "lexiconNsid", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: m
      }), Object.defineProperty(this, "validationError", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: p
      }), Object.defineProperty(this, "responseBody", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: b
      });
    }
  }
  t.XRPCInvalidResponseError = c;
})(Ou);
var Mi = {}, Ut = {};
Object.defineProperty(Ut, "__esModule", { value: !0 });
Ut.httpResponseBodyParse = Ut.httpResponseCodeToEnum = Ut.encodeMethodCallBody = Ut.constructMethodCallHeaders = Ut.normalizeHeaders = Ut.encodeQueryParam = Ut.constructMethodCallUri = Ut.getMethodSchemaHTTPMethod = void 0;
const Gp = wa, ti = Ou;
function Kv(t) {
  return t.type === "procedure" ? "post" : "get";
}
Ut.getMethodSchemaHTTPMethod = Kv;
function Mv(t, e, r, i) {
  const a = new URL(r);
  if (a.pathname = `/xrpc/${t}`, i)
    for (const [c, h] of Object.entries(i)) {
      const m = e.parameters?.properties?.[c];
      if (!m)
        throw new Error(`Invalid query parameter: ${c}`);
      h !== void 0 && (m.type === "array" ? [].concat(h).forEach((b) => {
        a.searchParams.append(c, Dc(m.items.type, b));
      }) : a.searchParams.set(c, Dc(m.type, h)));
    }
  return a.toString();
}
Ut.constructMethodCallUri = Mv;
function Dc(t, e) {
  if (t === "string" || t === "unknown")
    return String(e);
  if (t === "float")
    return String(Number(e));
  if (t === "integer")
    return String(Number(e) | 0);
  if (t === "boolean")
    return e ? "true" : "false";
  if (t === "datetime")
    return e instanceof Date ? e.toISOString() : String(e);
  throw new Error(`Unsupported query param type: ${t}`);
}
Ut.encodeQueryParam = Dc;
function Nv(t) {
  const e = {};
  for (const [r, i] of Object.entries(t))
    e[r.toLowerCase()] = i;
  return e;
}
Ut.normalizeHeaders = Nv;
function Vv(t, e, r) {
  const i = r?.headers || {};
  return t.type === "procedure" && (r?.encoding && (i["Content-Type"] = r.encoding), e && typeof e == "object" && (i["Content-Type"] || (i["Content-Type"] = "application/json"))), i;
}
Ut.constructMethodCallHeaders = Vv;
function jv(t, e) {
  if (!(!t["content-type"] || typeof e > "u"))
    return e instanceof ArrayBuffer ? e : t["content-type"].startsWith("text/") ? new TextEncoder().encode(e.toString()) : t["content-type"].startsWith("application/json") ? new TextEncoder().encode((0, Gp.stringifyLex)(e)) : e;
}
Ut.encodeMethodCallBody = jv;
function Fv(t) {
  let e;
  return t in ti.ResponseType ? e = t : t >= 100 && t < 200 ? e = ti.ResponseType.XRPCNotSupported : t >= 200 && t < 300 ? e = ti.ResponseType.Success : t >= 300 && t < 400 ? e = ti.ResponseType.XRPCNotSupported : t >= 400 && t < 500 ? e = ti.ResponseType.InvalidRequest : e = ti.ResponseType.InternalServerError, e;
}
Ut.httpResponseCodeToEnum = Fv;
function $v(t, e) {
  if (t) {
    if (t.includes("application/json") && e?.byteLength)
      try {
        const r = new TextDecoder().decode(e);
        return (0, Gp.jsonStringToLex)(r);
      } catch (r) {
        throw new ti.XRPCError(ti.ResponseType.InvalidResponse, `Failed to parse response body: ${String(r)}`);
      }
    if (t.startsWith("text/") && e?.byteLength)
      try {
        return new TextDecoder().decode(e);
      } catch (r) {
        throw new ti.XRPCError(ti.ResponseType.InvalidResponse, `Failed to parse response body: ${String(r)}`);
      }
  }
  return e instanceof ArrayBuffer ? new Uint8Array(e) : e;
}
Ut.httpResponseBodyParse = $v;
Object.defineProperty(Mi, "__esModule", { value: !0 });
Mi.defaultFetchHandler = Mi.ServiceClient = Mi.Client = void 0;
const qp = wa, Un = Ut, un = Ou;
class Gv {
  constructor() {
    Object.defineProperty(this, "fetch", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Xp
    }), Object.defineProperty(this, "lex", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new qp.Lexicons()
    });
  }
  // method calls
  //
  async call(e, r, i, a, c) {
    return this.service(e).call(r, i, a, c);
  }
  service(e) {
    return new zp(this, e);
  }
  // schemas
  // =
  addLexicon(e) {
    this.lex.add(e);
  }
  addLexicons(e) {
    for (const r of e)
      this.addLexicon(r);
  }
  removeLexicon(e) {
    this.lex.remove(e);
  }
}
Mi.Client = Gv;
class zp {
  constructor(e, r) {
    Object.defineProperty(this, "baseClient", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "uri", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), this.baseClient = e, this.uri = typeof r == "string" ? new URL(r) : r;
  }
  setHeader(e, r) {
    this.headers[e] = r;
  }
  unsetHeader(e) {
    delete this.headers[e];
  }
  async call(e, r, i, a) {
    const c = this.baseClient.lex.getDefOrThrow(e);
    if (!c || c.type !== "query" && c.type !== "procedure")
      throw new Error(`Invalid lexicon: ${e}. Must be a query or procedure.`);
    const h = (0, Un.getMethodSchemaHTTPMethod)(c), m = (0, Un.constructMethodCallUri)(e, c, this.uri, r), p = (0, Un.constructMethodCallHeaders)(c, i, {
      headers: {
        ...this.headers,
        ...a?.headers
      },
      encoding: a?.encoding
    }), b = await this.baseClient.fetch(m, h, p, i), d = (0, Un.httpResponseCodeToEnum)(b.status);
    if (d === un.ResponseType.Success) {
      try {
        this.baseClient.lex.assertValidXrpcOutput(e, b.body);
      } catch (v) {
        throw v instanceof qp.ValidationError ? new un.XRPCInvalidResponseError(e, v, b.body) : v;
      }
      return new un.XRPCResponse(b.body, b.headers);
    } else
      throw b.body && qv(b.body) ? new un.XRPCError(d, b.body.error, b.body.message, b.headers) : new un.XRPCError(d);
  }
}
Mi.ServiceClient = zp;
async function Xp(t, e, r, i) {
  try {
    const a = (0, Un.normalizeHeaders)(r), c = {
      method: e,
      headers: a,
      body: (0, Un.encodeMethodCallBody)(a, i),
      duplex: "half"
    }, h = await fetch(t, c), m = await h.arrayBuffer();
    return {
      status: h.status,
      headers: Object.fromEntries(h.headers.entries()),
      body: (0, Un.httpResponseBodyParse)(h.headers.get("content-type"), m)
    };
  } catch (a) {
    throw new un.XRPCError(un.ResponseType.Unknown, String(a));
  }
}
Mi.defaultFetchHandler = Xp;
function qv(t) {
  return un.errorResponseBody.safeParse(t).success;
}
(function(t) {
  var e = ne && ne.__createBinding || (Object.create ? function(c, h, m, p) {
    p === void 0 && (p = m);
    var b = Object.getOwnPropertyDescriptor(h, m);
    (!b || ("get" in b ? !h.__esModule : b.writable || b.configurable)) && (b = { enumerable: !0, get: function() {
      return h[m];
    } }), Object.defineProperty(c, p, b);
  } : function(c, h, m, p) {
    p === void 0 && (p = m), c[p] = h[m];
  }), r = ne && ne.__exportStar || function(c, h) {
    for (var m in c) m !== "default" && !Object.prototype.hasOwnProperty.call(h, m) && e(h, c, m);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), r(Ou, t), r(Mi, t);
  const i = Mi, a = new i.Client();
  t.default = a;
})(q);
var Le = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ids = t.lexicons = t.schemas = t.schemaDict = void 0;
  const e = wa;
  t.schemaDict = {
    ComAtprotoAdminDefs: {
      lexicon: 1,
      id: "com.atproto.admin.defs",
      defs: {
        statusAttr: {
          type: "object",
          required: ["applied"],
          properties: {
            applied: {
              type: "boolean"
            },
            ref: {
              type: "string"
            }
          }
        },
        accountView: {
          type: "object",
          required: ["did", "handle", "indexedAt"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            email: {
              type: "string"
            },
            relatedRecords: {
              type: "array",
              items: {
                type: "unknown"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            invitedBy: {
              type: "ref",
              ref: "lex:com.atproto.server.defs#inviteCode"
            },
            invites: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.server.defs#inviteCode"
              }
            },
            invitesDisabled: {
              type: "boolean"
            },
            emailConfirmedAt: {
              type: "string",
              format: "datetime"
            },
            inviteNote: {
              type: "string"
            },
            deactivatedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        repoRef: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        },
        repoBlobRef: {
          type: "object",
          required: ["did", "cid"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            recordUri: {
              type: "string",
              format: "at-uri"
            }
          }
        }
      }
    },
    ComAtprotoAdminDeleteAccount: {
      lexicon: 1,
      id: "com.atproto.admin.deleteAccount",
      defs: {
        main: {
          type: "procedure",
          description: "Delete a user account as an administrator.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminDisableAccountInvites: {
      lexicon: 1,
      id: "com.atproto.admin.disableAccountInvites",
      defs: {
        main: {
          type: "procedure",
          description: "Disable an account from receiving new invite codes, but does not invalidate existing codes.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["account"],
              properties: {
                account: {
                  type: "string",
                  format: "did"
                },
                note: {
                  type: "string",
                  description: "Optional reason for disabled invites."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminDisableInviteCodes: {
      lexicon: 1,
      id: "com.atproto.admin.disableInviteCodes",
      defs: {
        main: {
          type: "procedure",
          description: "Disable some set of codes and/or all codes associated with a set of users.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                codes: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                accounts: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminEnableAccountInvites: {
      lexicon: 1,
      id: "com.atproto.admin.enableAccountInvites",
      defs: {
        main: {
          type: "procedure",
          description: "Re-enable an account's ability to receive invite codes.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["account"],
              properties: {
                account: {
                  type: "string",
                  format: "did"
                },
                note: {
                  type: "string",
                  description: "Optional reason for enabled invites."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminGetAccountInfo: {
      lexicon: 1,
      id: "com.atproto.admin.getAccountInfo",
      defs: {
        main: {
          type: "query",
          description: "Get details about an account.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:com.atproto.admin.defs#accountView"
            }
          }
        }
      }
    },
    ComAtprotoAdminGetAccountInfos: {
      lexicon: 1,
      id: "com.atproto.admin.getAccountInfos",
      defs: {
        main: {
          type: "query",
          description: "Get details about some accounts.",
          parameters: {
            type: "params",
            required: ["dids"],
            properties: {
              dids: {
                type: "array",
                items: {
                  type: "string",
                  format: "did"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["infos"],
              properties: {
                infos: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#accountView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminGetInviteCodes: {
      lexicon: 1,
      id: "com.atproto.admin.getInviteCodes",
      defs: {
        main: {
          type: "query",
          description: "Get an admin view of invite codes.",
          parameters: {
            type: "params",
            properties: {
              sort: {
                type: "string",
                knownValues: ["recent", "usage"],
                default: "recent"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 500,
                default: 100
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["codes"],
              properties: {
                cursor: {
                  type: "string"
                },
                codes: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.defs#inviteCode"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminGetSubjectStatus: {
      lexicon: 1,
      id: "com.atproto.admin.getSubjectStatus",
      defs: {
        main: {
          type: "query",
          description: "Get the service-specific admin status of a subject (account, record, or blob).",
          parameters: {
            type: "params",
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              uri: {
                type: "string",
                format: "at-uri"
              },
              blob: {
                type: "string",
                format: "cid"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject"],
              properties: {
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef",
                    "lex:com.atproto.admin.defs#repoBlobRef"
                  ]
                },
                takedown: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#statusAttr"
                },
                deactivated: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#statusAttr"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminSearchAccounts: {
      lexicon: 1,
      id: "com.atproto.admin.searchAccounts",
      defs: {
        main: {
          type: "query",
          description: "Get list of accounts that matches your search query.",
          parameters: {
            type: "params",
            properties: {
              email: {
                type: "string"
              },
              cursor: {
                type: "string"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["accounts"],
              properties: {
                cursor: {
                  type: "string"
                },
                accounts: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#accountView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminSendEmail: {
      lexicon: 1,
      id: "com.atproto.admin.sendEmail",
      defs: {
        main: {
          type: "procedure",
          description: "Send email to a user's account email address.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["recipientDid", "content", "senderDid"],
              properties: {
                recipientDid: {
                  type: "string",
                  format: "did"
                },
                content: {
                  type: "string"
                },
                subject: {
                  type: "string"
                },
                senderDid: {
                  type: "string",
                  format: "did"
                },
                comment: {
                  type: "string",
                  description: "Additional comment by the sender that won't be used in the email itself but helpful to provide more context for moderators/reviewers"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["sent"],
              properties: {
                sent: {
                  type: "boolean"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminUpdateAccountEmail: {
      lexicon: 1,
      id: "com.atproto.admin.updateAccountEmail",
      defs: {
        main: {
          type: "procedure",
          description: "Administrative action to update an account's email.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["account", "email"],
              properties: {
                account: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo."
                },
                email: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminUpdateAccountHandle: {
      lexicon: 1,
      id: "com.atproto.admin.updateAccountHandle",
      defs: {
        main: {
          type: "procedure",
          description: "Administrative action to update an account's handle.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "handle"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminUpdateAccountPassword: {
      lexicon: 1,
      id: "com.atproto.admin.updateAccountPassword",
      defs: {
        main: {
          type: "procedure",
          description: "Update the password for a user account as an administrator.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "password"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                password: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminUpdateSubjectStatus: {
      lexicon: 1,
      id: "com.atproto.admin.updateSubjectStatus",
      defs: {
        main: {
          type: "procedure",
          description: "Update the service-specific admin status of a subject (account, record, or blob).",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject"],
              properties: {
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef",
                    "lex:com.atproto.admin.defs#repoBlobRef"
                  ]
                },
                takedown: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#statusAttr"
                },
                deactivated: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#statusAttr"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject"],
              properties: {
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef",
                    "lex:com.atproto.admin.defs#repoBlobRef"
                  ]
                },
                takedown: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#statusAttr"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoIdentityGetRecommendedDidCredentials: {
      lexicon: 1,
      id: "com.atproto.identity.getRecommendedDidCredentials",
      defs: {
        main: {
          type: "query",
          description: "Describe the credentials that should be included in the DID doc of an account that is migrating to this service.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                rotationKeys: {
                  description: "Recommended rotation keys for PLC dids. Should be undefined (or ignored) for did:webs.",
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                alsoKnownAs: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                verificationMethods: {
                  type: "unknown"
                },
                services: {
                  type: "unknown"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoIdentityRequestPlcOperationSignature: {
      lexicon: 1,
      id: "com.atproto.identity.requestPlcOperationSignature",
      defs: {
        main: {
          type: "procedure",
          description: "Request an email with a code to in order to request a signed PLC operation. Requires Auth."
        }
      }
    },
    ComAtprotoIdentityResolveHandle: {
      lexicon: 1,
      id: "com.atproto.identity.resolveHandle",
      defs: {
        main: {
          type: "query",
          description: "Resolves a handle (domain name) to a DID.",
          parameters: {
            type: "params",
            required: ["handle"],
            properties: {
              handle: {
                type: "string",
                format: "handle",
                description: "The handle to resolve."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoIdentitySignPlcOperation: {
      lexicon: 1,
      id: "com.atproto.identity.signPlcOperation",
      defs: {
        main: {
          type: "procedure",
          description: "Signs a PLC operation to update some value(s) in the requesting DID's document.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                token: {
                  description: "A token received through com.atproto.identity.requestPlcOperationSignature",
                  type: "string"
                },
                rotationKeys: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                alsoKnownAs: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                verificationMethods: {
                  type: "unknown"
                },
                services: {
                  type: "unknown"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["operation"],
              properties: {
                operation: {
                  type: "unknown",
                  description: "A signed DID PLC operation."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoIdentitySubmitPlcOperation: {
      lexicon: 1,
      id: "com.atproto.identity.submitPlcOperation",
      defs: {
        main: {
          type: "procedure",
          description: "Validates a PLC operation to ensure that it doesn't violate a service's constraints or get the identity into a bad state, then submits it to the PLC registry",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["operation"],
              properties: {
                operation: {
                  type: "unknown"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoIdentityUpdateHandle: {
      lexicon: 1,
      id: "com.atproto.identity.updateHandle",
      defs: {
        main: {
          type: "procedure",
          description: "Updates the current account's handle. Verifies handle validity, and updates did:plc document if necessary. Implemented by PDS, and requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["handle"],
              properties: {
                handle: {
                  type: "string",
                  format: "handle",
                  description: "The new handle."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoLabelDefs: {
      lexicon: 1,
      id: "com.atproto.label.defs",
      defs: {
        label: {
          type: "object",
          description: "Metadata tag on an atproto resource (eg, repo or record).",
          required: ["src", "uri", "val", "cts"],
          properties: {
            ver: {
              type: "integer",
              description: "The AT Protocol version of the label object."
            },
            src: {
              type: "string",
              format: "did",
              description: "DID of the actor who created this label."
            },
            uri: {
              type: "string",
              format: "uri",
              description: "AT URI of the record, repository (account), or other resource that this label applies to."
            },
            cid: {
              type: "string",
              format: "cid",
              description: "Optionally, CID specifying the specific version of 'uri' resource this label applies to."
            },
            val: {
              type: "string",
              maxLength: 128,
              description: "The short string name of the value or type of this label."
            },
            neg: {
              type: "boolean",
              description: "If true, this is a negation label, overwriting a previous label."
            },
            cts: {
              type: "string",
              format: "datetime",
              description: "Timestamp when this label was created."
            },
            exp: {
              type: "string",
              format: "datetime",
              description: "Timestamp at which this label expires (no longer applies)."
            },
            sig: {
              type: "bytes",
              description: "Signature of dag-cbor encoded label."
            }
          }
        },
        selfLabels: {
          type: "object",
          description: "Metadata tags on an atproto record, published by the author within the record.",
          required: ["values"],
          properties: {
            values: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#selfLabel"
              },
              maxLength: 10
            }
          }
        },
        selfLabel: {
          type: "object",
          description: "Metadata tag on an atproto record, published by the author within the record. Note that schemas should use #selfLabels, not #selfLabel.",
          required: ["val"],
          properties: {
            val: {
              type: "string",
              maxLength: 128,
              description: "The short string name of the value or type of this label."
            }
          }
        },
        labelValueDefinition: {
          type: "object",
          description: "Declares a label value and its expected interpretations and behaviors.",
          required: ["identifier", "severity", "blurs", "locales"],
          properties: {
            identifier: {
              type: "string",
              description: "The value of the label being defined. Must only include lowercase ascii and the '-' character ([a-z-]+).",
              maxLength: 100,
              maxGraphemes: 100
            },
            severity: {
              type: "string",
              description: "How should a client visually convey this label? 'inform' means neutral and informational; 'alert' means negative and warning; 'none' means show nothing.",
              knownValues: ["inform", "alert", "none"]
            },
            blurs: {
              type: "string",
              description: "What should this label hide in the UI, if applied? 'content' hides all of the target; 'media' hides the images/video/audio; 'none' hides nothing.",
              knownValues: ["content", "media", "none"]
            },
            defaultSetting: {
              type: "string",
              description: "The default setting for this label.",
              knownValues: ["ignore", "warn", "hide"],
              default: "warn"
            },
            adultOnly: {
              type: "boolean",
              description: "Does the user need to have adult content enabled in order to configure this label?"
            },
            locales: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#labelValueDefinitionStrings"
              }
            }
          }
        },
        labelValueDefinitionStrings: {
          type: "object",
          description: "Strings which describe the label in the UI, localized into a specific language.",
          required: ["lang", "name", "description"],
          properties: {
            lang: {
              type: "string",
              description: "The code of the language these strings are written in.",
              format: "language"
            },
            name: {
              type: "string",
              description: "A short human-readable name for the label.",
              maxGraphemes: 64,
              maxLength: 640
            },
            description: {
              type: "string",
              description: "A longer description of what the label means and why it might be applied.",
              maxGraphemes: 1e4,
              maxLength: 1e5
            }
          }
        },
        labelValue: {
          type: "string",
          knownValues: [
            "!hide",
            "!no-promote",
            "!warn",
            "!no-unauthenticated",
            "dmca-violation",
            "doxxing",
            "porn",
            "sexual",
            "nudity",
            "nsfl",
            "gore"
          ]
        }
      }
    },
    ComAtprotoLabelQueryLabels: {
      lexicon: 1,
      id: "com.atproto.label.queryLabels",
      defs: {
        main: {
          type: "query",
          description: "Find labels relevant to the provided AT-URI patterns. Public endpoint for moderation services, though may return different or additional results with auth.",
          parameters: {
            type: "params",
            required: ["uriPatterns"],
            properties: {
              uriPatterns: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "List of AT URI patterns to match (boolean 'OR'). Each may be a prefix (ending with '*'; will match inclusive of the string leading to '*'), or a full URI."
              },
              sources: {
                type: "array",
                items: {
                  type: "string",
                  format: "did"
                },
                description: "Optional list of label sources (DIDs) to filter on."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 250,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["labels"],
              properties: {
                cursor: {
                  type: "string"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoLabelSubscribeLabels: {
      lexicon: 1,
      id: "com.atproto.label.subscribeLabels",
      defs: {
        main: {
          type: "subscription",
          description: "Subscribe to stream of labels (and negations). Public endpoint implemented by mod services. Uses same sequencing scheme as repo event stream.",
          parameters: {
            type: "params",
            properties: {
              cursor: {
                type: "integer",
                description: "The last known event seq number to backfill from."
              }
            }
          },
          message: {
            schema: {
              type: "union",
              refs: [
                "lex:com.atproto.label.subscribeLabels#labels",
                "lex:com.atproto.label.subscribeLabels#info"
              ]
            }
          },
          errors: [
            {
              name: "FutureCursor"
            }
          ]
        },
        labels: {
          type: "object",
          required: ["seq", "labels"],
          properties: {
            seq: {
              type: "integer"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        info: {
          type: "object",
          required: ["name"],
          properties: {
            name: {
              type: "string",
              knownValues: ["OutdatedCursor"]
            },
            message: {
              type: "string"
            }
          }
        }
      }
    },
    ComAtprotoModerationCreateReport: {
      lexicon: 1,
      id: "com.atproto.moderation.createReport",
      defs: {
        main: {
          type: "procedure",
          description: "Submit a moderation report regarding an atproto account or record. Implemented by moderation services (with PDS proxying), and requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["reasonType", "subject"],
              properties: {
                reasonType: {
                  type: "ref",
                  description: "Indicates the broad category of violation the report is for.",
                  ref: "lex:com.atproto.moderation.defs#reasonType"
                },
                reason: {
                  type: "string",
                  maxGraphemes: 2e3,
                  maxLength: 2e4,
                  description: "Additional context about the content and violation."
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: [
                "id",
                "reasonType",
                "subject",
                "reportedBy",
                "createdAt"
              ],
              properties: {
                id: {
                  type: "integer"
                },
                reasonType: {
                  type: "ref",
                  ref: "lex:com.atproto.moderation.defs#reasonType"
                },
                reason: {
                  type: "string",
                  maxGraphemes: 2e3,
                  maxLength: 2e4
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                },
                reportedBy: {
                  type: "string",
                  format: "did"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoModerationDefs: {
      lexicon: 1,
      id: "com.atproto.moderation.defs",
      defs: {
        reasonType: {
          type: "string",
          knownValues: [
            "com.atproto.moderation.defs#reasonSpam",
            "com.atproto.moderation.defs#reasonViolation",
            "com.atproto.moderation.defs#reasonMisleading",
            "com.atproto.moderation.defs#reasonSexual",
            "com.atproto.moderation.defs#reasonRude",
            "com.atproto.moderation.defs#reasonOther",
            "com.atproto.moderation.defs#reasonAppeal"
          ]
        },
        reasonSpam: {
          type: "token",
          description: "Spam: frequent unwanted promotion, replies, mentions"
        },
        reasonViolation: {
          type: "token",
          description: "Direct violation of server rules, laws, terms of service"
        },
        reasonMisleading: {
          type: "token",
          description: "Misleading identity, affiliation, or content"
        },
        reasonSexual: {
          type: "token",
          description: "Unwanted or mislabeled sexual content"
        },
        reasonRude: {
          type: "token",
          description: "Rude, harassing, explicit, or otherwise unwelcoming behavior"
        },
        reasonOther: {
          type: "token",
          description: "Other: reports not falling under another report category"
        },
        reasonAppeal: {
          type: "token",
          description: "Appeal: appeal a previously taken moderation action"
        }
      }
    },
    ComAtprotoRepoApplyWrites: {
      lexicon: 1,
      id: "com.atproto.repo.applyWrites",
      defs: {
        main: {
          type: "procedure",
          description: "Apply a batch transaction of repository creates, updates, and deletes. Requires auth, implemented by PDS.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repo", "writes"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo (aka, current account)."
                },
                validate: {
                  type: "boolean",
                  default: !0,
                  description: "Can be set to 'false' to skip Lexicon schema validation of record data, for all operations."
                },
                writes: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:com.atproto.repo.applyWrites#create",
                      "lex:com.atproto.repo.applyWrites#update",
                      "lex:com.atproto.repo.applyWrites#delete"
                    ],
                    closed: !0
                  }
                },
                swapCommit: {
                  type: "string",
                  description: "If provided, the entire operation will fail if the current repo commit CID does not match this value. Used to prevent conflicting repo mutations.",
                  format: "cid"
                }
              }
            }
          },
          errors: [
            {
              name: "InvalidSwap",
              description: "Indicates that the 'swapCommit' parameter did not match current commit."
            }
          ]
        },
        create: {
          type: "object",
          description: "Operation which creates a new record.",
          required: ["collection", "value"],
          properties: {
            collection: {
              type: "string",
              format: "nsid"
            },
            rkey: {
              type: "string",
              maxLength: 15
            },
            value: {
              type: "unknown"
            }
          }
        },
        update: {
          type: "object",
          description: "Operation which updates an existing record.",
          required: ["collection", "rkey", "value"],
          properties: {
            collection: {
              type: "string",
              format: "nsid"
            },
            rkey: {
              type: "string"
            },
            value: {
              type: "unknown"
            }
          }
        },
        delete: {
          type: "object",
          description: "Operation which deletes an existing record.",
          required: ["collection", "rkey"],
          properties: {
            collection: {
              type: "string",
              format: "nsid"
            },
            rkey: {
              type: "string"
            }
          }
        }
      }
    },
    ComAtprotoRepoCreateRecord: {
      lexicon: 1,
      id: "com.atproto.repo.createRecord",
      defs: {
        main: {
          type: "procedure",
          description: "Create a single new repository record. Requires auth, implemented by PDS.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repo", "collection", "record"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo (aka, current account)."
                },
                collection: {
                  type: "string",
                  format: "nsid",
                  description: "The NSID of the record collection."
                },
                rkey: {
                  type: "string",
                  description: "The Record Key.",
                  maxLength: 15
                },
                validate: {
                  type: "boolean",
                  default: !0,
                  description: "Can be set to 'false' to skip Lexicon schema validation of record data."
                },
                record: {
                  type: "unknown",
                  description: "The record itself. Must contain a $type field."
                },
                swapCommit: {
                  type: "string",
                  format: "cid",
                  description: "Compare and swap with the previous commit by CID."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["uri", "cid"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                }
              }
            }
          },
          errors: [
            {
              name: "InvalidSwap",
              description: "Indicates that 'swapCommit' didn't match current repo commit."
            }
          ]
        }
      }
    },
    ComAtprotoRepoDeleteRecord: {
      lexicon: 1,
      id: "com.atproto.repo.deleteRecord",
      defs: {
        main: {
          type: "procedure",
          description: "Delete a repository record, or ensure it doesn't exist. Requires auth, implemented by PDS.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repo", "collection", "rkey"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo (aka, current account)."
                },
                collection: {
                  type: "string",
                  format: "nsid",
                  description: "The NSID of the record collection."
                },
                rkey: {
                  type: "string",
                  description: "The Record Key."
                },
                swapRecord: {
                  type: "string",
                  format: "cid",
                  description: "Compare and swap with the previous record by CID."
                },
                swapCommit: {
                  type: "string",
                  format: "cid",
                  description: "Compare and swap with the previous commit by CID."
                }
              }
            }
          },
          errors: [
            {
              name: "InvalidSwap"
            }
          ]
        }
      }
    },
    ComAtprotoRepoDescribeRepo: {
      lexicon: 1,
      id: "com.atproto.repo.describeRepo",
      defs: {
        main: {
          type: "query",
          description: "Get information about an account and repository, including the list of collections. Does not require auth.",
          parameters: {
            type: "params",
            required: ["repo"],
            properties: {
              repo: {
                type: "string",
                format: "at-identifier",
                description: "The handle or DID of the repo."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: [
                "handle",
                "did",
                "didDoc",
                "collections",
                "handleIsCorrect"
              ],
              properties: {
                handle: {
                  type: "string",
                  format: "handle"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                didDoc: {
                  type: "unknown",
                  description: "The complete DID document for this account."
                },
                collections: {
                  type: "array",
                  description: "List of all the collections (NSIDs) for which this repo contains at least one record.",
                  items: {
                    type: "string",
                    format: "nsid"
                  }
                },
                handleIsCorrect: {
                  type: "boolean",
                  description: "Indicates if handle is currently valid (resolves bi-directionally)"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoRepoGetRecord: {
      lexicon: 1,
      id: "com.atproto.repo.getRecord",
      defs: {
        main: {
          type: "query",
          description: "Get a single record from a repository. Does not require auth.",
          parameters: {
            type: "params",
            required: ["repo", "collection", "rkey"],
            properties: {
              repo: {
                type: "string",
                format: "at-identifier",
                description: "The handle or DID of the repo."
              },
              collection: {
                type: "string",
                format: "nsid",
                description: "The NSID of the record collection."
              },
              rkey: {
                type: "string",
                description: "The Record Key."
              },
              cid: {
                type: "string",
                format: "cid",
                description: "The CID of the version of the record. If not specified, then return the most recent version."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["uri", "value"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                value: {
                  type: "unknown"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoRepoImportRepo: {
      lexicon: 1,
      id: "com.atproto.repo.importRepo",
      defs: {
        main: {
          type: "procedure",
          description: "Import a repo in the form of a CAR file. Requires Content-Length HTTP header to be set.",
          input: {
            encoding: "application/vnd.ipld.car"
          }
        }
      }
    },
    ComAtprotoRepoListMissingBlobs: {
      lexicon: 1,
      id: "com.atproto.repo.listMissingBlobs",
      defs: {
        main: {
          type: "query",
          description: "Returns a list of missing blobs for the requesting account. Intended to be used in the account migration flow.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 1e3,
                default: 500
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["blobs"],
              properties: {
                cursor: {
                  type: "string"
                },
                blobs: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.listMissingBlobs#recordBlob"
                  }
                }
              }
            }
          }
        },
        recordBlob: {
          type: "object",
          required: ["cid", "recordUri"],
          properties: {
            cid: {
              type: "string",
              format: "cid"
            },
            recordUri: {
              type: "string",
              format: "at-uri"
            }
          }
        }
      }
    },
    ComAtprotoRepoListRecords: {
      lexicon: 1,
      id: "com.atproto.repo.listRecords",
      defs: {
        main: {
          type: "query",
          description: "List a range of records in a repository, matching a specific collection. Does not require auth.",
          parameters: {
            type: "params",
            required: ["repo", "collection"],
            properties: {
              repo: {
                type: "string",
                format: "at-identifier",
                description: "The handle or DID of the repo."
              },
              collection: {
                type: "string",
                format: "nsid",
                description: "The NSID of the record type."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50,
                description: "The number of records to return."
              },
              cursor: {
                type: "string"
              },
              rkeyStart: {
                type: "string",
                description: "DEPRECATED: The lowest sort-ordered rkey to start from (exclusive)"
              },
              rkeyEnd: {
                type: "string",
                description: "DEPRECATED: The highest sort-ordered rkey to stop at (exclusive)"
              },
              reverse: {
                type: "boolean",
                description: "Flag to reverse the order of the returned records."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["records"],
              properties: {
                cursor: {
                  type: "string"
                },
                records: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.listRecords#record"
                  }
                }
              }
            }
          }
        },
        record: {
          type: "object",
          required: ["uri", "cid", "value"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            value: {
              type: "unknown"
            }
          }
        }
      }
    },
    ComAtprotoRepoPutRecord: {
      lexicon: 1,
      id: "com.atproto.repo.putRecord",
      defs: {
        main: {
          type: "procedure",
          description: "Write a repository record, creating or updating it as needed. Requires auth, implemented by PDS.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repo", "collection", "rkey", "record"],
              nullable: ["swapRecord"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo (aka, current account)."
                },
                collection: {
                  type: "string",
                  format: "nsid",
                  description: "The NSID of the record collection."
                },
                rkey: {
                  type: "string",
                  description: "The Record Key.",
                  maxLength: 15
                },
                validate: {
                  type: "boolean",
                  default: !0,
                  description: "Can be set to 'false' to skip Lexicon schema validation of record data."
                },
                record: {
                  type: "unknown",
                  description: "The record to write."
                },
                swapRecord: {
                  type: "string",
                  format: "cid",
                  description: "Compare and swap with the previous record by CID. WARNING: nullable and optional field; may cause problems with golang implementation"
                },
                swapCommit: {
                  type: "string",
                  format: "cid",
                  description: "Compare and swap with the previous commit by CID."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["uri", "cid"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                }
              }
            }
          },
          errors: [
            {
              name: "InvalidSwap"
            }
          ]
        }
      }
    },
    ComAtprotoRepoStrongRef: {
      lexicon: 1,
      id: "com.atproto.repo.strongRef",
      description: "A URI with a content-hash fingerprint.",
      defs: {
        main: {
          type: "object",
          required: ["uri", "cid"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            }
          }
        }
      }
    },
    ComAtprotoRepoUploadBlob: {
      lexicon: 1,
      id: "com.atproto.repo.uploadBlob",
      defs: {
        main: {
          type: "procedure",
          description: "Upload a new blob, to be referenced from a repository record. The blob will be deleted if it is not referenced within a time window (eg, minutes). Blob restrictions (mimetype, size, etc) are enforced when the reference is created. Requires auth, implemented by PDS.",
          input: {
            encoding: "*/*"
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["blob"],
              properties: {
                blob: {
                  type: "blob"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerActivateAccount: {
      lexicon: 1,
      id: "com.atproto.server.activateAccount",
      defs: {
        main: {
          type: "procedure",
          description: "Activates a currently deactivated account. Used to finalize account migration after the account's repo is imported and identity is setup."
        }
      }
    },
    ComAtprotoServerCheckAccountStatus: {
      lexicon: 1,
      id: "com.atproto.server.checkAccountStatus",
      defs: {
        main: {
          type: "query",
          description: "Returns the status of an account, especially as pertaining to import or recovery. Can be called many times over the course of an account migration. Requires auth and can only be called pertaining to oneself.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: [
                "activated",
                "validDid",
                "repoCommit",
                "repoRev",
                "repoBlocks",
                "indexedRecords",
                "privateStateValues",
                "expectedBlobs",
                "importedBlobs"
              ],
              properties: {
                activated: {
                  type: "boolean"
                },
                validDid: {
                  type: "boolean"
                },
                repoCommit: {
                  type: "string",
                  format: "cid"
                },
                repoRev: {
                  type: "string"
                },
                repoBlocks: {
                  type: "integer"
                },
                indexedRecords: {
                  type: "integer"
                },
                privateStateValues: {
                  type: "integer"
                },
                expectedBlobs: {
                  type: "integer"
                },
                importedBlobs: {
                  type: "integer"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerConfirmEmail: {
      lexicon: 1,
      id: "com.atproto.server.confirmEmail",
      defs: {
        main: {
          type: "procedure",
          description: "Confirm an email using a token from com.atproto.server.requestEmailConfirmation.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["email", "token"],
              properties: {
                email: {
                  type: "string"
                },
                token: {
                  type: "string"
                }
              }
            }
          },
          errors: [
            {
              name: "AccountNotFound"
            },
            {
              name: "ExpiredToken"
            },
            {
              name: "InvalidToken"
            },
            {
              name: "InvalidEmail"
            }
          ]
        }
      }
    },
    ComAtprotoServerCreateAccount: {
      lexicon: 1,
      id: "com.atproto.server.createAccount",
      defs: {
        main: {
          type: "procedure",
          description: "Create an account. Implemented by PDS.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["handle"],
              properties: {
                email: {
                  type: "string"
                },
                handle: {
                  type: "string",
                  format: "handle",
                  description: "Requested handle for the account."
                },
                did: {
                  type: "string",
                  format: "did",
                  description: "Pre-existing atproto DID, being imported to a new account."
                },
                inviteCode: {
                  type: "string"
                },
                verificationCode: {
                  type: "string"
                },
                verificationPhone: {
                  type: "string"
                },
                password: {
                  type: "string",
                  description: "Initial account password. May need to meet instance-specific password strength requirements."
                },
                recoveryKey: {
                  type: "string",
                  description: "DID PLC rotation key (aka, recovery key) to be included in PLC creation operation."
                },
                plcOp: {
                  type: "unknown",
                  description: "A signed DID PLC operation to be submitted as part of importing an existing account to this instance. NOTE: this optional field may be updated when full account migration is implemented."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              description: "Account login session returned on successful account creation.",
              required: ["accessJwt", "refreshJwt", "handle", "did"],
              properties: {
                accessJwt: {
                  type: "string"
                },
                refreshJwt: {
                  type: "string"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID of the new account."
                },
                didDoc: {
                  type: "unknown",
                  description: "Complete DID document."
                }
              }
            }
          },
          errors: [
            {
              name: "InvalidHandle"
            },
            {
              name: "InvalidPassword"
            },
            {
              name: "InvalidInviteCode"
            },
            {
              name: "HandleNotAvailable"
            },
            {
              name: "UnsupportedDomain"
            },
            {
              name: "UnresolvableDid"
            },
            {
              name: "IncompatibleDidDoc"
            }
          ]
        }
      }
    },
    ComAtprotoServerCreateAppPassword: {
      lexicon: 1,
      id: "com.atproto.server.createAppPassword",
      defs: {
        main: {
          type: "procedure",
          description: "Create an App Password.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["name"],
              properties: {
                name: {
                  type: "string",
                  description: "A short name for the App Password, to help distinguish them."
                },
                privileged: {
                  type: "boolean",
                  description: "If an app password has 'privileged' access to possibly sensitive account state. Meant for use with trusted clients."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:com.atproto.server.createAppPassword#appPassword"
            }
          },
          errors: [
            {
              name: "AccountTakedown"
            }
          ]
        },
        appPassword: {
          type: "object",
          required: ["name", "password", "createdAt"],
          properties: {
            name: {
              type: "string"
            },
            password: {
              type: "string"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            privileged: {
              type: "boolean"
            }
          }
        }
      }
    },
    ComAtprotoServerCreateInviteCode: {
      lexicon: 1,
      id: "com.atproto.server.createInviteCode",
      defs: {
        main: {
          type: "procedure",
          description: "Create an invite code.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["useCount"],
              properties: {
                useCount: {
                  type: "integer"
                },
                forAccount: {
                  type: "string",
                  format: "did"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["code"],
              properties: {
                code: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerCreateInviteCodes: {
      lexicon: 1,
      id: "com.atproto.server.createInviteCodes",
      defs: {
        main: {
          type: "procedure",
          description: "Create invite codes.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["codeCount", "useCount"],
              properties: {
                codeCount: {
                  type: "integer",
                  default: 1
                },
                useCount: {
                  type: "integer"
                },
                forAccounts: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "did"
                  }
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["codes"],
              properties: {
                codes: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.createInviteCodes#accountCodes"
                  }
                }
              }
            }
          }
        },
        accountCodes: {
          type: "object",
          required: ["account", "codes"],
          properties: {
            account: {
              type: "string"
            },
            codes: {
              type: "array",
              items: {
                type: "string"
              }
            }
          }
        }
      }
    },
    ComAtprotoServerCreateSession: {
      lexicon: 1,
      id: "com.atproto.server.createSession",
      defs: {
        main: {
          type: "procedure",
          description: "Create an authentication session.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["identifier", "password"],
              properties: {
                identifier: {
                  type: "string",
                  description: "Handle or other identifier supported by the server for the authenticating user."
                },
                password: {
                  type: "string"
                },
                authFactorToken: {
                  type: "string"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["accessJwt", "refreshJwt", "handle", "did"],
              properties: {
                accessJwt: {
                  type: "string"
                },
                refreshJwt: {
                  type: "string"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                didDoc: {
                  type: "unknown"
                },
                email: {
                  type: "string"
                },
                emailConfirmed: {
                  type: "boolean"
                },
                emailAuthFactor: {
                  type: "boolean"
                },
                active: {
                  type: "boolean"
                },
                status: {
                  type: "string",
                  description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
                  knownValues: ["takendown", "suspended", "deactivated"]
                }
              }
            }
          },
          errors: [
            {
              name: "AccountTakedown"
            },
            {
              name: "AuthFactorTokenRequired"
            }
          ]
        }
      }
    },
    ComAtprotoServerDeactivateAccount: {
      lexicon: 1,
      id: "com.atproto.server.deactivateAccount",
      defs: {
        main: {
          type: "procedure",
          description: "Deactivates a currently active account. Stops serving of repo, and future writes to repo until reactivated. Used to finalize account migration with the old host after the account has been activated on the new host.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                deleteAfter: {
                  type: "string",
                  format: "datetime",
                  description: "A recommendation to server as to how long they should hold onto the deactivated account before deleting."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerDefs: {
      lexicon: 1,
      id: "com.atproto.server.defs",
      defs: {
        inviteCode: {
          type: "object",
          required: [
            "code",
            "available",
            "disabled",
            "forAccount",
            "createdBy",
            "createdAt",
            "uses"
          ],
          properties: {
            code: {
              type: "string"
            },
            available: {
              type: "integer"
            },
            disabled: {
              type: "boolean"
            },
            forAccount: {
              type: "string"
            },
            createdBy: {
              type: "string"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            uses: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.server.defs#inviteCodeUse"
              }
            }
          }
        },
        inviteCodeUse: {
          type: "object",
          required: ["usedBy", "usedAt"],
          properties: {
            usedBy: {
              type: "string",
              format: "did"
            },
            usedAt: {
              type: "string",
              format: "datetime"
            }
          }
        }
      }
    },
    ComAtprotoServerDeleteAccount: {
      lexicon: 1,
      id: "com.atproto.server.deleteAccount",
      defs: {
        main: {
          type: "procedure",
          description: "Delete an actor's account with a token and password. Can only be called after requesting a deletion token. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "password", "token"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                password: {
                  type: "string"
                },
                token: {
                  type: "string"
                }
              }
            }
          },
          errors: [
            {
              name: "ExpiredToken"
            },
            {
              name: "InvalidToken"
            }
          ]
        }
      }
    },
    ComAtprotoServerDeleteSession: {
      lexicon: 1,
      id: "com.atproto.server.deleteSession",
      defs: {
        main: {
          type: "procedure",
          description: "Delete the current session. Requires auth."
        }
      }
    },
    ComAtprotoServerDescribeServer: {
      lexicon: 1,
      id: "com.atproto.server.describeServer",
      defs: {
        main: {
          type: "query",
          description: "Describes the server's account creation requirements and capabilities. Implemented by PDS.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "availableUserDomains"],
              properties: {
                inviteCodeRequired: {
                  type: "boolean",
                  description: "If true, an invite code must be supplied to create an account on this instance."
                },
                phoneVerificationRequired: {
                  type: "boolean",
                  description: "If true, a phone verification token must be supplied to create an account on this instance."
                },
                availableUserDomains: {
                  type: "array",
                  description: "List of domain suffixes that can be used in account handles.",
                  items: {
                    type: "string"
                  }
                },
                links: {
                  type: "ref",
                  description: "URLs of service policy documents.",
                  ref: "lex:com.atproto.server.describeServer#links"
                },
                contact: {
                  type: "ref",
                  description: "Contact information",
                  ref: "lex:com.atproto.server.describeServer#contact"
                },
                did: {
                  type: "string",
                  format: "did"
                }
              }
            }
          }
        },
        links: {
          type: "object",
          properties: {
            privacyPolicy: {
              type: "string",
              format: "uri"
            },
            termsOfService: {
              type: "string",
              format: "uri"
            }
          }
        },
        contact: {
          type: "object",
          properties: {
            email: {
              type: "string"
            }
          }
        }
      }
    },
    ComAtprotoServerGetAccountInviteCodes: {
      lexicon: 1,
      id: "com.atproto.server.getAccountInviteCodes",
      defs: {
        main: {
          type: "query",
          description: "Get all invite codes for the current account. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              includeUsed: {
                type: "boolean",
                default: !0
              },
              createAvailable: {
                type: "boolean",
                default: !0,
                description: "Controls whether any new 'earned' but not 'created' invites should be created."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["codes"],
              properties: {
                codes: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.defs#inviteCode"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "DuplicateCreate"
            }
          ]
        }
      }
    },
    ComAtprotoServerGetServiceAuth: {
      lexicon: 1,
      id: "com.atproto.server.getServiceAuth",
      defs: {
        main: {
          type: "query",
          description: "Get a signed token on behalf of the requesting DID for the requested service.",
          parameters: {
            type: "params",
            required: ["aud"],
            properties: {
              aud: {
                type: "string",
                format: "did",
                description: "The DID of the service that the token will be used to authenticate with"
              },
              exp: {
                type: "integer",
                description: "The time in Unix Epoch seconds that the JWT expires. Defaults to 60 seconds in the future. The service may enforce certain time bounds on tokens depending on the requested scope."
              },
              lxm: {
                type: "string",
                format: "nsid",
                description: "Lexicon (XRPC) method to bind the requested token to"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["token"],
              properties: {
                token: {
                  type: "string"
                }
              }
            }
          },
          errors: [
            {
              name: "BadExpiration",
              description: "Indicates that the requested expiration date is not a valid. May be in the past or may be reliant on the requested scopes."
            }
          ]
        }
      }
    },
    ComAtprotoServerGetSession: {
      lexicon: 1,
      id: "com.atproto.server.getSession",
      defs: {
        main: {
          type: "query",
          description: "Get information about the current auth session. Requires auth.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["handle", "did"],
              properties: {
                handle: {
                  type: "string",
                  format: "handle"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                email: {
                  type: "string"
                },
                emailConfirmed: {
                  type: "boolean"
                },
                emailAuthFactor: {
                  type: "boolean"
                },
                didDoc: {
                  type: "unknown"
                },
                active: {
                  type: "boolean"
                },
                status: {
                  type: "string",
                  description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
                  knownValues: ["takendown", "suspended", "deactivated"]
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerListAppPasswords: {
      lexicon: 1,
      id: "com.atproto.server.listAppPasswords",
      defs: {
        main: {
          type: "query",
          description: "List all App Passwords.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["passwords"],
              properties: {
                passwords: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.listAppPasswords#appPassword"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "AccountTakedown"
            }
          ]
        },
        appPassword: {
          type: "object",
          required: ["name", "createdAt"],
          properties: {
            name: {
              type: "string"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            privileged: {
              type: "boolean"
            }
          }
        }
      }
    },
    ComAtprotoServerRefreshSession: {
      lexicon: 1,
      id: "com.atproto.server.refreshSession",
      defs: {
        main: {
          type: "procedure",
          description: "Refresh an authentication session. Requires auth using the 'refreshJwt' (not the 'accessJwt').",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["accessJwt", "refreshJwt", "handle", "did"],
              properties: {
                accessJwt: {
                  type: "string"
                },
                refreshJwt: {
                  type: "string"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                didDoc: {
                  type: "unknown"
                },
                active: {
                  type: "boolean"
                },
                status: {
                  type: "string",
                  description: "Hosting status of the account. If not specified, then assume 'active'.",
                  knownValues: ["takendown", "suspended", "deactivated"]
                }
              }
            }
          },
          errors: [
            {
              name: "AccountTakedown"
            }
          ]
        }
      }
    },
    ComAtprotoServerRequestAccountDelete: {
      lexicon: 1,
      id: "com.atproto.server.requestAccountDelete",
      defs: {
        main: {
          type: "procedure",
          description: "Initiate a user account deletion via email."
        }
      }
    },
    ComAtprotoServerRequestEmailConfirmation: {
      lexicon: 1,
      id: "com.atproto.server.requestEmailConfirmation",
      defs: {
        main: {
          type: "procedure",
          description: "Request an email with a code to confirm ownership of email."
        }
      }
    },
    ComAtprotoServerRequestEmailUpdate: {
      lexicon: 1,
      id: "com.atproto.server.requestEmailUpdate",
      defs: {
        main: {
          type: "procedure",
          description: "Request a token in order to update email.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["tokenRequired"],
              properties: {
                tokenRequired: {
                  type: "boolean"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerRequestPasswordReset: {
      lexicon: 1,
      id: "com.atproto.server.requestPasswordReset",
      defs: {
        main: {
          type: "procedure",
          description: "Initiate a user account password reset via email.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["email"],
              properties: {
                email: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerReserveSigningKey: {
      lexicon: 1,
      id: "com.atproto.server.reserveSigningKey",
      defs: {
        main: {
          type: "procedure",
          description: "Reserve a repo signing key, for use with account creation. Necessary so that a DID PLC update operation can be constructed during an account migraiton. Public and does not require auth; implemented by PDS. NOTE: this endpoint may change when full account migration is implemented.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID to reserve a key for."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["signingKey"],
              properties: {
                signingKey: {
                  type: "string",
                  description: "The public key for the reserved signing key, in did:key serialization."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerResetPassword: {
      lexicon: 1,
      id: "com.atproto.server.resetPassword",
      defs: {
        main: {
          type: "procedure",
          description: "Reset a user account password using a token.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["token", "password"],
              properties: {
                token: {
                  type: "string"
                },
                password: {
                  type: "string"
                }
              }
            }
          },
          errors: [
            {
              name: "ExpiredToken"
            },
            {
              name: "InvalidToken"
            }
          ]
        }
      }
    },
    ComAtprotoServerRevokeAppPassword: {
      lexicon: 1,
      id: "com.atproto.server.revokeAppPassword",
      defs: {
        main: {
          type: "procedure",
          description: "Revoke an App Password by name.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["name"],
              properties: {
                name: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerUpdateEmail: {
      lexicon: 1,
      id: "com.atproto.server.updateEmail",
      defs: {
        main: {
          type: "procedure",
          description: "Update an account's email.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["email"],
              properties: {
                email: {
                  type: "string"
                },
                emailAuthFactor: {
                  type: "boolean"
                },
                token: {
                  type: "string",
                  description: "Requires a token from com.atproto.sever.requestEmailUpdate if the account's email has been confirmed."
                }
              }
            }
          },
          errors: [
            {
              name: "ExpiredToken"
            },
            {
              name: "InvalidToken"
            },
            {
              name: "TokenRequired"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetBlob: {
      lexicon: 1,
      id: "com.atproto.sync.getBlob",
      defs: {
        main: {
          type: "query",
          description: "Get a blob associated with a given account. Returns the full blob as originally uploaded. Does not require auth; implemented by PDS.",
          parameters: {
            type: "params",
            required: ["did", "cid"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the account."
              },
              cid: {
                type: "string",
                format: "cid",
                description: "The CID of the blob to fetch"
              }
            }
          },
          output: {
            encoding: "*/*"
          },
          errors: [
            {
              name: "BlobNotFound"
            },
            {
              name: "RepoNotFound"
            },
            {
              name: "RepoTakendown"
            },
            {
              name: "RepoSuspended"
            },
            {
              name: "RepoDeactivated"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetBlocks: {
      lexicon: 1,
      id: "com.atproto.sync.getBlocks",
      defs: {
        main: {
          type: "query",
          description: "Get data blocks from a given repo, by CID. For example, intermediate MST nodes, or records. Does not require auth; implemented by PDS.",
          parameters: {
            type: "params",
            required: ["did", "cids"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              },
              cids: {
                type: "array",
                items: {
                  type: "string",
                  format: "cid"
                }
              }
            }
          },
          output: {
            encoding: "application/vnd.ipld.car"
          },
          errors: [
            {
              name: "BlockNotFound"
            },
            {
              name: "RepoNotFound"
            },
            {
              name: "RepoTakendown"
            },
            {
              name: "RepoSuspended"
            },
            {
              name: "RepoDeactivated"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetCheckout: {
      lexicon: 1,
      id: "com.atproto.sync.getCheckout",
      defs: {
        main: {
          type: "query",
          description: "DEPRECATED - please use com.atproto.sync.getRepo instead",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              }
            }
          },
          output: {
            encoding: "application/vnd.ipld.car"
          }
        }
      }
    },
    ComAtprotoSyncGetHead: {
      lexicon: 1,
      id: "com.atproto.sync.getHead",
      defs: {
        main: {
          type: "query",
          description: "DEPRECATED - please use com.atproto.sync.getLatestCommit instead",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["root"],
              properties: {
                root: {
                  type: "string",
                  format: "cid"
                }
              }
            }
          },
          errors: [
            {
              name: "HeadNotFound"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetLatestCommit: {
      lexicon: 1,
      id: "com.atproto.sync.getLatestCommit",
      defs: {
        main: {
          type: "query",
          description: "Get the current commit CID & revision of the specified repo. Does not require auth.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["cid", "rev"],
              properties: {
                cid: {
                  type: "string",
                  format: "cid"
                },
                rev: {
                  type: "string"
                }
              }
            }
          },
          errors: [
            {
              name: "RepoNotFound"
            },
            {
              name: "RepoTakendown"
            },
            {
              name: "RepoSuspended"
            },
            {
              name: "RepoDeactivated"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetRecord: {
      lexicon: 1,
      id: "com.atproto.sync.getRecord",
      defs: {
        main: {
          type: "query",
          description: "Get data blocks needed to prove the existence or non-existence of record in the current version of repo. Does not require auth.",
          parameters: {
            type: "params",
            required: ["did", "collection", "rkey"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              },
              collection: {
                type: "string",
                format: "nsid"
              },
              rkey: {
                type: "string",
                description: "Record Key"
              },
              commit: {
                type: "string",
                format: "cid",
                description: "DEPRECATED: referenced a repo commit by CID, and retrieved record as of that commit"
              }
            }
          },
          output: {
            encoding: "application/vnd.ipld.car"
          },
          errors: [
            {
              name: "RecordNotFound"
            },
            {
              name: "RepoNotFound"
            },
            {
              name: "RepoTakendown"
            },
            {
              name: "RepoSuspended"
            },
            {
              name: "RepoDeactivated"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetRepo: {
      lexicon: 1,
      id: "com.atproto.sync.getRepo",
      defs: {
        main: {
          type: "query",
          description: "Download a repository export as CAR file. Optionally only a 'diff' since a previous revision. Does not require auth; implemented by PDS.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              },
              since: {
                type: "string",
                description: "The revision ('rev') of the repo to create a diff from."
              }
            }
          },
          output: {
            encoding: "application/vnd.ipld.car"
          },
          errors: [
            {
              name: "RepoNotFound"
            },
            {
              name: "RepoTakendown"
            },
            {
              name: "RepoSuspended"
            },
            {
              name: "RepoDeactivated"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetRepoStatus: {
      lexicon: 1,
      id: "com.atproto.sync.getRepoStatus",
      defs: {
        main: {
          type: "query",
          description: "Get the hosting status for a repository, on this server. Expected to be implemented by PDS and Relay.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "active"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                active: {
                  type: "boolean"
                },
                status: {
                  type: "string",
                  description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
                  knownValues: ["takendown", "suspended", "deactivated"]
                },
                rev: {
                  type: "string",
                  description: "Optional field, the current rev of the repo, if active=true"
                }
              }
            }
          },
          errors: [
            {
              name: "RepoNotFound"
            }
          ]
        }
      }
    },
    ComAtprotoSyncListBlobs: {
      lexicon: 1,
      id: "com.atproto.sync.listBlobs",
      defs: {
        main: {
          type: "query",
          description: "List blob CIDs for an account, since some repo revision. Does not require auth; implemented by PDS.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              },
              since: {
                type: "string",
                description: "Optional revision of the repo to list blobs since."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 1e3,
                default: 500
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["cids"],
              properties: {
                cursor: {
                  type: "string"
                },
                cids: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "cid"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "RepoNotFound"
            },
            {
              name: "RepoTakendown"
            },
            {
              name: "RepoSuspended"
            },
            {
              name: "RepoDeactivated"
            }
          ]
        }
      }
    },
    ComAtprotoSyncListRepos: {
      lexicon: 1,
      id: "com.atproto.sync.listRepos",
      defs: {
        main: {
          type: "query",
          description: "Enumerates all the DID, rev, and commit CID for all repos hosted by this service. Does not require auth; implemented by PDS and Relay.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 1e3,
                default: 500
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repos"],
              properties: {
                cursor: {
                  type: "string"
                },
                repos: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.sync.listRepos#repo"
                  }
                }
              }
            }
          }
        },
        repo: {
          type: "object",
          required: ["did", "head", "rev"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            head: {
              type: "string",
              format: "cid",
              description: "Current repo commit CID"
            },
            rev: {
              type: "string"
            },
            active: {
              type: "boolean"
            },
            status: {
              type: "string",
              description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
              knownValues: ["takendown", "suspended", "deactivated"]
            }
          }
        }
      }
    },
    ComAtprotoSyncNotifyOfUpdate: {
      lexicon: 1,
      id: "com.atproto.sync.notifyOfUpdate",
      defs: {
        main: {
          type: "procedure",
          description: "Notify a crawling service of a recent update, and that crawling should resume. Intended use is after a gap between repo stream events caused the crawling service to disconnect. Does not require auth; implemented by Relay.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["hostname"],
              properties: {
                hostname: {
                  type: "string",
                  description: "Hostname of the current service (usually a PDS) that is notifying of update."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoSyncRequestCrawl: {
      lexicon: 1,
      id: "com.atproto.sync.requestCrawl",
      defs: {
        main: {
          type: "procedure",
          description: "Request a service to persistently crawl hosted repos. Expected use is new PDS instances declaring their existence to Relays. Does not require auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["hostname"],
              properties: {
                hostname: {
                  type: "string",
                  description: "Hostname of the current service (eg, PDS) that is requesting to be crawled."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoSyncSubscribeRepos: {
      lexicon: 1,
      id: "com.atproto.sync.subscribeRepos",
      defs: {
        main: {
          type: "subscription",
          description: "Repository event stream, aka Firehose endpoint. Outputs repo commits with diff data, and identity update events, for all repositories on the current server. See the atproto specifications for details around stream sequencing, repo versioning, CAR diff format, and more. Public and does not require auth; implemented by PDS and Relay.",
          parameters: {
            type: "params",
            properties: {
              cursor: {
                type: "integer",
                description: "The last known event seq number to backfill from."
              }
            }
          },
          message: {
            schema: {
              type: "union",
              refs: [
                "lex:com.atproto.sync.subscribeRepos#commit",
                "lex:com.atproto.sync.subscribeRepos#identity",
                "lex:com.atproto.sync.subscribeRepos#account",
                "lex:com.atproto.sync.subscribeRepos#handle",
                "lex:com.atproto.sync.subscribeRepos#migrate",
                "lex:com.atproto.sync.subscribeRepos#tombstone",
                "lex:com.atproto.sync.subscribeRepos#info"
              ]
            }
          },
          errors: [
            {
              name: "FutureCursor"
            },
            {
              name: "ConsumerTooSlow",
              description: "If the consumer of the stream can not keep up with events, and a backlog gets too large, the server will drop the connection."
            }
          ]
        },
        commit: {
          type: "object",
          description: "Represents an update of repository state. Note that empty commits are allowed, which include no repo data changes, but an update to rev and signature.",
          required: [
            "seq",
            "rebase",
            "tooBig",
            "repo",
            "commit",
            "rev",
            "since",
            "blocks",
            "ops",
            "blobs",
            "time"
          ],
          nullable: ["prev", "since"],
          properties: {
            seq: {
              type: "integer",
              description: "The stream sequence number of this message."
            },
            rebase: {
              type: "boolean",
              description: "DEPRECATED -- unused"
            },
            tooBig: {
              type: "boolean",
              description: "Indicates that this commit contained too many ops, or data size was too large. Consumers will need to make a separate request to get missing data."
            },
            repo: {
              type: "string",
              format: "did",
              description: "The repo this event comes from."
            },
            commit: {
              type: "cid-link",
              description: "Repo commit object CID."
            },
            prev: {
              type: "cid-link",
              description: "DEPRECATED -- unused. WARNING -- nullable and optional; stick with optional to ensure golang interoperability."
            },
            rev: {
              type: "string",
              description: "The rev of the emitted commit. Note that this information is also in the commit object included in blocks, unless this is a tooBig event."
            },
            since: {
              type: "string",
              description: "The rev of the last emitted commit from this repo (if any)."
            },
            blocks: {
              type: "bytes",
              description: "CAR file containing relevant blocks, as a diff since the previous repo state.",
              maxLength: 1e6
            },
            ops: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.sync.subscribeRepos#repoOp",
                description: "List of repo mutation operations in this commit (eg, records created, updated, or deleted)."
              },
              maxLength: 200
            },
            blobs: {
              type: "array",
              items: {
                type: "cid-link",
                description: "List of new blobs (by CID) referenced by records in this commit."
              }
            },
            time: {
              type: "string",
              format: "datetime",
              description: "Timestamp of when this message was originally broadcast."
            }
          }
        },
        identity: {
          type: "object",
          description: "Represents a change to an account's identity. Could be an updated handle, signing key, or pds hosting endpoint. Serves as a prod to all downstream services to refresh their identity cache.",
          required: ["seq", "did", "time"],
          properties: {
            seq: {
              type: "integer"
            },
            did: {
              type: "string",
              format: "did"
            },
            time: {
              type: "string",
              format: "datetime"
            },
            handle: {
              type: "string",
              format: "handle",
              description: "The current handle for the account, or 'handle.invalid' if validation fails. This field is optional, might have been validated or passed-through from an upstream source. Semantics and behaviors for PDS vs Relay may evolve in the future; see atproto specs for more details."
            }
          }
        },
        account: {
          type: "object",
          description: "Represents a change to an account's status on a host (eg, PDS or Relay). The semantics of this event are that the status is at the host which emitted the event, not necessarily that at the currently active PDS. Eg, a Relay takedown would emit a takedown with active=false, even if the PDS is still active.",
          required: ["seq", "did", "time", "active"],
          properties: {
            seq: {
              type: "integer"
            },
            did: {
              type: "string",
              format: "did"
            },
            time: {
              type: "string",
              format: "datetime"
            },
            active: {
              type: "boolean",
              description: "Indicates that the account has a repository which can be fetched from the host that emitted this event."
            },
            status: {
              type: "string",
              description: "If active=false, this optional field indicates a reason for why the account is not active.",
              knownValues: ["takendown", "suspended", "deleted", "deactivated"]
            }
          }
        },
        handle: {
          type: "object",
          description: "DEPRECATED -- Use #identity event instead",
          required: ["seq", "did", "handle", "time"],
          properties: {
            seq: {
              type: "integer"
            },
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            time: {
              type: "string",
              format: "datetime"
            }
          }
        },
        migrate: {
          type: "object",
          description: "DEPRECATED -- Use #account event instead",
          required: ["seq", "did", "migrateTo", "time"],
          nullable: ["migrateTo"],
          properties: {
            seq: {
              type: "integer"
            },
            did: {
              type: "string",
              format: "did"
            },
            migrateTo: {
              type: "string"
            },
            time: {
              type: "string",
              format: "datetime"
            }
          }
        },
        tombstone: {
          type: "object",
          description: "DEPRECATED -- Use #account event instead",
          required: ["seq", "did", "time"],
          properties: {
            seq: {
              type: "integer"
            },
            did: {
              type: "string",
              format: "did"
            },
            time: {
              type: "string",
              format: "datetime"
            }
          }
        },
        info: {
          type: "object",
          required: ["name"],
          properties: {
            name: {
              type: "string",
              knownValues: ["OutdatedCursor"]
            },
            message: {
              type: "string"
            }
          }
        },
        repoOp: {
          type: "object",
          description: "A repo operation, ie a mutation of a single record.",
          required: ["action", "path", "cid"],
          nullable: ["cid"],
          properties: {
            action: {
              type: "string",
              knownValues: ["create", "update", "delete"]
            },
            path: {
              type: "string"
            },
            cid: {
              type: "cid-link",
              description: "For creates and updates, the new record CID. For deletions, null."
            }
          }
        }
      }
    },
    ComAtprotoTempCheckSignupQueue: {
      lexicon: 1,
      id: "com.atproto.temp.checkSignupQueue",
      defs: {
        main: {
          type: "query",
          description: "Check accounts location in signup queue.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["activated"],
              properties: {
                activated: {
                  type: "boolean"
                },
                placeInQueue: {
                  type: "integer"
                },
                estimatedTimeMs: {
                  type: "integer"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoTempFetchLabels: {
      lexicon: 1,
      id: "com.atproto.temp.fetchLabels",
      defs: {
        main: {
          type: "query",
          description: "DEPRECATED: use queryLabels or subscribeLabels instead -- Fetch all labels from a labeler created after a certain date.",
          parameters: {
            type: "params",
            properties: {
              since: {
                type: "integer"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 250,
                default: 50
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["labels"],
              properties: {
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoTempRequestPhoneVerification: {
      lexicon: 1,
      id: "com.atproto.temp.requestPhoneVerification",
      defs: {
        main: {
          type: "procedure",
          description: "Request a verification code to be sent to the supplied phone number",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["phoneNumber"],
              properties: {
                phoneNumber: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorDefs: {
      lexicon: 1,
      id: "app.bsky.actor.defs",
      defs: {
        profileViewBasic: {
          type: "object",
          required: ["did", "handle"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            displayName: {
              type: "string",
              maxGraphemes: 64,
              maxLength: 640
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            associated: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileAssociated"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#viewerState"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            createdAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        profileView: {
          type: "object",
          required: ["did", "handle"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            displayName: {
              type: "string",
              maxGraphemes: 64,
              maxLength: 640
            },
            description: {
              type: "string",
              maxGraphemes: 256,
              maxLength: 2560
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            associated: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileAssociated"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#viewerState"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        profileViewDetailed: {
          type: "object",
          required: ["did", "handle"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            displayName: {
              type: "string",
              maxGraphemes: 64,
              maxLength: 640
            },
            description: {
              type: "string",
              maxGraphemes: 256,
              maxLength: 2560
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            banner: {
              type: "string",
              format: "uri"
            },
            followersCount: {
              type: "integer"
            },
            followsCount: {
              type: "integer"
            },
            postsCount: {
              type: "integer"
            },
            associated: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileAssociated"
            },
            joinedViaStarterPack: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#starterPackViewBasic"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#viewerState"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        profileAssociated: {
          type: "object",
          properties: {
            lists: {
              type: "integer"
            },
            feedgens: {
              type: "integer"
            },
            starterPacks: {
              type: "integer"
            },
            labeler: {
              type: "boolean"
            },
            chat: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileAssociatedChat"
            }
          }
        },
        profileAssociatedChat: {
          type: "object",
          required: ["allowIncoming"],
          properties: {
            allowIncoming: {
              type: "string",
              knownValues: ["all", "none", "following"]
            }
          }
        },
        viewerState: {
          type: "object",
          description: "Metadata about the requesting account's relationship with the subject account. Only has meaningful content for authed requests.",
          properties: {
            muted: {
              type: "boolean"
            },
            mutedByList: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listViewBasic"
            },
            blockedBy: {
              type: "boolean"
            },
            blocking: {
              type: "string",
              format: "at-uri"
            },
            blockingByList: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listViewBasic"
            },
            following: {
              type: "string",
              format: "at-uri"
            },
            followedBy: {
              type: "string",
              format: "at-uri"
            },
            knownFollowers: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#knownFollowers"
            }
          }
        },
        knownFollowers: {
          type: "object",
          description: "The subject's followers whom you also follow",
          required: ["count", "followers"],
          properties: {
            count: {
              type: "integer"
            },
            followers: {
              type: "array",
              minLength: 0,
              maxLength: 5,
              items: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#profileViewBasic"
              }
            }
          }
        },
        preferences: {
          type: "array",
          items: {
            type: "union",
            refs: [
              "lex:app.bsky.actor.defs#adultContentPref",
              "lex:app.bsky.actor.defs#contentLabelPref",
              "lex:app.bsky.actor.defs#savedFeedsPref",
              "lex:app.bsky.actor.defs#savedFeedsPrefV2",
              "lex:app.bsky.actor.defs#personalDetailsPref",
              "lex:app.bsky.actor.defs#feedViewPref",
              "lex:app.bsky.actor.defs#threadViewPref",
              "lex:app.bsky.actor.defs#interestsPref",
              "lex:app.bsky.actor.defs#mutedWordsPref",
              "lex:app.bsky.actor.defs#hiddenPostsPref",
              "lex:app.bsky.actor.defs#bskyAppStatePref",
              "lex:app.bsky.actor.defs#labelersPref"
            ]
          }
        },
        adultContentPref: {
          type: "object",
          required: ["enabled"],
          properties: {
            enabled: {
              type: "boolean",
              default: !1
            }
          }
        },
        contentLabelPref: {
          type: "object",
          required: ["label", "visibility"],
          properties: {
            labelerDid: {
              type: "string",
              description: "Which labeler does this preference apply to? If undefined, applies globally.",
              format: "did"
            },
            label: {
              type: "string"
            },
            visibility: {
              type: "string",
              knownValues: ["ignore", "show", "warn", "hide"]
            }
          }
        },
        savedFeed: {
          type: "object",
          required: ["id", "type", "value", "pinned"],
          properties: {
            id: {
              type: "string"
            },
            type: {
              type: "string",
              knownValues: ["feed", "list", "timeline"]
            },
            value: {
              type: "string"
            },
            pinned: {
              type: "boolean"
            }
          }
        },
        savedFeedsPrefV2: {
          type: "object",
          required: ["items"],
          properties: {
            items: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#savedFeed"
              }
            }
          }
        },
        savedFeedsPref: {
          type: "object",
          required: ["pinned", "saved"],
          properties: {
            pinned: {
              type: "array",
              items: {
                type: "string",
                format: "at-uri"
              }
            },
            saved: {
              type: "array",
              items: {
                type: "string",
                format: "at-uri"
              }
            },
            timelineIndex: {
              type: "integer"
            }
          }
        },
        personalDetailsPref: {
          type: "object",
          properties: {
            birthDate: {
              type: "string",
              format: "datetime",
              description: "The birth date of account owner."
            }
          }
        },
        feedViewPref: {
          type: "object",
          required: ["feed"],
          properties: {
            feed: {
              type: "string",
              description: "The URI of the feed, or an identifier which describes the feed."
            },
            hideReplies: {
              type: "boolean",
              description: "Hide replies in the feed."
            },
            hideRepliesByUnfollowed: {
              type: "boolean",
              description: "Hide replies in the feed if they are not by followed users.",
              default: !0
            },
            hideRepliesByLikeCount: {
              type: "integer",
              description: "Hide replies in the feed if they do not have this number of likes."
            },
            hideReposts: {
              type: "boolean",
              description: "Hide reposts in the feed."
            },
            hideQuotePosts: {
              type: "boolean",
              description: "Hide quote posts in the feed."
            }
          }
        },
        threadViewPref: {
          type: "object",
          properties: {
            sort: {
              type: "string",
              description: "Sorting mode for threads.",
              knownValues: ["oldest", "newest", "most-likes", "random"]
            },
            prioritizeFollowedUsers: {
              type: "boolean",
              description: "Show followed users at the top of all replies."
            }
          }
        },
        interestsPref: {
          type: "object",
          required: ["tags"],
          properties: {
            tags: {
              type: "array",
              maxLength: 100,
              items: {
                type: "string",
                maxLength: 640,
                maxGraphemes: 64
              },
              description: "A list of tags which describe the account owner's interests gathered during onboarding."
            }
          }
        },
        mutedWordTarget: {
          type: "string",
          knownValues: ["content", "tag"],
          maxLength: 640,
          maxGraphemes: 64
        },
        mutedWord: {
          type: "object",
          description: "A word that the account owner has muted.",
          required: ["value", "targets"],
          properties: {
            id: {
              type: "string"
            },
            value: {
              type: "string",
              description: "The muted word itself.",
              maxLength: 1e4,
              maxGraphemes: 1e3
            },
            targets: {
              type: "array",
              description: "The intended targets of the muted word.",
              items: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#mutedWordTarget"
              }
            },
            actorTarget: {
              type: "string",
              description: "Groups of users to apply the muted word to. If undefined, applies to all users.",
              knownValues: ["all", "exclude-following"],
              default: "all"
            },
            expiresAt: {
              type: "string",
              format: "datetime",
              description: "The date and time at which the muted word will expire and no longer be applied."
            }
          }
        },
        mutedWordsPref: {
          type: "object",
          required: ["items"],
          properties: {
            items: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#mutedWord"
              },
              description: "A list of words the account owner has muted."
            }
          }
        },
        hiddenPostsPref: {
          type: "object",
          required: ["items"],
          properties: {
            items: {
              type: "array",
              items: {
                type: "string",
                format: "at-uri"
              },
              description: "A list of URIs of posts the account owner has hidden."
            }
          }
        },
        labelersPref: {
          type: "object",
          required: ["labelers"],
          properties: {
            labelers: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#labelerPrefItem"
              }
            }
          }
        },
        labelerPrefItem: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        },
        bskyAppStatePref: {
          description: "A grab bag of state that's specific to the bsky.app program. Third-party apps shouldn't use this.",
          type: "object",
          properties: {
            activeProgressGuide: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#bskyAppProgressGuide"
            },
            queuedNudges: {
              description: "An array of tokens which identify nudges (modals, popups, tours, highlight dots) that should be shown to the user.",
              type: "array",
              maxLength: 1e3,
              items: {
                type: "string",
                maxLength: 100
              }
            }
          }
        },
        bskyAppProgressGuide: {
          description: "If set, an active progress guide. Once completed, can be set to undefined. Should have unspecced fields tracking progress.",
          type: "object",
          required: ["guide"],
          properties: {
            guide: {
              type: "string",
              maxLength: 100
            }
          }
        }
      }
    },
    AppBskyActorGetPreferences: {
      lexicon: 1,
      id: "app.bsky.actor.getPreferences",
      defs: {
        main: {
          type: "query",
          description: "Get private preferences attached to the current account. Expected use is synchronization between multiple devices, and import/export during account migration. Requires auth.",
          parameters: {
            type: "params",
            properties: {}
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["preferences"],
              properties: {
                preferences: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#preferences"
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorGetProfile: {
      lexicon: 1,
      id: "app.bsky.actor.getProfile",
      defs: {
        main: {
          type: "query",
          description: "Get detailed profile view of an actor. Does not require auth, but contains relevant metadata with auth.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier",
                description: "Handle or DID of account to fetch profile of."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewDetailed"
            }
          }
        }
      }
    },
    AppBskyActorGetProfiles: {
      lexicon: 1,
      id: "app.bsky.actor.getProfiles",
      defs: {
        main: {
          type: "query",
          description: "Get detailed profile views of multiple actors.",
          parameters: {
            type: "params",
            required: ["actors"],
            properties: {
              actors: {
                type: "array",
                items: {
                  type: "string",
                  format: "at-identifier"
                },
                maxLength: 25
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["profiles"],
              properties: {
                profiles: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileViewDetailed"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorGetSuggestions: {
      lexicon: 1,
      id: "app.bsky.actor.getSuggestions",
      defs: {
        main: {
          type: "query",
          description: "Get a list of suggested actors. Expected use is discovery of accounts to follow during new account onboarding.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actors"],
              properties: {
                cursor: {
                  type: "string"
                },
                actors: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorProfile: {
      lexicon: 1,
      id: "app.bsky.actor.profile",
      defs: {
        main: {
          type: "record",
          description: "A declaration of a Bluesky account profile.",
          key: "literal:self",
          record: {
            type: "object",
            properties: {
              displayName: {
                type: "string",
                maxGraphemes: 64,
                maxLength: 640
              },
              description: {
                type: "string",
                description: "Free-form profile description text.",
                maxGraphemes: 256,
                maxLength: 2560
              },
              avatar: {
                type: "blob",
                description: "Small image to be displayed next to posts from account. AKA, 'profile picture'",
                accept: ["image/png", "image/jpeg"],
                maxSize: 1e6
              },
              banner: {
                type: "blob",
                description: "Larger horizontal image to display behind profile view.",
                accept: ["image/png", "image/jpeg"],
                maxSize: 1e6
              },
              labels: {
                type: "union",
                description: "Self-label values, specific to the Bluesky application, on the overall account.",
                refs: ["lex:com.atproto.label.defs#selfLabels"]
              },
              joinedViaStarterPack: {
                type: "ref",
                ref: "lex:com.atproto.repo.strongRef"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyActorPutPreferences: {
      lexicon: 1,
      id: "app.bsky.actor.putPreferences",
      defs: {
        main: {
          type: "procedure",
          description: "Set the private preferences attached to the account.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["preferences"],
              properties: {
                preferences: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#preferences"
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorSearchActors: {
      lexicon: 1,
      id: "app.bsky.actor.searchActors",
      defs: {
        main: {
          type: "query",
          description: "Find actors (profiles) matching search criteria. Does not require auth.",
          parameters: {
            type: "params",
            properties: {
              term: {
                type: "string",
                description: "DEPRECATED: use 'q' instead."
              },
              q: {
                type: "string",
                description: "Search query string. Syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 25
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actors"],
              properties: {
                cursor: {
                  type: "string"
                },
                actors: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorSearchActorsTypeahead: {
      lexicon: 1,
      id: "app.bsky.actor.searchActorsTypeahead",
      defs: {
        main: {
          type: "query",
          description: "Find actor suggestions for a prefix search term. Expected use is for auto-completion during text field entry. Does not require auth.",
          parameters: {
            type: "params",
            properties: {
              term: {
                type: "string",
                description: "DEPRECATED: use 'q' instead."
              },
              q: {
                type: "string",
                description: "Search query prefix; not a full query string."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 10
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actors"],
              properties: {
                actors: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileViewBasic"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyEmbedExternal: {
      lexicon: 1,
      id: "app.bsky.embed.external",
      defs: {
        main: {
          type: "object",
          description: "A representation of some externally linked content (eg, a URL and 'card'), embedded in a Bluesky record (eg, a post).",
          required: ["external"],
          properties: {
            external: {
              type: "ref",
              ref: "lex:app.bsky.embed.external#external"
            }
          }
        },
        external: {
          type: "object",
          required: ["uri", "title", "description"],
          properties: {
            uri: {
              type: "string",
              format: "uri"
            },
            title: {
              type: "string"
            },
            description: {
              type: "string"
            },
            thumb: {
              type: "blob",
              accept: ["image/*"],
              maxSize: 1e6
            }
          }
        },
        view: {
          type: "object",
          required: ["external"],
          properties: {
            external: {
              type: "ref",
              ref: "lex:app.bsky.embed.external#viewExternal"
            }
          }
        },
        viewExternal: {
          type: "object",
          required: ["uri", "title", "description"],
          properties: {
            uri: {
              type: "string",
              format: "uri"
            },
            title: {
              type: "string"
            },
            description: {
              type: "string"
            },
            thumb: {
              type: "string",
              format: "uri"
            }
          }
        }
      }
    },
    AppBskyEmbedImages: {
      lexicon: 1,
      id: "app.bsky.embed.images",
      description: "A set of images embedded in a Bluesky record (eg, a post).",
      defs: {
        main: {
          type: "object",
          required: ["images"],
          properties: {
            images: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.embed.images#image"
              },
              maxLength: 4
            }
          }
        },
        image: {
          type: "object",
          required: ["image", "alt"],
          properties: {
            image: {
              type: "blob",
              accept: ["image/*"],
              maxSize: 1e6
            },
            alt: {
              type: "string",
              description: "Alt text description of the image, for accessibility."
            },
            aspectRatio: {
              type: "ref",
              ref: "lex:app.bsky.embed.images#aspectRatio"
            }
          }
        },
        aspectRatio: {
          type: "object",
          description: "width:height represents an aspect ratio. It may be approximate, and may not correspond to absolute dimensions in any given unit.",
          required: ["width", "height"],
          properties: {
            width: {
              type: "integer",
              minimum: 1
            },
            height: {
              type: "integer",
              minimum: 1
            }
          }
        },
        view: {
          type: "object",
          required: ["images"],
          properties: {
            images: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.embed.images#viewImage"
              },
              maxLength: 4
            }
          }
        },
        viewImage: {
          type: "object",
          required: ["thumb", "fullsize", "alt"],
          properties: {
            thumb: {
              type: "string",
              format: "uri",
              description: "Fully-qualified URL where a thumbnail of the image can be fetched. For example, CDN location provided by the App View."
            },
            fullsize: {
              type: "string",
              format: "uri",
              description: "Fully-qualified URL where a large version of the image can be fetched. May or may not be the exact original blob. For example, CDN location provided by the App View."
            },
            alt: {
              type: "string",
              description: "Alt text description of the image, for accessibility."
            },
            aspectRatio: {
              type: "ref",
              ref: "lex:app.bsky.embed.images#aspectRatio"
            }
          }
        }
      }
    },
    AppBskyEmbedRecord: {
      lexicon: 1,
      id: "app.bsky.embed.record",
      description: "A representation of a record embedded in a Bluesky record (eg, a post). For example, a quote-post, or sharing a feed generator record.",
      defs: {
        main: {
          type: "object",
          required: ["record"],
          properties: {
            record: {
              type: "ref",
              ref: "lex:com.atproto.repo.strongRef"
            }
          }
        },
        view: {
          type: "object",
          required: ["record"],
          properties: {
            record: {
              type: "union",
              refs: [
                "lex:app.bsky.embed.record#viewRecord",
                "lex:app.bsky.embed.record#viewNotFound",
                "lex:app.bsky.embed.record#viewBlocked",
                "lex:app.bsky.feed.defs#generatorView",
                "lex:app.bsky.graph.defs#listView",
                "lex:app.bsky.labeler.defs#labelerView",
                "lex:app.bsky.graph.defs#starterPackViewBasic"
              ]
            }
          }
        },
        viewRecord: {
          type: "object",
          required: ["uri", "cid", "author", "value", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            author: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic"
            },
            value: {
              type: "unknown",
              description: "The record data itself."
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            replyCount: {
              type: "integer"
            },
            repostCount: {
              type: "integer"
            },
            likeCount: {
              type: "integer"
            },
            embeds: {
              type: "array",
              items: {
                type: "union",
                refs: [
                  "lex:app.bsky.embed.images#view",
                  "lex:app.bsky.embed.external#view",
                  "lex:app.bsky.embed.record#view",
                  "lex:app.bsky.embed.recordWithMedia#view"
                ]
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        viewNotFound: {
          type: "object",
          required: ["uri", "notFound"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            notFound: {
              type: "boolean",
              const: !0
            }
          }
        },
        viewBlocked: {
          type: "object",
          required: ["uri", "blocked", "author"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            blocked: {
              type: "boolean",
              const: !0
            },
            author: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#blockedAuthor"
            }
          }
        }
      }
    },
    AppBskyEmbedRecordWithMedia: {
      lexicon: 1,
      id: "app.bsky.embed.recordWithMedia",
      description: "A representation of a record embedded in a Bluesky record (eg, a post), alongside other compatible embeds. For example, a quote post and image, or a quote post and external URL card.",
      defs: {
        main: {
          type: "object",
          required: ["record", "media"],
          properties: {
            record: {
              type: "ref",
              ref: "lex:app.bsky.embed.record"
            },
            media: {
              type: "union",
              refs: ["lex:app.bsky.embed.images", "lex:app.bsky.embed.external"]
            }
          }
        },
        view: {
          type: "object",
          required: ["record", "media"],
          properties: {
            record: {
              type: "ref",
              ref: "lex:app.bsky.embed.record#view"
            },
            media: {
              type: "union",
              refs: [
                "lex:app.bsky.embed.images#view",
                "lex:app.bsky.embed.external#view"
              ]
            }
          }
        }
      }
    },
    AppBskyFeedDefs: {
      lexicon: 1,
      id: "app.bsky.feed.defs",
      defs: {
        postView: {
          type: "object",
          required: ["uri", "cid", "author", "record", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            author: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic"
            },
            record: {
              type: "unknown"
            },
            embed: {
              type: "union",
              refs: [
                "lex:app.bsky.embed.images#view",
                "lex:app.bsky.embed.external#view",
                "lex:app.bsky.embed.record#view",
                "lex:app.bsky.embed.recordWithMedia#view"
              ]
            },
            replyCount: {
              type: "integer"
            },
            repostCount: {
              type: "integer"
            },
            likeCount: {
              type: "integer"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#viewerState"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            threadgate: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#threadgateView"
            }
          }
        },
        viewerState: {
          type: "object",
          description: "Metadata about the requesting account's relationship with the subject content. Only has meaningful content for authed requests.",
          properties: {
            repost: {
              type: "string",
              format: "at-uri"
            },
            like: {
              type: "string",
              format: "at-uri"
            },
            threadMuted: {
              type: "boolean"
            },
            replyDisabled: {
              type: "boolean"
            }
          }
        },
        feedViewPost: {
          type: "object",
          required: ["post"],
          properties: {
            post: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#postView"
            },
            reply: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#replyRef"
            },
            reason: {
              type: "union",
              refs: ["lex:app.bsky.feed.defs#reasonRepost"]
            },
            feedContext: {
              type: "string",
              description: "Context provided by feed generator that may be passed back alongside interactions.",
              maxLength: 2e3
            }
          }
        },
        replyRef: {
          type: "object",
          required: ["root", "parent"],
          properties: {
            root: {
              type: "union",
              refs: [
                "lex:app.bsky.feed.defs#postView",
                "lex:app.bsky.feed.defs#notFoundPost",
                "lex:app.bsky.feed.defs#blockedPost"
              ]
            },
            parent: {
              type: "union",
              refs: [
                "lex:app.bsky.feed.defs#postView",
                "lex:app.bsky.feed.defs#notFoundPost",
                "lex:app.bsky.feed.defs#blockedPost"
              ]
            },
            grandparentAuthor: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic",
              description: "When parent is a reply to another post, this is the author of that post."
            }
          }
        },
        reasonRepost: {
          type: "object",
          required: ["by", "indexedAt"],
          properties: {
            by: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        threadViewPost: {
          type: "object",
          required: ["post"],
          properties: {
            post: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#postView"
            },
            parent: {
              type: "union",
              refs: [
                "lex:app.bsky.feed.defs#threadViewPost",
                "lex:app.bsky.feed.defs#notFoundPost",
                "lex:app.bsky.feed.defs#blockedPost"
              ]
            },
            replies: {
              type: "array",
              items: {
                type: "union",
                refs: [
                  "lex:app.bsky.feed.defs#threadViewPost",
                  "lex:app.bsky.feed.defs#notFoundPost",
                  "lex:app.bsky.feed.defs#blockedPost"
                ]
              }
            }
          }
        },
        notFoundPost: {
          type: "object",
          required: ["uri", "notFound"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            notFound: {
              type: "boolean",
              const: !0
            }
          }
        },
        blockedPost: {
          type: "object",
          required: ["uri", "blocked", "author"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            blocked: {
              type: "boolean",
              const: !0
            },
            author: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#blockedAuthor"
            }
          }
        },
        blockedAuthor: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#viewerState"
            }
          }
        },
        generatorView: {
          type: "object",
          required: ["uri", "cid", "did", "creator", "displayName", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            did: {
              type: "string",
              format: "did"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            },
            displayName: {
              type: "string"
            },
            description: {
              type: "string",
              maxGraphemes: 300,
              maxLength: 3e3
            },
            descriptionFacets: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.richtext.facet"
              }
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            likeCount: {
              type: "integer",
              minimum: 0
            },
            acceptsInteractions: {
              type: "boolean"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#generatorViewerState"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        generatorViewerState: {
          type: "object",
          properties: {
            like: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        skeletonFeedPost: {
          type: "object",
          required: ["post"],
          properties: {
            post: {
              type: "string",
              format: "at-uri"
            },
            reason: {
              type: "union",
              refs: ["lex:app.bsky.feed.defs#skeletonReasonRepost"]
            },
            feedContext: {
              type: "string",
              description: "Context that will be passed through to client and may be passed to feed generator back alongside interactions.",
              maxLength: 2e3
            }
          }
        },
        skeletonReasonRepost: {
          type: "object",
          required: ["repost"],
          properties: {
            repost: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        threadgateView: {
          type: "object",
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            record: {
              type: "unknown"
            },
            lists: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.graph.defs#listViewBasic"
              }
            }
          }
        },
        interaction: {
          type: "object",
          properties: {
            item: {
              type: "string",
              format: "at-uri"
            },
            event: {
              type: "string",
              knownValues: [
                "app.bsky.feed.defs#requestLess",
                "app.bsky.feed.defs#requestMore",
                "app.bsky.feed.defs#clickthroughItem",
                "app.bsky.feed.defs#clickthroughAuthor",
                "app.bsky.feed.defs#clickthroughReposter",
                "app.bsky.feed.defs#clickthroughEmbed",
                "app.bsky.feed.defs#interactionSeen",
                "app.bsky.feed.defs#interactionLike",
                "app.bsky.feed.defs#interactionRepost",
                "app.bsky.feed.defs#interactionReply",
                "app.bsky.feed.defs#interactionQuote",
                "app.bsky.feed.defs#interactionShare"
              ]
            },
            feedContext: {
              type: "string",
              description: "Context on a feed item that was originally supplied by the feed generator on getFeedSkeleton.",
              maxLength: 2e3
            }
          }
        },
        requestLess: {
          type: "token",
          description: "Request that less content like the given feed item be shown in the feed"
        },
        requestMore: {
          type: "token",
          description: "Request that more content like the given feed item be shown in the feed"
        },
        clickthroughItem: {
          type: "token",
          description: "User clicked through to the feed item"
        },
        clickthroughAuthor: {
          type: "token",
          description: "User clicked through to the author of the feed item"
        },
        clickthroughReposter: {
          type: "token",
          description: "User clicked through to the reposter of the feed item"
        },
        clickthroughEmbed: {
          type: "token",
          description: "User clicked through to the embedded content of the feed item"
        },
        interactionSeen: {
          type: "token",
          description: "Feed item was seen by user"
        },
        interactionLike: {
          type: "token",
          description: "User liked the feed item"
        },
        interactionRepost: {
          type: "token",
          description: "User reposted the feed item"
        },
        interactionReply: {
          type: "token",
          description: "User replied to the feed item"
        },
        interactionQuote: {
          type: "token",
          description: "User quoted the feed item"
        },
        interactionShare: {
          type: "token",
          description: "User shared the feed item"
        }
      }
    },
    AppBskyFeedDescribeFeedGenerator: {
      lexicon: 1,
      id: "app.bsky.feed.describeFeedGenerator",
      defs: {
        main: {
          type: "query",
          description: "Get information about a feed generator, including policies and offered feed URIs. Does not require auth; implemented by Feed Generator services (not App View).",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "feeds"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                feeds: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.describeFeedGenerator#feed"
                  }
                },
                links: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.describeFeedGenerator#links"
                }
              }
            }
          }
        },
        feed: {
          type: "object",
          required: ["uri"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        links: {
          type: "object",
          properties: {
            privacyPolicy: {
              type: "string"
            },
            termsOfService: {
              type: "string"
            }
          }
        }
      }
    },
    AppBskyFeedGenerator: {
      lexicon: 1,
      id: "app.bsky.feed.generator",
      defs: {
        main: {
          type: "record",
          description: "Record declaring of the existence of a feed generator, and containing metadata about it. The record can exist in any repository.",
          key: "any",
          record: {
            type: "object",
            required: ["did", "displayName", "createdAt"],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              displayName: {
                type: "string",
                maxGraphemes: 24,
                maxLength: 240
              },
              description: {
                type: "string",
                maxGraphemes: 300,
                maxLength: 3e3
              },
              descriptionFacets: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet"
                }
              },
              avatar: {
                type: "blob",
                accept: ["image/png", "image/jpeg"],
                maxSize: 1e6
              },
              acceptsInteractions: {
                type: "boolean",
                description: "Declaration that a feed accepts feedback interactions from a client through app.bsky.feed.sendInteractions"
              },
              labels: {
                type: "union",
                description: "Self-label values",
                refs: ["lex:com.atproto.label.defs#selfLabels"]
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetActorFeeds: {
      lexicon: 1,
      id: "app.bsky.feed.getActorFeeds",
      defs: {
        main: {
          type: "query",
          description: "Get a list of feeds (feed generator records) created by the actor (in the actor's repo).",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feeds"],
              properties: {
                cursor: {
                  type: "string"
                },
                feeds: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#generatorView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetActorLikes: {
      lexicon: 1,
      id: "app.bsky.feed.getActorLikes",
      defs: {
        main: {
          type: "query",
          description: "Get a list of posts liked by an actor. Does not require auth.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#feedViewPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "BlockedActor"
            },
            {
              name: "BlockedByActor"
            }
          ]
        }
      }
    },
    AppBskyFeedGetAuthorFeed: {
      lexicon: 1,
      id: "app.bsky.feed.getAuthorFeed",
      defs: {
        main: {
          type: "query",
          description: "Get a view of an actor's 'author feed' (post and reposts by the author). Does not require auth.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              },
              filter: {
                type: "string",
                description: "Combinations of post/repost types to include in response.",
                knownValues: [
                  "posts_with_replies",
                  "posts_no_replies",
                  "posts_with_media",
                  "posts_and_author_threads"
                ],
                default: "posts_with_replies"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#feedViewPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "BlockedActor"
            },
            {
              name: "BlockedByActor"
            }
          ]
        }
      }
    },
    AppBskyFeedGetFeed: {
      lexicon: 1,
      id: "app.bsky.feed.getFeed",
      defs: {
        main: {
          type: "query",
          description: "Get a hydrated feed from an actor's selected feed generator. Implemented by App View.",
          parameters: {
            type: "params",
            required: ["feed"],
            properties: {
              feed: {
                type: "string",
                format: "at-uri"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#feedViewPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "UnknownFeed"
            }
          ]
        }
      }
    },
    AppBskyFeedGetFeedGenerator: {
      lexicon: 1,
      id: "app.bsky.feed.getFeedGenerator",
      defs: {
        main: {
          type: "query",
          description: "Get information about a feed generator. Implemented by AppView.",
          parameters: {
            type: "params",
            required: ["feed"],
            properties: {
              feed: {
                type: "string",
                format: "at-uri",
                description: "AT-URI of the feed generator record."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["view", "isOnline", "isValid"],
              properties: {
                view: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#generatorView"
                },
                isOnline: {
                  type: "boolean",
                  description: "Indicates whether the feed generator service has been online recently, or else seems to be inactive."
                },
                isValid: {
                  type: "boolean",
                  description: "Indicates whether the feed generator service is compatible with the record declaration."
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetFeedGenerators: {
      lexicon: 1,
      id: "app.bsky.feed.getFeedGenerators",
      defs: {
        main: {
          type: "query",
          description: "Get information about a list of feed generators.",
          parameters: {
            type: "params",
            required: ["feeds"],
            properties: {
              feeds: {
                type: "array",
                items: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feeds"],
              properties: {
                feeds: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#generatorView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetFeedSkeleton: {
      lexicon: 1,
      id: "app.bsky.feed.getFeedSkeleton",
      defs: {
        main: {
          type: "query",
          description: "Get a skeleton of a feed provided by a feed generator. Auth is optional, depending on provider requirements, and provides the DID of the requester. Implemented by Feed Generator Service.",
          parameters: {
            type: "params",
            required: ["feed"],
            properties: {
              feed: {
                type: "string",
                format: "at-uri",
                description: "Reference to feed generator record describing the specific feed being requested."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#skeletonFeedPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "UnknownFeed"
            }
          ]
        }
      }
    },
    AppBskyFeedGetLikes: {
      lexicon: 1,
      id: "app.bsky.feed.getLikes",
      defs: {
        main: {
          type: "query",
          description: "Get like records which reference a subject (by AT-URI and CID).",
          parameters: {
            type: "params",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri",
                description: "AT-URI of the subject (eg, a post record)."
              },
              cid: {
                type: "string",
                format: "cid",
                description: "CID of the subject record (aka, specific version of record), to filter likes."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["uri", "likes"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                cursor: {
                  type: "string"
                },
                likes: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.getLikes#like"
                  }
                }
              }
            }
          }
        },
        like: {
          type: "object",
          required: ["indexedAt", "createdAt", "actor"],
          properties: {
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            actor: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            }
          }
        }
      }
    },
    AppBskyFeedGetListFeed: {
      lexicon: 1,
      id: "app.bsky.feed.getListFeed",
      defs: {
        main: {
          type: "query",
          description: "Get a feed of recent posts from a list (posts and reposts from any actors on the list). Does not require auth.",
          parameters: {
            type: "params",
            required: ["list"],
            properties: {
              list: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to the list record."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#feedViewPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "UnknownList"
            }
          ]
        }
      }
    },
    AppBskyFeedGetPostThread: {
      lexicon: 1,
      id: "app.bsky.feed.getPostThread",
      defs: {
        main: {
          type: "query",
          description: "Get posts in a thread. Does not require auth, but additional metadata and filtering will be applied for authed requests.",
          parameters: {
            type: "params",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to post record."
              },
              depth: {
                type: "integer",
                description: "How many levels of reply depth should be included in response.",
                default: 6,
                minimum: 0,
                maximum: 1e3
              },
              parentHeight: {
                type: "integer",
                description: "How many levels of parent (and grandparent, etc) post to include.",
                default: 80,
                minimum: 0,
                maximum: 1e3
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["thread"],
              properties: {
                thread: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#threadViewPost",
                    "lex:app.bsky.feed.defs#notFoundPost",
                    "lex:app.bsky.feed.defs#blockedPost"
                  ]
                }
              }
            }
          },
          errors: [
            {
              name: "NotFound"
            }
          ]
        }
      }
    },
    AppBskyFeedGetPosts: {
      lexicon: 1,
      id: "app.bsky.feed.getPosts",
      defs: {
        main: {
          type: "query",
          description: "Gets post views for a specified list of posts (by AT-URI). This is sometimes referred to as 'hydrating' a 'feed skeleton'.",
          parameters: {
            type: "params",
            required: ["uris"],
            properties: {
              uris: {
                type: "array",
                description: "List of post AT-URIs to return hydrated views for.",
                items: {
                  type: "string",
                  format: "at-uri"
                },
                maxLength: 25
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["posts"],
              properties: {
                posts: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#postView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetRepostedBy: {
      lexicon: 1,
      id: "app.bsky.feed.getRepostedBy",
      defs: {
        main: {
          type: "query",
          description: "Get a list of reposts for a given post.",
          parameters: {
            type: "params",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) of post record"
              },
              cid: {
                type: "string",
                format: "cid",
                description: "If supplied, filters to reposts of specific version (by CID) of the post record."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["uri", "repostedBy"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                cursor: {
                  type: "string"
                },
                repostedBy: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetSuggestedFeeds: {
      lexicon: 1,
      id: "app.bsky.feed.getSuggestedFeeds",
      defs: {
        main: {
          type: "query",
          description: "Get a list of suggested feeds (feed generators) for the requesting account.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feeds"],
              properties: {
                cursor: {
                  type: "string"
                },
                feeds: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#generatorView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetTimeline: {
      lexicon: 1,
      id: "app.bsky.feed.getTimeline",
      defs: {
        main: {
          type: "query",
          description: "Get a view of the requesting account's home timeline. This is expected to be some form of reverse-chronological feed.",
          parameters: {
            type: "params",
            properties: {
              algorithm: {
                type: "string",
                description: "Variant 'algorithm' for timeline. Implementation-specific. NOTE: most feed flexibility has been moved to feed generator mechanism."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#feedViewPost"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedLike: {
      lexicon: 1,
      id: "app.bsky.feed.like",
      defs: {
        main: {
          type: "record",
          description: "Record declaring a 'like' of a piece of subject content.",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "createdAt"],
            properties: {
              subject: {
                type: "ref",
                ref: "lex:com.atproto.repo.strongRef"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyFeedPost: {
      lexicon: 1,
      id: "app.bsky.feed.post",
      defs: {
        main: {
          type: "record",
          description: "Record containing a Bluesky post.",
          key: "tid",
          record: {
            type: "object",
            required: ["text", "createdAt"],
            properties: {
              text: {
                type: "string",
                maxLength: 3e3,
                maxGraphemes: 300,
                description: "The primary post content. May be an empty string, if there are embeds."
              },
              entities: {
                type: "array",
                description: "DEPRECATED: replaced by app.bsky.richtext.facet.",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.post#entity"
                }
              },
              facets: {
                type: "array",
                description: "Annotations of text (mentions, URLs, hashtags, etc)",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet"
                }
              },
              reply: {
                type: "ref",
                ref: "lex:app.bsky.feed.post#replyRef"
              },
              embed: {
                type: "union",
                refs: [
                  "lex:app.bsky.embed.images",
                  "lex:app.bsky.embed.external",
                  "lex:app.bsky.embed.record",
                  "lex:app.bsky.embed.recordWithMedia"
                ]
              },
              langs: {
                type: "array",
                description: "Indicates human language of post primary text content.",
                maxLength: 3,
                items: {
                  type: "string",
                  format: "language"
                }
              },
              labels: {
                type: "union",
                description: "Self-label values for this post. Effectively content warnings.",
                refs: ["lex:com.atproto.label.defs#selfLabels"]
              },
              tags: {
                type: "array",
                description: "Additional hashtags, in addition to any included in post text and facets.",
                maxLength: 8,
                items: {
                  type: "string",
                  maxLength: 640,
                  maxGraphemes: 64
                }
              },
              createdAt: {
                type: "string",
                format: "datetime",
                description: "Client-declared timestamp when this post was originally created."
              }
            }
          }
        },
        replyRef: {
          type: "object",
          required: ["root", "parent"],
          properties: {
            root: {
              type: "ref",
              ref: "lex:com.atproto.repo.strongRef"
            },
            parent: {
              type: "ref",
              ref: "lex:com.atproto.repo.strongRef"
            }
          }
        },
        entity: {
          type: "object",
          description: "Deprecated: use facets instead.",
          required: ["index", "type", "value"],
          properties: {
            index: {
              type: "ref",
              ref: "lex:app.bsky.feed.post#textSlice"
            },
            type: {
              type: "string",
              description: "Expected values are 'mention' and 'link'."
            },
            value: {
              type: "string"
            }
          }
        },
        textSlice: {
          type: "object",
          description: "Deprecated. Use app.bsky.richtext instead -- A text segment. Start is inclusive, end is exclusive. Indices are for utf16-encoded strings.",
          required: ["start", "end"],
          properties: {
            start: {
              type: "integer",
              minimum: 0
            },
            end: {
              type: "integer",
              minimum: 0
            }
          }
        }
      }
    },
    AppBskyFeedRepost: {
      lexicon: 1,
      id: "app.bsky.feed.repost",
      defs: {
        main: {
          description: "Record representing a 'repost' of an existing Bluesky post.",
          type: "record",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "createdAt"],
            properties: {
              subject: {
                type: "ref",
                ref: "lex:com.atproto.repo.strongRef"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyFeedSearchPosts: {
      lexicon: 1,
      id: "app.bsky.feed.searchPosts",
      defs: {
        main: {
          type: "query",
          description: "Find posts matching search criteria, returning views of those posts.",
          parameters: {
            type: "params",
            required: ["q"],
            properties: {
              q: {
                type: "string",
                description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
              },
              sort: {
                type: "string",
                knownValues: ["top", "latest"],
                default: "latest",
                description: "Specifies the ranking order of results."
              },
              since: {
                type: "string",
                description: "Filter results for posts after the indicated datetime (inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYYY-MM-DD)."
              },
              until: {
                type: "string",
                description: "Filter results for posts before the indicated datetime (not inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYY-MM-DD)."
              },
              mentions: {
                type: "string",
                format: "at-identifier",
                description: "Filter to posts which mention the given account. Handles are resolved to DID before query-time. Only matches rich-text facet mentions."
              },
              author: {
                type: "string",
                format: "at-identifier",
                description: "Filter to posts by the given account. Handles are resolved to DID before query-time."
              },
              lang: {
                type: "string",
                format: "language",
                description: "Filter to posts in the given language. Expected to be based on post language field, though server may override language detection."
              },
              domain: {
                type: "string",
                description: "Filter to posts with URLs (facet links or embeds) linking to the given domain (hostname). Server may apply hostname normalization."
              },
              url: {
                type: "string",
                format: "uri",
                description: "Filter to posts with links (facet links or embeds) pointing to this URL. Server may apply URL normalization or fuzzy matching."
              },
              tag: {
                type: "array",
                items: {
                  type: "string",
                  maxLength: 640,
                  maxGraphemes: 64
                },
                description: "Filter to posts with the given tag (hashtag), based on rich-text facet or tag field. Do not include the hash (#) prefix. Multiple tags can be specified, with 'AND' matching."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 25
              },
              cursor: {
                type: "string",
                description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["posts"],
              properties: {
                cursor: {
                  type: "string"
                },
                hitsTotal: {
                  type: "integer",
                  description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                },
                posts: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#postView"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "BadQueryString"
            }
          ]
        }
      }
    },
    AppBskyFeedSendInteractions: {
      lexicon: 1,
      id: "app.bsky.feed.sendInteractions",
      defs: {
        main: {
          type: "procedure",
          description: "Send information about interactions with feed items back to the feed generator that served them.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["interactions"],
              properties: {
                interactions: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#interaction"
                  }
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {}
            }
          }
        }
      }
    },
    AppBskyFeedThreadgate: {
      lexicon: 1,
      id: "app.bsky.feed.threadgate",
      defs: {
        main: {
          type: "record",
          key: "tid",
          description: "Record defining interaction gating rules for a thread (aka, reply controls). The record key (rkey) of the threadgate record must match the record key of the thread's root post, and that record must be in the same repository..",
          record: {
            type: "object",
            required: ["post", "createdAt"],
            properties: {
              post: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to the post record."
              },
              allow: {
                type: "array",
                maxLength: 5,
                items: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.threadgate#mentionRule",
                    "lex:app.bsky.feed.threadgate#followingRule",
                    "lex:app.bsky.feed.threadgate#listRule"
                  ]
                }
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        },
        mentionRule: {
          type: "object",
          description: "Allow replies from actors mentioned in your post.",
          properties: {}
        },
        followingRule: {
          type: "object",
          description: "Allow replies from actors you follow.",
          properties: {}
        },
        listRule: {
          type: "object",
          description: "Allow replies from actors on a list.",
          required: ["list"],
          properties: {
            list: {
              type: "string",
              format: "at-uri"
            }
          }
        }
      }
    },
    AppBskyGraphBlock: {
      lexicon: 1,
      id: "app.bsky.graph.block",
      defs: {
        main: {
          type: "record",
          description: "Record declaring a 'block' relationship against another account. NOTE: blocks are public in Bluesky; see blog posts for details.",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "createdAt"],
            properties: {
              subject: {
                type: "string",
                format: "did",
                description: "DID of the account to be blocked."
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyGraphDefs: {
      lexicon: 1,
      id: "app.bsky.graph.defs",
      defs: {
        listViewBasic: {
          type: "object",
          required: ["uri", "cid", "name", "purpose"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            name: {
              type: "string",
              maxLength: 64,
              minLength: 1
            },
            purpose: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listPurpose"
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            listItemCount: {
              type: "integer",
              minimum: 0
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listViewerState"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        listView: {
          type: "object",
          required: ["uri", "cid", "creator", "name", "purpose", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            },
            name: {
              type: "string",
              maxLength: 64,
              minLength: 1
            },
            purpose: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listPurpose"
            },
            description: {
              type: "string",
              maxGraphemes: 300,
              maxLength: 3e3
            },
            descriptionFacets: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.richtext.facet"
              }
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            listItemCount: {
              type: "integer",
              minimum: 0
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listViewerState"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        listItemView: {
          type: "object",
          required: ["uri", "subject"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            subject: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            }
          }
        },
        starterPackView: {
          type: "object",
          required: ["uri", "cid", "record", "creator", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            record: {
              type: "unknown"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic"
            },
            list: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listViewBasic"
            },
            listItemsSample: {
              type: "array",
              maxLength: 12,
              items: {
                type: "ref",
                ref: "lex:app.bsky.graph.defs#listItemView"
              }
            },
            feeds: {
              type: "array",
              maxLength: 3,
              items: {
                type: "ref",
                ref: "lex:app.bsky.feed.defs#generatorView"
              }
            },
            joinedWeekCount: {
              type: "integer",
              minimum: 0
            },
            joinedAllTimeCount: {
              type: "integer",
              minimum: 0
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        starterPackViewBasic: {
          type: "object",
          required: ["uri", "cid", "record", "creator", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            record: {
              type: "unknown"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic"
            },
            listItemCount: {
              type: "integer",
              minimum: 0
            },
            joinedWeekCount: {
              type: "integer",
              minimum: 0
            },
            joinedAllTimeCount: {
              type: "integer",
              minimum: 0
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        listPurpose: {
          type: "string",
          knownValues: [
            "app.bsky.graph.defs#modlist",
            "app.bsky.graph.defs#curatelist",
            "app.bsky.graph.defs#referencelist"
          ]
        },
        modlist: {
          type: "token",
          description: "A list of actors to apply an aggregate moderation action (mute/block) on."
        },
        curatelist: {
          type: "token",
          description: "A list of actors used for curation purposes such as list feeds or interaction gating."
        },
        referencelist: {
          type: "token",
          description: "A list of actors used for only for reference purposes such as within a starter pack."
        },
        listViewerState: {
          type: "object",
          properties: {
            muted: {
              type: "boolean"
            },
            blocked: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        notFoundActor: {
          type: "object",
          description: "indicates that a handle or DID could not be resolved",
          required: ["actor", "notFound"],
          properties: {
            actor: {
              type: "string",
              format: "at-identifier"
            },
            notFound: {
              type: "boolean",
              const: !0
            }
          }
        },
        relationship: {
          type: "object",
          description: "lists the bi-directional graph relationships between one actor (not indicated in the object), and the target actors (the DID included in the object)",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            following: {
              type: "string",
              format: "at-uri",
              description: "if the actor follows this DID, this is the AT-URI of the follow record"
            },
            followedBy: {
              type: "string",
              format: "at-uri",
              description: "if the actor is followed by this DID, contains the AT-URI of the follow record"
            }
          }
        }
      }
    },
    AppBskyGraphFollow: {
      lexicon: 1,
      id: "app.bsky.graph.follow",
      defs: {
        main: {
          type: "record",
          description: "Record declaring a social 'follow' relationship of another account. Duplicate follows will be ignored by the AppView.",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "createdAt"],
            properties: {
              subject: {
                type: "string",
                format: "did"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetActorStarterPacks: {
      lexicon: 1,
      id: "app.bsky.graph.getActorStarterPacks",
      defs: {
        main: {
          type: "query",
          description: "Get a list of starter packs created by the actor.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["starterPacks"],
              properties: {
                cursor: {
                  type: "string"
                },
                starterPacks: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#starterPackViewBasic"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetBlocks: {
      lexicon: 1,
      id: "app.bsky.graph.getBlocks",
      defs: {
        main: {
          type: "query",
          description: "Enumerates which accounts the requesting account is currently blocking. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["blocks"],
              properties: {
                cursor: {
                  type: "string"
                },
                blocks: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetFollowers: {
      lexicon: 1,
      id: "app.bsky.graph.getFollowers",
      defs: {
        main: {
          type: "query",
          description: "Enumerates accounts which follow a specified account (actor).",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject", "followers"],
              properties: {
                subject: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                cursor: {
                  type: "string"
                },
                followers: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetFollows: {
      lexicon: 1,
      id: "app.bsky.graph.getFollows",
      defs: {
        main: {
          type: "query",
          description: "Enumerates accounts which a specified account (actor) follows.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject", "follows"],
              properties: {
                subject: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                cursor: {
                  type: "string"
                },
                follows: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetKnownFollowers: {
      lexicon: 1,
      id: "app.bsky.graph.getKnownFollowers",
      defs: {
        main: {
          type: "query",
          description: "Enumerates accounts which follow a specified account (actor) and are followed by the viewer.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject", "followers"],
              properties: {
                subject: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                cursor: {
                  type: "string"
                },
                followers: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetList: {
      lexicon: 1,
      id: "app.bsky.graph.getList",
      defs: {
        main: {
          type: "query",
          description: "Gets a 'view' (with additional context) of a specified list.",
          parameters: {
            type: "params",
            required: ["list"],
            properties: {
              list: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) of the list record to hydrate."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["list", "items"],
              properties: {
                cursor: {
                  type: "string"
                },
                list: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listView"
                },
                items: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listItemView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetListBlocks: {
      lexicon: 1,
      id: "app.bsky.graph.getListBlocks",
      defs: {
        main: {
          type: "query",
          description: "Get mod lists that the requesting account (actor) is blocking. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["lists"],
              properties: {
                cursor: {
                  type: "string"
                },
                lists: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetListMutes: {
      lexicon: 1,
      id: "app.bsky.graph.getListMutes",
      defs: {
        main: {
          type: "query",
          description: "Enumerates mod lists that the requesting account (actor) currently has muted. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["lists"],
              properties: {
                cursor: {
                  type: "string"
                },
                lists: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetLists: {
      lexicon: 1,
      id: "app.bsky.graph.getLists",
      defs: {
        main: {
          type: "query",
          description: "Enumerates the lists created by a specified account (actor).",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier",
                description: "The account (actor) to enumerate lists from."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["lists"],
              properties: {
                cursor: {
                  type: "string"
                },
                lists: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetMutes: {
      lexicon: 1,
      id: "app.bsky.graph.getMutes",
      defs: {
        main: {
          type: "query",
          description: "Enumerates accounts that the requesting account (actor) currently has muted. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["mutes"],
              properties: {
                cursor: {
                  type: "string"
                },
                mutes: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetRelationships: {
      lexicon: 1,
      id: "app.bsky.graph.getRelationships",
      defs: {
        main: {
          type: "query",
          description: "Enumerates public relationships between one account, and a list of other accounts. Does not require auth.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier",
                description: "Primary account requesting relationships for."
              },
              others: {
                type: "array",
                description: "List of 'other' accounts to be related back to the primary.",
                maxLength: 30,
                items: {
                  type: "string",
                  format: "at-identifier"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["relationships"],
              properties: {
                actor: {
                  type: "string",
                  format: "did"
                },
                relationships: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.graph.defs#relationship",
                      "lex:app.bsky.graph.defs#notFoundActor"
                    ]
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "ActorNotFound",
              description: "the primary actor at-identifier could not be resolved"
            }
          ]
        }
      }
    },
    AppBskyGraphGetStarterPack: {
      lexicon: 1,
      id: "app.bsky.graph.getStarterPack",
      defs: {
        main: {
          type: "query",
          description: "Gets a view of a starter pack.",
          parameters: {
            type: "params",
            required: ["starterPack"],
            properties: {
              starterPack: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) of the starter pack record."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["starterPack"],
              properties: {
                starterPack: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#starterPackView"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetStarterPacks: {
      lexicon: 1,
      id: "app.bsky.graph.getStarterPacks",
      defs: {
        main: {
          type: "query",
          description: "Get views for a list of starter packs.",
          parameters: {
            type: "params",
            required: ["uris"],
            properties: {
              uris: {
                type: "array",
                items: {
                  type: "string",
                  format: "at-uri"
                },
                maxLength: 25
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["starterPacks"],
              properties: {
                starterPacks: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#starterPackViewBasic"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetSuggestedFollowsByActor: {
      lexicon: 1,
      id: "app.bsky.graph.getSuggestedFollowsByActor",
      defs: {
        main: {
          type: "query",
          description: "Enumerates follows similar to a given account (actor). Expected use is to recommend additional accounts immediately after following one account.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["suggestions"],
              properties: {
                suggestions: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphList: {
      lexicon: 1,
      id: "app.bsky.graph.list",
      defs: {
        main: {
          type: "record",
          description: "Record representing a list of accounts (actors). Scope includes both moderation-oriented lists and curration-oriented lists.",
          key: "tid",
          record: {
            type: "object",
            required: ["name", "purpose", "createdAt"],
            properties: {
              purpose: {
                type: "ref",
                description: "Defines the purpose of the list (aka, moderation-oriented or curration-oriented)",
                ref: "lex:app.bsky.graph.defs#listPurpose"
              },
              name: {
                type: "string",
                maxLength: 64,
                minLength: 1,
                description: "Display name for list; can not be empty."
              },
              description: {
                type: "string",
                maxGraphemes: 300,
                maxLength: 3e3
              },
              descriptionFacets: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet"
                }
              },
              avatar: {
                type: "blob",
                accept: ["image/png", "image/jpeg"],
                maxSize: 1e6
              },
              labels: {
                type: "union",
                refs: ["lex:com.atproto.label.defs#selfLabels"]
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyGraphListblock: {
      lexicon: 1,
      id: "app.bsky.graph.listblock",
      defs: {
        main: {
          type: "record",
          description: "Record representing a block relationship against an entire an entire list of accounts (actors).",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "createdAt"],
            properties: {
              subject: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to the mod list record."
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyGraphListitem: {
      lexicon: 1,
      id: "app.bsky.graph.listitem",
      defs: {
        main: {
          type: "record",
          description: "Record representing an account's inclusion on a specific list. The AppView will ignore duplicate listitem records.",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "list", "createdAt"],
            properties: {
              subject: {
                type: "string",
                format: "did",
                description: "The account which is included on the list."
              },
              list: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to the list record (app.bsky.graph.list)."
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyGraphMuteActor: {
      lexicon: 1,
      id: "app.bsky.graph.muteActor",
      defs: {
        main: {
          type: "procedure",
          description: "Creates a mute relationship for the specified account. Mutes are private in Bluesky. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphMuteActorList: {
      lexicon: 1,
      id: "app.bsky.graph.muteActorList",
      defs: {
        main: {
          type: "procedure",
          description: "Creates a mute relationship for the specified list of accounts. Mutes are private in Bluesky. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["list"],
              properties: {
                list: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphMuteThread: {
      lexicon: 1,
      id: "app.bsky.graph.muteThread",
      defs: {
        main: {
          type: "procedure",
          description: "Mutes a thread preventing notifications from the thread and any of its children. Mutes are private in Bluesky. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["root"],
              properties: {
                root: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphStarterpack: {
      lexicon: 1,
      id: "app.bsky.graph.starterpack",
      defs: {
        main: {
          type: "record",
          description: "Record defining a starter pack of actors and feeds for new users.",
          key: "tid",
          record: {
            type: "object",
            required: ["name", "list", "createdAt"],
            properties: {
              name: {
                type: "string",
                maxGraphemes: 50,
                maxLength: 500,
                minLength: 1,
                description: "Display name for starter pack; can not be empty."
              },
              description: {
                type: "string",
                maxGraphemes: 300,
                maxLength: 3e3
              },
              descriptionFacets: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet"
                }
              },
              list: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to the list record."
              },
              feeds: {
                type: "array",
                maxLength: 3,
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.starterpack#feedItem"
                }
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        },
        feedItem: {
          type: "object",
          required: ["uri"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            }
          }
        }
      }
    },
    AppBskyGraphUnmuteActor: {
      lexicon: 1,
      id: "app.bsky.graph.unmuteActor",
      defs: {
        main: {
          type: "procedure",
          description: "Unmutes the specified account. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphUnmuteActorList: {
      lexicon: 1,
      id: "app.bsky.graph.unmuteActorList",
      defs: {
        main: {
          type: "procedure",
          description: "Unmutes the specified list of accounts. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["list"],
              properties: {
                list: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphUnmuteThread: {
      lexicon: 1,
      id: "app.bsky.graph.unmuteThread",
      defs: {
        main: {
          type: "procedure",
          description: "Unmutes the specified thread. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["root"],
              properties: {
                root: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        }
      }
    },
    AppBskyLabelerDefs: {
      lexicon: 1,
      id: "app.bsky.labeler.defs",
      defs: {
        labelerView: {
          type: "object",
          required: ["uri", "cid", "creator", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            },
            likeCount: {
              type: "integer",
              minimum: 0
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.labeler.defs#labelerViewerState"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        labelerViewDetailed: {
          type: "object",
          required: ["uri", "cid", "creator", "policies", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            },
            policies: {
              type: "ref",
              ref: "lex:app.bsky.labeler.defs#labelerPolicies"
            },
            likeCount: {
              type: "integer",
              minimum: 0
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.labeler.defs#labelerViewerState"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        labelerViewerState: {
          type: "object",
          properties: {
            like: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        labelerPolicies: {
          type: "object",
          required: ["labelValues"],
          properties: {
            labelValues: {
              type: "array",
              description: "The label values which this labeler publishes. May include global or custom labels.",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#labelValue"
              }
            },
            labelValueDefinitions: {
              type: "array",
              description: "Label values created by this labeler and scoped exclusively to it. Labels defined here will override global label definitions for this labeler.",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#labelValueDefinition"
              }
            }
          }
        }
      }
    },
    AppBskyLabelerGetServices: {
      lexicon: 1,
      id: "app.bsky.labeler.getServices",
      defs: {
        main: {
          type: "query",
          description: "Get information about a list of labeler services.",
          parameters: {
            type: "params",
            required: ["dids"],
            properties: {
              dids: {
                type: "array",
                items: {
                  type: "string",
                  format: "did"
                }
              },
              detailed: {
                type: "boolean",
                default: !1
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["views"],
              properties: {
                views: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.labeler.defs#labelerView",
                      "lex:app.bsky.labeler.defs#labelerViewDetailed"
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyLabelerService: {
      lexicon: 1,
      id: "app.bsky.labeler.service",
      defs: {
        main: {
          type: "record",
          description: "A declaration of the existence of labeler service.",
          key: "literal:self",
          record: {
            type: "object",
            required: ["policies", "createdAt"],
            properties: {
              policies: {
                type: "ref",
                ref: "lex:app.bsky.labeler.defs#labelerPolicies"
              },
              labels: {
                type: "union",
                refs: ["lex:com.atproto.label.defs#selfLabels"]
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyNotificationGetUnreadCount: {
      lexicon: 1,
      id: "app.bsky.notification.getUnreadCount",
      defs: {
        main: {
          type: "query",
          description: "Count the number of unread notifications for the requesting account. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              priority: {
                type: "boolean"
              },
              seenAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["count"],
              properties: {
                count: {
                  type: "integer"
                }
              }
            }
          }
        }
      }
    },
    AppBskyNotificationListNotifications: {
      lexicon: 1,
      id: "app.bsky.notification.listNotifications",
      defs: {
        main: {
          type: "query",
          description: "Enumerate notifications for the requesting account. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              priority: {
                type: "boolean"
              },
              cursor: {
                type: "string"
              },
              seenAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["notifications"],
              properties: {
                cursor: {
                  type: "string"
                },
                notifications: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.notification.listNotifications#notification"
                  }
                },
                priority: {
                  type: "boolean"
                },
                seenAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        },
        notification: {
          type: "object",
          required: [
            "uri",
            "cid",
            "author",
            "reason",
            "record",
            "isRead",
            "indexedAt"
          ],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            author: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            },
            reason: {
              type: "string",
              description: "Expected values are 'like', 'repost', 'follow', 'mention', 'reply', 'quote', and 'starterpack-joined'.",
              knownValues: [
                "like",
                "repost",
                "follow",
                "mention",
                "reply",
                "quote",
                "starterpack-joined"
              ]
            },
            reasonSubject: {
              type: "string",
              format: "at-uri"
            },
            record: {
              type: "unknown"
            },
            isRead: {
              type: "boolean"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        }
      }
    },
    AppBskyNotificationPutPreferences: {
      lexicon: 1,
      id: "app.bsky.notification.putPreferences",
      defs: {
        main: {
          type: "procedure",
          description: "Set notification-related preferences for an account. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["priority"],
              properties: {
                priority: {
                  type: "boolean"
                }
              }
            }
          }
        }
      }
    },
    AppBskyNotificationRegisterPush: {
      lexicon: 1,
      id: "app.bsky.notification.registerPush",
      defs: {
        main: {
          type: "procedure",
          description: "Register to receive push notifications, via a specified service, for the requesting account. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["serviceDid", "token", "platform", "appId"],
              properties: {
                serviceDid: {
                  type: "string",
                  format: "did"
                },
                token: {
                  type: "string"
                },
                platform: {
                  type: "string",
                  knownValues: ["ios", "android", "web"]
                },
                appId: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    AppBskyNotificationUpdateSeen: {
      lexicon: 1,
      id: "app.bsky.notification.updateSeen",
      defs: {
        main: {
          type: "procedure",
          description: "Notify server that the requesting account has seen notifications. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["seenAt"],
              properties: {
                seenAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      }
    },
    AppBskyRichtextFacet: {
      lexicon: 1,
      id: "app.bsky.richtext.facet",
      defs: {
        main: {
          type: "object",
          description: "Annotation of a sub-string within rich text.",
          required: ["index", "features"],
          properties: {
            index: {
              type: "ref",
              ref: "lex:app.bsky.richtext.facet#byteSlice"
            },
            features: {
              type: "array",
              items: {
                type: "union",
                refs: [
                  "lex:app.bsky.richtext.facet#mention",
                  "lex:app.bsky.richtext.facet#link",
                  "lex:app.bsky.richtext.facet#tag"
                ]
              }
            }
          }
        },
        mention: {
          type: "object",
          description: "Facet feature for mention of another account. The text is usually a handle, including a '@' prefix, but the facet reference is a DID.",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        },
        link: {
          type: "object",
          description: "Facet feature for a URL. The text URL may have been simplified or truncated, but the facet reference should be a complete URL.",
          required: ["uri"],
          properties: {
            uri: {
              type: "string",
              format: "uri"
            }
          }
        },
        tag: {
          type: "object",
          description: "Facet feature for a hashtag. The text usually includes a '#' prefix, but the facet reference should not (except in the case of 'double hash tags').",
          required: ["tag"],
          properties: {
            tag: {
              type: "string",
              maxLength: 640,
              maxGraphemes: 64
            }
          }
        },
        byteSlice: {
          type: "object",
          description: "Specifies the sub-string range a facet feature applies to. Start index is inclusive, end index is exclusive. Indices are zero-indexed, counting bytes of the UTF-8 encoded text. NOTE: some languages, like Javascript, use UTF-16 or Unicode codepoints for string slice indexing; in these languages, convert to byte arrays before working with facets.",
          required: ["byteStart", "byteEnd"],
          properties: {
            byteStart: {
              type: "integer",
              minimum: 0
            },
            byteEnd: {
              type: "integer",
              minimum: 0
            }
          }
        }
      }
    },
    AppBskyUnspeccedDefs: {
      lexicon: 1,
      id: "app.bsky.unspecced.defs",
      defs: {
        skeletonSearchPost: {
          type: "object",
          required: ["uri"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        skeletonSearchActor: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        }
      }
    },
    AppBskyUnspeccedGetPopularFeedGenerators: {
      lexicon: 1,
      id: "app.bsky.unspecced.getPopularFeedGenerators",
      defs: {
        main: {
          type: "query",
          description: "An unspecced view of globally popular feed generators.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              },
              query: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feeds"],
              properties: {
                cursor: {
                  type: "string"
                },
                feeds: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#generatorView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyUnspeccedGetSuggestionsSkeleton: {
      lexicon: 1,
      id: "app.bsky.unspecced.getSuggestionsSkeleton",
      defs: {
        main: {
          type: "query",
          description: "Get a skeleton of suggested actors. Intended to be called and then hydrated through app.bsky.actor.getSuggestions",
          parameters: {
            type: "params",
            properties: {
              viewer: {
                type: "string",
                format: "did",
                description: "DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              },
              relativeToDid: {
                type: "string",
                format: "did",
                description: "DID of the account to get suggestions relative to. If not provided, suggestions will be based on the viewer."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actors"],
              properties: {
                cursor: {
                  type: "string"
                },
                actors: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.unspecced.defs#skeletonSearchActor"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyUnspeccedGetTaggedSuggestions: {
      lexicon: 1,
      id: "app.bsky.unspecced.getTaggedSuggestions",
      defs: {
        main: {
          type: "query",
          description: "Get a list of suggestions (feeds and users) tagged with categories",
          parameters: {
            type: "params",
            properties: {}
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["suggestions"],
              properties: {
                suggestions: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.unspecced.getTaggedSuggestions#suggestion"
                  }
                }
              }
            }
          }
        },
        suggestion: {
          type: "object",
          required: ["tag", "subjectType", "subject"],
          properties: {
            tag: {
              type: "string"
            },
            subjectType: {
              type: "string",
              knownValues: ["actor", "feed"]
            },
            subject: {
              type: "string",
              format: "uri"
            }
          }
        }
      }
    },
    AppBskyUnspeccedSearchActorsSkeleton: {
      lexicon: 1,
      id: "app.bsky.unspecced.searchActorsSkeleton",
      defs: {
        main: {
          type: "query",
          description: "Backend Actors (profile) search, returns only skeleton.",
          parameters: {
            type: "params",
            required: ["q"],
            properties: {
              q: {
                type: "string",
                description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. For typeahead search, only simple term match is supported, not full syntax."
              },
              viewer: {
                type: "string",
                format: "did",
                description: "DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking."
              },
              typeahead: {
                type: "boolean",
                description: "If true, acts as fast/simple 'typeahead' query."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 25
              },
              cursor: {
                type: "string",
                description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actors"],
              properties: {
                cursor: {
                  type: "string"
                },
                hitsTotal: {
                  type: "integer",
                  description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                },
                actors: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.unspecced.defs#skeletonSearchActor"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "BadQueryString"
            }
          ]
        }
      }
    },
    AppBskyUnspeccedSearchPostsSkeleton: {
      lexicon: 1,
      id: "app.bsky.unspecced.searchPostsSkeleton",
      defs: {
        main: {
          type: "query",
          description: "Backend Posts search, returns only skeleton",
          parameters: {
            type: "params",
            required: ["q"],
            properties: {
              q: {
                type: "string",
                description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
              },
              sort: {
                type: "string",
                knownValues: ["top", "latest"],
                default: "latest",
                description: "Specifies the ranking order of results."
              },
              since: {
                type: "string",
                description: "Filter results for posts after the indicated datetime (inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYYY-MM-DD)."
              },
              until: {
                type: "string",
                description: "Filter results for posts before the indicated datetime (not inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYY-MM-DD)."
              },
              mentions: {
                type: "string",
                format: "at-identifier",
                description: "Filter to posts which mention the given account. Handles are resolved to DID before query-time. Only matches rich-text facet mentions."
              },
              author: {
                type: "string",
                format: "at-identifier",
                description: "Filter to posts by the given account. Handles are resolved to DID before query-time."
              },
              lang: {
                type: "string",
                format: "language",
                description: "Filter to posts in the given language. Expected to be based on post language field, though server may override language detection."
              },
              domain: {
                type: "string",
                description: "Filter to posts with URLs (facet links or embeds) linking to the given domain (hostname). Server may apply hostname normalization."
              },
              url: {
                type: "string",
                format: "uri",
                description: "Filter to posts with links (facet links or embeds) pointing to this URL. Server may apply URL normalization or fuzzy matching."
              },
              tag: {
                type: "array",
                items: {
                  type: "string",
                  maxLength: 640,
                  maxGraphemes: 64
                },
                description: "Filter to posts with the given tag (hashtag), based on rich-text facet or tag field. Do not include the hash (#) prefix. Multiple tags can be specified, with 'AND' matching."
              },
              viewer: {
                type: "string",
                format: "did",
                description: "DID of the account making the request (not included for public/unauthenticated queries). Used for 'from:me' queries."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 25
              },
              cursor: {
                type: "string",
                description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["posts"],
              properties: {
                cursor: {
                  type: "string"
                },
                hitsTotal: {
                  type: "integer",
                  description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                },
                posts: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.unspecced.defs#skeletonSearchPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "BadQueryString"
            }
          ]
        }
      }
    },
    ChatBskyActorDeclaration: {
      lexicon: 1,
      id: "chat.bsky.actor.declaration",
      defs: {
        main: {
          type: "record",
          description: "A declaration of a Bluesky chat account.",
          key: "literal:self",
          record: {
            type: "object",
            required: ["allowIncoming"],
            properties: {
              allowIncoming: {
                type: "string",
                knownValues: ["all", "none", "following"]
              }
            }
          }
        }
      }
    },
    ChatBskyActorDefs: {
      lexicon: 1,
      id: "chat.bsky.actor.defs",
      defs: {
        profileViewBasic: {
          type: "object",
          required: ["did", "handle"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            displayName: {
              type: "string",
              maxGraphemes: 64,
              maxLength: 640
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            associated: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileAssociated"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#viewerState"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            chatDisabled: {
              type: "boolean",
              description: "Set to true when the actor cannot actively participate in converations"
            }
          }
        }
      }
    },
    ChatBskyActorDeleteAccount: {
      lexicon: 1,
      id: "chat.bsky.actor.deleteAccount",
      defs: {
        main: {
          type: "procedure",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {}
            }
          }
        }
      }
    },
    ChatBskyActorExportAccountData: {
      lexicon: 1,
      id: "chat.bsky.actor.exportAccountData",
      defs: {
        main: {
          type: "query",
          output: {
            encoding: "application/jsonl"
          }
        }
      }
    },
    ChatBskyConvoDefs: {
      lexicon: 1,
      id: "chat.bsky.convo.defs",
      defs: {
        messageRef: {
          type: "object",
          required: ["did", "messageId", "convoId"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            convoId: {
              type: "string"
            },
            messageId: {
              type: "string"
            }
          }
        },
        messageInput: {
          type: "object",
          required: ["text"],
          properties: {
            text: {
              type: "string",
              maxLength: 1e4,
              maxGraphemes: 1e3
            },
            facets: {
              type: "array",
              description: "Annotations of text (mentions, URLs, hashtags, etc)",
              items: {
                type: "ref",
                ref: "lex:app.bsky.richtext.facet"
              }
            },
            embed: {
              type: "union",
              refs: ["lex:app.bsky.embed.record"]
            }
          }
        },
        messageView: {
          type: "object",
          required: ["id", "rev", "text", "sender", "sentAt"],
          properties: {
            id: {
              type: "string"
            },
            rev: {
              type: "string"
            },
            text: {
              type: "string",
              maxLength: 1e4,
              maxGraphemes: 1e3
            },
            facets: {
              type: "array",
              description: "Annotations of text (mentions, URLs, hashtags, etc)",
              items: {
                type: "ref",
                ref: "lex:app.bsky.richtext.facet"
              }
            },
            embed: {
              type: "union",
              refs: ["lex:app.bsky.embed.record#view"]
            },
            sender: {
              type: "ref",
              ref: "lex:chat.bsky.convo.defs#messageViewSender"
            },
            sentAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        deletedMessageView: {
          type: "object",
          required: ["id", "rev", "sender", "sentAt"],
          properties: {
            id: {
              type: "string"
            },
            rev: {
              type: "string"
            },
            sender: {
              type: "ref",
              ref: "lex:chat.bsky.convo.defs#messageViewSender"
            },
            sentAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        messageViewSender: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        },
        convoView: {
          type: "object",
          required: ["id", "rev", "members", "muted", "unreadCount"],
          properties: {
            id: {
              type: "string"
            },
            rev: {
              type: "string"
            },
            members: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:chat.bsky.actor.defs#profileViewBasic"
              }
            },
            lastMessage: {
              type: "union",
              refs: [
                "lex:chat.bsky.convo.defs#messageView",
                "lex:chat.bsky.convo.defs#deletedMessageView"
              ]
            },
            muted: {
              type: "boolean"
            },
            unreadCount: {
              type: "integer"
            }
          }
        },
        logBeginConvo: {
          type: "object",
          required: ["rev", "convoId"],
          properties: {
            rev: {
              type: "string"
            },
            convoId: {
              type: "string"
            }
          }
        },
        logLeaveConvo: {
          type: "object",
          required: ["rev", "convoId"],
          properties: {
            rev: {
              type: "string"
            },
            convoId: {
              type: "string"
            }
          }
        },
        logCreateMessage: {
          type: "object",
          required: ["rev", "convoId", "message"],
          properties: {
            rev: {
              type: "string"
            },
            convoId: {
              type: "string"
            },
            message: {
              type: "union",
              refs: [
                "lex:chat.bsky.convo.defs#messageView",
                "lex:chat.bsky.convo.defs#deletedMessageView"
              ]
            }
          }
        },
        logDeleteMessage: {
          type: "object",
          required: ["rev", "convoId", "message"],
          properties: {
            rev: {
              type: "string"
            },
            convoId: {
              type: "string"
            },
            message: {
              type: "union",
              refs: [
                "lex:chat.bsky.convo.defs#messageView",
                "lex:chat.bsky.convo.defs#deletedMessageView"
              ]
            }
          }
        }
      }
    },
    ChatBskyConvoDeleteMessageForSelf: {
      lexicon: 1,
      id: "chat.bsky.convo.deleteMessageForSelf",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId", "messageId"],
              properties: {
                convoId: {
                  type: "string"
                },
                messageId: {
                  type: "string"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:chat.bsky.convo.defs#deletedMessageView"
            }
          }
        }
      }
    },
    ChatBskyConvoGetConvo: {
      lexicon: 1,
      id: "chat.bsky.convo.getConvo",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            required: ["convoId"],
            properties: {
              convoId: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convo"],
              properties: {
                convo: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#convoView"
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoGetConvoForMembers: {
      lexicon: 1,
      id: "chat.bsky.convo.getConvoForMembers",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            required: ["members"],
            properties: {
              members: {
                type: "array",
                minLength: 1,
                maxLength: 10,
                items: {
                  type: "string",
                  format: "did"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convo"],
              properties: {
                convo: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#convoView"
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoGetLog: {
      lexicon: 1,
      id: "chat.bsky.convo.getLog",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            required: [],
            properties: {
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["logs"],
              properties: {
                cursor: {
                  type: "string"
                },
                logs: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:chat.bsky.convo.defs#logBeginConvo",
                      "lex:chat.bsky.convo.defs#logLeaveConvo",
                      "lex:chat.bsky.convo.defs#logCreateMessage",
                      "lex:chat.bsky.convo.defs#logDeleteMessage"
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoGetMessages: {
      lexicon: 1,
      id: "chat.bsky.convo.getMessages",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            required: ["convoId"],
            properties: {
              convoId: {
                type: "string"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["messages"],
              properties: {
                cursor: {
                  type: "string"
                },
                messages: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:chat.bsky.convo.defs#messageView",
                      "lex:chat.bsky.convo.defs#deletedMessageView"
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoLeaveConvo: {
      lexicon: 1,
      id: "chat.bsky.convo.leaveConvo",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId"],
              properties: {
                convoId: {
                  type: "string"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId", "rev"],
              properties: {
                convoId: {
                  type: "string"
                },
                rev: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoListConvos: {
      lexicon: 1,
      id: "chat.bsky.convo.listConvos",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convos"],
              properties: {
                cursor: {
                  type: "string"
                },
                convos: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:chat.bsky.convo.defs#convoView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoMuteConvo: {
      lexicon: 1,
      id: "chat.bsky.convo.muteConvo",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId"],
              properties: {
                convoId: {
                  type: "string"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convo"],
              properties: {
                convo: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#convoView"
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoSendMessage: {
      lexicon: 1,
      id: "chat.bsky.convo.sendMessage",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId", "message"],
              properties: {
                convoId: {
                  type: "string"
                },
                message: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#messageInput"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:chat.bsky.convo.defs#messageView"
            }
          }
        }
      }
    },
    ChatBskyConvoSendMessageBatch: {
      lexicon: 1,
      id: "chat.bsky.convo.sendMessageBatch",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["items"],
              properties: {
                items: {
                  type: "array",
                  maxLength: 100,
                  items: {
                    type: "ref",
                    ref: "lex:chat.bsky.convo.sendMessageBatch#batchItem"
                  }
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["items"],
              properties: {
                items: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:chat.bsky.convo.defs#messageView"
                  }
                }
              }
            }
          }
        },
        batchItem: {
          type: "object",
          required: ["convoId", "message"],
          properties: {
            convoId: {
              type: "string"
            },
            message: {
              type: "ref",
              ref: "lex:chat.bsky.convo.defs#messageInput"
            }
          }
        }
      }
    },
    ChatBskyConvoUnmuteConvo: {
      lexicon: 1,
      id: "chat.bsky.convo.unmuteConvo",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId"],
              properties: {
                convoId: {
                  type: "string"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convo"],
              properties: {
                convo: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#convoView"
                }
              }
            }
          }
        }
      }
    },
    ChatBskyConvoUpdateRead: {
      lexicon: 1,
      id: "chat.bsky.convo.updateRead",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convoId"],
              properties: {
                convoId: {
                  type: "string"
                },
                messageId: {
                  type: "string"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["convo"],
              properties: {
                convo: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#convoView"
                }
              }
            }
          }
        }
      }
    },
    ChatBskyModerationGetActorMetadata: {
      lexicon: 1,
      id: "chat.bsky.moderation.getActorMetadata",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "did"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["day", "month", "all"],
              properties: {
                day: {
                  type: "ref",
                  ref: "lex:chat.bsky.moderation.getActorMetadata#metadata"
                },
                month: {
                  type: "ref",
                  ref: "lex:chat.bsky.moderation.getActorMetadata#metadata"
                },
                all: {
                  type: "ref",
                  ref: "lex:chat.bsky.moderation.getActorMetadata#metadata"
                }
              }
            }
          }
        },
        metadata: {
          type: "object",
          required: [
            "messagesSent",
            "messagesReceived",
            "convos",
            "convosStarted"
          ],
          properties: {
            messagesSent: {
              type: "integer"
            },
            messagesReceived: {
              type: "integer"
            },
            convos: {
              type: "integer"
            },
            convosStarted: {
              type: "integer"
            }
          }
        }
      }
    },
    ChatBskyModerationGetMessageContext: {
      lexicon: 1,
      id: "chat.bsky.moderation.getMessageContext",
      defs: {
        main: {
          type: "query",
          parameters: {
            type: "params",
            required: ["messageId"],
            properties: {
              convoId: {
                type: "string",
                description: "Conversation that the message is from. NOTE: this field will eventually be required."
              },
              messageId: {
                type: "string"
              },
              before: {
                type: "integer",
                default: 5
              },
              after: {
                type: "integer",
                default: 5
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["messages"],
              properties: {
                messages: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:chat.bsky.convo.defs#messageView",
                      "lex:chat.bsky.convo.defs#deletedMessageView"
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    ChatBskyModerationUpdateActorAccess: {
      lexicon: 1,
      id: "chat.bsky.moderation.updateActorAccess",
      defs: {
        main: {
          type: "procedure",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actor", "allowAccess"],
              properties: {
                actor: {
                  type: "string",
                  format: "did"
                },
                allowAccess: {
                  type: "boolean"
                },
                ref: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneCommunicationCreateTemplate: {
      lexicon: 1,
      id: "tools.ozone.communication.createTemplate",
      defs: {
        main: {
          type: "procedure",
          description: "Administrative action to create a new, re-usable communication (email for now) template.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject", "contentMarkdown", "name"],
              properties: {
                name: {
                  type: "string",
                  description: "Name of the template."
                },
                contentMarkdown: {
                  type: "string",
                  description: "Content of the template, markdown supported, can contain variable placeholders."
                },
                subject: {
                  type: "string",
                  description: "Subject of the message, used in emails."
                },
                createdBy: {
                  type: "string",
                  format: "did",
                  description: "DID of the user who is creating the template."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.communication.defs#templateView"
            }
          }
        }
      }
    },
    ToolsOzoneCommunicationDefs: {
      lexicon: 1,
      id: "tools.ozone.communication.defs",
      defs: {
        templateView: {
          type: "object",
          required: [
            "id",
            "name",
            "contentMarkdown",
            "disabled",
            "lastUpdatedBy",
            "createdAt",
            "updatedAt"
          ],
          properties: {
            id: {
              type: "string"
            },
            name: {
              type: "string",
              description: "Name of the template."
            },
            subject: {
              type: "string",
              description: "Content of the template, can contain markdown and variable placeholders."
            },
            contentMarkdown: {
              type: "string",
              description: "Subject of the message, used in emails."
            },
            disabled: {
              type: "boolean"
            },
            lastUpdatedBy: {
              type: "string",
              format: "did",
              description: "DID of the user who last updated the template."
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            updatedAt: {
              type: "string",
              format: "datetime"
            }
          }
        }
      }
    },
    ToolsOzoneCommunicationDeleteTemplate: {
      lexicon: 1,
      id: "tools.ozone.communication.deleteTemplate",
      defs: {
        main: {
          type: "procedure",
          description: "Delete a communication template.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["id"],
              properties: {
                id: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneCommunicationListTemplates: {
      lexicon: 1,
      id: "tools.ozone.communication.listTemplates",
      defs: {
        main: {
          type: "query",
          description: "Get list of all communication templates.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["communicationTemplates"],
              properties: {
                communicationTemplates: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.communication.defs#templateView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneCommunicationUpdateTemplate: {
      lexicon: 1,
      id: "tools.ozone.communication.updateTemplate",
      defs: {
        main: {
          type: "procedure",
          description: "Administrative action to update an existing communication template. Allows passing partial fields to patch specific fields only.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["id"],
              properties: {
                id: {
                  type: "string",
                  description: "ID of the template to be updated."
                },
                name: {
                  type: "string",
                  description: "Name of the template."
                },
                contentMarkdown: {
                  type: "string",
                  description: "Content of the template, markdown supported, can contain variable placeholders."
                },
                subject: {
                  type: "string",
                  description: "Subject of the message, used in emails."
                },
                updatedBy: {
                  type: "string",
                  format: "did",
                  description: "DID of the user who is updating the template."
                },
                disabled: {
                  type: "boolean"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.communication.defs#templateView"
            }
          }
        }
      }
    },
    ToolsOzoneModerationDefs: {
      lexicon: 1,
      id: "tools.ozone.moderation.defs",
      defs: {
        modEventView: {
          type: "object",
          required: [
            "id",
            "event",
            "subject",
            "subjectBlobCids",
            "createdBy",
            "createdAt"
          ],
          properties: {
            id: {
              type: "integer"
            },
            event: {
              type: "union",
              refs: [
                "lex:tools.ozone.moderation.defs#modEventTakedown",
                "lex:tools.ozone.moderation.defs#modEventReverseTakedown",
                "lex:tools.ozone.moderation.defs#modEventComment",
                "lex:tools.ozone.moderation.defs#modEventReport",
                "lex:tools.ozone.moderation.defs#modEventLabel",
                "lex:tools.ozone.moderation.defs#modEventAcknowledge",
                "lex:tools.ozone.moderation.defs#modEventEscalate",
                "lex:tools.ozone.moderation.defs#modEventMute",
                "lex:tools.ozone.moderation.defs#modEventUnmute",
                "lex:tools.ozone.moderation.defs#modEventMuteReporter",
                "lex:tools.ozone.moderation.defs#modEventUnmuteReporter",
                "lex:tools.ozone.moderation.defs#modEventEmail",
                "lex:tools.ozone.moderation.defs#modEventResolveAppeal",
                "lex:tools.ozone.moderation.defs#modEventDivert",
                "lex:tools.ozone.moderation.defs#modEventTag"
              ]
            },
            subject: {
              type: "union",
              refs: [
                "lex:com.atproto.admin.defs#repoRef",
                "lex:com.atproto.repo.strongRef",
                "lex:chat.bsky.convo.defs#messageRef"
              ]
            },
            subjectBlobCids: {
              type: "array",
              items: {
                type: "string"
              }
            },
            createdBy: {
              type: "string",
              format: "did"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            creatorHandle: {
              type: "string"
            },
            subjectHandle: {
              type: "string"
            }
          }
        },
        modEventViewDetail: {
          type: "object",
          required: [
            "id",
            "event",
            "subject",
            "subjectBlobs",
            "createdBy",
            "createdAt"
          ],
          properties: {
            id: {
              type: "integer"
            },
            event: {
              type: "union",
              refs: [
                "lex:tools.ozone.moderation.defs#modEventTakedown",
                "lex:tools.ozone.moderation.defs#modEventReverseTakedown",
                "lex:tools.ozone.moderation.defs#modEventComment",
                "lex:tools.ozone.moderation.defs#modEventReport",
                "lex:tools.ozone.moderation.defs#modEventLabel",
                "lex:tools.ozone.moderation.defs#modEventAcknowledge",
                "lex:tools.ozone.moderation.defs#modEventEscalate",
                "lex:tools.ozone.moderation.defs#modEventMute",
                "lex:tools.ozone.moderation.defs#modEventUnmute",
                "lex:tools.ozone.moderation.defs#modEventMuteReporter",
                "lex:tools.ozone.moderation.defs#modEventUnmuteReporter",
                "lex:tools.ozone.moderation.defs#modEventEmail",
                "lex:tools.ozone.moderation.defs#modEventResolveAppeal",
                "lex:tools.ozone.moderation.defs#modEventDivert",
                "lex:tools.ozone.moderation.defs#modEventTag"
              ]
            },
            subject: {
              type: "union",
              refs: [
                "lex:tools.ozone.moderation.defs#repoView",
                "lex:tools.ozone.moderation.defs#repoViewNotFound",
                "lex:tools.ozone.moderation.defs#recordView",
                "lex:tools.ozone.moderation.defs#recordViewNotFound"
              ]
            },
            subjectBlobs: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#blobView"
              }
            },
            createdBy: {
              type: "string",
              format: "did"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        subjectStatusView: {
          type: "object",
          required: ["id", "subject", "createdAt", "updatedAt", "reviewState"],
          properties: {
            id: {
              type: "integer"
            },
            subject: {
              type: "union",
              refs: [
                "lex:com.atproto.admin.defs#repoRef",
                "lex:com.atproto.repo.strongRef"
              ]
            },
            subjectBlobCids: {
              type: "array",
              items: {
                type: "string",
                format: "cid"
              }
            },
            subjectRepoHandle: {
              type: "string"
            },
            updatedAt: {
              type: "string",
              format: "datetime",
              description: "Timestamp referencing when the last update was made to the moderation status of the subject"
            },
            createdAt: {
              type: "string",
              format: "datetime",
              description: "Timestamp referencing the first moderation status impacting event was emitted on the subject"
            },
            reviewState: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#subjectReviewState"
            },
            comment: {
              type: "string",
              description: "Sticky comment on the subject."
            },
            muteUntil: {
              type: "string",
              format: "datetime"
            },
            muteReportingUntil: {
              type: "string",
              format: "datetime"
            },
            lastReviewedBy: {
              type: "string",
              format: "did"
            },
            lastReviewedAt: {
              type: "string",
              format: "datetime"
            },
            lastReportedAt: {
              type: "string",
              format: "datetime"
            },
            lastAppealedAt: {
              type: "string",
              format: "datetime",
              description: "Timestamp referencing when the author of the subject appealed a moderation action"
            },
            takendown: {
              type: "boolean"
            },
            appealed: {
              type: "boolean",
              description: "True indicates that the a previously taken moderator action was appealed against, by the author of the content. False indicates last appeal was resolved by moderators."
            },
            suspendUntil: {
              type: "string",
              format: "datetime"
            },
            tags: {
              type: "array",
              items: {
                type: "string"
              }
            }
          }
        },
        subjectReviewState: {
          type: "string",
          knownValues: [
            "lex:tools.ozone.moderation.defs#reviewOpen",
            "lex:tools.ozone.moderation.defs#reviewEscalated",
            "lex:tools.ozone.moderation.defs#reviewClosed",
            "lex:tools.ozone.moderation.defs#reviewNone"
          ]
        },
        reviewOpen: {
          type: "token",
          description: "Moderator review status of a subject: Open. Indicates that the subject needs to be reviewed by a moderator"
        },
        reviewEscalated: {
          type: "token",
          description: "Moderator review status of a subject: Escalated. Indicates that the subject was escalated for review by a moderator"
        },
        reviewClosed: {
          type: "token",
          description: "Moderator review status of a subject: Closed. Indicates that the subject was already reviewed and resolved by a moderator"
        },
        reviewNone: {
          type: "token",
          description: "Moderator review status of a subject: Unnecessary. Indicates that the subject does not need a review at the moment but there is probably some moderation related metadata available for it"
        },
        modEventTakedown: {
          type: "object",
          description: "Take down a subject permanently or temporarily",
          properties: {
            comment: {
              type: "string"
            },
            durationInHours: {
              type: "integer",
              description: "Indicates how long the takedown should be in effect before automatically expiring."
            }
          }
        },
        modEventReverseTakedown: {
          type: "object",
          description: "Revert take down action on a subject",
          properties: {
            comment: {
              type: "string",
              description: "Describe reasoning behind the reversal."
            }
          }
        },
        modEventResolveAppeal: {
          type: "object",
          description: "Resolve appeal on a subject",
          properties: {
            comment: {
              type: "string",
              description: "Describe resolution."
            }
          }
        },
        modEventComment: {
          type: "object",
          description: "Add a comment to a subject",
          required: ["comment"],
          properties: {
            comment: {
              type: "string"
            },
            sticky: {
              type: "boolean",
              description: "Make the comment persistent on the subject"
            }
          }
        },
        modEventReport: {
          type: "object",
          description: "Report a subject",
          required: ["reportType"],
          properties: {
            comment: {
              type: "string"
            },
            isReporterMuted: {
              type: "boolean",
              description: "Set to true if the reporter was muted from reporting at the time of the event. These reports won't impact the reviewState of the subject."
            },
            reportType: {
              type: "ref",
              ref: "lex:com.atproto.moderation.defs#reasonType"
            }
          }
        },
        modEventLabel: {
          type: "object",
          description: "Apply/Negate labels on a subject",
          required: ["createLabelVals", "negateLabelVals"],
          properties: {
            comment: {
              type: "string"
            },
            createLabelVals: {
              type: "array",
              items: {
                type: "string"
              }
            },
            negateLabelVals: {
              type: "array",
              items: {
                type: "string"
              }
            }
          }
        },
        modEventAcknowledge: {
          type: "object",
          properties: {
            comment: {
              type: "string"
            }
          }
        },
        modEventEscalate: {
          type: "object",
          properties: {
            comment: {
              type: "string"
            }
          }
        },
        modEventMute: {
          type: "object",
          description: "Mute incoming reports on a subject",
          required: ["durationInHours"],
          properties: {
            comment: {
              type: "string"
            },
            durationInHours: {
              type: "integer",
              description: "Indicates how long the subject should remain muted."
            }
          }
        },
        modEventUnmute: {
          type: "object",
          description: "Unmute action on a subject",
          properties: {
            comment: {
              type: "string",
              description: "Describe reasoning behind the reversal."
            }
          }
        },
        modEventMuteReporter: {
          type: "object",
          description: "Mute incoming reports from an account",
          required: ["durationInHours"],
          properties: {
            comment: {
              type: "string"
            },
            durationInHours: {
              type: "integer",
              description: "Indicates how long the account should remain muted."
            }
          }
        },
        modEventUnmuteReporter: {
          type: "object",
          description: "Unmute incoming reports from an account",
          properties: {
            comment: {
              type: "string",
              description: "Describe reasoning behind the reversal."
            }
          }
        },
        modEventEmail: {
          type: "object",
          description: "Keep a log of outgoing email to a user",
          required: ["subjectLine"],
          properties: {
            subjectLine: {
              type: "string",
              description: "The subject line of the email sent to the user."
            },
            content: {
              type: "string",
              description: "The content of the email sent to the user."
            },
            comment: {
              type: "string",
              description: "Additional comment about the outgoing comm."
            }
          }
        },
        modEventDivert: {
          type: "object",
          description: "Divert a record's blobs to a 3rd party service for further scanning/tagging",
          properties: {
            comment: {
              type: "string"
            }
          }
        },
        modEventTag: {
          type: "object",
          description: "Add/Remove a tag on a subject",
          required: ["add", "remove"],
          properties: {
            add: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Tags to be added to the subject. If already exists, won't be duplicated."
            },
            remove: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Tags to be removed to the subject. Ignores a tag If it doesn't exist, won't be duplicated."
            },
            comment: {
              type: "string",
              description: "Additional comment about added/removed tags."
            }
          }
        },
        repoView: {
          type: "object",
          required: [
            "did",
            "handle",
            "relatedRecords",
            "indexedAt",
            "moderation"
          ],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            email: {
              type: "string"
            },
            relatedRecords: {
              type: "array",
              items: {
                type: "unknown"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            moderation: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#moderation"
            },
            invitedBy: {
              type: "ref",
              ref: "lex:com.atproto.server.defs#inviteCode"
            },
            invitesDisabled: {
              type: "boolean"
            },
            inviteNote: {
              type: "string"
            },
            deactivatedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        repoViewDetail: {
          type: "object",
          required: [
            "did",
            "handle",
            "relatedRecords",
            "indexedAt",
            "moderation"
          ],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            email: {
              type: "string"
            },
            relatedRecords: {
              type: "array",
              items: {
                type: "unknown"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            moderation: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#moderationDetail"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            invitedBy: {
              type: "ref",
              ref: "lex:com.atproto.server.defs#inviteCode"
            },
            invites: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.server.defs#inviteCode"
              }
            },
            invitesDisabled: {
              type: "boolean"
            },
            inviteNote: {
              type: "string"
            },
            emailConfirmedAt: {
              type: "string",
              format: "datetime"
            },
            deactivatedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        repoViewNotFound: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        },
        recordView: {
          type: "object",
          required: [
            "uri",
            "cid",
            "value",
            "blobCids",
            "indexedAt",
            "moderation",
            "repo"
          ],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            value: {
              type: "unknown"
            },
            blobCids: {
              type: "array",
              items: {
                type: "string",
                format: "cid"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            moderation: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#moderation"
            },
            repo: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#repoView"
            }
          }
        },
        recordViewDetail: {
          type: "object",
          required: [
            "uri",
            "cid",
            "value",
            "blobs",
            "indexedAt",
            "moderation",
            "repo"
          ],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            value: {
              type: "unknown"
            },
            blobs: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#blobView"
              }
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            moderation: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#moderationDetail"
            },
            repo: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#repoView"
            }
          }
        },
        recordViewNotFound: {
          type: "object",
          required: ["uri"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        moderation: {
          type: "object",
          properties: {
            subjectStatus: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#subjectStatusView"
            }
          }
        },
        moderationDetail: {
          type: "object",
          properties: {
            subjectStatus: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#subjectStatusView"
            }
          }
        },
        blobView: {
          type: "object",
          required: ["cid", "mimeType", "size", "createdAt"],
          properties: {
            cid: {
              type: "string",
              format: "cid"
            },
            mimeType: {
              type: "string"
            },
            size: {
              type: "integer"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            details: {
              type: "union",
              refs: [
                "lex:tools.ozone.moderation.defs#imageDetails",
                "lex:tools.ozone.moderation.defs#videoDetails"
              ]
            },
            moderation: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#moderation"
            }
          }
        },
        imageDetails: {
          type: "object",
          required: ["width", "height"],
          properties: {
            width: {
              type: "integer"
            },
            height: {
              type: "integer"
            }
          }
        },
        videoDetails: {
          type: "object",
          required: ["width", "height", "length"],
          properties: {
            width: {
              type: "integer"
            },
            height: {
              type: "integer"
            },
            length: {
              type: "integer"
            }
          }
        }
      }
    },
    ToolsOzoneModerationEmitEvent: {
      lexicon: 1,
      id: "tools.ozone.moderation.emitEvent",
      defs: {
        main: {
          type: "procedure",
          description: "Take a moderation action on an actor.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["event", "subject", "createdBy"],
              properties: {
                event: {
                  type: "union",
                  refs: [
                    "lex:tools.ozone.moderation.defs#modEventTakedown",
                    "lex:tools.ozone.moderation.defs#modEventAcknowledge",
                    "lex:tools.ozone.moderation.defs#modEventEscalate",
                    "lex:tools.ozone.moderation.defs#modEventComment",
                    "lex:tools.ozone.moderation.defs#modEventLabel",
                    "lex:tools.ozone.moderation.defs#modEventReport",
                    "lex:tools.ozone.moderation.defs#modEventMute",
                    "lex:tools.ozone.moderation.defs#modEventUnmute",
                    "lex:tools.ozone.moderation.defs#modEventMuteReporter",
                    "lex:tools.ozone.moderation.defs#modEventUnmuteReporter",
                    "lex:tools.ozone.moderation.defs#modEventReverseTakedown",
                    "lex:tools.ozone.moderation.defs#modEventEmail",
                    "lex:tools.ozone.moderation.defs#modEventTag"
                  ]
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                },
                subjectBlobCids: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "cid"
                  }
                },
                createdBy: {
                  type: "string",
                  format: "did"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#modEventView"
            }
          },
          errors: [
            {
              name: "SubjectHasAction"
            }
          ]
        }
      }
    },
    ToolsOzoneModerationGetEvent: {
      lexicon: 1,
      id: "tools.ozone.moderation.getEvent",
      defs: {
        main: {
          type: "query",
          description: "Get details about a moderation event.",
          parameters: {
            type: "params",
            required: ["id"],
            properties: {
              id: {
                type: "integer"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#modEventViewDetail"
            }
          }
        }
      }
    },
    ToolsOzoneModerationGetRecord: {
      lexicon: 1,
      id: "tools.ozone.moderation.getRecord",
      defs: {
        main: {
          type: "query",
          description: "Get details about a record.",
          parameters: {
            type: "params",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#recordViewDetail"
            }
          },
          errors: [
            {
              name: "RecordNotFound"
            }
          ]
        }
      }
    },
    ToolsOzoneModerationGetRepo: {
      lexicon: 1,
      id: "tools.ozone.moderation.getRepo",
      defs: {
        main: {
          type: "query",
          description: "Get details about a repository.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#repoViewDetail"
            }
          },
          errors: [
            {
              name: "RepoNotFound"
            }
          ]
        }
      }
    },
    ToolsOzoneModerationQueryEvents: {
      lexicon: 1,
      id: "tools.ozone.moderation.queryEvents",
      defs: {
        main: {
          type: "query",
          description: "List moderation events related to a subject.",
          parameters: {
            type: "params",
            properties: {
              types: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "The types of events (fully qualified string in the format of tools.ozone.moderation.defs#modEvent<name>) to filter by. If not specified, all events are returned."
              },
              createdBy: {
                type: "string",
                format: "did"
              },
              sortDirection: {
                type: "string",
                default: "desc",
                enum: ["asc", "desc"],
                description: "Sort direction for the events. Defaults to descending order of created at timestamp."
              },
              createdAfter: {
                type: "string",
                format: "datetime",
                description: "Retrieve events created after a given timestamp"
              },
              createdBefore: {
                type: "string",
                format: "datetime",
                description: "Retrieve events created before a given timestamp"
              },
              subject: {
                type: "string",
                format: "uri"
              },
              includeAllUserRecords: {
                type: "boolean",
                default: !1,
                description: "If true, events on all record types (posts, lists, profile etc.) owned by the did are returned"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              hasComment: {
                type: "boolean",
                description: "If true, only events with comments are returned"
              },
              comment: {
                type: "string",
                description: "If specified, only events with comments containing the keyword are returned"
              },
              addedLabels: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "If specified, only events where all of these labels were added are returned"
              },
              removedLabels: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "If specified, only events where all of these labels were removed are returned"
              },
              addedTags: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "If specified, only events where all of these tags were added are returned"
              },
              removedTags: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "If specified, only events where all of these tags were removed are returned"
              },
              reportTypes: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["events"],
              properties: {
                cursor: {
                  type: "string"
                },
                events: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.moderation.defs#modEventView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneModerationQueryStatuses: {
      lexicon: 1,
      id: "tools.ozone.moderation.queryStatuses",
      defs: {
        main: {
          type: "query",
          description: "View moderation statuses of subjects (record or repo).",
          parameters: {
            type: "params",
            properties: {
              subject: {
                type: "string",
                format: "uri"
              },
              comment: {
                type: "string",
                description: "Search subjects by keyword from comments"
              },
              reportedAfter: {
                type: "string",
                format: "datetime",
                description: "Search subjects reported after a given timestamp"
              },
              reportedBefore: {
                type: "string",
                format: "datetime",
                description: "Search subjects reported before a given timestamp"
              },
              reviewedAfter: {
                type: "string",
                format: "datetime",
                description: "Search subjects reviewed after a given timestamp"
              },
              reviewedBefore: {
                type: "string",
                format: "datetime",
                description: "Search subjects reviewed before a given timestamp"
              },
              includeMuted: {
                type: "boolean",
                description: "By default, we don't include muted subjects in the results. Set this to true to include them."
              },
              onlyMuted: {
                type: "boolean",
                description: "When set to true, only muted subjects and reporters will be returned."
              },
              reviewState: {
                type: "string",
                description: "Specify when fetching subjects in a certain state"
              },
              ignoreSubjects: {
                type: "array",
                items: {
                  type: "string",
                  format: "uri"
                }
              },
              lastReviewedBy: {
                type: "string",
                format: "did",
                description: "Get all subject statuses that were reviewed by a specific moderator"
              },
              sortField: {
                type: "string",
                default: "lastReportedAt",
                enum: ["lastReviewedAt", "lastReportedAt"]
              },
              sortDirection: {
                type: "string",
                default: "desc",
                enum: ["asc", "desc"]
              },
              takendown: {
                type: "boolean",
                description: "Get subjects that were taken down"
              },
              appealed: {
                type: "boolean",
                description: "Get subjects in unresolved appealed status"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              tags: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              excludeTags: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subjectStatuses"],
              properties: {
                cursor: {
                  type: "string"
                },
                subjectStatuses: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.moderation.defs#subjectStatusView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneModerationSearchRepos: {
      lexicon: 1,
      id: "tools.ozone.moderation.searchRepos",
      defs: {
        main: {
          type: "query",
          description: "Find repositories based on a search term.",
          parameters: {
            type: "params",
            properties: {
              term: {
                type: "string",
                description: "DEPRECATED: use 'q' instead"
              },
              q: {
                type: "string"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repos"],
              properties: {
                cursor: {
                  type: "string"
                },
                repos: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.moderation.defs#repoView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneServerGetConfig: {
      lexicon: 1,
      id: "tools.ozone.server.getConfig",
      defs: {
        main: {
          type: "query",
          description: "Get details about ozone's server configuration.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                appview: {
                  type: "ref",
                  ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                },
                pds: {
                  type: "ref",
                  ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                },
                blobDivert: {
                  type: "ref",
                  ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                },
                chat: {
                  type: "ref",
                  ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:tools.ozone.server.getConfig#viewerConfig"
                }
              }
            }
          }
        },
        serviceConfig: {
          type: "object",
          properties: {
            url: {
              type: "string",
              format: "uri"
            }
          }
        },
        viewerConfig: {
          type: "object",
          properties: {
            role: {
              type: "string",
              knownValues: [
                "tools.ozone.team.defs#roleAdmin",
                "tools.ozone.team.defs#roleModerator",
                "tools.ozone.team.defs#roleTriage"
              ]
            }
          }
        }
      }
    },
    ToolsOzoneTeamAddMember: {
      lexicon: 1,
      id: "tools.ozone.team.addMember",
      defs: {
        main: {
          type: "procedure",
          description: "Add a member to the ozone team. Requires admin role.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "role"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                role: {
                  type: "string",
                  knownValues: [
                    "tools.ozone.team.defs#roleAdmin",
                    "tools.ozone.team.defs#roleModerator",
                    "tools.ozone.team.defs#roleTriage"
                  ]
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.team.defs#member"
            }
          },
          errors: [
            {
              name: "MemberAlreadyExists",
              description: "Member already exists in the team."
            }
          ]
        }
      }
    },
    ToolsOzoneTeamDefs: {
      lexicon: 1,
      id: "tools.ozone.team.defs",
      defs: {
        member: {
          type: "object",
          required: ["did", "role"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            disabled: {
              type: "boolean"
            },
            profile: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewDetailed"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            updatedAt: {
              type: "string",
              format: "datetime"
            },
            lastUpdatedBy: {
              type: "string"
            },
            role: {
              type: "string",
              knownValues: [
                "lex:tools.ozone.team.defs#roleAdmin",
                "lex:tools.ozone.team.defs#roleModerator",
                "lex:tools.ozone.team.defs#roleTriage"
              ]
            }
          }
        },
        roleAdmin: {
          type: "token",
          description: "Admin role. Highest level of access, can perform all actions."
        },
        roleModerator: {
          type: "token",
          description: "Moderator role. Can perform most actions."
        },
        roleTriage: {
          type: "token",
          description: "Triage role. Mostly intended for monitoring and escalating issues."
        }
      }
    },
    ToolsOzoneTeamDeleteMember: {
      lexicon: 1,
      id: "tools.ozone.team.deleteMember",
      defs: {
        main: {
          type: "procedure",
          description: "Delete a member from ozone team. Requires admin role.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            }
          },
          errors: [
            {
              name: "MemberNotFound",
              description: "The member being deleted does not exist"
            },
            {
              name: "CannotDeleteSelf",
              description: "You can not delete yourself from the team"
            }
          ]
        }
      }
    },
    ToolsOzoneTeamListMembers: {
      lexicon: 1,
      id: "tools.ozone.team.listMembers",
      defs: {
        main: {
          type: "query",
          description: "List all members with access to the ozone service.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["members"],
              properties: {
                cursor: {
                  type: "string"
                },
                members: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.team.defs#member"
                  }
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneTeamUpdateMember: {
      lexicon: 1,
      id: "tools.ozone.team.updateMember",
      defs: {
        main: {
          type: "procedure",
          description: "Update a member in the ozone service. Requires admin role.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                disabled: {
                  type: "boolean"
                },
                role: {
                  type: "string",
                  knownValues: [
                    "tools.ozone.team.defs#roleAdmin",
                    "tools.ozone.team.defs#roleModerator",
                    "tools.ozone.team.defs#roleTriage"
                  ]
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.team.defs#member"
            }
          },
          errors: [
            {
              name: "MemberNotFound",
              description: "The member being updated does not exist in the team"
            }
          ]
        }
      }
    }
  }, t.schemas = Object.values(t.schemaDict), t.lexicons = new e.Lexicons(t.schemas), t.ids = {
    ComAtprotoAdminDefs: "com.atproto.admin.defs",
    ComAtprotoAdminDeleteAccount: "com.atproto.admin.deleteAccount",
    ComAtprotoAdminDisableAccountInvites: "com.atproto.admin.disableAccountInvites",
    ComAtprotoAdminDisableInviteCodes: "com.atproto.admin.disableInviteCodes",
    ComAtprotoAdminEnableAccountInvites: "com.atproto.admin.enableAccountInvites",
    ComAtprotoAdminGetAccountInfo: "com.atproto.admin.getAccountInfo",
    ComAtprotoAdminGetAccountInfos: "com.atproto.admin.getAccountInfos",
    ComAtprotoAdminGetInviteCodes: "com.atproto.admin.getInviteCodes",
    ComAtprotoAdminGetSubjectStatus: "com.atproto.admin.getSubjectStatus",
    ComAtprotoAdminSearchAccounts: "com.atproto.admin.searchAccounts",
    ComAtprotoAdminSendEmail: "com.atproto.admin.sendEmail",
    ComAtprotoAdminUpdateAccountEmail: "com.atproto.admin.updateAccountEmail",
    ComAtprotoAdminUpdateAccountHandle: "com.atproto.admin.updateAccountHandle",
    ComAtprotoAdminUpdateAccountPassword: "com.atproto.admin.updateAccountPassword",
    ComAtprotoAdminUpdateSubjectStatus: "com.atproto.admin.updateSubjectStatus",
    ComAtprotoIdentityGetRecommendedDidCredentials: "com.atproto.identity.getRecommendedDidCredentials",
    ComAtprotoIdentityRequestPlcOperationSignature: "com.atproto.identity.requestPlcOperationSignature",
    ComAtprotoIdentityResolveHandle: "com.atproto.identity.resolveHandle",
    ComAtprotoIdentitySignPlcOperation: "com.atproto.identity.signPlcOperation",
    ComAtprotoIdentitySubmitPlcOperation: "com.atproto.identity.submitPlcOperation",
    ComAtprotoIdentityUpdateHandle: "com.atproto.identity.updateHandle",
    ComAtprotoLabelDefs: "com.atproto.label.defs",
    ComAtprotoLabelQueryLabels: "com.atproto.label.queryLabels",
    ComAtprotoLabelSubscribeLabels: "com.atproto.label.subscribeLabels",
    ComAtprotoModerationCreateReport: "com.atproto.moderation.createReport",
    ComAtprotoModerationDefs: "com.atproto.moderation.defs",
    ComAtprotoRepoApplyWrites: "com.atproto.repo.applyWrites",
    ComAtprotoRepoCreateRecord: "com.atproto.repo.createRecord",
    ComAtprotoRepoDeleteRecord: "com.atproto.repo.deleteRecord",
    ComAtprotoRepoDescribeRepo: "com.atproto.repo.describeRepo",
    ComAtprotoRepoGetRecord: "com.atproto.repo.getRecord",
    ComAtprotoRepoImportRepo: "com.atproto.repo.importRepo",
    ComAtprotoRepoListMissingBlobs: "com.atproto.repo.listMissingBlobs",
    ComAtprotoRepoListRecords: "com.atproto.repo.listRecords",
    ComAtprotoRepoPutRecord: "com.atproto.repo.putRecord",
    ComAtprotoRepoStrongRef: "com.atproto.repo.strongRef",
    ComAtprotoRepoUploadBlob: "com.atproto.repo.uploadBlob",
    ComAtprotoServerActivateAccount: "com.atproto.server.activateAccount",
    ComAtprotoServerCheckAccountStatus: "com.atproto.server.checkAccountStatus",
    ComAtprotoServerConfirmEmail: "com.atproto.server.confirmEmail",
    ComAtprotoServerCreateAccount: "com.atproto.server.createAccount",
    ComAtprotoServerCreateAppPassword: "com.atproto.server.createAppPassword",
    ComAtprotoServerCreateInviteCode: "com.atproto.server.createInviteCode",
    ComAtprotoServerCreateInviteCodes: "com.atproto.server.createInviteCodes",
    ComAtprotoServerCreateSession: "com.atproto.server.createSession",
    ComAtprotoServerDeactivateAccount: "com.atproto.server.deactivateAccount",
    ComAtprotoServerDefs: "com.atproto.server.defs",
    ComAtprotoServerDeleteAccount: "com.atproto.server.deleteAccount",
    ComAtprotoServerDeleteSession: "com.atproto.server.deleteSession",
    ComAtprotoServerDescribeServer: "com.atproto.server.describeServer",
    ComAtprotoServerGetAccountInviteCodes: "com.atproto.server.getAccountInviteCodes",
    ComAtprotoServerGetServiceAuth: "com.atproto.server.getServiceAuth",
    ComAtprotoServerGetSession: "com.atproto.server.getSession",
    ComAtprotoServerListAppPasswords: "com.atproto.server.listAppPasswords",
    ComAtprotoServerRefreshSession: "com.atproto.server.refreshSession",
    ComAtprotoServerRequestAccountDelete: "com.atproto.server.requestAccountDelete",
    ComAtprotoServerRequestEmailConfirmation: "com.atproto.server.requestEmailConfirmation",
    ComAtprotoServerRequestEmailUpdate: "com.atproto.server.requestEmailUpdate",
    ComAtprotoServerRequestPasswordReset: "com.atproto.server.requestPasswordReset",
    ComAtprotoServerReserveSigningKey: "com.atproto.server.reserveSigningKey",
    ComAtprotoServerResetPassword: "com.atproto.server.resetPassword",
    ComAtprotoServerRevokeAppPassword: "com.atproto.server.revokeAppPassword",
    ComAtprotoServerUpdateEmail: "com.atproto.server.updateEmail",
    ComAtprotoSyncGetBlob: "com.atproto.sync.getBlob",
    ComAtprotoSyncGetBlocks: "com.atproto.sync.getBlocks",
    ComAtprotoSyncGetCheckout: "com.atproto.sync.getCheckout",
    ComAtprotoSyncGetHead: "com.atproto.sync.getHead",
    ComAtprotoSyncGetLatestCommit: "com.atproto.sync.getLatestCommit",
    ComAtprotoSyncGetRecord: "com.atproto.sync.getRecord",
    ComAtprotoSyncGetRepo: "com.atproto.sync.getRepo",
    ComAtprotoSyncGetRepoStatus: "com.atproto.sync.getRepoStatus",
    ComAtprotoSyncListBlobs: "com.atproto.sync.listBlobs",
    ComAtprotoSyncListRepos: "com.atproto.sync.listRepos",
    ComAtprotoSyncNotifyOfUpdate: "com.atproto.sync.notifyOfUpdate",
    ComAtprotoSyncRequestCrawl: "com.atproto.sync.requestCrawl",
    ComAtprotoSyncSubscribeRepos: "com.atproto.sync.subscribeRepos",
    ComAtprotoTempCheckSignupQueue: "com.atproto.temp.checkSignupQueue",
    ComAtprotoTempFetchLabels: "com.atproto.temp.fetchLabels",
    ComAtprotoTempRequestPhoneVerification: "com.atproto.temp.requestPhoneVerification",
    AppBskyActorDefs: "app.bsky.actor.defs",
    AppBskyActorGetPreferences: "app.bsky.actor.getPreferences",
    AppBskyActorGetProfile: "app.bsky.actor.getProfile",
    AppBskyActorGetProfiles: "app.bsky.actor.getProfiles",
    AppBskyActorGetSuggestions: "app.bsky.actor.getSuggestions",
    AppBskyActorProfile: "app.bsky.actor.profile",
    AppBskyActorPutPreferences: "app.bsky.actor.putPreferences",
    AppBskyActorSearchActors: "app.bsky.actor.searchActors",
    AppBskyActorSearchActorsTypeahead: "app.bsky.actor.searchActorsTypeahead",
    AppBskyEmbedExternal: "app.bsky.embed.external",
    AppBskyEmbedImages: "app.bsky.embed.images",
    AppBskyEmbedRecord: "app.bsky.embed.record",
    AppBskyEmbedRecordWithMedia: "app.bsky.embed.recordWithMedia",
    AppBskyFeedDefs: "app.bsky.feed.defs",
    AppBskyFeedDescribeFeedGenerator: "app.bsky.feed.describeFeedGenerator",
    AppBskyFeedGenerator: "app.bsky.feed.generator",
    AppBskyFeedGetActorFeeds: "app.bsky.feed.getActorFeeds",
    AppBskyFeedGetActorLikes: "app.bsky.feed.getActorLikes",
    AppBskyFeedGetAuthorFeed: "app.bsky.feed.getAuthorFeed",
    AppBskyFeedGetFeed: "app.bsky.feed.getFeed",
    AppBskyFeedGetFeedGenerator: "app.bsky.feed.getFeedGenerator",
    AppBskyFeedGetFeedGenerators: "app.bsky.feed.getFeedGenerators",
    AppBskyFeedGetFeedSkeleton: "app.bsky.feed.getFeedSkeleton",
    AppBskyFeedGetLikes: "app.bsky.feed.getLikes",
    AppBskyFeedGetListFeed: "app.bsky.feed.getListFeed",
    AppBskyFeedGetPostThread: "app.bsky.feed.getPostThread",
    AppBskyFeedGetPosts: "app.bsky.feed.getPosts",
    AppBskyFeedGetRepostedBy: "app.bsky.feed.getRepostedBy",
    AppBskyFeedGetSuggestedFeeds: "app.bsky.feed.getSuggestedFeeds",
    AppBskyFeedGetTimeline: "app.bsky.feed.getTimeline",
    AppBskyFeedLike: "app.bsky.feed.like",
    AppBskyFeedPost: "app.bsky.feed.post",
    AppBskyFeedRepost: "app.bsky.feed.repost",
    AppBskyFeedSearchPosts: "app.bsky.feed.searchPosts",
    AppBskyFeedSendInteractions: "app.bsky.feed.sendInteractions",
    AppBskyFeedThreadgate: "app.bsky.feed.threadgate",
    AppBskyGraphBlock: "app.bsky.graph.block",
    AppBskyGraphDefs: "app.bsky.graph.defs",
    AppBskyGraphFollow: "app.bsky.graph.follow",
    AppBskyGraphGetActorStarterPacks: "app.bsky.graph.getActorStarterPacks",
    AppBskyGraphGetBlocks: "app.bsky.graph.getBlocks",
    AppBskyGraphGetFollowers: "app.bsky.graph.getFollowers",
    AppBskyGraphGetFollows: "app.bsky.graph.getFollows",
    AppBskyGraphGetKnownFollowers: "app.bsky.graph.getKnownFollowers",
    AppBskyGraphGetList: "app.bsky.graph.getList",
    AppBskyGraphGetListBlocks: "app.bsky.graph.getListBlocks",
    AppBskyGraphGetListMutes: "app.bsky.graph.getListMutes",
    AppBskyGraphGetLists: "app.bsky.graph.getLists",
    AppBskyGraphGetMutes: "app.bsky.graph.getMutes",
    AppBskyGraphGetRelationships: "app.bsky.graph.getRelationships",
    AppBskyGraphGetStarterPack: "app.bsky.graph.getStarterPack",
    AppBskyGraphGetStarterPacks: "app.bsky.graph.getStarterPacks",
    AppBskyGraphGetSuggestedFollowsByActor: "app.bsky.graph.getSuggestedFollowsByActor",
    AppBskyGraphList: "app.bsky.graph.list",
    AppBskyGraphListblock: "app.bsky.graph.listblock",
    AppBskyGraphListitem: "app.bsky.graph.listitem",
    AppBskyGraphMuteActor: "app.bsky.graph.muteActor",
    AppBskyGraphMuteActorList: "app.bsky.graph.muteActorList",
    AppBskyGraphMuteThread: "app.bsky.graph.muteThread",
    AppBskyGraphStarterpack: "app.bsky.graph.starterpack",
    AppBskyGraphUnmuteActor: "app.bsky.graph.unmuteActor",
    AppBskyGraphUnmuteActorList: "app.bsky.graph.unmuteActorList",
    AppBskyGraphUnmuteThread: "app.bsky.graph.unmuteThread",
    AppBskyLabelerDefs: "app.bsky.labeler.defs",
    AppBskyLabelerGetServices: "app.bsky.labeler.getServices",
    AppBskyLabelerService: "app.bsky.labeler.service",
    AppBskyNotificationGetUnreadCount: "app.bsky.notification.getUnreadCount",
    AppBskyNotificationListNotifications: "app.bsky.notification.listNotifications",
    AppBskyNotificationPutPreferences: "app.bsky.notification.putPreferences",
    AppBskyNotificationRegisterPush: "app.bsky.notification.registerPush",
    AppBskyNotificationUpdateSeen: "app.bsky.notification.updateSeen",
    AppBskyRichtextFacet: "app.bsky.richtext.facet",
    AppBskyUnspeccedDefs: "app.bsky.unspecced.defs",
    AppBskyUnspeccedGetPopularFeedGenerators: "app.bsky.unspecced.getPopularFeedGenerators",
    AppBskyUnspeccedGetSuggestionsSkeleton: "app.bsky.unspecced.getSuggestionsSkeleton",
    AppBskyUnspeccedGetTaggedSuggestions: "app.bsky.unspecced.getTaggedSuggestions",
    AppBskyUnspeccedSearchActorsSkeleton: "app.bsky.unspecced.searchActorsSkeleton",
    AppBskyUnspeccedSearchPostsSkeleton: "app.bsky.unspecced.searchPostsSkeleton",
    ChatBskyActorDeclaration: "chat.bsky.actor.declaration",
    ChatBskyActorDefs: "chat.bsky.actor.defs",
    ChatBskyActorDeleteAccount: "chat.bsky.actor.deleteAccount",
    ChatBskyActorExportAccountData: "chat.bsky.actor.exportAccountData",
    ChatBskyConvoDefs: "chat.bsky.convo.defs",
    ChatBskyConvoDeleteMessageForSelf: "chat.bsky.convo.deleteMessageForSelf",
    ChatBskyConvoGetConvo: "chat.bsky.convo.getConvo",
    ChatBskyConvoGetConvoForMembers: "chat.bsky.convo.getConvoForMembers",
    ChatBskyConvoGetLog: "chat.bsky.convo.getLog",
    ChatBskyConvoGetMessages: "chat.bsky.convo.getMessages",
    ChatBskyConvoLeaveConvo: "chat.bsky.convo.leaveConvo",
    ChatBskyConvoListConvos: "chat.bsky.convo.listConvos",
    ChatBskyConvoMuteConvo: "chat.bsky.convo.muteConvo",
    ChatBskyConvoSendMessage: "chat.bsky.convo.sendMessage",
    ChatBskyConvoSendMessageBatch: "chat.bsky.convo.sendMessageBatch",
    ChatBskyConvoUnmuteConvo: "chat.bsky.convo.unmuteConvo",
    ChatBskyConvoUpdateRead: "chat.bsky.convo.updateRead",
    ChatBskyModerationGetActorMetadata: "chat.bsky.moderation.getActorMetadata",
    ChatBskyModerationGetMessageContext: "chat.bsky.moderation.getMessageContext",
    ChatBskyModerationUpdateActorAccess: "chat.bsky.moderation.updateActorAccess",
    ToolsOzoneCommunicationCreateTemplate: "tools.ozone.communication.createTemplate",
    ToolsOzoneCommunicationDefs: "tools.ozone.communication.defs",
    ToolsOzoneCommunicationDeleteTemplate: "tools.ozone.communication.deleteTemplate",
    ToolsOzoneCommunicationListTemplates: "tools.ozone.communication.listTemplates",
    ToolsOzoneCommunicationUpdateTemplate: "tools.ozone.communication.updateTemplate",
    ToolsOzoneModerationDefs: "tools.ozone.moderation.defs",
    ToolsOzoneModerationEmitEvent: "tools.ozone.moderation.emitEvent",
    ToolsOzoneModerationGetEvent: "tools.ozone.moderation.getEvent",
    ToolsOzoneModerationGetRecord: "tools.ozone.moderation.getRecord",
    ToolsOzoneModerationGetRepo: "tools.ozone.moderation.getRepo",
    ToolsOzoneModerationQueryEvents: "tools.ozone.moderation.queryEvents",
    ToolsOzoneModerationQueryStatuses: "tools.ozone.moderation.queryStatuses",
    ToolsOzoneModerationSearchRepos: "tools.ozone.moderation.searchRepos",
    ToolsOzoneServerGetConfig: "tools.ozone.server.getConfig",
    ToolsOzoneTeamAddMember: "tools.ozone.team.addMember",
    ToolsOzoneTeamDefs: "tools.ozone.team.defs",
    ToolsOzoneTeamDeleteMember: "tools.ozone.team.deleteMember",
    ToolsOzoneTeamListMembers: "tools.ozone.team.listMembers",
    ToolsOzoneTeamUpdateMember: "tools.ozone.team.updateMember"
  };
})(Le);
var Da = {};
Object.defineProperty(Da, "__esModule", { value: !0 });
Da.toKnownErr = void 0;
const zv = q;
function Xv(t) {
  return t instanceof zv.XRPCError, t;
}
Da.toKnownErr = Xv;
var Pa = {};
Object.defineProperty(Pa, "__esModule", { value: !0 });
Pa.toKnownErr = void 0;
const Hv = q;
function Zv(t) {
  return t instanceof Hv.XRPCError, t;
}
Pa.toKnownErr = Zv;
var Ba = {};
Object.defineProperty(Ba, "__esModule", { value: !0 });
Ba.toKnownErr = void 0;
const Wv = q;
function Yv(t) {
  return t instanceof Wv.XRPCError, t;
}
Ba.toKnownErr = Yv;
var Ia = {};
Object.defineProperty(Ia, "__esModule", { value: !0 });
Ia.toKnownErr = void 0;
const Jv = q;
function Qv(t) {
  return t instanceof Jv.XRPCError, t;
}
Ia.toKnownErr = Qv;
var Ua = {};
Object.defineProperty(Ua, "__esModule", { value: !0 });
Ua.toKnownErr = void 0;
const eR = q;
function tR(t) {
  return t instanceof eR.XRPCError, t;
}
Ua.toKnownErr = tR;
var Oa = {};
Object.defineProperty(Oa, "__esModule", { value: !0 });
Oa.toKnownErr = void 0;
const rR = q;
function iR(t) {
  return t instanceof rR.XRPCError, t;
}
Oa.toKnownErr = iR;
var Ka = {};
Object.defineProperty(Ka, "__esModule", { value: !0 });
Ka.toKnownErr = void 0;
const nR = q;
function sR(t) {
  return t instanceof nR.XRPCError, t;
}
Ka.toKnownErr = sR;
var Ma = {};
Object.defineProperty(Ma, "__esModule", { value: !0 });
Ma.toKnownErr = void 0;
const aR = q;
function oR(t) {
  return t instanceof aR.XRPCError, t;
}
Ma.toKnownErr = oR;
var Na = {};
Object.defineProperty(Na, "__esModule", { value: !0 });
Na.toKnownErr = void 0;
const lR = q;
function uR(t) {
  return t instanceof lR.XRPCError, t;
}
Na.toKnownErr = uR;
var Va = {};
Object.defineProperty(Va, "__esModule", { value: !0 });
Va.toKnownErr = void 0;
const cR = q;
function dR(t) {
  return t instanceof cR.XRPCError, t;
}
Va.toKnownErr = dR;
var ja = {};
Object.defineProperty(ja, "__esModule", { value: !0 });
ja.toKnownErr = void 0;
const fR = q;
function pR(t) {
  return t instanceof fR.XRPCError, t;
}
ja.toKnownErr = pR;
var Fa = {};
Object.defineProperty(Fa, "__esModule", { value: !0 });
Fa.toKnownErr = void 0;
const hR = q;
function mR(t) {
  return t instanceof hR.XRPCError, t;
}
Fa.toKnownErr = mR;
var $a = {};
Object.defineProperty($a, "__esModule", { value: !0 });
$a.toKnownErr = void 0;
const yR = q;
function bR(t) {
  return t instanceof yR.XRPCError, t;
}
$a.toKnownErr = bR;
var Ga = {};
Object.defineProperty(Ga, "__esModule", { value: !0 });
Ga.toKnownErr = void 0;
const gR = q;
function xR(t) {
  return t instanceof gR.XRPCError, t;
}
Ga.toKnownErr = xR;
var qa = {};
Object.defineProperty(qa, "__esModule", { value: !0 });
qa.toKnownErr = void 0;
const ER = q;
function vR(t) {
  return t instanceof ER.XRPCError, t;
}
qa.toKnownErr = vR;
var za = {};
Object.defineProperty(za, "__esModule", { value: !0 });
za.toKnownErr = void 0;
const RR = q;
function AR(t) {
  return t instanceof RR.XRPCError, t;
}
za.toKnownErr = AR;
var Xa = {};
Object.defineProperty(Xa, "__esModule", { value: !0 });
Xa.toKnownErr = void 0;
const _R = q;
function wR(t) {
  return t instanceof _R.XRPCError, t;
}
Xa.toKnownErr = wR;
var Ha = {};
Object.defineProperty(Ha, "__esModule", { value: !0 });
Ha.toKnownErr = void 0;
const TR = q;
function SR(t) {
  return t instanceof TR.XRPCError, t;
}
Ha.toKnownErr = SR;
var Za = {};
Object.defineProperty(Za, "__esModule", { value: !0 });
Za.toKnownErr = void 0;
const CR = q;
function LR(t) {
  return t instanceof CR.XRPCError, t;
}
Za.toKnownErr = LR;
var Wa = {};
Object.defineProperty(Wa, "__esModule", { value: !0 });
Wa.toKnownErr = void 0;
const kR = q;
function DR(t) {
  return t instanceof kR.XRPCError, t;
}
Wa.toKnownErr = DR;
var Ya = {};
Object.defineProperty(Ya, "__esModule", { value: !0 });
Ya.toKnownErr = void 0;
const PR = q;
function BR(t) {
  return t instanceof PR.XRPCError, t;
}
Ya.toKnownErr = BR;
var Ja = {};
Object.defineProperty(Ja, "__esModule", { value: !0 });
Ja.toKnownErr = void 0;
const IR = q;
function UR(t) {
  return t instanceof IR.XRPCError, t;
}
Ja.toKnownErr = UR;
var Lt = {}, we = {};
Object.defineProperty(we, "__esModule", { value: !0 });
we.hasProp = we.isObj = void 0;
function OR(t) {
  return typeof t == "object" && t !== null;
}
we.isObj = OR;
function KR(t, e) {
  return e in t;
}
we.hasProp = KR;
Object.defineProperty(Lt, "__esModule", { value: !0 });
Lt.validateDelete = Lt.isDelete = Lt.validateUpdate = Lt.isUpdate = Lt.validateCreate = Lt.isCreate = Lt.toKnownErr = Lt.InvalidSwapError = void 0;
const Hp = q, Ts = we, Wc = Le;
let Zp = class extends Hp.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Lt.InvalidSwapError = Zp;
function MR(t) {
  return t instanceof Hp.XRPCError && t.error === "InvalidSwap" ? new Zp(t) : t;
}
Lt.toKnownErr = MR;
function NR(t) {
  return (0, Ts.isObj)(t) && (0, Ts.hasProp)(t, "$type") && t.$type === "com.atproto.repo.applyWrites#create";
}
Lt.isCreate = NR;
function VR(t) {
  return Wc.lexicons.validate("com.atproto.repo.applyWrites#create", t);
}
Lt.validateCreate = VR;
function jR(t) {
  return (0, Ts.isObj)(t) && (0, Ts.hasProp)(t, "$type") && t.$type === "com.atproto.repo.applyWrites#update";
}
Lt.isUpdate = jR;
function FR(t) {
  return Wc.lexicons.validate("com.atproto.repo.applyWrites#update", t);
}
Lt.validateUpdate = FR;
function $R(t) {
  return (0, Ts.isObj)(t) && (0, Ts.hasProp)(t, "$type") && t.$type === "com.atproto.repo.applyWrites#delete";
}
Lt.isDelete = $R;
function GR(t) {
  return Wc.lexicons.validate("com.atproto.repo.applyWrites#delete", t);
}
Lt.validateDelete = GR;
var Nn = {};
Object.defineProperty(Nn, "__esModule", { value: !0 });
Nn.toKnownErr = Nn.InvalidSwapError = void 0;
const Wp = q;
let Yp = class extends Wp.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Nn.InvalidSwapError = Yp;
function qR(t) {
  return t instanceof Wp.XRPCError && t.error === "InvalidSwap" ? new Yp(t) : t;
}
Nn.toKnownErr = qR;
var Vn = {};
Object.defineProperty(Vn, "__esModule", { value: !0 });
Vn.toKnownErr = Vn.InvalidSwapError = void 0;
const Jp = q;
let Qp = class extends Jp.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Vn.InvalidSwapError = Qp;
function zR(t) {
  return t instanceof Jp.XRPCError && t.error === "InvalidSwap" ? new Qp(t) : t;
}
Vn.toKnownErr = zR;
var Qa = {};
Object.defineProperty(Qa, "__esModule", { value: !0 });
Qa.toKnownErr = void 0;
const XR = q;
function HR(t) {
  return t instanceof XR.XRPCError, t;
}
Qa.toKnownErr = HR;
var eo = {};
Object.defineProperty(eo, "__esModule", { value: !0 });
eo.toKnownErr = void 0;
const ZR = q;
function WR(t) {
  return t instanceof ZR.XRPCError, t;
}
eo.toKnownErr = WR;
var to = {};
Object.defineProperty(to, "__esModule", { value: !0 });
to.toKnownErr = void 0;
const YR = q;
function JR(t) {
  return t instanceof YR.XRPCError, t;
}
to.toKnownErr = JR;
var Ni = {};
Object.defineProperty(Ni, "__esModule", { value: !0 });
Ni.validateRecordBlob = Ni.isRecordBlob = Ni.toKnownErr = void 0;
const QR = q, jd = we, eA = Le;
function tA(t) {
  return t instanceof QR.XRPCError, t;
}
Ni.toKnownErr = tA;
function rA(t) {
  return (0, jd.isObj)(t) && (0, jd.hasProp)(t, "$type") && t.$type === "com.atproto.repo.listMissingBlobs#recordBlob";
}
Ni.isRecordBlob = rA;
function iA(t) {
  return eA.lexicons.validate("com.atproto.repo.listMissingBlobs#recordBlob", t);
}
Ni.validateRecordBlob = iA;
var Vi = {};
Object.defineProperty(Vi, "__esModule", { value: !0 });
Vi.validateRecord = Vi.isRecord = Vi.toKnownErr = void 0;
const nA = q, Fd = we, sA = Le;
function aA(t) {
  return t instanceof nA.XRPCError, t;
}
Vi.toKnownErr = aA;
function oA(t) {
  return (0, Fd.isObj)(t) && (0, Fd.hasProp)(t, "$type") && t.$type === "com.atproto.repo.listRecords#record";
}
Vi.isRecord = oA;
function lA(t) {
  return sA.lexicons.validate("com.atproto.repo.listRecords#record", t);
}
Vi.validateRecord = lA;
var jn = {};
Object.defineProperty(jn, "__esModule", { value: !0 });
jn.toKnownErr = jn.InvalidSwapError = void 0;
const eh = q;
class th extends eh.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
jn.InvalidSwapError = th;
function uA(t) {
  return t instanceof eh.XRPCError && t.error === "InvalidSwap" ? new th(t) : t;
}
jn.toKnownErr = uA;
var ro = {};
Object.defineProperty(ro, "__esModule", { value: !0 });
ro.toKnownErr = void 0;
const cA = q;
function dA(t) {
  return t instanceof cA.XRPCError, t;
}
ro.toKnownErr = dA;
var io = {};
Object.defineProperty(io, "__esModule", { value: !0 });
io.toKnownErr = void 0;
const fA = q;
function pA(t) {
  return t instanceof fA.XRPCError, t;
}
io.toKnownErr = pA;
var no = {};
Object.defineProperty(no, "__esModule", { value: !0 });
no.toKnownErr = void 0;
const hA = q;
function mA(t) {
  return t instanceof hA.XRPCError, t;
}
no.toKnownErr = mA;
var Rr = {};
Object.defineProperty(Rr, "__esModule", { value: !0 });
Rr.toKnownErr = Rr.InvalidEmailError = Rr.InvalidTokenError = Rr.ExpiredTokenError = Rr.AccountNotFoundError = void 0;
const so = q;
class rh extends so.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Rr.AccountNotFoundError = rh;
let ih = class extends so.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Rr.ExpiredTokenError = ih;
let nh = class extends so.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Rr.InvalidTokenError = nh;
class sh extends so.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Rr.InvalidEmailError = sh;
function yA(t) {
  if (t instanceof so.XRPCError) {
    if (t.error === "AccountNotFound")
      return new rh(t);
    if (t.error === "ExpiredToken")
      return new ih(t);
    if (t.error === "InvalidToken")
      return new nh(t);
    if (t.error === "InvalidEmail")
      return new sh(t);
  }
  return t;
}
Rr.toKnownErr = yA;
var kt = {};
Object.defineProperty(kt, "__esModule", { value: !0 });
kt.toKnownErr = kt.IncompatibleDidDocError = kt.UnresolvableDidError = kt.UnsupportedDomainError = kt.HandleNotAvailableError = kt.InvalidInviteCodeError = kt.InvalidPasswordError = kt.InvalidHandleError = void 0;
const _n = q;
class ah extends _n.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
kt.InvalidHandleError = ah;
class oh extends _n.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
kt.InvalidPasswordError = oh;
class lh extends _n.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
kt.InvalidInviteCodeError = lh;
class uh extends _n.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
kt.HandleNotAvailableError = uh;
class ch extends _n.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
kt.UnsupportedDomainError = ch;
class dh extends _n.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
kt.UnresolvableDidError = dh;
class fh extends _n.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
kt.IncompatibleDidDocError = fh;
function bA(t) {
  if (t instanceof _n.XRPCError) {
    if (t.error === "InvalidHandle")
      return new ah(t);
    if (t.error === "InvalidPassword")
      return new oh(t);
    if (t.error === "InvalidInviteCode")
      return new lh(t);
    if (t.error === "HandleNotAvailable")
      return new uh(t);
    if (t.error === "UnsupportedDomain")
      return new ch(t);
    if (t.error === "UnresolvableDid")
      return new dh(t);
    if (t.error === "IncompatibleDidDoc")
      return new fh(t);
  }
  return t;
}
kt.toKnownErr = bA;
var Vr = {};
Object.defineProperty(Vr, "__esModule", { value: !0 });
Vr.validateAppPassword = Vr.isAppPassword = Vr.toKnownErr = Vr.AccountTakedownError = void 0;
const ph = q, $d = we, gA = Le;
let hh = class extends ph.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Vr.AccountTakedownError = hh;
function xA(t) {
  return t instanceof ph.XRPCError && t.error === "AccountTakedown" ? new hh(t) : t;
}
Vr.toKnownErr = xA;
function EA(t) {
  return (0, $d.isObj)(t) && (0, $d.hasProp)(t, "$type") && t.$type === "com.atproto.server.createAppPassword#appPassword";
}
Vr.isAppPassword = EA;
function vA(t) {
  return gA.lexicons.validate("com.atproto.server.createAppPassword#appPassword", t);
}
Vr.validateAppPassword = vA;
var ao = {};
Object.defineProperty(ao, "__esModule", { value: !0 });
ao.toKnownErr = void 0;
const RA = q;
function AA(t) {
  return t instanceof RA.XRPCError, t;
}
ao.toKnownErr = AA;
var ji = {};
Object.defineProperty(ji, "__esModule", { value: !0 });
ji.validateAccountCodes = ji.isAccountCodes = ji.toKnownErr = void 0;
const _A = q, Gd = we, wA = Le;
function TA(t) {
  return t instanceof _A.XRPCError, t;
}
ji.toKnownErr = TA;
function SA(t) {
  return (0, Gd.isObj)(t) && (0, Gd.hasProp)(t, "$type") && t.$type === "com.atproto.server.createInviteCodes#accountCodes";
}
ji.isAccountCodes = SA;
function CA(t) {
  return wA.lexicons.validate("com.atproto.server.createInviteCodes#accountCodes", t);
}
ji.validateAccountCodes = CA;
var Fi = {};
Object.defineProperty(Fi, "__esModule", { value: !0 });
Fi.toKnownErr = Fi.AuthFactorTokenRequiredError = Fi.AccountTakedownError = void 0;
const Yc = q;
let mh = class extends Yc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Fi.AccountTakedownError = mh;
class yh extends Yc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Fi.AuthFactorTokenRequiredError = yh;
function LA(t) {
  if (t instanceof Yc.XRPCError) {
    if (t.error === "AccountTakedown")
      return new mh(t);
    if (t.error === "AuthFactorTokenRequired")
      return new yh(t);
  }
  return t;
}
Fi.toKnownErr = LA;
var oo = {};
Object.defineProperty(oo, "__esModule", { value: !0 });
oo.toKnownErr = void 0;
const kA = q;
function DA(t) {
  return t instanceof kA.XRPCError, t;
}
oo.toKnownErr = DA;
var $i = {};
Object.defineProperty($i, "__esModule", { value: !0 });
$i.toKnownErr = $i.InvalidTokenError = $i.ExpiredTokenError = void 0;
const Jc = q;
let bh = class extends Jc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
$i.ExpiredTokenError = bh;
let gh = class extends Jc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
$i.InvalidTokenError = gh;
function PA(t) {
  if (t instanceof Jc.XRPCError) {
    if (t.error === "ExpiredToken")
      return new bh(t);
    if (t.error === "InvalidToken")
      return new gh(t);
  }
  return t;
}
$i.toKnownErr = PA;
var lo = {};
Object.defineProperty(lo, "__esModule", { value: !0 });
lo.toKnownErr = void 0;
const BA = q;
function IA(t) {
  return t instanceof BA.XRPCError, t;
}
lo.toKnownErr = IA;
var Ar = {};
Object.defineProperty(Ar, "__esModule", { value: !0 });
Ar.validateContact = Ar.isContact = Ar.validateLinks = Ar.isLinks = Ar.toKnownErr = void 0;
const UA = q, vu = we, xh = Le;
function OA(t) {
  return t instanceof UA.XRPCError, t;
}
Ar.toKnownErr = OA;
function KA(t) {
  return (0, vu.isObj)(t) && (0, vu.hasProp)(t, "$type") && t.$type === "com.atproto.server.describeServer#links";
}
Ar.isLinks = KA;
function MA(t) {
  return xh.lexicons.validate("com.atproto.server.describeServer#links", t);
}
Ar.validateLinks = MA;
function NA(t) {
  return (0, vu.isObj)(t) && (0, vu.hasProp)(t, "$type") && t.$type === "com.atproto.server.describeServer#contact";
}
Ar.isContact = NA;
function VA(t) {
  return xh.lexicons.validate("com.atproto.server.describeServer#contact", t);
}
Ar.validateContact = VA;
var Fn = {};
Object.defineProperty(Fn, "__esModule", { value: !0 });
Fn.toKnownErr = Fn.DuplicateCreateError = void 0;
const Eh = q;
class vh extends Eh.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Fn.DuplicateCreateError = vh;
function jA(t) {
  return t instanceof Eh.XRPCError && t.error === "DuplicateCreate" ? new vh(t) : t;
}
Fn.toKnownErr = jA;
var $n = {};
Object.defineProperty($n, "__esModule", { value: !0 });
$n.toKnownErr = $n.BadExpirationError = void 0;
const Rh = q;
class Ah extends Rh.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
$n.BadExpirationError = Ah;
function FA(t) {
  return t instanceof Rh.XRPCError && t.error === "BadExpiration" ? new Ah(t) : t;
}
$n.toKnownErr = FA;
var uo = {};
Object.defineProperty(uo, "__esModule", { value: !0 });
uo.toKnownErr = void 0;
const $A = q;
function GA(t) {
  return t instanceof $A.XRPCError, t;
}
uo.toKnownErr = GA;
var jr = {};
Object.defineProperty(jr, "__esModule", { value: !0 });
jr.validateAppPassword = jr.isAppPassword = jr.toKnownErr = jr.AccountTakedownError = void 0;
const _h = q, qd = we, qA = Le;
let wh = class extends _h.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
jr.AccountTakedownError = wh;
function zA(t) {
  return t instanceof _h.XRPCError && t.error === "AccountTakedown" ? new wh(t) : t;
}
jr.toKnownErr = zA;
function XA(t) {
  return (0, qd.isObj)(t) && (0, qd.hasProp)(t, "$type") && t.$type === "com.atproto.server.listAppPasswords#appPassword";
}
jr.isAppPassword = XA;
function HA(t) {
  return qA.lexicons.validate("com.atproto.server.listAppPasswords#appPassword", t);
}
jr.validateAppPassword = HA;
var Gn = {};
Object.defineProperty(Gn, "__esModule", { value: !0 });
Gn.toKnownErr = Gn.AccountTakedownError = void 0;
const Th = q;
class Sh extends Th.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Gn.AccountTakedownError = Sh;
function ZA(t) {
  return t instanceof Th.XRPCError && t.error === "AccountTakedown" ? new Sh(t) : t;
}
Gn.toKnownErr = ZA;
var co = {};
Object.defineProperty(co, "__esModule", { value: !0 });
co.toKnownErr = void 0;
const WA = q;
function YA(t) {
  return t instanceof WA.XRPCError, t;
}
co.toKnownErr = YA;
var fo = {};
Object.defineProperty(fo, "__esModule", { value: !0 });
fo.toKnownErr = void 0;
const JA = q;
function QA(t) {
  return t instanceof JA.XRPCError, t;
}
fo.toKnownErr = QA;
var po = {};
Object.defineProperty(po, "__esModule", { value: !0 });
po.toKnownErr = void 0;
const e_ = q;
function t_(t) {
  return t instanceof e_.XRPCError, t;
}
po.toKnownErr = t_;
var ho = {};
Object.defineProperty(ho, "__esModule", { value: !0 });
ho.toKnownErr = void 0;
const r_ = q;
function i_(t) {
  return t instanceof r_.XRPCError, t;
}
ho.toKnownErr = i_;
var mo = {};
Object.defineProperty(mo, "__esModule", { value: !0 });
mo.toKnownErr = void 0;
const n_ = q;
function s_(t) {
  return t instanceof n_.XRPCError, t;
}
mo.toKnownErr = s_;
var Gi = {};
Object.defineProperty(Gi, "__esModule", { value: !0 });
Gi.toKnownErr = Gi.InvalidTokenError = Gi.ExpiredTokenError = void 0;
const Qc = q;
let Ch = class extends Qc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Gi.ExpiredTokenError = Ch;
let Lh = class extends Qc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Gi.InvalidTokenError = Lh;
function a_(t) {
  if (t instanceof Qc.XRPCError) {
    if (t.error === "ExpiredToken")
      return new Ch(t);
    if (t.error === "InvalidToken")
      return new Lh(t);
  }
  return t;
}
Gi.toKnownErr = a_;
var yo = {};
Object.defineProperty(yo, "__esModule", { value: !0 });
yo.toKnownErr = void 0;
const o_ = q;
function l_(t) {
  return t instanceof o_.XRPCError, t;
}
yo.toKnownErr = l_;
var Fr = {};
Object.defineProperty(Fr, "__esModule", { value: !0 });
Fr.toKnownErr = Fr.TokenRequiredError = Fr.InvalidTokenError = Fr.ExpiredTokenError = void 0;
const Ku = q;
class kh extends Ku.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Fr.ExpiredTokenError = kh;
class Dh extends Ku.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Fr.InvalidTokenError = Dh;
class Ph extends Ku.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Fr.TokenRequiredError = Ph;
function u_(t) {
  if (t instanceof Ku.XRPCError) {
    if (t.error === "ExpiredToken")
      return new kh(t);
    if (t.error === "InvalidToken")
      return new Dh(t);
    if (t.error === "TokenRequired")
      return new Ph(t);
  }
  return t;
}
Fr.toKnownErr = u_;
var ar = {};
Object.defineProperty(ar, "__esModule", { value: !0 });
ar.toKnownErr = ar.RepoDeactivatedError = ar.RepoSuspendedError = ar.RepoTakendownError = ar.RepoNotFoundError = ar.BlobNotFoundError = void 0;
const qs = q;
class Bh extends qs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
ar.BlobNotFoundError = Bh;
let Ih = class extends qs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
ar.RepoNotFoundError = Ih;
let Uh = class extends qs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
ar.RepoTakendownError = Uh;
let Oh = class extends qs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
ar.RepoSuspendedError = Oh;
let Kh = class extends qs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
ar.RepoDeactivatedError = Kh;
function c_(t) {
  if (t instanceof qs.XRPCError) {
    if (t.error === "BlobNotFound")
      return new Bh(t);
    if (t.error === "RepoNotFound")
      return new Ih(t);
    if (t.error === "RepoTakendown")
      return new Uh(t);
    if (t.error === "RepoSuspended")
      return new Oh(t);
    if (t.error === "RepoDeactivated")
      return new Kh(t);
  }
  return t;
}
ar.toKnownErr = c_;
var or = {};
Object.defineProperty(or, "__esModule", { value: !0 });
or.toKnownErr = or.RepoDeactivatedError = or.RepoSuspendedError = or.RepoTakendownError = or.RepoNotFoundError = or.BlockNotFoundError = void 0;
const zs = q;
class Mh extends zs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
or.BlockNotFoundError = Mh;
let Nh = class extends zs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
or.RepoNotFoundError = Nh;
let Vh = class extends zs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
or.RepoTakendownError = Vh;
let jh = class extends zs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
or.RepoSuspendedError = jh;
let Fh = class extends zs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
or.RepoDeactivatedError = Fh;
function d_(t) {
  if (t instanceof zs.XRPCError) {
    if (t.error === "BlockNotFound")
      return new Mh(t);
    if (t.error === "RepoNotFound")
      return new Nh(t);
    if (t.error === "RepoTakendown")
      return new Vh(t);
    if (t.error === "RepoSuspended")
      return new jh(t);
    if (t.error === "RepoDeactivated")
      return new Fh(t);
  }
  return t;
}
or.toKnownErr = d_;
var bo = {};
Object.defineProperty(bo, "__esModule", { value: !0 });
bo.toKnownErr = void 0;
const f_ = q;
function p_(t) {
  return t instanceof f_.XRPCError, t;
}
bo.toKnownErr = p_;
var qn = {};
Object.defineProperty(qn, "__esModule", { value: !0 });
qn.toKnownErr = qn.HeadNotFoundError = void 0;
const $h = q;
class Gh extends $h.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
qn.HeadNotFoundError = Gh;
function h_(t) {
  return t instanceof $h.XRPCError && t.error === "HeadNotFound" ? new Gh(t) : t;
}
qn.toKnownErr = h_;
var _r = {};
Object.defineProperty(_r, "__esModule", { value: !0 });
_r.toKnownErr = _r.RepoDeactivatedError = _r.RepoSuspendedError = _r.RepoTakendownError = _r.RepoNotFoundError = void 0;
const go = q;
let qh = class extends go.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
_r.RepoNotFoundError = qh;
let zh = class extends go.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
_r.RepoTakendownError = zh;
let Xh = class extends go.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
_r.RepoSuspendedError = Xh;
let Hh = class extends go.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
_r.RepoDeactivatedError = Hh;
function m_(t) {
  if (t instanceof go.XRPCError) {
    if (t.error === "RepoNotFound")
      return new qh(t);
    if (t.error === "RepoTakendown")
      return new zh(t);
    if (t.error === "RepoSuspended")
      return new Xh(t);
    if (t.error === "RepoDeactivated")
      return new Hh(t);
  }
  return t;
}
_r.toKnownErr = m_;
var lr = {};
Object.defineProperty(lr, "__esModule", { value: !0 });
lr.toKnownErr = lr.RepoDeactivatedError = lr.RepoSuspendedError = lr.RepoTakendownError = lr.RepoNotFoundError = lr.RecordNotFoundError = void 0;
const Xs = q;
let Zh = class extends Xs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
lr.RecordNotFoundError = Zh;
let Wh = class extends Xs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
lr.RepoNotFoundError = Wh;
let Yh = class extends Xs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
lr.RepoTakendownError = Yh;
let Jh = class extends Xs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
lr.RepoSuspendedError = Jh;
let Qh = class extends Xs.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
lr.RepoDeactivatedError = Qh;
function y_(t) {
  if (t instanceof Xs.XRPCError) {
    if (t.error === "RecordNotFound")
      return new Zh(t);
    if (t.error === "RepoNotFound")
      return new Wh(t);
    if (t.error === "RepoTakendown")
      return new Yh(t);
    if (t.error === "RepoSuspended")
      return new Jh(t);
    if (t.error === "RepoDeactivated")
      return new Qh(t);
  }
  return t;
}
lr.toKnownErr = y_;
var wr = {};
Object.defineProperty(wr, "__esModule", { value: !0 });
wr.toKnownErr = wr.RepoDeactivatedError = wr.RepoSuspendedError = wr.RepoTakendownError = wr.RepoNotFoundError = void 0;
const xo = q;
let e0 = class extends xo.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
wr.RepoNotFoundError = e0;
let t0 = class extends xo.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
wr.RepoTakendownError = t0;
let r0 = class extends xo.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
wr.RepoSuspendedError = r0;
let i0 = class extends xo.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
wr.RepoDeactivatedError = i0;
function b_(t) {
  if (t instanceof xo.XRPCError) {
    if (t.error === "RepoNotFound")
      return new e0(t);
    if (t.error === "RepoTakendown")
      return new t0(t);
    if (t.error === "RepoSuspended")
      return new r0(t);
    if (t.error === "RepoDeactivated")
      return new i0(t);
  }
  return t;
}
wr.toKnownErr = b_;
var zn = {};
Object.defineProperty(zn, "__esModule", { value: !0 });
zn.toKnownErr = zn.RepoNotFoundError = void 0;
const n0 = q;
let s0 = class extends n0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
zn.RepoNotFoundError = s0;
function g_(t) {
  return t instanceof n0.XRPCError && t.error === "RepoNotFound" ? new s0(t) : t;
}
zn.toKnownErr = g_;
var Tr = {};
Object.defineProperty(Tr, "__esModule", { value: !0 });
Tr.toKnownErr = Tr.RepoDeactivatedError = Tr.RepoSuspendedError = Tr.RepoTakendownError = Tr.RepoNotFoundError = void 0;
const Eo = q;
let a0 = class extends Eo.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Tr.RepoNotFoundError = a0;
class o0 extends Eo.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Tr.RepoTakendownError = o0;
class l0 extends Eo.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Tr.RepoSuspendedError = l0;
class u0 extends Eo.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Tr.RepoDeactivatedError = u0;
function x_(t) {
  if (t instanceof Eo.XRPCError) {
    if (t.error === "RepoNotFound")
      return new a0(t);
    if (t.error === "RepoTakendown")
      return new o0(t);
    if (t.error === "RepoSuspended")
      return new l0(t);
    if (t.error === "RepoDeactivated")
      return new u0(t);
  }
  return t;
}
Tr.toKnownErr = x_;
var qi = {};
Object.defineProperty(qi, "__esModule", { value: !0 });
qi.validateRepo = qi.isRepo = qi.toKnownErr = void 0;
const E_ = q, zd = we, v_ = Le;
function R_(t) {
  return t instanceof E_.XRPCError, t;
}
qi.toKnownErr = R_;
function A_(t) {
  return (0, zd.isObj)(t) && (0, zd.hasProp)(t, "$type") && t.$type === "com.atproto.sync.listRepos#repo";
}
qi.isRepo = A_;
function __(t) {
  return v_.lexicons.validate("com.atproto.sync.listRepos#repo", t);
}
qi.validateRepo = __;
var vo = {};
Object.defineProperty(vo, "__esModule", { value: !0 });
vo.toKnownErr = void 0;
const w_ = q;
function T_(t) {
  return t instanceof w_.XRPCError, t;
}
vo.toKnownErr = T_;
var Ro = {};
Object.defineProperty(Ro, "__esModule", { value: !0 });
Ro.toKnownErr = void 0;
const S_ = q;
function C_(t) {
  return t instanceof S_.XRPCError, t;
}
Ro.toKnownErr = C_;
var Ao = {};
Object.defineProperty(Ao, "__esModule", { value: !0 });
Ao.toKnownErr = void 0;
const L_ = q;
function k_(t) {
  return t instanceof L_.XRPCError, t;
}
Ao.toKnownErr = k_;
var _o = {};
Object.defineProperty(_o, "__esModule", { value: !0 });
_o.toKnownErr = void 0;
const D_ = q;
function P_(t) {
  return t instanceof D_.XRPCError, t;
}
_o.toKnownErr = P_;
var wo = {};
Object.defineProperty(wo, "__esModule", { value: !0 });
wo.toKnownErr = void 0;
const B_ = q;
function I_(t) {
  return t instanceof B_.XRPCError, t;
}
wo.toKnownErr = I_;
var To = {};
Object.defineProperty(To, "__esModule", { value: !0 });
To.toKnownErr = void 0;
const U_ = q;
function O_(t) {
  return t instanceof U_.XRPCError, t;
}
To.toKnownErr = O_;
var So = {};
Object.defineProperty(So, "__esModule", { value: !0 });
So.toKnownErr = void 0;
const K_ = q;
function M_(t) {
  return t instanceof K_.XRPCError, t;
}
So.toKnownErr = M_;
var Co = {};
Object.defineProperty(Co, "__esModule", { value: !0 });
Co.toKnownErr = void 0;
const N_ = q;
function V_(t) {
  return t instanceof N_.XRPCError, t;
}
Co.toKnownErr = V_;
var Lo = {};
Object.defineProperty(Lo, "__esModule", { value: !0 });
Lo.toKnownErr = void 0;
const j_ = q;
function F_(t) {
  return t instanceof j_.XRPCError, t;
}
Lo.toKnownErr = F_;
var ko = {};
Object.defineProperty(ko, "__esModule", { value: !0 });
ko.toKnownErr = void 0;
const $_ = q;
function G_(t) {
  return t instanceof $_.XRPCError, t;
}
ko.toKnownErr = G_;
var Do = {};
Object.defineProperty(Do, "__esModule", { value: !0 });
Do.toKnownErr = void 0;
const q_ = q;
function z_(t) {
  return t instanceof q_.XRPCError, t;
}
Do.toKnownErr = z_;
var Po = {};
Object.defineProperty(Po, "__esModule", { value: !0 });
Po.toKnownErr = void 0;
const X_ = q;
function H_(t) {
  return t instanceof X_.XRPCError, t;
}
Po.toKnownErr = H_;
var Sr = {};
Object.defineProperty(Sr, "__esModule", { value: !0 });
Sr.validateLinks = Sr.isLinks = Sr.validateFeed = Sr.isFeed = Sr.toKnownErr = void 0;
const Z_ = q, Ru = we, c0 = Le;
function W_(t) {
  return t instanceof Z_.XRPCError, t;
}
Sr.toKnownErr = W_;
function Y_(t) {
  return (0, Ru.isObj)(t) && (0, Ru.hasProp)(t, "$type") && t.$type === "app.bsky.feed.describeFeedGenerator#feed";
}
Sr.isFeed = Y_;
function J_(t) {
  return c0.lexicons.validate("app.bsky.feed.describeFeedGenerator#feed", t);
}
Sr.validateFeed = J_;
function Q_(t) {
  return (0, Ru.isObj)(t) && (0, Ru.hasProp)(t, "$type") && t.$type === "app.bsky.feed.describeFeedGenerator#links";
}
Sr.isLinks = Q_;
function ew(t) {
  return c0.lexicons.validate("app.bsky.feed.describeFeedGenerator#links", t);
}
Sr.validateLinks = ew;
var Bo = {};
Object.defineProperty(Bo, "__esModule", { value: !0 });
Bo.toKnownErr = void 0;
const tw = q;
function rw(t) {
  return t instanceof tw.XRPCError, t;
}
Bo.toKnownErr = rw;
var zi = {};
Object.defineProperty(zi, "__esModule", { value: !0 });
zi.toKnownErr = zi.BlockedByActorError = zi.BlockedActorError = void 0;
const ed = q;
let d0 = class extends ed.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
zi.BlockedActorError = d0;
let f0 = class extends ed.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
zi.BlockedByActorError = f0;
function iw(t) {
  if (t instanceof ed.XRPCError) {
    if (t.error === "BlockedActor")
      return new d0(t);
    if (t.error === "BlockedByActor")
      return new f0(t);
  }
  return t;
}
zi.toKnownErr = iw;
var Xi = {};
Object.defineProperty(Xi, "__esModule", { value: !0 });
Xi.toKnownErr = Xi.BlockedByActorError = Xi.BlockedActorError = void 0;
const td = q;
class p0 extends td.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Xi.BlockedActorError = p0;
class h0 extends td.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Xi.BlockedByActorError = h0;
function nw(t) {
  if (t instanceof td.XRPCError) {
    if (t.error === "BlockedActor")
      return new p0(t);
    if (t.error === "BlockedByActor")
      return new h0(t);
  }
  return t;
}
Xi.toKnownErr = nw;
var Xn = {};
Object.defineProperty(Xn, "__esModule", { value: !0 });
Xn.toKnownErr = Xn.UnknownFeedError = void 0;
const m0 = q;
let y0 = class extends m0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Xn.UnknownFeedError = y0;
function sw(t) {
  return t instanceof m0.XRPCError && t.error === "UnknownFeed" ? new y0(t) : t;
}
Xn.toKnownErr = sw;
var Io = {};
Object.defineProperty(Io, "__esModule", { value: !0 });
Io.toKnownErr = void 0;
const aw = q;
function ow(t) {
  return t instanceof aw.XRPCError, t;
}
Io.toKnownErr = ow;
var Uo = {};
Object.defineProperty(Uo, "__esModule", { value: !0 });
Uo.toKnownErr = void 0;
const lw = q;
function uw(t) {
  return t instanceof lw.XRPCError, t;
}
Uo.toKnownErr = uw;
var Hn = {};
Object.defineProperty(Hn, "__esModule", { value: !0 });
Hn.toKnownErr = Hn.UnknownFeedError = void 0;
const b0 = q;
class g0 extends b0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Hn.UnknownFeedError = g0;
function cw(t) {
  return t instanceof b0.XRPCError && t.error === "UnknownFeed" ? new g0(t) : t;
}
Hn.toKnownErr = cw;
var Hi = {};
Object.defineProperty(Hi, "__esModule", { value: !0 });
Hi.validateLike = Hi.isLike = Hi.toKnownErr = void 0;
const dw = q, Xd = we, fw = Le;
function pw(t) {
  return t instanceof dw.XRPCError, t;
}
Hi.toKnownErr = pw;
function hw(t) {
  return (0, Xd.isObj)(t) && (0, Xd.hasProp)(t, "$type") && t.$type === "app.bsky.feed.getLikes#like";
}
Hi.isLike = hw;
function mw(t) {
  return fw.lexicons.validate("app.bsky.feed.getLikes#like", t);
}
Hi.validateLike = mw;
var Zn = {};
Object.defineProperty(Zn, "__esModule", { value: !0 });
Zn.toKnownErr = Zn.UnknownListError = void 0;
const x0 = q;
class E0 extends x0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Zn.UnknownListError = E0;
function yw(t) {
  return t instanceof x0.XRPCError && t.error === "UnknownList" ? new E0(t) : t;
}
Zn.toKnownErr = yw;
var Wn = {};
Object.defineProperty(Wn, "__esModule", { value: !0 });
Wn.toKnownErr = Wn.NotFoundError = void 0;
const v0 = q;
class R0 extends v0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Wn.NotFoundError = R0;
function bw(t) {
  return t instanceof v0.XRPCError && t.error === "NotFound" ? new R0(t) : t;
}
Wn.toKnownErr = bw;
var Oo = {};
Object.defineProperty(Oo, "__esModule", { value: !0 });
Oo.toKnownErr = void 0;
const gw = q;
function xw(t) {
  return t instanceof gw.XRPCError, t;
}
Oo.toKnownErr = xw;
var Ko = {};
Object.defineProperty(Ko, "__esModule", { value: !0 });
Ko.toKnownErr = void 0;
const Ew = q;
function vw(t) {
  return t instanceof Ew.XRPCError, t;
}
Ko.toKnownErr = vw;
var Mo = {};
Object.defineProperty(Mo, "__esModule", { value: !0 });
Mo.toKnownErr = void 0;
const Rw = q;
function Aw(t) {
  return t instanceof Rw.XRPCError, t;
}
Mo.toKnownErr = Aw;
var No = {};
Object.defineProperty(No, "__esModule", { value: !0 });
No.toKnownErr = void 0;
const _w = q;
function ww(t) {
  return t instanceof _w.XRPCError, t;
}
No.toKnownErr = ww;
var Yn = {};
Object.defineProperty(Yn, "__esModule", { value: !0 });
Yn.toKnownErr = Yn.BadQueryStringError = void 0;
const A0 = q;
let _0 = class extends A0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Yn.BadQueryStringError = _0;
function Tw(t) {
  return t instanceof A0.XRPCError && t.error === "BadQueryString" ? new _0(t) : t;
}
Yn.toKnownErr = Tw;
var Vo = {};
Object.defineProperty(Vo, "__esModule", { value: !0 });
Vo.toKnownErr = void 0;
const Sw = q;
function Cw(t) {
  return t instanceof Sw.XRPCError, t;
}
Vo.toKnownErr = Cw;
var jo = {};
Object.defineProperty(jo, "__esModule", { value: !0 });
jo.toKnownErr = void 0;
const Lw = q;
function kw(t) {
  return t instanceof Lw.XRPCError, t;
}
jo.toKnownErr = kw;
var Fo = {};
Object.defineProperty(Fo, "__esModule", { value: !0 });
Fo.toKnownErr = void 0;
const Dw = q;
function Pw(t) {
  return t instanceof Dw.XRPCError, t;
}
Fo.toKnownErr = Pw;
var $o = {};
Object.defineProperty($o, "__esModule", { value: !0 });
$o.toKnownErr = void 0;
const Bw = q;
function Iw(t) {
  return t instanceof Bw.XRPCError, t;
}
$o.toKnownErr = Iw;
var Go = {};
Object.defineProperty(Go, "__esModule", { value: !0 });
Go.toKnownErr = void 0;
const Uw = q;
function Ow(t) {
  return t instanceof Uw.XRPCError, t;
}
Go.toKnownErr = Ow;
var qo = {};
Object.defineProperty(qo, "__esModule", { value: !0 });
qo.toKnownErr = void 0;
const Kw = q;
function Mw(t) {
  return t instanceof Kw.XRPCError, t;
}
qo.toKnownErr = Mw;
var zo = {};
Object.defineProperty(zo, "__esModule", { value: !0 });
zo.toKnownErr = void 0;
const Nw = q;
function Vw(t) {
  return t instanceof Nw.XRPCError, t;
}
zo.toKnownErr = Vw;
var Xo = {};
Object.defineProperty(Xo, "__esModule", { value: !0 });
Xo.toKnownErr = void 0;
const jw = q;
function Fw(t) {
  return t instanceof jw.XRPCError, t;
}
Xo.toKnownErr = Fw;
var Ho = {};
Object.defineProperty(Ho, "__esModule", { value: !0 });
Ho.toKnownErr = void 0;
const $w = q;
function Gw(t) {
  return t instanceof $w.XRPCError, t;
}
Ho.toKnownErr = Gw;
var Zo = {};
Object.defineProperty(Zo, "__esModule", { value: !0 });
Zo.toKnownErr = void 0;
const qw = q;
function zw(t) {
  return t instanceof qw.XRPCError, t;
}
Zo.toKnownErr = zw;
var Wo = {};
Object.defineProperty(Wo, "__esModule", { value: !0 });
Wo.toKnownErr = void 0;
const Xw = q;
function Hw(t) {
  return t instanceof Xw.XRPCError, t;
}
Wo.toKnownErr = Hw;
var Jn = {};
Object.defineProperty(Jn, "__esModule", { value: !0 });
Jn.toKnownErr = Jn.ActorNotFoundError = void 0;
const w0 = q;
class T0 extends w0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Jn.ActorNotFoundError = T0;
function Zw(t) {
  return t instanceof w0.XRPCError && t.error === "ActorNotFound" ? new T0(t) : t;
}
Jn.toKnownErr = Zw;
var Yo = {};
Object.defineProperty(Yo, "__esModule", { value: !0 });
Yo.toKnownErr = void 0;
const Ww = q;
function Yw(t) {
  return t instanceof Ww.XRPCError, t;
}
Yo.toKnownErr = Yw;
var Jo = {};
Object.defineProperty(Jo, "__esModule", { value: !0 });
Jo.toKnownErr = void 0;
const Jw = q;
function Qw(t) {
  return t instanceof Jw.XRPCError, t;
}
Jo.toKnownErr = Qw;
var Qo = {};
Object.defineProperty(Qo, "__esModule", { value: !0 });
Qo.toKnownErr = void 0;
const eT = q;
function tT(t) {
  return t instanceof eT.XRPCError, t;
}
Qo.toKnownErr = tT;
var el = {};
Object.defineProperty(el, "__esModule", { value: !0 });
el.toKnownErr = void 0;
const rT = q;
function iT(t) {
  return t instanceof rT.XRPCError, t;
}
el.toKnownErr = iT;
var tl = {};
Object.defineProperty(tl, "__esModule", { value: !0 });
tl.toKnownErr = void 0;
const nT = q;
function sT(t) {
  return t instanceof nT.XRPCError, t;
}
tl.toKnownErr = sT;
var rl = {};
Object.defineProperty(rl, "__esModule", { value: !0 });
rl.toKnownErr = void 0;
const aT = q;
function oT(t) {
  return t instanceof aT.XRPCError, t;
}
rl.toKnownErr = oT;
var il = {};
Object.defineProperty(il, "__esModule", { value: !0 });
il.toKnownErr = void 0;
const lT = q;
function uT(t) {
  return t instanceof lT.XRPCError, t;
}
il.toKnownErr = uT;
var nl = {};
Object.defineProperty(nl, "__esModule", { value: !0 });
nl.toKnownErr = void 0;
const cT = q;
function dT(t) {
  return t instanceof cT.XRPCError, t;
}
nl.toKnownErr = dT;
var sl = {};
Object.defineProperty(sl, "__esModule", { value: !0 });
sl.toKnownErr = void 0;
const fT = q;
function pT(t) {
  return t instanceof fT.XRPCError, t;
}
sl.toKnownErr = pT;
var al = {};
Object.defineProperty(al, "__esModule", { value: !0 });
al.toKnownErr = void 0;
const hT = q;
function mT(t) {
  return t instanceof hT.XRPCError, t;
}
al.toKnownErr = mT;
var ol = {};
Object.defineProperty(ol, "__esModule", { value: !0 });
ol.toKnownErr = void 0;
const yT = q;
function bT(t) {
  return t instanceof yT.XRPCError, t;
}
ol.toKnownErr = bT;
var Zi = {};
Object.defineProperty(Zi, "__esModule", { value: !0 });
Zi.validateNotification = Zi.isNotification = Zi.toKnownErr = void 0;
const gT = q, Hd = we, xT = Le;
function ET(t) {
  return t instanceof gT.XRPCError, t;
}
Zi.toKnownErr = ET;
function vT(t) {
  return (0, Hd.isObj)(t) && (0, Hd.hasProp)(t, "$type") && t.$type === "app.bsky.notification.listNotifications#notification";
}
Zi.isNotification = vT;
function RT(t) {
  return xT.lexicons.validate("app.bsky.notification.listNotifications#notification", t);
}
Zi.validateNotification = RT;
var ll = {};
Object.defineProperty(ll, "__esModule", { value: !0 });
ll.toKnownErr = void 0;
const AT = q;
function _T(t) {
  return t instanceof AT.XRPCError, t;
}
ll.toKnownErr = _T;
var ul = {};
Object.defineProperty(ul, "__esModule", { value: !0 });
ul.toKnownErr = void 0;
const wT = q;
function TT(t) {
  return t instanceof wT.XRPCError, t;
}
ul.toKnownErr = TT;
var cl = {};
Object.defineProperty(cl, "__esModule", { value: !0 });
cl.toKnownErr = void 0;
const ST = q;
function CT(t) {
  return t instanceof ST.XRPCError, t;
}
cl.toKnownErr = CT;
var dl = {};
Object.defineProperty(dl, "__esModule", { value: !0 });
dl.toKnownErr = void 0;
const LT = q;
function kT(t) {
  return t instanceof LT.XRPCError, t;
}
dl.toKnownErr = kT;
var fl = {};
Object.defineProperty(fl, "__esModule", { value: !0 });
fl.toKnownErr = void 0;
const DT = q;
function PT(t) {
  return t instanceof DT.XRPCError, t;
}
fl.toKnownErr = PT;
var Wi = {};
Object.defineProperty(Wi, "__esModule", { value: !0 });
Wi.validateSuggestion = Wi.isSuggestion = Wi.toKnownErr = void 0;
const BT = q, Zd = we, IT = Le;
function UT(t) {
  return t instanceof BT.XRPCError, t;
}
Wi.toKnownErr = UT;
function OT(t) {
  return (0, Zd.isObj)(t) && (0, Zd.hasProp)(t, "$type") && t.$type === "app.bsky.unspecced.getTaggedSuggestions#suggestion";
}
Wi.isSuggestion = OT;
function KT(t) {
  return IT.lexicons.validate("app.bsky.unspecced.getTaggedSuggestions#suggestion", t);
}
Wi.validateSuggestion = KT;
var Qn = {};
Object.defineProperty(Qn, "__esModule", { value: !0 });
Qn.toKnownErr = Qn.BadQueryStringError = void 0;
const S0 = q;
let C0 = class extends S0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Qn.BadQueryStringError = C0;
function MT(t) {
  return t instanceof S0.XRPCError && t.error === "BadQueryString" ? new C0(t) : t;
}
Qn.toKnownErr = MT;
var es = {};
Object.defineProperty(es, "__esModule", { value: !0 });
es.toKnownErr = es.BadQueryStringError = void 0;
const L0 = q;
class k0 extends L0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
es.BadQueryStringError = k0;
function NT(t) {
  return t instanceof L0.XRPCError && t.error === "BadQueryString" ? new k0(t) : t;
}
es.toKnownErr = NT;
var pl = {};
Object.defineProperty(pl, "__esModule", { value: !0 });
pl.toKnownErr = void 0;
const VT = q;
function jT(t) {
  return t instanceof VT.XRPCError, t;
}
pl.toKnownErr = jT;
var hl = {};
Object.defineProperty(hl, "__esModule", { value: !0 });
hl.toKnownErr = void 0;
const FT = q;
function $T(t) {
  return t instanceof FT.XRPCError, t;
}
hl.toKnownErr = $T;
var ml = {};
Object.defineProperty(ml, "__esModule", { value: !0 });
ml.toKnownErr = void 0;
const GT = q;
function qT(t) {
  return t instanceof GT.XRPCError, t;
}
ml.toKnownErr = qT;
var yl = {};
Object.defineProperty(yl, "__esModule", { value: !0 });
yl.toKnownErr = void 0;
const zT = q;
function XT(t) {
  return t instanceof zT.XRPCError, t;
}
yl.toKnownErr = XT;
var bl = {};
Object.defineProperty(bl, "__esModule", { value: !0 });
bl.toKnownErr = void 0;
const HT = q;
function ZT(t) {
  return t instanceof HT.XRPCError, t;
}
bl.toKnownErr = ZT;
var gl = {};
Object.defineProperty(gl, "__esModule", { value: !0 });
gl.toKnownErr = void 0;
const WT = q;
function YT(t) {
  return t instanceof WT.XRPCError, t;
}
gl.toKnownErr = YT;
var xl = {};
Object.defineProperty(xl, "__esModule", { value: !0 });
xl.toKnownErr = void 0;
const JT = q;
function QT(t) {
  return t instanceof JT.XRPCError, t;
}
xl.toKnownErr = QT;
var El = {};
Object.defineProperty(El, "__esModule", { value: !0 });
El.toKnownErr = void 0;
const eS = q;
function tS(t) {
  return t instanceof eS.XRPCError, t;
}
El.toKnownErr = tS;
var vl = {};
Object.defineProperty(vl, "__esModule", { value: !0 });
vl.toKnownErr = void 0;
const rS = q;
function iS(t) {
  return t instanceof rS.XRPCError, t;
}
vl.toKnownErr = iS;
var Rl = {};
Object.defineProperty(Rl, "__esModule", { value: !0 });
Rl.toKnownErr = void 0;
const nS = q;
function sS(t) {
  return t instanceof nS.XRPCError, t;
}
Rl.toKnownErr = sS;
var Al = {};
Object.defineProperty(Al, "__esModule", { value: !0 });
Al.toKnownErr = void 0;
const aS = q;
function oS(t) {
  return t instanceof aS.XRPCError, t;
}
Al.toKnownErr = oS;
var Yi = {};
Object.defineProperty(Yi, "__esModule", { value: !0 });
Yi.validateBatchItem = Yi.isBatchItem = Yi.toKnownErr = void 0;
const lS = q, Wd = we, uS = Le;
function cS(t) {
  return t instanceof lS.XRPCError, t;
}
Yi.toKnownErr = cS;
function dS(t) {
  return (0, Wd.isObj)(t) && (0, Wd.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.sendMessageBatch#batchItem";
}
Yi.isBatchItem = dS;
function fS(t) {
  return uS.lexicons.validate("chat.bsky.convo.sendMessageBatch#batchItem", t);
}
Yi.validateBatchItem = fS;
var _l = {};
Object.defineProperty(_l, "__esModule", { value: !0 });
_l.toKnownErr = void 0;
const pS = q;
function hS(t) {
  return t instanceof pS.XRPCError, t;
}
_l.toKnownErr = hS;
var wl = {};
Object.defineProperty(wl, "__esModule", { value: !0 });
wl.toKnownErr = void 0;
const mS = q;
function yS(t) {
  return t instanceof mS.XRPCError, t;
}
wl.toKnownErr = yS;
var Ji = {};
Object.defineProperty(Ji, "__esModule", { value: !0 });
Ji.validateMetadata = Ji.isMetadata = Ji.toKnownErr = void 0;
const bS = q, Yd = we, gS = Le;
function xS(t) {
  return t instanceof bS.XRPCError, t;
}
Ji.toKnownErr = xS;
function ES(t) {
  return (0, Yd.isObj)(t) && (0, Yd.hasProp)(t, "$type") && t.$type === "chat.bsky.moderation.getActorMetadata#metadata";
}
Ji.isMetadata = ES;
function vS(t) {
  return gS.lexicons.validate("chat.bsky.moderation.getActorMetadata#metadata", t);
}
Ji.validateMetadata = vS;
var Tl = {};
Object.defineProperty(Tl, "__esModule", { value: !0 });
Tl.toKnownErr = void 0;
const RS = q;
function AS(t) {
  return t instanceof RS.XRPCError, t;
}
Tl.toKnownErr = AS;
var Sl = {};
Object.defineProperty(Sl, "__esModule", { value: !0 });
Sl.toKnownErr = void 0;
const _S = q;
function wS(t) {
  return t instanceof _S.XRPCError, t;
}
Sl.toKnownErr = wS;
var Cl = {};
Object.defineProperty(Cl, "__esModule", { value: !0 });
Cl.toKnownErr = void 0;
const TS = q;
function SS(t) {
  return t instanceof TS.XRPCError, t;
}
Cl.toKnownErr = SS;
var Ll = {};
Object.defineProperty(Ll, "__esModule", { value: !0 });
Ll.toKnownErr = void 0;
const CS = q;
function LS(t) {
  return t instanceof CS.XRPCError, t;
}
Ll.toKnownErr = LS;
var kl = {};
Object.defineProperty(kl, "__esModule", { value: !0 });
kl.toKnownErr = void 0;
const kS = q;
function DS(t) {
  return t instanceof kS.XRPCError, t;
}
kl.toKnownErr = DS;
var Dl = {};
Object.defineProperty(Dl, "__esModule", { value: !0 });
Dl.toKnownErr = void 0;
const PS = q;
function BS(t) {
  return t instanceof PS.XRPCError, t;
}
Dl.toKnownErr = BS;
var ts = {};
Object.defineProperty(ts, "__esModule", { value: !0 });
ts.toKnownErr = ts.SubjectHasActionError = void 0;
const D0 = q;
class P0 extends D0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
ts.SubjectHasActionError = P0;
function IS(t) {
  return t instanceof D0.XRPCError && t.error === "SubjectHasAction" ? new P0(t) : t;
}
ts.toKnownErr = IS;
var Pl = {};
Object.defineProperty(Pl, "__esModule", { value: !0 });
Pl.toKnownErr = void 0;
const US = q;
function OS(t) {
  return t instanceof US.XRPCError, t;
}
Pl.toKnownErr = OS;
var rs = {};
Object.defineProperty(rs, "__esModule", { value: !0 });
rs.toKnownErr = rs.RecordNotFoundError = void 0;
const B0 = q;
class I0 extends B0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
rs.RecordNotFoundError = I0;
function KS(t) {
  return t instanceof B0.XRPCError && t.error === "RecordNotFound" ? new I0(t) : t;
}
rs.toKnownErr = KS;
var is = {};
Object.defineProperty(is, "__esModule", { value: !0 });
is.toKnownErr = is.RepoNotFoundError = void 0;
const U0 = q;
class O0 extends U0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
is.RepoNotFoundError = O0;
function MS(t) {
  return t instanceof U0.XRPCError && t.error === "RepoNotFound" ? new O0(t) : t;
}
is.toKnownErr = MS;
var Bl = {};
Object.defineProperty(Bl, "__esModule", { value: !0 });
Bl.toKnownErr = void 0;
const NS = q;
function VS(t) {
  return t instanceof NS.XRPCError, t;
}
Bl.toKnownErr = VS;
var Il = {};
Object.defineProperty(Il, "__esModule", { value: !0 });
Il.toKnownErr = void 0;
const jS = q;
function FS(t) {
  return t instanceof jS.XRPCError, t;
}
Il.toKnownErr = FS;
var Ul = {};
Object.defineProperty(Ul, "__esModule", { value: !0 });
Ul.toKnownErr = void 0;
const $S = q;
function GS(t) {
  return t instanceof $S.XRPCError, t;
}
Ul.toKnownErr = GS;
var Cr = {};
Object.defineProperty(Cr, "__esModule", { value: !0 });
Cr.validateViewerConfig = Cr.isViewerConfig = Cr.validateServiceConfig = Cr.isServiceConfig = Cr.toKnownErr = void 0;
const qS = q, Au = we, K0 = Le;
function zS(t) {
  return t instanceof qS.XRPCError, t;
}
Cr.toKnownErr = zS;
function XS(t) {
  return (0, Au.isObj)(t) && (0, Au.hasProp)(t, "$type") && t.$type === "tools.ozone.server.getConfig#serviceConfig";
}
Cr.isServiceConfig = XS;
function HS(t) {
  return K0.lexicons.validate("tools.ozone.server.getConfig#serviceConfig", t);
}
Cr.validateServiceConfig = HS;
function ZS(t) {
  return (0, Au.isObj)(t) && (0, Au.hasProp)(t, "$type") && t.$type === "tools.ozone.server.getConfig#viewerConfig";
}
Cr.isViewerConfig = ZS;
function WS(t) {
  return K0.lexicons.validate("tools.ozone.server.getConfig#viewerConfig", t);
}
Cr.validateViewerConfig = WS;
var ns = {};
Object.defineProperty(ns, "__esModule", { value: !0 });
ns.toKnownErr = ns.MemberAlreadyExistsError = void 0;
const M0 = q;
class N0 extends M0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
ns.MemberAlreadyExistsError = N0;
function YS(t) {
  return t instanceof M0.XRPCError && t.error === "MemberAlreadyExists" ? new N0(t) : t;
}
ns.toKnownErr = YS;
var Qi = {};
Object.defineProperty(Qi, "__esModule", { value: !0 });
Qi.toKnownErr = Qi.CannotDeleteSelfError = Qi.MemberNotFoundError = void 0;
const rd = q;
let V0 = class extends rd.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Qi.MemberNotFoundError = V0;
class j0 extends rd.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Qi.CannotDeleteSelfError = j0;
function JS(t) {
  if (t instanceof rd.XRPCError) {
    if (t.error === "MemberNotFound")
      return new V0(t);
    if (t.error === "CannotDeleteSelf")
      return new j0(t);
  }
  return t;
}
Qi.toKnownErr = JS;
var Ol = {};
Object.defineProperty(Ol, "__esModule", { value: !0 });
Ol.toKnownErr = void 0;
const QS = q;
function eC(t) {
  return t instanceof QS.XRPCError, t;
}
Ol.toKnownErr = eC;
var ss = {};
Object.defineProperty(ss, "__esModule", { value: !0 });
ss.toKnownErr = ss.MemberNotFoundError = void 0;
const F0 = q;
class $0 extends F0.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
ss.MemberNotFoundError = $0;
function tC(t) {
  return t instanceof F0.XRPCError && t.error === "MemberNotFound" ? new $0(t) : t;
}
ss.toKnownErr = tC;
var Ot = {};
Object.defineProperty(Ot, "__esModule", { value: !0 });
Ot.validateRepoBlobRef = Ot.isRepoBlobRef = Ot.validateRepoRef = Ot.isRepoRef = Ot.validateAccountView = Ot.isAccountView = Ot.validateStatusAttr = Ot.isStatusAttr = void 0;
const mn = we, Mu = Le;
function rC(t) {
  return (0, mn.isObj)(t) && (0, mn.hasProp)(t, "$type") && t.$type === "com.atproto.admin.defs#statusAttr";
}
Ot.isStatusAttr = rC;
function iC(t) {
  return Mu.lexicons.validate("com.atproto.admin.defs#statusAttr", t);
}
Ot.validateStatusAttr = iC;
function nC(t) {
  return (0, mn.isObj)(t) && (0, mn.hasProp)(t, "$type") && t.$type === "com.atproto.admin.defs#accountView";
}
Ot.isAccountView = nC;
function sC(t) {
  return Mu.lexicons.validate("com.atproto.admin.defs#accountView", t);
}
Ot.validateAccountView = sC;
function aC(t) {
  return (0, mn.isObj)(t) && (0, mn.hasProp)(t, "$type") && t.$type === "com.atproto.admin.defs#repoRef";
}
Ot.isRepoRef = aC;
function oC(t) {
  return Mu.lexicons.validate("com.atproto.admin.defs#repoRef", t);
}
Ot.validateRepoRef = oC;
function lC(t) {
  return (0, mn.isObj)(t) && (0, mn.hasProp)(t, "$type") && t.$type === "com.atproto.admin.defs#repoBlobRef";
}
Ot.isRepoBlobRef = lC;
function uC(t) {
  return Mu.lexicons.validate("com.atproto.admin.defs#repoBlobRef", t);
}
Ot.validateRepoBlobRef = uC;
var mt = {};
Object.defineProperty(mt, "__esModule", { value: !0 });
mt.validateLabelValueDefinitionStrings = mt.isLabelValueDefinitionStrings = mt.validateLabelValueDefinition = mt.isLabelValueDefinition = mt.validateSelfLabel = mt.isSelfLabel = mt.validateSelfLabels = mt.isSelfLabels = mt.validateLabel = mt.isLabel = void 0;
const mi = we, Kl = Le;
function cC(t) {
  return (0, mi.isObj)(t) && (0, mi.hasProp)(t, "$type") && t.$type === "com.atproto.label.defs#label";
}
mt.isLabel = cC;
function dC(t) {
  return Kl.lexicons.validate("com.atproto.label.defs#label", t);
}
mt.validateLabel = dC;
function fC(t) {
  return (0, mi.isObj)(t) && (0, mi.hasProp)(t, "$type") && t.$type === "com.atproto.label.defs#selfLabels";
}
mt.isSelfLabels = fC;
function pC(t) {
  return Kl.lexicons.validate("com.atproto.label.defs#selfLabels", t);
}
mt.validateSelfLabels = pC;
function hC(t) {
  return (0, mi.isObj)(t) && (0, mi.hasProp)(t, "$type") && t.$type === "com.atproto.label.defs#selfLabel";
}
mt.isSelfLabel = hC;
function mC(t) {
  return Kl.lexicons.validate("com.atproto.label.defs#selfLabel", t);
}
mt.validateSelfLabel = mC;
function yC(t) {
  return (0, mi.isObj)(t) && (0, mi.hasProp)(t, "$type") && t.$type === "com.atproto.label.defs#labelValueDefinition";
}
mt.isLabelValueDefinition = yC;
function bC(t) {
  return Kl.lexicons.validate("com.atproto.label.defs#labelValueDefinition", t);
}
mt.validateLabelValueDefinition = bC;
function gC(t) {
  return (0, mi.isObj)(t) && (0, mi.hasProp)(t, "$type") && t.$type === "com.atproto.label.defs#labelValueDefinitionStrings";
}
mt.isLabelValueDefinitionStrings = gC;
function xC(t) {
  return Kl.lexicons.validate("com.atproto.label.defs#labelValueDefinitionStrings", t);
}
mt.validateLabelValueDefinitionStrings = xC;
var ni = {};
Object.defineProperty(ni, "__esModule", { value: !0 });
ni.validateInfo = ni.isInfo = ni.validateLabels = ni.isLabels = void 0;
const _u = we, G0 = Le;
function EC(t) {
  return (0, _u.isObj)(t) && (0, _u.hasProp)(t, "$type") && t.$type === "com.atproto.label.subscribeLabels#labels";
}
ni.isLabels = EC;
function vC(t) {
  return G0.lexicons.validate("com.atproto.label.subscribeLabels#labels", t);
}
ni.validateLabels = vC;
function RC(t) {
  return (0, _u.isObj)(t) && (0, _u.hasProp)(t, "$type") && t.$type === "com.atproto.label.subscribeLabels#info";
}
ni.isInfo = RC;
function AC(t) {
  return G0.lexicons.validate("com.atproto.label.subscribeLabels#info", t);
}
ni.validateInfo = AC;
var Yt = {};
Object.defineProperty(Yt, "__esModule", { value: !0 });
Yt.REASONAPPEAL = Yt.REASONOTHER = Yt.REASONRUDE = Yt.REASONSEXUAL = Yt.REASONMISLEADING = Yt.REASONVIOLATION = Yt.REASONSPAM = void 0;
Yt.REASONSPAM = "com.atproto.moderation.defs#reasonSpam";
Yt.REASONVIOLATION = "com.atproto.moderation.defs#reasonViolation";
Yt.REASONMISLEADING = "com.atproto.moderation.defs#reasonMisleading";
Yt.REASONSEXUAL = "com.atproto.moderation.defs#reasonSexual";
Yt.REASONRUDE = "com.atproto.moderation.defs#reasonRude";
Yt.REASONOTHER = "com.atproto.moderation.defs#reasonOther";
Yt.REASONAPPEAL = "com.atproto.moderation.defs#reasonAppeal";
var Ss = {};
Object.defineProperty(Ss, "__esModule", { value: !0 });
Ss.validateMain = Ss.isMain = void 0;
const Jd = we, _C = Le;
function wC(t) {
  return (0, Jd.isObj)(t) && (0, Jd.hasProp)(t, "$type") && (t.$type === "com.atproto.repo.strongRef#main" || t.$type === "com.atproto.repo.strongRef");
}
Ss.isMain = wC;
function TC(t) {
  return _C.lexicons.validate("com.atproto.repo.strongRef#main", t);
}
Ss.validateMain = TC;
var si = {};
Object.defineProperty(si, "__esModule", { value: !0 });
si.validateInviteCodeUse = si.isInviteCodeUse = si.validateInviteCode = si.isInviteCode = void 0;
const wu = we, q0 = Le;
function SC(t) {
  return (0, wu.isObj)(t) && (0, wu.hasProp)(t, "$type") && t.$type === "com.atproto.server.defs#inviteCode";
}
si.isInviteCode = SC;
function CC(t) {
  return q0.lexicons.validate("com.atproto.server.defs#inviteCode", t);
}
si.validateInviteCode = CC;
function LC(t) {
  return (0, wu.isObj)(t) && (0, wu.hasProp)(t, "$type") && t.$type === "com.atproto.server.defs#inviteCodeUse";
}
si.isInviteCodeUse = LC;
function kC(t) {
  return q0.lexicons.validate("com.atproto.server.defs#inviteCodeUse", t);
}
si.validateInviteCodeUse = kC;
var ze = {};
Object.defineProperty(ze, "__esModule", { value: !0 });
ze.validateRepoOp = ze.isRepoOp = ze.validateInfo = ze.isInfo = ze.validateTombstone = ze.isTombstone = ze.validateMigrate = ze.isMigrate = ze.validateHandle = ze.isHandle = ze.validateAccount = ze.isAccount = ze.validateIdentity = ze.isIdentity = ze.validateCommit = ze.isCommit = void 0;
const Qt = we, wn = Le;
function DC(t) {
  return (0, Qt.isObj)(t) && (0, Qt.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#commit";
}
ze.isCommit = DC;
function PC(t) {
  return wn.lexicons.validate("com.atproto.sync.subscribeRepos#commit", t);
}
ze.validateCommit = PC;
function BC(t) {
  return (0, Qt.isObj)(t) && (0, Qt.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#identity";
}
ze.isIdentity = BC;
function IC(t) {
  return wn.lexicons.validate("com.atproto.sync.subscribeRepos#identity", t);
}
ze.validateIdentity = IC;
function UC(t) {
  return (0, Qt.isObj)(t) && (0, Qt.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#account";
}
ze.isAccount = UC;
function OC(t) {
  return wn.lexicons.validate("com.atproto.sync.subscribeRepos#account", t);
}
ze.validateAccount = OC;
function KC(t) {
  return (0, Qt.isObj)(t) && (0, Qt.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#handle";
}
ze.isHandle = KC;
function MC(t) {
  return wn.lexicons.validate("com.atproto.sync.subscribeRepos#handle", t);
}
ze.validateHandle = MC;
function NC(t) {
  return (0, Qt.isObj)(t) && (0, Qt.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#migrate";
}
ze.isMigrate = NC;
function VC(t) {
  return wn.lexicons.validate("com.atproto.sync.subscribeRepos#migrate", t);
}
ze.validateMigrate = VC;
function jC(t) {
  return (0, Qt.isObj)(t) && (0, Qt.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#tombstone";
}
ze.isTombstone = jC;
function FC(t) {
  return wn.lexicons.validate("com.atproto.sync.subscribeRepos#tombstone", t);
}
ze.validateTombstone = FC;
function $C(t) {
  return (0, Qt.isObj)(t) && (0, Qt.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#info";
}
ze.isInfo = $C;
function GC(t) {
  return wn.lexicons.validate("com.atproto.sync.subscribeRepos#info", t);
}
ze.validateInfo = GC;
function qC(t) {
  return (0, Qt.isObj)(t) && (0, Qt.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#repoOp";
}
ze.isRepoOp = qC;
function zC(t) {
  return wn.lexicons.validate("com.atproto.sync.subscribeRepos#repoOp", t);
}
ze.validateRepoOp = zC;
var se = {};
Object.defineProperty(se, "__esModule", { value: !0 });
se.validateBskyAppProgressGuide = se.isBskyAppProgressGuide = se.validateBskyAppStatePref = se.isBskyAppStatePref = se.validateLabelerPrefItem = se.isLabelerPrefItem = se.validateLabelersPref = se.isLabelersPref = se.validateHiddenPostsPref = se.isHiddenPostsPref = se.validateMutedWordsPref = se.isMutedWordsPref = se.validateMutedWord = se.isMutedWord = se.validateInterestsPref = se.isInterestsPref = se.validateThreadViewPref = se.isThreadViewPref = se.validateFeedViewPref = se.isFeedViewPref = se.validatePersonalDetailsPref = se.isPersonalDetailsPref = se.validateSavedFeedsPref = se.isSavedFeedsPref = se.validateSavedFeedsPrefV2 = se.isSavedFeedsPrefV2 = se.validateSavedFeed = se.isSavedFeed = se.validateContentLabelPref = se.isContentLabelPref = se.validateAdultContentPref = se.isAdultContentPref = se.validateKnownFollowers = se.isKnownFollowers = se.validateViewerState = se.isViewerState = se.validateProfileAssociatedChat = se.isProfileAssociatedChat = se.validateProfileAssociated = se.isProfileAssociated = se.validateProfileViewDetailed = se.isProfileViewDetailed = se.validateProfileView = se.isProfileView = se.validateProfileViewBasic = se.isProfileViewBasic = void 0;
const Pe = we, ht = Le;
function XC(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#profileViewBasic";
}
se.isProfileViewBasic = XC;
function HC(t) {
  return ht.lexicons.validate("app.bsky.actor.defs#profileViewBasic", t);
}
se.validateProfileViewBasic = HC;
function ZC(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#profileView";
}
se.isProfileView = ZC;
function WC(t) {
  return ht.lexicons.validate("app.bsky.actor.defs#profileView", t);
}
se.validateProfileView = WC;
function YC(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#profileViewDetailed";
}
se.isProfileViewDetailed = YC;
function JC(t) {
  return ht.lexicons.validate("app.bsky.actor.defs#profileViewDetailed", t);
}
se.validateProfileViewDetailed = JC;
function QC(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#profileAssociated";
}
se.isProfileAssociated = QC;
function e1(t) {
  return ht.lexicons.validate("app.bsky.actor.defs#profileAssociated", t);
}
se.validateProfileAssociated = e1;
function t1(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#profileAssociatedChat";
}
se.isProfileAssociatedChat = t1;
function r1(t) {
  return ht.lexicons.validate("app.bsky.actor.defs#profileAssociatedChat", t);
}
se.validateProfileAssociatedChat = r1;
function i1(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#viewerState";
}
se.isViewerState = i1;
function n1(t) {
  return ht.lexicons.validate("app.bsky.actor.defs#viewerState", t);
}
se.validateViewerState = n1;
function s1(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#knownFollowers";
}
se.isKnownFollowers = s1;
function a1(t) {
  return ht.lexicons.validate("app.bsky.actor.defs#knownFollowers", t);
}
se.validateKnownFollowers = a1;
function o1(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#adultContentPref";
}
se.isAdultContentPref = o1;
function l1(t) {
  return ht.lexicons.validate("app.bsky.actor.defs#adultContentPref", t);
}
se.validateAdultContentPref = l1;
function u1(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#contentLabelPref";
}
se.isContentLabelPref = u1;
function c1(t) {
  return ht.lexicons.validate("app.bsky.actor.defs#contentLabelPref", t);
}
se.validateContentLabelPref = c1;
function d1(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#savedFeed";
}
se.isSavedFeed = d1;
function f1(t) {
  return ht.lexicons.validate("app.bsky.actor.defs#savedFeed", t);
}
se.validateSavedFeed = f1;
function p1(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#savedFeedsPrefV2";
}
se.isSavedFeedsPrefV2 = p1;
function h1(t) {
  return ht.lexicons.validate("app.bsky.actor.defs#savedFeedsPrefV2", t);
}
se.validateSavedFeedsPrefV2 = h1;
function m1(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#savedFeedsPref";
}
se.isSavedFeedsPref = m1;
function y1(t) {
  return ht.lexicons.validate("app.bsky.actor.defs#savedFeedsPref", t);
}
se.validateSavedFeedsPref = y1;
function b1(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#personalDetailsPref";
}
se.isPersonalDetailsPref = b1;
function g1(t) {
  return ht.lexicons.validate("app.bsky.actor.defs#personalDetailsPref", t);
}
se.validatePersonalDetailsPref = g1;
function x1(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#feedViewPref";
}
se.isFeedViewPref = x1;
function E1(t) {
  return ht.lexicons.validate("app.bsky.actor.defs#feedViewPref", t);
}
se.validateFeedViewPref = E1;
function v1(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#threadViewPref";
}
se.isThreadViewPref = v1;
function R1(t) {
  return ht.lexicons.validate("app.bsky.actor.defs#threadViewPref", t);
}
se.validateThreadViewPref = R1;
function A1(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#interestsPref";
}
se.isInterestsPref = A1;
function _1(t) {
  return ht.lexicons.validate("app.bsky.actor.defs#interestsPref", t);
}
se.validateInterestsPref = _1;
function w1(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#mutedWord";
}
se.isMutedWord = w1;
function T1(t) {
  return ht.lexicons.validate("app.bsky.actor.defs#mutedWord", t);
}
se.validateMutedWord = T1;
function S1(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#mutedWordsPref";
}
se.isMutedWordsPref = S1;
function C1(t) {
  return ht.lexicons.validate("app.bsky.actor.defs#mutedWordsPref", t);
}
se.validateMutedWordsPref = C1;
function L1(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#hiddenPostsPref";
}
se.isHiddenPostsPref = L1;
function k1(t) {
  return ht.lexicons.validate("app.bsky.actor.defs#hiddenPostsPref", t);
}
se.validateHiddenPostsPref = k1;
function D1(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#labelersPref";
}
se.isLabelersPref = D1;
function P1(t) {
  return ht.lexicons.validate("app.bsky.actor.defs#labelersPref", t);
}
se.validateLabelersPref = P1;
function B1(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#labelerPrefItem";
}
se.isLabelerPrefItem = B1;
function I1(t) {
  return ht.lexicons.validate("app.bsky.actor.defs#labelerPrefItem", t);
}
se.validateLabelerPrefItem = I1;
function U1(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#bskyAppStatePref";
}
se.isBskyAppStatePref = U1;
function O1(t) {
  return ht.lexicons.validate("app.bsky.actor.defs#bskyAppStatePref", t);
}
se.validateBskyAppStatePref = O1;
function K1(t) {
  return (0, Pe.isObj)(t) && (0, Pe.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#bskyAppProgressGuide";
}
se.isBskyAppProgressGuide = K1;
function M1(t) {
  return ht.lexicons.validate("app.bsky.actor.defs#bskyAppProgressGuide", t);
}
se.validateBskyAppProgressGuide = M1;
var Cs = {};
Object.defineProperty(Cs, "__esModule", { value: !0 });
Cs.validateRecord = Cs.isRecord = void 0;
const Qd = we, N1 = Le;
function V1(t) {
  return (0, Qd.isObj)(t) && (0, Qd.hasProp)(t, "$type") && (t.$type === "app.bsky.actor.profile#main" || t.$type === "app.bsky.actor.profile");
}
Cs.isRecord = V1;
function j1(t) {
  return N1.lexicons.validate("app.bsky.actor.profile#main", t);
}
Cs.validateRecord = j1;
var Kt = {};
Object.defineProperty(Kt, "__esModule", { value: !0 });
Kt.validateViewExternal = Kt.isViewExternal = Kt.validateView = Kt.isView = Kt.validateExternal = Kt.isExternal = Kt.validateMain = Kt.isMain = void 0;
const yn = we, Nu = Le;
function F1(t) {
  return (0, yn.isObj)(t) && (0, yn.hasProp)(t, "$type") && (t.$type === "app.bsky.embed.external#main" || t.$type === "app.bsky.embed.external");
}
Kt.isMain = F1;
function $1(t) {
  return Nu.lexicons.validate("app.bsky.embed.external#main", t);
}
Kt.validateMain = $1;
function G1(t) {
  return (0, yn.isObj)(t) && (0, yn.hasProp)(t, "$type") && t.$type === "app.bsky.embed.external#external";
}
Kt.isExternal = G1;
function q1(t) {
  return Nu.lexicons.validate("app.bsky.embed.external#external", t);
}
Kt.validateExternal = q1;
function z1(t) {
  return (0, yn.isObj)(t) && (0, yn.hasProp)(t, "$type") && t.$type === "app.bsky.embed.external#view";
}
Kt.isView = z1;
function X1(t) {
  return Nu.lexicons.validate("app.bsky.embed.external#view", t);
}
Kt.validateView = X1;
function H1(t) {
  return (0, yn.isObj)(t) && (0, yn.hasProp)(t, "$type") && t.$type === "app.bsky.embed.external#viewExternal";
}
Kt.isViewExternal = H1;
function Z1(t) {
  return Nu.lexicons.validate("app.bsky.embed.external#viewExternal", t);
}
Kt.validateViewExternal = Z1;
var yt = {};
Object.defineProperty(yt, "__esModule", { value: !0 });
yt.validateViewImage = yt.isViewImage = yt.validateView = yt.isView = yt.validateAspectRatio = yt.isAspectRatio = yt.validateImage = yt.isImage = yt.validateMain = yt.isMain = void 0;
const yi = we, Ml = Le;
function W1(t) {
  return (0, yi.isObj)(t) && (0, yi.hasProp)(t, "$type") && (t.$type === "app.bsky.embed.images#main" || t.$type === "app.bsky.embed.images");
}
yt.isMain = W1;
function Y1(t) {
  return Ml.lexicons.validate("app.bsky.embed.images#main", t);
}
yt.validateMain = Y1;
function J1(t) {
  return (0, yi.isObj)(t) && (0, yi.hasProp)(t, "$type") && t.$type === "app.bsky.embed.images#image";
}
yt.isImage = J1;
function Q1(t) {
  return Ml.lexicons.validate("app.bsky.embed.images#image", t);
}
yt.validateImage = Q1;
function eL(t) {
  return (0, yi.isObj)(t) && (0, yi.hasProp)(t, "$type") && t.$type === "app.bsky.embed.images#aspectRatio";
}
yt.isAspectRatio = eL;
function tL(t) {
  return Ml.lexicons.validate("app.bsky.embed.images#aspectRatio", t);
}
yt.validateAspectRatio = tL;
function rL(t) {
  return (0, yi.isObj)(t) && (0, yi.hasProp)(t, "$type") && t.$type === "app.bsky.embed.images#view";
}
yt.isView = rL;
function iL(t) {
  return Ml.lexicons.validate("app.bsky.embed.images#view", t);
}
yt.validateView = iL;
function nL(t) {
  return (0, yi.isObj)(t) && (0, yi.hasProp)(t, "$type") && t.$type === "app.bsky.embed.images#viewImage";
}
yt.isViewImage = nL;
function sL(t) {
  return Ml.lexicons.validate("app.bsky.embed.images#viewImage", t);
}
yt.validateViewImage = sL;
var bt = {};
Object.defineProperty(bt, "__esModule", { value: !0 });
bt.validateViewBlocked = bt.isViewBlocked = bt.validateViewNotFound = bt.isViewNotFound = bt.validateViewRecord = bt.isViewRecord = bt.validateView = bt.isView = bt.validateMain = bt.isMain = void 0;
const bi = we, Nl = Le;
function aL(t) {
  return (0, bi.isObj)(t) && (0, bi.hasProp)(t, "$type") && (t.$type === "app.bsky.embed.record#main" || t.$type === "app.bsky.embed.record");
}
bt.isMain = aL;
function oL(t) {
  return Nl.lexicons.validate("app.bsky.embed.record#main", t);
}
bt.validateMain = oL;
function lL(t) {
  return (0, bi.isObj)(t) && (0, bi.hasProp)(t, "$type") && t.$type === "app.bsky.embed.record#view";
}
bt.isView = lL;
function uL(t) {
  return Nl.lexicons.validate("app.bsky.embed.record#view", t);
}
bt.validateView = uL;
function cL(t) {
  return (0, bi.isObj)(t) && (0, bi.hasProp)(t, "$type") && t.$type === "app.bsky.embed.record#viewRecord";
}
bt.isViewRecord = cL;
function dL(t) {
  return Nl.lexicons.validate("app.bsky.embed.record#viewRecord", t);
}
bt.validateViewRecord = dL;
function fL(t) {
  return (0, bi.isObj)(t) && (0, bi.hasProp)(t, "$type") && t.$type === "app.bsky.embed.record#viewNotFound";
}
bt.isViewNotFound = fL;
function pL(t) {
  return Nl.lexicons.validate("app.bsky.embed.record#viewNotFound", t);
}
bt.validateViewNotFound = pL;
function hL(t) {
  return (0, bi.isObj)(t) && (0, bi.hasProp)(t, "$type") && t.$type === "app.bsky.embed.record#viewBlocked";
}
bt.isViewBlocked = hL;
function mL(t) {
  return Nl.lexicons.validate("app.bsky.embed.record#viewBlocked", t);
}
bt.validateViewBlocked = mL;
var ai = {};
Object.defineProperty(ai, "__esModule", { value: !0 });
ai.validateView = ai.isView = ai.validateMain = ai.isMain = void 0;
const Tu = we, z0 = Le;
function yL(t) {
  return (0, Tu.isObj)(t) && (0, Tu.hasProp)(t, "$type") && (t.$type === "app.bsky.embed.recordWithMedia#main" || t.$type === "app.bsky.embed.recordWithMedia");
}
ai.isMain = yL;
function bL(t) {
  return z0.lexicons.validate("app.bsky.embed.recordWithMedia#main", t);
}
ai.validateMain = bL;
function gL(t) {
  return (0, Tu.isObj)(t) && (0, Tu.hasProp)(t, "$type") && t.$type === "app.bsky.embed.recordWithMedia#view";
}
ai.isView = gL;
function xL(t) {
  return z0.lexicons.validate("app.bsky.embed.recordWithMedia#view", t);
}
ai.validateView = xL;
var ue = {};
Object.defineProperty(ue, "__esModule", { value: !0 });
ue.INTERACTIONSHARE = ue.INTERACTIONQUOTE = ue.INTERACTIONREPLY = ue.INTERACTIONREPOST = ue.INTERACTIONLIKE = ue.INTERACTIONSEEN = ue.CLICKTHROUGHEMBED = ue.CLICKTHROUGHREPOSTER = ue.CLICKTHROUGHAUTHOR = ue.CLICKTHROUGHITEM = ue.REQUESTMORE = ue.REQUESTLESS = ue.validateInteraction = ue.isInteraction = ue.validateThreadgateView = ue.isThreadgateView = ue.validateSkeletonReasonRepost = ue.isSkeletonReasonRepost = ue.validateSkeletonFeedPost = ue.isSkeletonFeedPost = ue.validateGeneratorViewerState = ue.isGeneratorViewerState = ue.validateGeneratorView = ue.isGeneratorView = ue.validateBlockedAuthor = ue.isBlockedAuthor = ue.validateBlockedPost = ue.isBlockedPost = ue.validateNotFoundPost = ue.isNotFoundPost = ue.validateThreadViewPost = ue.isThreadViewPost = ue.validateReasonRepost = ue.isReasonRepost = ue.validateReplyRef = ue.isReplyRef = ue.validateFeedViewPost = ue.isFeedViewPost = ue.validateViewerState = ue.isViewerState = ue.validatePostView = ue.isPostView = void 0;
const We = we, cr = Le;
function EL(t) {
  return (0, We.isObj)(t) && (0, We.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#postView";
}
ue.isPostView = EL;
function vL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#postView", t);
}
ue.validatePostView = vL;
function RL(t) {
  return (0, We.isObj)(t) && (0, We.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#viewerState";
}
ue.isViewerState = RL;
function AL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#viewerState", t);
}
ue.validateViewerState = AL;
function _L(t) {
  return (0, We.isObj)(t) && (0, We.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#feedViewPost";
}
ue.isFeedViewPost = _L;
function wL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#feedViewPost", t);
}
ue.validateFeedViewPost = wL;
function TL(t) {
  return (0, We.isObj)(t) && (0, We.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#replyRef";
}
ue.isReplyRef = TL;
function SL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#replyRef", t);
}
ue.validateReplyRef = SL;
function CL(t) {
  return (0, We.isObj)(t) && (0, We.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#reasonRepost";
}
ue.isReasonRepost = CL;
function LL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#reasonRepost", t);
}
ue.validateReasonRepost = LL;
function kL(t) {
  return (0, We.isObj)(t) && (0, We.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#threadViewPost";
}
ue.isThreadViewPost = kL;
function DL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#threadViewPost", t);
}
ue.validateThreadViewPost = DL;
function PL(t) {
  return (0, We.isObj)(t) && (0, We.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#notFoundPost";
}
ue.isNotFoundPost = PL;
function BL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#notFoundPost", t);
}
ue.validateNotFoundPost = BL;
function IL(t) {
  return (0, We.isObj)(t) && (0, We.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#blockedPost";
}
ue.isBlockedPost = IL;
function UL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#blockedPost", t);
}
ue.validateBlockedPost = UL;
function OL(t) {
  return (0, We.isObj)(t) && (0, We.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#blockedAuthor";
}
ue.isBlockedAuthor = OL;
function KL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#blockedAuthor", t);
}
ue.validateBlockedAuthor = KL;
function ML(t) {
  return (0, We.isObj)(t) && (0, We.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#generatorView";
}
ue.isGeneratorView = ML;
function NL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#generatorView", t);
}
ue.validateGeneratorView = NL;
function VL(t) {
  return (0, We.isObj)(t) && (0, We.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#generatorViewerState";
}
ue.isGeneratorViewerState = VL;
function jL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#generatorViewerState", t);
}
ue.validateGeneratorViewerState = jL;
function FL(t) {
  return (0, We.isObj)(t) && (0, We.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#skeletonFeedPost";
}
ue.isSkeletonFeedPost = FL;
function $L(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#skeletonFeedPost", t);
}
ue.validateSkeletonFeedPost = $L;
function GL(t) {
  return (0, We.isObj)(t) && (0, We.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#skeletonReasonRepost";
}
ue.isSkeletonReasonRepost = GL;
function qL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#skeletonReasonRepost", t);
}
ue.validateSkeletonReasonRepost = qL;
function zL(t) {
  return (0, We.isObj)(t) && (0, We.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#threadgateView";
}
ue.isThreadgateView = zL;
function XL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#threadgateView", t);
}
ue.validateThreadgateView = XL;
function HL(t) {
  return (0, We.isObj)(t) && (0, We.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#interaction";
}
ue.isInteraction = HL;
function ZL(t) {
  return cr.lexicons.validate("app.bsky.feed.defs#interaction", t);
}
ue.validateInteraction = ZL;
ue.REQUESTLESS = "app.bsky.feed.defs#requestLess";
ue.REQUESTMORE = "app.bsky.feed.defs#requestMore";
ue.CLICKTHROUGHITEM = "app.bsky.feed.defs#clickthroughItem";
ue.CLICKTHROUGHAUTHOR = "app.bsky.feed.defs#clickthroughAuthor";
ue.CLICKTHROUGHREPOSTER = "app.bsky.feed.defs#clickthroughReposter";
ue.CLICKTHROUGHEMBED = "app.bsky.feed.defs#clickthroughEmbed";
ue.INTERACTIONSEEN = "app.bsky.feed.defs#interactionSeen";
ue.INTERACTIONLIKE = "app.bsky.feed.defs#interactionLike";
ue.INTERACTIONREPOST = "app.bsky.feed.defs#interactionRepost";
ue.INTERACTIONREPLY = "app.bsky.feed.defs#interactionReply";
ue.INTERACTIONQUOTE = "app.bsky.feed.defs#interactionQuote";
ue.INTERACTIONSHARE = "app.bsky.feed.defs#interactionShare";
var Ls = {};
Object.defineProperty(Ls, "__esModule", { value: !0 });
Ls.validateRecord = Ls.isRecord = void 0;
const ef = we, WL = Le;
function YL(t) {
  return (0, ef.isObj)(t) && (0, ef.hasProp)(t, "$type") && (t.$type === "app.bsky.feed.generator#main" || t.$type === "app.bsky.feed.generator");
}
Ls.isRecord = YL;
function JL(t) {
  return WL.lexicons.validate("app.bsky.feed.generator#main", t);
}
Ls.validateRecord = JL;
var ks = {};
Object.defineProperty(ks, "__esModule", { value: !0 });
ks.validateRecord = ks.isRecord = void 0;
const tf = we, QL = Le;
function ek(t) {
  return (0, tf.isObj)(t) && (0, tf.hasProp)(t, "$type") && (t.$type === "app.bsky.feed.like#main" || t.$type === "app.bsky.feed.like");
}
ks.isRecord = ek;
function tk(t) {
  return QL.lexicons.validate("app.bsky.feed.like#main", t);
}
ks.validateRecord = tk;
var Mt = {};
Object.defineProperty(Mt, "__esModule", { value: !0 });
Mt.validateTextSlice = Mt.isTextSlice = Mt.validateEntity = Mt.isEntity = Mt.validateReplyRef = Mt.isReplyRef = Mt.validateRecord = Mt.isRecord = void 0;
const bn = we, Vu = Le;
function rk(t) {
  return (0, bn.isObj)(t) && (0, bn.hasProp)(t, "$type") && (t.$type === "app.bsky.feed.post#main" || t.$type === "app.bsky.feed.post");
}
Mt.isRecord = rk;
function ik(t) {
  return Vu.lexicons.validate("app.bsky.feed.post#main", t);
}
Mt.validateRecord = ik;
function nk(t) {
  return (0, bn.isObj)(t) && (0, bn.hasProp)(t, "$type") && t.$type === "app.bsky.feed.post#replyRef";
}
Mt.isReplyRef = nk;
function sk(t) {
  return Vu.lexicons.validate("app.bsky.feed.post#replyRef", t);
}
Mt.validateReplyRef = sk;
function ak(t) {
  return (0, bn.isObj)(t) && (0, bn.hasProp)(t, "$type") && t.$type === "app.bsky.feed.post#entity";
}
Mt.isEntity = ak;
function ok(t) {
  return Vu.lexicons.validate("app.bsky.feed.post#entity", t);
}
Mt.validateEntity = ok;
function lk(t) {
  return (0, bn.isObj)(t) && (0, bn.hasProp)(t, "$type") && t.$type === "app.bsky.feed.post#textSlice";
}
Mt.isTextSlice = lk;
function uk(t) {
  return Vu.lexicons.validate("app.bsky.feed.post#textSlice", t);
}
Mt.validateTextSlice = uk;
var Ds = {};
Object.defineProperty(Ds, "__esModule", { value: !0 });
Ds.validateRecord = Ds.isRecord = void 0;
const rf = we, ck = Le;
function dk(t) {
  return (0, rf.isObj)(t) && (0, rf.hasProp)(t, "$type") && (t.$type === "app.bsky.feed.repost#main" || t.$type === "app.bsky.feed.repost");
}
Ds.isRecord = dk;
function fk(t) {
  return ck.lexicons.validate("app.bsky.feed.repost#main", t);
}
Ds.validateRecord = fk;
var Nt = {};
Object.defineProperty(Nt, "__esModule", { value: !0 });
Nt.validateListRule = Nt.isListRule = Nt.validateFollowingRule = Nt.isFollowingRule = Nt.validateMentionRule = Nt.isMentionRule = Nt.validateRecord = Nt.isRecord = void 0;
const gn = we, ju = Le;
function pk(t) {
  return (0, gn.isObj)(t) && (0, gn.hasProp)(t, "$type") && (t.$type === "app.bsky.feed.threadgate#main" || t.$type === "app.bsky.feed.threadgate");
}
Nt.isRecord = pk;
function hk(t) {
  return ju.lexicons.validate("app.bsky.feed.threadgate#main", t);
}
Nt.validateRecord = hk;
function mk(t) {
  return (0, gn.isObj)(t) && (0, gn.hasProp)(t, "$type") && t.$type === "app.bsky.feed.threadgate#mentionRule";
}
Nt.isMentionRule = mk;
function yk(t) {
  return ju.lexicons.validate("app.bsky.feed.threadgate#mentionRule", t);
}
Nt.validateMentionRule = yk;
function bk(t) {
  return (0, gn.isObj)(t) && (0, gn.hasProp)(t, "$type") && t.$type === "app.bsky.feed.threadgate#followingRule";
}
Nt.isFollowingRule = bk;
function gk(t) {
  return ju.lexicons.validate("app.bsky.feed.threadgate#followingRule", t);
}
Nt.validateFollowingRule = gk;
function xk(t) {
  return (0, gn.isObj)(t) && (0, gn.hasProp)(t, "$type") && t.$type === "app.bsky.feed.threadgate#listRule";
}
Nt.isListRule = xk;
function Ek(t) {
  return ju.lexicons.validate("app.bsky.feed.threadgate#listRule", t);
}
Nt.validateListRule = Ek;
var Ps = {};
Object.defineProperty(Ps, "__esModule", { value: !0 });
Ps.validateRecord = Ps.isRecord = void 0;
const nf = we, vk = Le;
function Rk(t) {
  return (0, nf.isObj)(t) && (0, nf.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.block#main" || t.$type === "app.bsky.graph.block");
}
Ps.isRecord = Rk;
function Ak(t) {
  return vk.lexicons.validate("app.bsky.graph.block#main", t);
}
Ps.validateRecord = Ak;
var Ne = {};
Object.defineProperty(Ne, "__esModule", { value: !0 });
Ne.validateRelationship = Ne.isRelationship = Ne.validateNotFoundActor = Ne.isNotFoundActor = Ne.validateListViewerState = Ne.isListViewerState = Ne.REFERENCELIST = Ne.CURATELIST = Ne.MODLIST = Ne.validateStarterPackViewBasic = Ne.isStarterPackViewBasic = Ne.validateStarterPackView = Ne.isStarterPackView = Ne.validateListItemView = Ne.isListItemView = Ne.validateListView = Ne.isListView = Ne.validateListViewBasic = Ne.isListViewBasic = void 0;
const er = we, Tn = Le;
function _k(t) {
  return (0, er.isObj)(t) && (0, er.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#listViewBasic";
}
Ne.isListViewBasic = _k;
function wk(t) {
  return Tn.lexicons.validate("app.bsky.graph.defs#listViewBasic", t);
}
Ne.validateListViewBasic = wk;
function Tk(t) {
  return (0, er.isObj)(t) && (0, er.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#listView";
}
Ne.isListView = Tk;
function Sk(t) {
  return Tn.lexicons.validate("app.bsky.graph.defs#listView", t);
}
Ne.validateListView = Sk;
function Ck(t) {
  return (0, er.isObj)(t) && (0, er.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#listItemView";
}
Ne.isListItemView = Ck;
function Lk(t) {
  return Tn.lexicons.validate("app.bsky.graph.defs#listItemView", t);
}
Ne.validateListItemView = Lk;
function kk(t) {
  return (0, er.isObj)(t) && (0, er.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#starterPackView";
}
Ne.isStarterPackView = kk;
function Dk(t) {
  return Tn.lexicons.validate("app.bsky.graph.defs#starterPackView", t);
}
Ne.validateStarterPackView = Dk;
function Pk(t) {
  return (0, er.isObj)(t) && (0, er.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#starterPackViewBasic";
}
Ne.isStarterPackViewBasic = Pk;
function Bk(t) {
  return Tn.lexicons.validate("app.bsky.graph.defs#starterPackViewBasic", t);
}
Ne.validateStarterPackViewBasic = Bk;
Ne.MODLIST = "app.bsky.graph.defs#modlist";
Ne.CURATELIST = "app.bsky.graph.defs#curatelist";
Ne.REFERENCELIST = "app.bsky.graph.defs#referencelist";
function Ik(t) {
  return (0, er.isObj)(t) && (0, er.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#listViewerState";
}
Ne.isListViewerState = Ik;
function Uk(t) {
  return Tn.lexicons.validate("app.bsky.graph.defs#listViewerState", t);
}
Ne.validateListViewerState = Uk;
function Ok(t) {
  return (0, er.isObj)(t) && (0, er.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#notFoundActor";
}
Ne.isNotFoundActor = Ok;
function Kk(t) {
  return Tn.lexicons.validate("app.bsky.graph.defs#notFoundActor", t);
}
Ne.validateNotFoundActor = Kk;
function Mk(t) {
  return (0, er.isObj)(t) && (0, er.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#relationship";
}
Ne.isRelationship = Mk;
function Nk(t) {
  return Tn.lexicons.validate("app.bsky.graph.defs#relationship", t);
}
Ne.validateRelationship = Nk;
var Bs = {};
Object.defineProperty(Bs, "__esModule", { value: !0 });
Bs.validateRecord = Bs.isRecord = void 0;
const sf = we, Vk = Le;
function jk(t) {
  return (0, sf.isObj)(t) && (0, sf.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.follow#main" || t.$type === "app.bsky.graph.follow");
}
Bs.isRecord = jk;
function Fk(t) {
  return Vk.lexicons.validate("app.bsky.graph.follow#main", t);
}
Bs.validateRecord = Fk;
var Is = {};
Object.defineProperty(Is, "__esModule", { value: !0 });
Is.validateRecord = Is.isRecord = void 0;
const af = we, $k = Le;
function Gk(t) {
  return (0, af.isObj)(t) && (0, af.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.list#main" || t.$type === "app.bsky.graph.list");
}
Is.isRecord = Gk;
function qk(t) {
  return $k.lexicons.validate("app.bsky.graph.list#main", t);
}
Is.validateRecord = qk;
var Us = {};
Object.defineProperty(Us, "__esModule", { value: !0 });
Us.validateRecord = Us.isRecord = void 0;
const of = we, zk = Le;
function Xk(t) {
  return (0, of.isObj)(t) && (0, of.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.listblock#main" || t.$type === "app.bsky.graph.listblock");
}
Us.isRecord = Xk;
function Hk(t) {
  return zk.lexicons.validate("app.bsky.graph.listblock#main", t);
}
Us.validateRecord = Hk;
var Os = {};
Object.defineProperty(Os, "__esModule", { value: !0 });
Os.validateRecord = Os.isRecord = void 0;
const lf = we, Zk = Le;
function Wk(t) {
  return (0, lf.isObj)(t) && (0, lf.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.listitem#main" || t.$type === "app.bsky.graph.listitem");
}
Os.isRecord = Wk;
function Yk(t) {
  return Zk.lexicons.validate("app.bsky.graph.listitem#main", t);
}
Os.validateRecord = Yk;
var oi = {};
Object.defineProperty(oi, "__esModule", { value: !0 });
oi.validateFeedItem = oi.isFeedItem = oi.validateRecord = oi.isRecord = void 0;
const Su = we, X0 = Le;
function Jk(t) {
  return (0, Su.isObj)(t) && (0, Su.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.starterpack#main" || t.$type === "app.bsky.graph.starterpack");
}
oi.isRecord = Jk;
function Qk(t) {
  return X0.lexicons.validate("app.bsky.graph.starterpack#main", t);
}
oi.validateRecord = Qk;
function eD(t) {
  return (0, Su.isObj)(t) && (0, Su.hasProp)(t, "$type") && t.$type === "app.bsky.graph.starterpack#feedItem";
}
oi.isFeedItem = eD;
function tD(t) {
  return X0.lexicons.validate("app.bsky.graph.starterpack#feedItem", t);
}
oi.validateFeedItem = tD;
var Vt = {};
Object.defineProperty(Vt, "__esModule", { value: !0 });
Vt.validateLabelerPolicies = Vt.isLabelerPolicies = Vt.validateLabelerViewerState = Vt.isLabelerViewerState = Vt.validateLabelerViewDetailed = Vt.isLabelerViewDetailed = Vt.validateLabelerView = Vt.isLabelerView = void 0;
const xn = we, Fu = Le;
function rD(t) {
  return (0, xn.isObj)(t) && (0, xn.hasProp)(t, "$type") && t.$type === "app.bsky.labeler.defs#labelerView";
}
Vt.isLabelerView = rD;
function iD(t) {
  return Fu.lexicons.validate("app.bsky.labeler.defs#labelerView", t);
}
Vt.validateLabelerView = iD;
function nD(t) {
  return (0, xn.isObj)(t) && (0, xn.hasProp)(t, "$type") && t.$type === "app.bsky.labeler.defs#labelerViewDetailed";
}
Vt.isLabelerViewDetailed = nD;
function sD(t) {
  return Fu.lexicons.validate("app.bsky.labeler.defs#labelerViewDetailed", t);
}
Vt.validateLabelerViewDetailed = sD;
function aD(t) {
  return (0, xn.isObj)(t) && (0, xn.hasProp)(t, "$type") && t.$type === "app.bsky.labeler.defs#labelerViewerState";
}
Vt.isLabelerViewerState = aD;
function oD(t) {
  return Fu.lexicons.validate("app.bsky.labeler.defs#labelerViewerState", t);
}
Vt.validateLabelerViewerState = oD;
function lD(t) {
  return (0, xn.isObj)(t) && (0, xn.hasProp)(t, "$type") && t.$type === "app.bsky.labeler.defs#labelerPolicies";
}
Vt.isLabelerPolicies = lD;
function uD(t) {
  return Fu.lexicons.validate("app.bsky.labeler.defs#labelerPolicies", t);
}
Vt.validateLabelerPolicies = uD;
var Ks = {};
Object.defineProperty(Ks, "__esModule", { value: !0 });
Ks.validateRecord = Ks.isRecord = void 0;
const uf = we, cD = Le;
function dD(t) {
  return (0, uf.isObj)(t) && (0, uf.hasProp)(t, "$type") && (t.$type === "app.bsky.labeler.service#main" || t.$type === "app.bsky.labeler.service");
}
Ks.isRecord = dD;
function fD(t) {
  return cD.lexicons.validate("app.bsky.labeler.service#main", t);
}
Ks.validateRecord = fD;
var gt = {};
Object.defineProperty(gt, "__esModule", { value: !0 });
gt.validateByteSlice = gt.isByteSlice = gt.validateTag = gt.isTag = gt.validateLink = gt.isLink = gt.validateMention = gt.isMention = gt.validateMain = gt.isMain = void 0;
const gi = we, Vl = Le;
function pD(t) {
  return (0, gi.isObj)(t) && (0, gi.hasProp)(t, "$type") && (t.$type === "app.bsky.richtext.facet#main" || t.$type === "app.bsky.richtext.facet");
}
gt.isMain = pD;
function hD(t) {
  return Vl.lexicons.validate("app.bsky.richtext.facet#main", t);
}
gt.validateMain = hD;
function mD(t) {
  return (0, gi.isObj)(t) && (0, gi.hasProp)(t, "$type") && t.$type === "app.bsky.richtext.facet#mention";
}
gt.isMention = mD;
function yD(t) {
  return Vl.lexicons.validate("app.bsky.richtext.facet#mention", t);
}
gt.validateMention = yD;
function bD(t) {
  return (0, gi.isObj)(t) && (0, gi.hasProp)(t, "$type") && t.$type === "app.bsky.richtext.facet#link";
}
gt.isLink = bD;
function gD(t) {
  return Vl.lexicons.validate("app.bsky.richtext.facet#link", t);
}
gt.validateLink = gD;
function xD(t) {
  return (0, gi.isObj)(t) && (0, gi.hasProp)(t, "$type") && t.$type === "app.bsky.richtext.facet#tag";
}
gt.isTag = xD;
function ED(t) {
  return Vl.lexicons.validate("app.bsky.richtext.facet#tag", t);
}
gt.validateTag = ED;
function vD(t) {
  return (0, gi.isObj)(t) && (0, gi.hasProp)(t, "$type") && t.$type === "app.bsky.richtext.facet#byteSlice";
}
gt.isByteSlice = vD;
function RD(t) {
  return Vl.lexicons.validate("app.bsky.richtext.facet#byteSlice", t);
}
gt.validateByteSlice = RD;
var li = {};
Object.defineProperty(li, "__esModule", { value: !0 });
li.validateSkeletonSearchActor = li.isSkeletonSearchActor = li.validateSkeletonSearchPost = li.isSkeletonSearchPost = void 0;
const Cu = we, H0 = Le;
function AD(t) {
  return (0, Cu.isObj)(t) && (0, Cu.hasProp)(t, "$type") && t.$type === "app.bsky.unspecced.defs#skeletonSearchPost";
}
li.isSkeletonSearchPost = AD;
function _D(t) {
  return H0.lexicons.validate("app.bsky.unspecced.defs#skeletonSearchPost", t);
}
li.validateSkeletonSearchPost = _D;
function wD(t) {
  return (0, Cu.isObj)(t) && (0, Cu.hasProp)(t, "$type") && t.$type === "app.bsky.unspecced.defs#skeletonSearchActor";
}
li.isSkeletonSearchActor = wD;
function TD(t) {
  return H0.lexicons.validate("app.bsky.unspecced.defs#skeletonSearchActor", t);
}
li.validateSkeletonSearchActor = TD;
var Ms = {};
Object.defineProperty(Ms, "__esModule", { value: !0 });
Ms.validateRecord = Ms.isRecord = void 0;
const cf = we, SD = Le;
function CD(t) {
  return (0, cf.isObj)(t) && (0, cf.hasProp)(t, "$type") && (t.$type === "chat.bsky.actor.declaration#main" || t.$type === "chat.bsky.actor.declaration");
}
Ms.isRecord = CD;
function LD(t) {
  return SD.lexicons.validate("chat.bsky.actor.declaration#main", t);
}
Ms.validateRecord = LD;
var Ns = {};
Object.defineProperty(Ns, "__esModule", { value: !0 });
Ns.validateProfileViewBasic = Ns.isProfileViewBasic = void 0;
const df = we, kD = Le;
function DD(t) {
  return (0, df.isObj)(t) && (0, df.hasProp)(t, "$type") && t.$type === "chat.bsky.actor.defs#profileViewBasic";
}
Ns.isProfileViewBasic = DD;
function PD(t) {
  return kD.lexicons.validate("chat.bsky.actor.defs#profileViewBasic", t);
}
Ns.validateProfileViewBasic = PD;
var Ue = {};
Object.defineProperty(Ue, "__esModule", { value: !0 });
Ue.validateLogDeleteMessage = Ue.isLogDeleteMessage = Ue.validateLogCreateMessage = Ue.isLogCreateMessage = Ue.validateLogLeaveConvo = Ue.isLogLeaveConvo = Ue.validateLogBeginConvo = Ue.isLogBeginConvo = Ue.validateConvoView = Ue.isConvoView = Ue.validateMessageViewSender = Ue.isMessageViewSender = Ue.validateDeletedMessageView = Ue.isDeletedMessageView = Ue.validateMessageView = Ue.isMessageView = Ue.validateMessageInput = Ue.isMessageInput = Ue.validateMessageRef = Ue.isMessageRef = void 0;
const Tt = we, Ai = Le;
function BD(t) {
  return (0, Tt.isObj)(t) && (0, Tt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#messageRef";
}
Ue.isMessageRef = BD;
function ID(t) {
  return Ai.lexicons.validate("chat.bsky.convo.defs#messageRef", t);
}
Ue.validateMessageRef = ID;
function UD(t) {
  return (0, Tt.isObj)(t) && (0, Tt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#messageInput";
}
Ue.isMessageInput = UD;
function OD(t) {
  return Ai.lexicons.validate("chat.bsky.convo.defs#messageInput", t);
}
Ue.validateMessageInput = OD;
function KD(t) {
  return (0, Tt.isObj)(t) && (0, Tt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#messageView";
}
Ue.isMessageView = KD;
function MD(t) {
  return Ai.lexicons.validate("chat.bsky.convo.defs#messageView", t);
}
Ue.validateMessageView = MD;
function ND(t) {
  return (0, Tt.isObj)(t) && (0, Tt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#deletedMessageView";
}
Ue.isDeletedMessageView = ND;
function VD(t) {
  return Ai.lexicons.validate("chat.bsky.convo.defs#deletedMessageView", t);
}
Ue.validateDeletedMessageView = VD;
function jD(t) {
  return (0, Tt.isObj)(t) && (0, Tt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#messageViewSender";
}
Ue.isMessageViewSender = jD;
function FD(t) {
  return Ai.lexicons.validate("chat.bsky.convo.defs#messageViewSender", t);
}
Ue.validateMessageViewSender = FD;
function $D(t) {
  return (0, Tt.isObj)(t) && (0, Tt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#convoView";
}
Ue.isConvoView = $D;
function GD(t) {
  return Ai.lexicons.validate("chat.bsky.convo.defs#convoView", t);
}
Ue.validateConvoView = GD;
function qD(t) {
  return (0, Tt.isObj)(t) && (0, Tt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#logBeginConvo";
}
Ue.isLogBeginConvo = qD;
function zD(t) {
  return Ai.lexicons.validate("chat.bsky.convo.defs#logBeginConvo", t);
}
Ue.validateLogBeginConvo = zD;
function XD(t) {
  return (0, Tt.isObj)(t) && (0, Tt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#logLeaveConvo";
}
Ue.isLogLeaveConvo = XD;
function HD(t) {
  return Ai.lexicons.validate("chat.bsky.convo.defs#logLeaveConvo", t);
}
Ue.validateLogLeaveConvo = HD;
function ZD(t) {
  return (0, Tt.isObj)(t) && (0, Tt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#logCreateMessage";
}
Ue.isLogCreateMessage = ZD;
function WD(t) {
  return Ai.lexicons.validate("chat.bsky.convo.defs#logCreateMessage", t);
}
Ue.validateLogCreateMessage = WD;
function YD(t) {
  return (0, Tt.isObj)(t) && (0, Tt.hasProp)(t, "$type") && t.$type === "chat.bsky.convo.defs#logDeleteMessage";
}
Ue.isLogDeleteMessage = YD;
function JD(t) {
  return Ai.lexicons.validate("chat.bsky.convo.defs#logDeleteMessage", t);
}
Ue.validateLogDeleteMessage = JD;
var Vs = {};
Object.defineProperty(Vs, "__esModule", { value: !0 });
Vs.validateTemplateView = Vs.isTemplateView = void 0;
const ff = we, QD = Le;
function eP(t) {
  return (0, ff.isObj)(t) && (0, ff.hasProp)(t, "$type") && t.$type === "tools.ozone.communication.defs#templateView";
}
Vs.isTemplateView = eP;
function tP(t) {
  return QD.lexicons.validate("tools.ozone.communication.defs#templateView", t);
}
Vs.validateTemplateView = tP;
var Y = {};
Object.defineProperty(Y, "__esModule", { value: !0 });
Y.validateRecordViewDetail = Y.isRecordViewDetail = Y.validateRecordView = Y.isRecordView = Y.validateRepoViewNotFound = Y.isRepoViewNotFound = Y.validateRepoViewDetail = Y.isRepoViewDetail = Y.validateRepoView = Y.isRepoView = Y.validateModEventTag = Y.isModEventTag = Y.validateModEventDivert = Y.isModEventDivert = Y.validateModEventEmail = Y.isModEventEmail = Y.validateModEventUnmuteReporter = Y.isModEventUnmuteReporter = Y.validateModEventMuteReporter = Y.isModEventMuteReporter = Y.validateModEventUnmute = Y.isModEventUnmute = Y.validateModEventMute = Y.isModEventMute = Y.validateModEventEscalate = Y.isModEventEscalate = Y.validateModEventAcknowledge = Y.isModEventAcknowledge = Y.validateModEventLabel = Y.isModEventLabel = Y.validateModEventReport = Y.isModEventReport = Y.validateModEventComment = Y.isModEventComment = Y.validateModEventResolveAppeal = Y.isModEventResolveAppeal = Y.validateModEventReverseTakedown = Y.isModEventReverseTakedown = Y.validateModEventTakedown = Y.isModEventTakedown = Y.REVIEWNONE = Y.REVIEWCLOSED = Y.REVIEWESCALATED = Y.REVIEWOPEN = Y.validateSubjectStatusView = Y.isSubjectStatusView = Y.validateModEventViewDetail = Y.isModEventViewDetail = Y.validateModEventView = Y.isModEventView = void 0;
Y.validateVideoDetails = Y.isVideoDetails = Y.validateImageDetails = Y.isImageDetails = Y.validateBlobView = Y.isBlobView = Y.validateModerationDetail = Y.isModerationDetail = Y.validateModeration = Y.isModeration = Y.validateRecordViewNotFound = Y.isRecordViewNotFound = void 0;
const Ae = we, Ye = Le;
function rP(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventView";
}
Y.isModEventView = rP;
function iP(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#modEventView", t);
}
Y.validateModEventView = iP;
function nP(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventViewDetail";
}
Y.isModEventViewDetail = nP;
function sP(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#modEventViewDetail", t);
}
Y.validateModEventViewDetail = sP;
function aP(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#subjectStatusView";
}
Y.isSubjectStatusView = aP;
function oP(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#subjectStatusView", t);
}
Y.validateSubjectStatusView = oP;
Y.REVIEWOPEN = "tools.ozone.moderation.defs#reviewOpen";
Y.REVIEWESCALATED = "tools.ozone.moderation.defs#reviewEscalated";
Y.REVIEWCLOSED = "tools.ozone.moderation.defs#reviewClosed";
Y.REVIEWNONE = "tools.ozone.moderation.defs#reviewNone";
function lP(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventTakedown";
}
Y.isModEventTakedown = lP;
function uP(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#modEventTakedown", t);
}
Y.validateModEventTakedown = uP;
function cP(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventReverseTakedown";
}
Y.isModEventReverseTakedown = cP;
function dP(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#modEventReverseTakedown", t);
}
Y.validateModEventReverseTakedown = dP;
function fP(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventResolveAppeal";
}
Y.isModEventResolveAppeal = fP;
function pP(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#modEventResolveAppeal", t);
}
Y.validateModEventResolveAppeal = pP;
function hP(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventComment";
}
Y.isModEventComment = hP;
function mP(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#modEventComment", t);
}
Y.validateModEventComment = mP;
function yP(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventReport";
}
Y.isModEventReport = yP;
function bP(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#modEventReport", t);
}
Y.validateModEventReport = bP;
function gP(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventLabel";
}
Y.isModEventLabel = gP;
function xP(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#modEventLabel", t);
}
Y.validateModEventLabel = xP;
function EP(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventAcknowledge";
}
Y.isModEventAcknowledge = EP;
function vP(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#modEventAcknowledge", t);
}
Y.validateModEventAcknowledge = vP;
function RP(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventEscalate";
}
Y.isModEventEscalate = RP;
function AP(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#modEventEscalate", t);
}
Y.validateModEventEscalate = AP;
function _P(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventMute";
}
Y.isModEventMute = _P;
function wP(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#modEventMute", t);
}
Y.validateModEventMute = wP;
function TP(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventUnmute";
}
Y.isModEventUnmute = TP;
function SP(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#modEventUnmute", t);
}
Y.validateModEventUnmute = SP;
function CP(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventMuteReporter";
}
Y.isModEventMuteReporter = CP;
function LP(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#modEventMuteReporter", t);
}
Y.validateModEventMuteReporter = LP;
function kP(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventUnmuteReporter";
}
Y.isModEventUnmuteReporter = kP;
function DP(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#modEventUnmuteReporter", t);
}
Y.validateModEventUnmuteReporter = DP;
function PP(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventEmail";
}
Y.isModEventEmail = PP;
function BP(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#modEventEmail", t);
}
Y.validateModEventEmail = BP;
function IP(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventDivert";
}
Y.isModEventDivert = IP;
function UP(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#modEventDivert", t);
}
Y.validateModEventDivert = UP;
function OP(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventTag";
}
Y.isModEventTag = OP;
function KP(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#modEventTag", t);
}
Y.validateModEventTag = KP;
function MP(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#repoView";
}
Y.isRepoView = MP;
function NP(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#repoView", t);
}
Y.validateRepoView = NP;
function VP(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#repoViewDetail";
}
Y.isRepoViewDetail = VP;
function jP(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#repoViewDetail", t);
}
Y.validateRepoViewDetail = jP;
function FP(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#repoViewNotFound";
}
Y.isRepoViewNotFound = FP;
function $P(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#repoViewNotFound", t);
}
Y.validateRepoViewNotFound = $P;
function GP(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#recordView";
}
Y.isRecordView = GP;
function qP(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#recordView", t);
}
Y.validateRecordView = qP;
function zP(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#recordViewDetail";
}
Y.isRecordViewDetail = zP;
function XP(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#recordViewDetail", t);
}
Y.validateRecordViewDetail = XP;
function HP(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#recordViewNotFound";
}
Y.isRecordViewNotFound = HP;
function ZP(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#recordViewNotFound", t);
}
Y.validateRecordViewNotFound = ZP;
function WP(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#moderation";
}
Y.isModeration = WP;
function YP(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#moderation", t);
}
Y.validateModeration = YP;
function JP(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#moderationDetail";
}
Y.isModerationDetail = JP;
function QP(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#moderationDetail", t);
}
Y.validateModerationDetail = QP;
function eB(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#blobView";
}
Y.isBlobView = eB;
function tB(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#blobView", t);
}
Y.validateBlobView = tB;
function rB(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#imageDetails";
}
Y.isImageDetails = rB;
function iB(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#imageDetails", t);
}
Y.validateImageDetails = iB;
function nB(t) {
  return (0, Ae.isObj)(t) && (0, Ae.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#videoDetails";
}
Y.isVideoDetails = nB;
function sB(t) {
  return Ye.lexicons.validate("tools.ozone.moderation.defs#videoDetails", t);
}
Y.validateVideoDetails = sB;
var Dr = {};
Object.defineProperty(Dr, "__esModule", { value: !0 });
Dr.ROLETRIAGE = Dr.ROLEMODERATOR = Dr.ROLEADMIN = Dr.validateMember = Dr.isMember = void 0;
const pf = we, aB = Le;
function oB(t) {
  return (0, pf.isObj)(t) && (0, pf.hasProp)(t, "$type") && t.$type === "tools.ozone.team.defs#member";
}
Dr.isMember = oB;
function lB(t) {
  return aB.lexicons.validate("tools.ozone.team.defs#member", t);
}
Dr.validateMember = lB;
Dr.ROLEADMIN = "tools.ozone.team.defs#roleAdmin";
Dr.ROLEMODERATOR = "tools.ozone.team.defs#roleModerator";
Dr.ROLETRIAGE = "tools.ozone.team.defs#roleTriage";
var uB = ne && ne.__createBinding || (Object.create ? function(t, e, r, i) {
  i === void 0 && (i = r);
  var a = Object.getOwnPropertyDescriptor(e, r);
  (!a || ("get" in a ? !e.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, i, a);
} : function(t, e, r, i) {
  i === void 0 && (i = r), t[i] = e[r];
}), cB = ne && ne.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), _ = ne && ne.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && uB(e, t, r);
  return cB(e, t), e;
};
Object.defineProperty(x, "__esModule", { value: !0 });
x.ComAtprotoServerDescribeServer = x.ComAtprotoServerDeleteSession = x.ComAtprotoServerDeleteAccount = x.ComAtprotoServerDefs = x.ComAtprotoServerDeactivateAccount = x.ComAtprotoServerCreateSession = x.ComAtprotoServerCreateInviteCodes = x.ComAtprotoServerCreateInviteCode = x.ComAtprotoServerCreateAppPassword = x.ComAtprotoServerCreateAccount = x.ComAtprotoServerConfirmEmail = x.ComAtprotoServerCheckAccountStatus = x.ComAtprotoServerActivateAccount = x.ComAtprotoRepoUploadBlob = x.ComAtprotoRepoStrongRef = x.ComAtprotoRepoPutRecord = x.ComAtprotoRepoListRecords = x.ComAtprotoRepoListMissingBlobs = x.ComAtprotoRepoImportRepo = x.ComAtprotoRepoGetRecord = x.ComAtprotoRepoDescribeRepo = x.ComAtprotoRepoDeleteRecord = x.ComAtprotoRepoCreateRecord = x.ComAtprotoRepoApplyWrites = x.ComAtprotoModerationDefs = x.ComAtprotoModerationCreateReport = x.ComAtprotoLabelSubscribeLabels = x.ComAtprotoLabelQueryLabels = x.ComAtprotoLabelDefs = x.ComAtprotoIdentityUpdateHandle = x.ComAtprotoIdentitySubmitPlcOperation = x.ComAtprotoIdentitySignPlcOperation = x.ComAtprotoIdentityResolveHandle = x.ComAtprotoIdentityRequestPlcOperationSignature = x.ComAtprotoIdentityGetRecommendedDidCredentials = x.ComAtprotoAdminUpdateSubjectStatus = x.ComAtprotoAdminUpdateAccountPassword = x.ComAtprotoAdminUpdateAccountHandle = x.ComAtprotoAdminUpdateAccountEmail = x.ComAtprotoAdminSendEmail = x.ComAtprotoAdminSearchAccounts = x.ComAtprotoAdminGetSubjectStatus = x.ComAtprotoAdminGetInviteCodes = x.ComAtprotoAdminGetAccountInfos = x.ComAtprotoAdminGetAccountInfo = x.ComAtprotoAdminEnableAccountInvites = x.ComAtprotoAdminDisableInviteCodes = x.ComAtprotoAdminDisableAccountInvites = x.ComAtprotoAdminDeleteAccount = x.ComAtprotoAdminDefs = void 0;
x.AppBskyFeedGetFeedGenerator = x.AppBskyFeedGetFeed = x.AppBskyFeedGetAuthorFeed = x.AppBskyFeedGetActorLikes = x.AppBskyFeedGetActorFeeds = x.AppBskyFeedGenerator = x.AppBskyFeedDescribeFeedGenerator = x.AppBskyFeedDefs = x.AppBskyEmbedRecordWithMedia = x.AppBskyEmbedRecord = x.AppBskyEmbedImages = x.AppBskyEmbedExternal = x.AppBskyActorSearchActorsTypeahead = x.AppBskyActorSearchActors = x.AppBskyActorPutPreferences = x.AppBskyActorProfile = x.AppBskyActorGetSuggestions = x.AppBskyActorGetProfiles = x.AppBskyActorGetProfile = x.AppBskyActorGetPreferences = x.AppBskyActorDefs = x.ComAtprotoTempRequestPhoneVerification = x.ComAtprotoTempFetchLabels = x.ComAtprotoTempCheckSignupQueue = x.ComAtprotoSyncSubscribeRepos = x.ComAtprotoSyncRequestCrawl = x.ComAtprotoSyncNotifyOfUpdate = x.ComAtprotoSyncListRepos = x.ComAtprotoSyncListBlobs = x.ComAtprotoSyncGetRepoStatus = x.ComAtprotoSyncGetRepo = x.ComAtprotoSyncGetRecord = x.ComAtprotoSyncGetLatestCommit = x.ComAtprotoSyncGetHead = x.ComAtprotoSyncGetCheckout = x.ComAtprotoSyncGetBlocks = x.ComAtprotoSyncGetBlob = x.ComAtprotoServerUpdateEmail = x.ComAtprotoServerRevokeAppPassword = x.ComAtprotoServerResetPassword = x.ComAtprotoServerReserveSigningKey = x.ComAtprotoServerRequestPasswordReset = x.ComAtprotoServerRequestEmailUpdate = x.ComAtprotoServerRequestEmailConfirmation = x.ComAtprotoServerRequestAccountDelete = x.ComAtprotoServerRefreshSession = x.ComAtprotoServerListAppPasswords = x.ComAtprotoServerGetSession = x.ComAtprotoServerGetServiceAuth = x.ComAtprotoServerGetAccountInviteCodes = void 0;
x.AppBskyNotificationUpdateSeen = x.AppBskyNotificationRegisterPush = x.AppBskyNotificationPutPreferences = x.AppBskyNotificationListNotifications = x.AppBskyNotificationGetUnreadCount = x.AppBskyLabelerService = x.AppBskyLabelerGetServices = x.AppBskyLabelerDefs = x.AppBskyGraphUnmuteThread = x.AppBskyGraphUnmuteActorList = x.AppBskyGraphUnmuteActor = x.AppBskyGraphStarterpack = x.AppBskyGraphMuteThread = x.AppBskyGraphMuteActorList = x.AppBskyGraphMuteActor = x.AppBskyGraphListitem = x.AppBskyGraphListblock = x.AppBskyGraphList = x.AppBskyGraphGetSuggestedFollowsByActor = x.AppBskyGraphGetStarterPacks = x.AppBskyGraphGetStarterPack = x.AppBskyGraphGetRelationships = x.AppBskyGraphGetMutes = x.AppBskyGraphGetLists = x.AppBskyGraphGetListMutes = x.AppBskyGraphGetListBlocks = x.AppBskyGraphGetList = x.AppBskyGraphGetKnownFollowers = x.AppBskyGraphGetFollows = x.AppBskyGraphGetFollowers = x.AppBskyGraphGetBlocks = x.AppBskyGraphGetActorStarterPacks = x.AppBskyGraphFollow = x.AppBskyGraphDefs = x.AppBskyGraphBlock = x.AppBskyFeedThreadgate = x.AppBskyFeedSendInteractions = x.AppBskyFeedSearchPosts = x.AppBskyFeedRepost = x.AppBskyFeedPost = x.AppBskyFeedLike = x.AppBskyFeedGetTimeline = x.AppBskyFeedGetSuggestedFeeds = x.AppBskyFeedGetRepostedBy = x.AppBskyFeedGetPosts = x.AppBskyFeedGetPostThread = x.AppBskyFeedGetListFeed = x.AppBskyFeedGetLikes = x.AppBskyFeedGetFeedSkeleton = x.AppBskyFeedGetFeedGenerators = void 0;
x.TOOLS_OZONE_MODERATION = x.APP_BSKY_GRAPH = x.APP_BSKY_FEED = x.COM_ATPROTO_MODERATION = x.ToolsOzoneTeamUpdateMember = x.ToolsOzoneTeamListMembers = x.ToolsOzoneTeamDeleteMember = x.ToolsOzoneTeamDefs = x.ToolsOzoneTeamAddMember = x.ToolsOzoneServerGetConfig = x.ToolsOzoneModerationSearchRepos = x.ToolsOzoneModerationQueryStatuses = x.ToolsOzoneModerationQueryEvents = x.ToolsOzoneModerationGetRepo = x.ToolsOzoneModerationGetRecord = x.ToolsOzoneModerationGetEvent = x.ToolsOzoneModerationEmitEvent = x.ToolsOzoneModerationDefs = x.ToolsOzoneCommunicationUpdateTemplate = x.ToolsOzoneCommunicationListTemplates = x.ToolsOzoneCommunicationDeleteTemplate = x.ToolsOzoneCommunicationDefs = x.ToolsOzoneCommunicationCreateTemplate = x.ChatBskyModerationUpdateActorAccess = x.ChatBskyModerationGetMessageContext = x.ChatBskyModerationGetActorMetadata = x.ChatBskyConvoUpdateRead = x.ChatBskyConvoUnmuteConvo = x.ChatBskyConvoSendMessageBatch = x.ChatBskyConvoSendMessage = x.ChatBskyConvoMuteConvo = x.ChatBskyConvoListConvos = x.ChatBskyConvoLeaveConvo = x.ChatBskyConvoGetMessages = x.ChatBskyConvoGetLog = x.ChatBskyConvoGetConvoForMembers = x.ChatBskyConvoGetConvo = x.ChatBskyConvoDeleteMessageForSelf = x.ChatBskyConvoDefs = x.ChatBskyActorExportAccountData = x.ChatBskyActorDeleteAccount = x.ChatBskyActorDefs = x.ChatBskyActorDeclaration = x.AppBskyUnspeccedSearchPostsSkeleton = x.AppBskyUnspeccedSearchActorsSkeleton = x.AppBskyUnspeccedGetTaggedSuggestions = x.AppBskyUnspeccedGetSuggestionsSkeleton = x.AppBskyUnspeccedGetPopularFeedGenerators = x.AppBskyUnspeccedDefs = x.AppBskyRichtextFacet = void 0;
x.ToolsOzoneTeamNS = x.ToolsOzoneServerNS = x.ToolsOzoneModerationNS = x.ToolsOzoneCommunicationNS = x.ToolsOzoneNS = x.ToolsNS = x.ChatBskyModerationNS = x.ChatBskyConvoNS = x.DeclarationRecord = x.ChatBskyActorNS = x.ChatBskyNS = x.ChatNS = x.AppBskyUnspeccedNS = x.AppBskyRichtextNS = x.AppBskyNotificationNS = x.ServiceRecord = x.AppBskyLabelerNS = x.StarterpackRecord = x.ListitemRecord = x.ListblockRecord = x.ListRecord = x.FollowRecord = x.BlockRecord = x.AppBskyGraphNS = x.ThreadgateRecord = x.RepostRecord = x.PostRecord = x.LikeRecord = x.GeneratorRecord = x.AppBskyFeedNS = x.AppBskyEmbedNS = x.ProfileRecord = x.AppBskyActorNS = x.AppBskyNS = x.AppNS = x.ComAtprotoTempNS = x.ComAtprotoSyncNS = x.ComAtprotoServerNS = x.ComAtprotoRepoNS = x.ComAtprotoModerationNS = x.ComAtprotoLabelNS = x.ComAtprotoIdentityNS = x.ComAtprotoAdminNS = x.ComAtprotoNS = x.ComNS = x.AtpServiceClient = x.AtpBaseClient = x.TOOLS_OZONE_TEAM = void 0;
const dB = q, fB = Le, pB = _(Da), hB = _(Pa), mB = _(Ba), yB = _(Ia), bB = _(Ua), gB = _(Oa), xB = _(Ka), EB = _(Ma), vB = _(Na), RB = _(Va), AB = _(ja), _B = _(Fa), wB = _($a), TB = _(Ga), SB = _(qa), CB = _(za), LB = _(Xa), kB = _(Ha), DB = _(Za), PB = _(Wa), BB = _(Ya), IB = _(Ja), UB = _(Lt), OB = _(Nn), KB = _(Vn), MB = _(Qa), NB = _(eo), VB = _(to), jB = _(Ni), FB = _(Vi), $B = _(jn), GB = _(ro), qB = _(io), zB = _(no), XB = _(Rr), HB = _(kt), ZB = _(Vr), WB = _(ao), YB = _(ji), JB = _(Fi), QB = _(oo), eI = _($i), tI = _(lo), rI = _(Ar), iI = _(Fn), nI = _($n), sI = _(uo), aI = _(jr), oI = _(Gn), lI = _(co), uI = _(fo), cI = _(po), dI = _(ho), fI = _(mo), pI = _(Gi), hI = _(yo), mI = _(Fr), yI = _(ar), bI = _(or), gI = _(bo), xI = _(qn), EI = _(_r), vI = _(lr), RI = _(wr), AI = _(zn), _I = _(Tr), wI = _(qi), TI = _(vo), SI = _(Ro), CI = _(Ao), LI = _(_o), kI = _(wo), DI = _(To), PI = _(So), BI = _(Co), II = _(Lo), UI = _(ko), OI = _(Do), KI = _(Po), MI = _(Sr), NI = _(Bo), VI = _(zi), jI = _(Xi), FI = _(Xn), $I = _(Io), GI = _(Uo), qI = _(Hn), zI = _(Hi), XI = _(Zn), HI = _(Wn), ZI = _(Oo), WI = _(Ko), YI = _(Mo), JI = _(No), QI = _(Yn), eU = _(Vo), tU = _(jo), rU = _(Fo), iU = _($o), nU = _(Go), sU = _(qo), aU = _(zo), oU = _(Xo), lU = _(Ho), uU = _(Zo), cU = _(Wo), dU = _(Jn), fU = _(Yo), pU = _(Jo), hU = _(Qo), mU = _(el), yU = _(tl), bU = _(rl), gU = _(il), xU = _(nl), EU = _(sl), vU = _(al), RU = _(ol), AU = _(Zi), _U = _(ll), wU = _(ul), TU = _(cl), SU = _(dl), CU = _(fl), LU = _(Wi), kU = _(Qn), DU = _(es), PU = _(pl), BU = _(hl), IU = _(ml), UU = _(yl), OU = _(bl), KU = _(gl), MU = _(xl), NU = _(El), VU = _(vl), jU = _(Rl), FU = _(Al), $U = _(Yi), GU = _(_l), qU = _(wl), zU = _(Ji), XU = _(Tl), HU = _(Sl), ZU = _(Cl), WU = _(Ll), YU = _(kl), JU = _(Dl), QU = _(ts), eO = _(Pl), tO = _(rs), rO = _(is), iO = _(Bl), nO = _(Il), sO = _(Ul), aO = _(Cr), oO = _(ns), lO = _(Qi), uO = _(Ol), cO = _(ss);
x.ComAtprotoAdminDefs = _(Ot);
x.ComAtprotoAdminDeleteAccount = _(Da);
x.ComAtprotoAdminDisableAccountInvites = _(Pa);
x.ComAtprotoAdminDisableInviteCodes = _(Ba);
x.ComAtprotoAdminEnableAccountInvites = _(Ia);
x.ComAtprotoAdminGetAccountInfo = _(Ua);
x.ComAtprotoAdminGetAccountInfos = _(Oa);
x.ComAtprotoAdminGetInviteCodes = _(Ka);
x.ComAtprotoAdminGetSubjectStatus = _(Ma);
x.ComAtprotoAdminSearchAccounts = _(Na);
x.ComAtprotoAdminSendEmail = _(Va);
x.ComAtprotoAdminUpdateAccountEmail = _(ja);
x.ComAtprotoAdminUpdateAccountHandle = _(Fa);
x.ComAtprotoAdminUpdateAccountPassword = _($a);
x.ComAtprotoAdminUpdateSubjectStatus = _(Ga);
x.ComAtprotoIdentityGetRecommendedDidCredentials = _(qa);
x.ComAtprotoIdentityRequestPlcOperationSignature = _(za);
x.ComAtprotoIdentityResolveHandle = _(Xa);
x.ComAtprotoIdentitySignPlcOperation = _(Ha);
x.ComAtprotoIdentitySubmitPlcOperation = _(Za);
x.ComAtprotoIdentityUpdateHandle = _(Wa);
x.ComAtprotoLabelDefs = _(mt);
x.ComAtprotoLabelQueryLabels = _(Ya);
x.ComAtprotoLabelSubscribeLabels = _(ni);
x.ComAtprotoModerationCreateReport = _(Ja);
x.ComAtprotoModerationDefs = _(Yt);
x.ComAtprotoRepoApplyWrites = _(Lt);
x.ComAtprotoRepoCreateRecord = _(Nn);
x.ComAtprotoRepoDeleteRecord = _(Vn);
x.ComAtprotoRepoDescribeRepo = _(Qa);
x.ComAtprotoRepoGetRecord = _(eo);
x.ComAtprotoRepoImportRepo = _(to);
x.ComAtprotoRepoListMissingBlobs = _(Ni);
x.ComAtprotoRepoListRecords = _(Vi);
x.ComAtprotoRepoPutRecord = _(jn);
x.ComAtprotoRepoStrongRef = _(Ss);
x.ComAtprotoRepoUploadBlob = _(ro);
x.ComAtprotoServerActivateAccount = _(io);
x.ComAtprotoServerCheckAccountStatus = _(no);
x.ComAtprotoServerConfirmEmail = _(Rr);
x.ComAtprotoServerCreateAccount = _(kt);
x.ComAtprotoServerCreateAppPassword = _(Vr);
x.ComAtprotoServerCreateInviteCode = _(ao);
x.ComAtprotoServerCreateInviteCodes = _(ji);
x.ComAtprotoServerCreateSession = _(Fi);
x.ComAtprotoServerDeactivateAccount = _(oo);
x.ComAtprotoServerDefs = _(si);
x.ComAtprotoServerDeleteAccount = _($i);
x.ComAtprotoServerDeleteSession = _(lo);
x.ComAtprotoServerDescribeServer = _(Ar);
x.ComAtprotoServerGetAccountInviteCodes = _(Fn);
x.ComAtprotoServerGetServiceAuth = _($n);
x.ComAtprotoServerGetSession = _(uo);
x.ComAtprotoServerListAppPasswords = _(jr);
x.ComAtprotoServerRefreshSession = _(Gn);
x.ComAtprotoServerRequestAccountDelete = _(co);
x.ComAtprotoServerRequestEmailConfirmation = _(fo);
x.ComAtprotoServerRequestEmailUpdate = _(po);
x.ComAtprotoServerRequestPasswordReset = _(ho);
x.ComAtprotoServerReserveSigningKey = _(mo);
x.ComAtprotoServerResetPassword = _(Gi);
x.ComAtprotoServerRevokeAppPassword = _(yo);
x.ComAtprotoServerUpdateEmail = _(Fr);
x.ComAtprotoSyncGetBlob = _(ar);
x.ComAtprotoSyncGetBlocks = _(or);
x.ComAtprotoSyncGetCheckout = _(bo);
x.ComAtprotoSyncGetHead = _(qn);
x.ComAtprotoSyncGetLatestCommit = _(_r);
x.ComAtprotoSyncGetRecord = _(lr);
x.ComAtprotoSyncGetRepo = _(wr);
x.ComAtprotoSyncGetRepoStatus = _(zn);
x.ComAtprotoSyncListBlobs = _(Tr);
x.ComAtprotoSyncListRepos = _(qi);
x.ComAtprotoSyncNotifyOfUpdate = _(vo);
x.ComAtprotoSyncRequestCrawl = _(Ro);
x.ComAtprotoSyncSubscribeRepos = _(ze);
x.ComAtprotoTempCheckSignupQueue = _(Ao);
x.ComAtprotoTempFetchLabels = _(_o);
x.ComAtprotoTempRequestPhoneVerification = _(wo);
x.AppBskyActorDefs = _(se);
x.AppBskyActorGetPreferences = _(To);
x.AppBskyActorGetProfile = _(So);
x.AppBskyActorGetProfiles = _(Co);
x.AppBskyActorGetSuggestions = _(Lo);
x.AppBskyActorProfile = _(Cs);
x.AppBskyActorPutPreferences = _(ko);
x.AppBskyActorSearchActors = _(Do);
x.AppBskyActorSearchActorsTypeahead = _(Po);
x.AppBskyEmbedExternal = _(Kt);
x.AppBskyEmbedImages = _(yt);
x.AppBskyEmbedRecord = _(bt);
x.AppBskyEmbedRecordWithMedia = _(ai);
x.AppBskyFeedDefs = _(ue);
x.AppBskyFeedDescribeFeedGenerator = _(Sr);
x.AppBskyFeedGenerator = _(Ls);
x.AppBskyFeedGetActorFeeds = _(Bo);
x.AppBskyFeedGetActorLikes = _(zi);
x.AppBskyFeedGetAuthorFeed = _(Xi);
x.AppBskyFeedGetFeed = _(Xn);
x.AppBskyFeedGetFeedGenerator = _(Io);
x.AppBskyFeedGetFeedGenerators = _(Uo);
x.AppBskyFeedGetFeedSkeleton = _(Hn);
x.AppBskyFeedGetLikes = _(Hi);
x.AppBskyFeedGetListFeed = _(Zn);
x.AppBskyFeedGetPostThread = _(Wn);
x.AppBskyFeedGetPosts = _(Oo);
x.AppBskyFeedGetRepostedBy = _(Ko);
x.AppBskyFeedGetSuggestedFeeds = _(Mo);
x.AppBskyFeedGetTimeline = _(No);
x.AppBskyFeedLike = _(ks);
x.AppBskyFeedPost = _(Mt);
x.AppBskyFeedRepost = _(Ds);
x.AppBskyFeedSearchPosts = _(Yn);
x.AppBskyFeedSendInteractions = _(Vo);
x.AppBskyFeedThreadgate = _(Nt);
x.AppBskyGraphBlock = _(Ps);
x.AppBskyGraphDefs = _(Ne);
x.AppBskyGraphFollow = _(Bs);
x.AppBskyGraphGetActorStarterPacks = _(jo);
x.AppBskyGraphGetBlocks = _(Fo);
x.AppBskyGraphGetFollowers = _($o);
x.AppBskyGraphGetFollows = _(Go);
x.AppBskyGraphGetKnownFollowers = _(qo);
x.AppBskyGraphGetList = _(zo);
x.AppBskyGraphGetListBlocks = _(Xo);
x.AppBskyGraphGetListMutes = _(Ho);
x.AppBskyGraphGetLists = _(Zo);
x.AppBskyGraphGetMutes = _(Wo);
x.AppBskyGraphGetRelationships = _(Jn);
x.AppBskyGraphGetStarterPack = _(Yo);
x.AppBskyGraphGetStarterPacks = _(Jo);
x.AppBskyGraphGetSuggestedFollowsByActor = _(Qo);
x.AppBskyGraphList = _(Is);
x.AppBskyGraphListblock = _(Us);
x.AppBskyGraphListitem = _(Os);
x.AppBskyGraphMuteActor = _(el);
x.AppBskyGraphMuteActorList = _(tl);
x.AppBskyGraphMuteThread = _(rl);
x.AppBskyGraphStarterpack = _(oi);
x.AppBskyGraphUnmuteActor = _(il);
x.AppBskyGraphUnmuteActorList = _(nl);
x.AppBskyGraphUnmuteThread = _(sl);
x.AppBskyLabelerDefs = _(Vt);
x.AppBskyLabelerGetServices = _(al);
x.AppBskyLabelerService = _(Ks);
x.AppBskyNotificationGetUnreadCount = _(ol);
x.AppBskyNotificationListNotifications = _(Zi);
x.AppBskyNotificationPutPreferences = _(ll);
x.AppBskyNotificationRegisterPush = _(ul);
x.AppBskyNotificationUpdateSeen = _(cl);
x.AppBskyRichtextFacet = _(gt);
x.AppBskyUnspeccedDefs = _(li);
x.AppBskyUnspeccedGetPopularFeedGenerators = _(dl);
x.AppBskyUnspeccedGetSuggestionsSkeleton = _(fl);
x.AppBskyUnspeccedGetTaggedSuggestions = _(Wi);
x.AppBskyUnspeccedSearchActorsSkeleton = _(Qn);
x.AppBskyUnspeccedSearchPostsSkeleton = _(es);
x.ChatBskyActorDeclaration = _(Ms);
x.ChatBskyActorDefs = _(Ns);
x.ChatBskyActorDeleteAccount = _(pl);
x.ChatBskyActorExportAccountData = _(hl);
x.ChatBskyConvoDefs = _(Ue);
x.ChatBskyConvoDeleteMessageForSelf = _(ml);
x.ChatBskyConvoGetConvo = _(yl);
x.ChatBskyConvoGetConvoForMembers = _(bl);
x.ChatBskyConvoGetLog = _(gl);
x.ChatBskyConvoGetMessages = _(xl);
x.ChatBskyConvoLeaveConvo = _(El);
x.ChatBskyConvoListConvos = _(vl);
x.ChatBskyConvoMuteConvo = _(Rl);
x.ChatBskyConvoSendMessage = _(Al);
x.ChatBskyConvoSendMessageBatch = _(Yi);
x.ChatBskyConvoUnmuteConvo = _(_l);
x.ChatBskyConvoUpdateRead = _(wl);
x.ChatBskyModerationGetActorMetadata = _(Ji);
x.ChatBskyModerationGetMessageContext = _(Tl);
x.ChatBskyModerationUpdateActorAccess = _(Sl);
x.ToolsOzoneCommunicationCreateTemplate = _(Cl);
x.ToolsOzoneCommunicationDefs = _(Vs);
x.ToolsOzoneCommunicationDeleteTemplate = _(Ll);
x.ToolsOzoneCommunicationListTemplates = _(kl);
x.ToolsOzoneCommunicationUpdateTemplate = _(Dl);
x.ToolsOzoneModerationDefs = _(Y);
x.ToolsOzoneModerationEmitEvent = _(ts);
x.ToolsOzoneModerationGetEvent = _(Pl);
x.ToolsOzoneModerationGetRecord = _(rs);
x.ToolsOzoneModerationGetRepo = _(is);
x.ToolsOzoneModerationQueryEvents = _(Bl);
x.ToolsOzoneModerationQueryStatuses = _(Il);
x.ToolsOzoneModerationSearchRepos = _(Ul);
x.ToolsOzoneServerGetConfig = _(Cr);
x.ToolsOzoneTeamAddMember = _(ns);
x.ToolsOzoneTeamDefs = _(Dr);
x.ToolsOzoneTeamDeleteMember = _(Qi);
x.ToolsOzoneTeamListMembers = _(Ol);
x.ToolsOzoneTeamUpdateMember = _(ss);
x.COM_ATPROTO_MODERATION = {
  DefsReasonSpam: "com.atproto.moderation.defs#reasonSpam",
  DefsReasonViolation: "com.atproto.moderation.defs#reasonViolation",
  DefsReasonMisleading: "com.atproto.moderation.defs#reasonMisleading",
  DefsReasonSexual: "com.atproto.moderation.defs#reasonSexual",
  DefsReasonRude: "com.atproto.moderation.defs#reasonRude",
  DefsReasonOther: "com.atproto.moderation.defs#reasonOther",
  DefsReasonAppeal: "com.atproto.moderation.defs#reasonAppeal"
};
x.APP_BSKY_FEED = {
  DefsRequestLess: "app.bsky.feed.defs#requestLess",
  DefsRequestMore: "app.bsky.feed.defs#requestMore",
  DefsClickthroughItem: "app.bsky.feed.defs#clickthroughItem",
  DefsClickthroughAuthor: "app.bsky.feed.defs#clickthroughAuthor",
  DefsClickthroughReposter: "app.bsky.feed.defs#clickthroughReposter",
  DefsClickthroughEmbed: "app.bsky.feed.defs#clickthroughEmbed",
  DefsInteractionSeen: "app.bsky.feed.defs#interactionSeen",
  DefsInteractionLike: "app.bsky.feed.defs#interactionLike",
  DefsInteractionRepost: "app.bsky.feed.defs#interactionRepost",
  DefsInteractionReply: "app.bsky.feed.defs#interactionReply",
  DefsInteractionQuote: "app.bsky.feed.defs#interactionQuote",
  DefsInteractionShare: "app.bsky.feed.defs#interactionShare"
};
x.APP_BSKY_GRAPH = {
  DefsModlist: "app.bsky.graph.defs#modlist",
  DefsCuratelist: "app.bsky.graph.defs#curatelist",
  DefsReferencelist: "app.bsky.graph.defs#referencelist"
};
x.TOOLS_OZONE_MODERATION = {
  DefsReviewOpen: "tools.ozone.moderation.defs#reviewOpen",
  DefsReviewEscalated: "tools.ozone.moderation.defs#reviewEscalated",
  DefsReviewClosed: "tools.ozone.moderation.defs#reviewClosed",
  DefsReviewNone: "tools.ozone.moderation.defs#reviewNone"
};
x.TOOLS_OZONE_TEAM = {
  DefsRoleAdmin: "tools.ozone.team.defs#roleAdmin",
  DefsRoleModerator: "tools.ozone.team.defs#roleModerator",
  DefsRoleTriage: "tools.ozone.team.defs#roleTriage"
};
class dO {
  constructor() {
    Object.defineProperty(this, "xrpc", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new dB.Client()
    }), this.xrpc.addLexicons(fB.schemas);
  }
  service(e) {
    return new Z0(this, this.xrpc.service(e));
  }
}
x.AtpBaseClient = dO;
class Z0 {
  constructor(e, r) {
    Object.defineProperty(this, "_baseClient", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "xrpc", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "com", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "app", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "chat", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tools", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._baseClient = e, this.xrpc = r, this.com = new W0(this), this.app = new am(this), this.chat = new Lm(this), this.tools = new Um(this);
  }
  setHeader(e, r) {
    this.xrpc.setHeader(e, r);
  }
}
x.AtpServiceClient = Z0;
class W0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "atproto", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.atproto = new Y0(e);
  }
}
x.ComNS = W0;
class Y0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "admin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "identity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "label", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "moderation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "repo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "server", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "sync", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "temp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.admin = new J0(e), this.identity = new Q0(e), this.label = new em(e), this.moderation = new tm(e), this.repo = new rm(e), this.server = new im(e), this.sync = new nm(e), this.temp = new sm(e);
  }
}
x.ComAtprotoNS = Y0;
class J0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  deleteAccount(e, r) {
    return this._service.xrpc.call("com.atproto.admin.deleteAccount", r?.qp, e, r).catch((i) => {
      throw pB.toKnownErr(i);
    });
  }
  disableAccountInvites(e, r) {
    return this._service.xrpc.call("com.atproto.admin.disableAccountInvites", r?.qp, e, r).catch((i) => {
      throw hB.toKnownErr(i);
    });
  }
  disableInviteCodes(e, r) {
    return this._service.xrpc.call("com.atproto.admin.disableInviteCodes", r?.qp, e, r).catch((i) => {
      throw mB.toKnownErr(i);
    });
  }
  enableAccountInvites(e, r) {
    return this._service.xrpc.call("com.atproto.admin.enableAccountInvites", r?.qp, e, r).catch((i) => {
      throw yB.toKnownErr(i);
    });
  }
  getAccountInfo(e, r) {
    return this._service.xrpc.call("com.atproto.admin.getAccountInfo", e, void 0, r).catch((i) => {
      throw bB.toKnownErr(i);
    });
  }
  getAccountInfos(e, r) {
    return this._service.xrpc.call("com.atproto.admin.getAccountInfos", e, void 0, r).catch((i) => {
      throw gB.toKnownErr(i);
    });
  }
  getInviteCodes(e, r) {
    return this._service.xrpc.call("com.atproto.admin.getInviteCodes", e, void 0, r).catch((i) => {
      throw xB.toKnownErr(i);
    });
  }
  getSubjectStatus(e, r) {
    return this._service.xrpc.call("com.atproto.admin.getSubjectStatus", e, void 0, r).catch((i) => {
      throw EB.toKnownErr(i);
    });
  }
  searchAccounts(e, r) {
    return this._service.xrpc.call("com.atproto.admin.searchAccounts", e, void 0, r).catch((i) => {
      throw vB.toKnownErr(i);
    });
  }
  sendEmail(e, r) {
    return this._service.xrpc.call("com.atproto.admin.sendEmail", r?.qp, e, r).catch((i) => {
      throw RB.toKnownErr(i);
    });
  }
  updateAccountEmail(e, r) {
    return this._service.xrpc.call("com.atproto.admin.updateAccountEmail", r?.qp, e, r).catch((i) => {
      throw AB.toKnownErr(i);
    });
  }
  updateAccountHandle(e, r) {
    return this._service.xrpc.call("com.atproto.admin.updateAccountHandle", r?.qp, e, r).catch((i) => {
      throw _B.toKnownErr(i);
    });
  }
  updateAccountPassword(e, r) {
    return this._service.xrpc.call("com.atproto.admin.updateAccountPassword", r?.qp, e, r).catch((i) => {
      throw wB.toKnownErr(i);
    });
  }
  updateSubjectStatus(e, r) {
    return this._service.xrpc.call("com.atproto.admin.updateSubjectStatus", r?.qp, e, r).catch((i) => {
      throw TB.toKnownErr(i);
    });
  }
}
x.ComAtprotoAdminNS = J0;
class Q0 {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getRecommendedDidCredentials(e, r) {
    return this._service.xrpc.call("com.atproto.identity.getRecommendedDidCredentials", e, void 0, r).catch((i) => {
      throw SB.toKnownErr(i);
    });
  }
  requestPlcOperationSignature(e, r) {
    return this._service.xrpc.call("com.atproto.identity.requestPlcOperationSignature", r?.qp, e, r).catch((i) => {
      throw CB.toKnownErr(i);
    });
  }
  resolveHandle(e, r) {
    return this._service.xrpc.call("com.atproto.identity.resolveHandle", e, void 0, r).catch((i) => {
      throw LB.toKnownErr(i);
    });
  }
  signPlcOperation(e, r) {
    return this._service.xrpc.call("com.atproto.identity.signPlcOperation", r?.qp, e, r).catch((i) => {
      throw kB.toKnownErr(i);
    });
  }
  submitPlcOperation(e, r) {
    return this._service.xrpc.call("com.atproto.identity.submitPlcOperation", r?.qp, e, r).catch((i) => {
      throw DB.toKnownErr(i);
    });
  }
  updateHandle(e, r) {
    return this._service.xrpc.call("com.atproto.identity.updateHandle", r?.qp, e, r).catch((i) => {
      throw PB.toKnownErr(i);
    });
  }
}
x.ComAtprotoIdentityNS = Q0;
class em {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  queryLabels(e, r) {
    return this._service.xrpc.call("com.atproto.label.queryLabels", e, void 0, r).catch((i) => {
      throw BB.toKnownErr(i);
    });
  }
}
x.ComAtprotoLabelNS = em;
class tm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  createReport(e, r) {
    return this._service.xrpc.call("com.atproto.moderation.createReport", r?.qp, e, r).catch((i) => {
      throw IB.toKnownErr(i);
    });
  }
}
x.ComAtprotoModerationNS = tm;
class rm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  applyWrites(e, r) {
    return this._service.xrpc.call("com.atproto.repo.applyWrites", r?.qp, e, r).catch((i) => {
      throw UB.toKnownErr(i);
    });
  }
  createRecord(e, r) {
    return this._service.xrpc.call("com.atproto.repo.createRecord", r?.qp, e, r).catch((i) => {
      throw OB.toKnownErr(i);
    });
  }
  deleteRecord(e, r) {
    return this._service.xrpc.call("com.atproto.repo.deleteRecord", r?.qp, e, r).catch((i) => {
      throw KB.toKnownErr(i);
    });
  }
  describeRepo(e, r) {
    return this._service.xrpc.call("com.atproto.repo.describeRepo", e, void 0, r).catch((i) => {
      throw MB.toKnownErr(i);
    });
  }
  getRecord(e, r) {
    return this._service.xrpc.call("com.atproto.repo.getRecord", e, void 0, r).catch((i) => {
      throw NB.toKnownErr(i);
    });
  }
  importRepo(e, r) {
    return this._service.xrpc.call("com.atproto.repo.importRepo", r?.qp, e, r).catch((i) => {
      throw VB.toKnownErr(i);
    });
  }
  listMissingBlobs(e, r) {
    return this._service.xrpc.call("com.atproto.repo.listMissingBlobs", e, void 0, r).catch((i) => {
      throw jB.toKnownErr(i);
    });
  }
  listRecords(e, r) {
    return this._service.xrpc.call("com.atproto.repo.listRecords", e, void 0, r).catch((i) => {
      throw FB.toKnownErr(i);
    });
  }
  putRecord(e, r) {
    return this._service.xrpc.call("com.atproto.repo.putRecord", r?.qp, e, r).catch((i) => {
      throw $B.toKnownErr(i);
    });
  }
  uploadBlob(e, r) {
    return this._service.xrpc.call("com.atproto.repo.uploadBlob", r?.qp, e, r).catch((i) => {
      throw GB.toKnownErr(i);
    });
  }
}
x.ComAtprotoRepoNS = rm;
class im {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  activateAccount(e, r) {
    return this._service.xrpc.call("com.atproto.server.activateAccount", r?.qp, e, r).catch((i) => {
      throw qB.toKnownErr(i);
    });
  }
  checkAccountStatus(e, r) {
    return this._service.xrpc.call("com.atproto.server.checkAccountStatus", e, void 0, r).catch((i) => {
      throw zB.toKnownErr(i);
    });
  }
  confirmEmail(e, r) {
    return this._service.xrpc.call("com.atproto.server.confirmEmail", r?.qp, e, r).catch((i) => {
      throw XB.toKnownErr(i);
    });
  }
  createAccount(e, r) {
    return this._service.xrpc.call("com.atproto.server.createAccount", r?.qp, e, r).catch((i) => {
      throw HB.toKnownErr(i);
    });
  }
  createAppPassword(e, r) {
    return this._service.xrpc.call("com.atproto.server.createAppPassword", r?.qp, e, r).catch((i) => {
      throw ZB.toKnownErr(i);
    });
  }
  createInviteCode(e, r) {
    return this._service.xrpc.call("com.atproto.server.createInviteCode", r?.qp, e, r).catch((i) => {
      throw WB.toKnownErr(i);
    });
  }
  createInviteCodes(e, r) {
    return this._service.xrpc.call("com.atproto.server.createInviteCodes", r?.qp, e, r).catch((i) => {
      throw YB.toKnownErr(i);
    });
  }
  createSession(e, r) {
    return this._service.xrpc.call("com.atproto.server.createSession", r?.qp, e, r).catch((i) => {
      throw JB.toKnownErr(i);
    });
  }
  deactivateAccount(e, r) {
    return this._service.xrpc.call("com.atproto.server.deactivateAccount", r?.qp, e, r).catch((i) => {
      throw QB.toKnownErr(i);
    });
  }
  deleteAccount(e, r) {
    return this._service.xrpc.call("com.atproto.server.deleteAccount", r?.qp, e, r).catch((i) => {
      throw eI.toKnownErr(i);
    });
  }
  deleteSession(e, r) {
    return this._service.xrpc.call("com.atproto.server.deleteSession", r?.qp, e, r).catch((i) => {
      throw tI.toKnownErr(i);
    });
  }
  describeServer(e, r) {
    return this._service.xrpc.call("com.atproto.server.describeServer", e, void 0, r).catch((i) => {
      throw rI.toKnownErr(i);
    });
  }
  getAccountInviteCodes(e, r) {
    return this._service.xrpc.call("com.atproto.server.getAccountInviteCodes", e, void 0, r).catch((i) => {
      throw iI.toKnownErr(i);
    });
  }
  getServiceAuth(e, r) {
    return this._service.xrpc.call("com.atproto.server.getServiceAuth", e, void 0, r).catch((i) => {
      throw nI.toKnownErr(i);
    });
  }
  getSession(e, r) {
    return this._service.xrpc.call("com.atproto.server.getSession", e, void 0, r).catch((i) => {
      throw sI.toKnownErr(i);
    });
  }
  listAppPasswords(e, r) {
    return this._service.xrpc.call("com.atproto.server.listAppPasswords", e, void 0, r).catch((i) => {
      throw aI.toKnownErr(i);
    });
  }
  refreshSession(e, r) {
    return this._service.xrpc.call("com.atproto.server.refreshSession", r?.qp, e, r).catch((i) => {
      throw oI.toKnownErr(i);
    });
  }
  requestAccountDelete(e, r) {
    return this._service.xrpc.call("com.atproto.server.requestAccountDelete", r?.qp, e, r).catch((i) => {
      throw lI.toKnownErr(i);
    });
  }
  requestEmailConfirmation(e, r) {
    return this._service.xrpc.call("com.atproto.server.requestEmailConfirmation", r?.qp, e, r).catch((i) => {
      throw uI.toKnownErr(i);
    });
  }
  requestEmailUpdate(e, r) {
    return this._service.xrpc.call("com.atproto.server.requestEmailUpdate", r?.qp, e, r).catch((i) => {
      throw cI.toKnownErr(i);
    });
  }
  requestPasswordReset(e, r) {
    return this._service.xrpc.call("com.atproto.server.requestPasswordReset", r?.qp, e, r).catch((i) => {
      throw dI.toKnownErr(i);
    });
  }
  reserveSigningKey(e, r) {
    return this._service.xrpc.call("com.atproto.server.reserveSigningKey", r?.qp, e, r).catch((i) => {
      throw fI.toKnownErr(i);
    });
  }
  resetPassword(e, r) {
    return this._service.xrpc.call("com.atproto.server.resetPassword", r?.qp, e, r).catch((i) => {
      throw pI.toKnownErr(i);
    });
  }
  revokeAppPassword(e, r) {
    return this._service.xrpc.call("com.atproto.server.revokeAppPassword", r?.qp, e, r).catch((i) => {
      throw hI.toKnownErr(i);
    });
  }
  updateEmail(e, r) {
    return this._service.xrpc.call("com.atproto.server.updateEmail", r?.qp, e, r).catch((i) => {
      throw mI.toKnownErr(i);
    });
  }
}
x.ComAtprotoServerNS = im;
class nm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getBlob(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getBlob", e, void 0, r).catch((i) => {
      throw yI.toKnownErr(i);
    });
  }
  getBlocks(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getBlocks", e, void 0, r).catch((i) => {
      throw bI.toKnownErr(i);
    });
  }
  getCheckout(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getCheckout", e, void 0, r).catch((i) => {
      throw gI.toKnownErr(i);
    });
  }
  getHead(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getHead", e, void 0, r).catch((i) => {
      throw xI.toKnownErr(i);
    });
  }
  getLatestCommit(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getLatestCommit", e, void 0, r).catch((i) => {
      throw EI.toKnownErr(i);
    });
  }
  getRecord(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getRecord", e, void 0, r).catch((i) => {
      throw vI.toKnownErr(i);
    });
  }
  getRepo(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getRepo", e, void 0, r).catch((i) => {
      throw RI.toKnownErr(i);
    });
  }
  getRepoStatus(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getRepoStatus", e, void 0, r).catch((i) => {
      throw AI.toKnownErr(i);
    });
  }
  listBlobs(e, r) {
    return this._service.xrpc.call("com.atproto.sync.listBlobs", e, void 0, r).catch((i) => {
      throw _I.toKnownErr(i);
    });
  }
  listRepos(e, r) {
    return this._service.xrpc.call("com.atproto.sync.listRepos", e, void 0, r).catch((i) => {
      throw wI.toKnownErr(i);
    });
  }
  notifyOfUpdate(e, r) {
    return this._service.xrpc.call("com.atproto.sync.notifyOfUpdate", r?.qp, e, r).catch((i) => {
      throw TI.toKnownErr(i);
    });
  }
  requestCrawl(e, r) {
    return this._service.xrpc.call("com.atproto.sync.requestCrawl", r?.qp, e, r).catch((i) => {
      throw SI.toKnownErr(i);
    });
  }
}
x.ComAtprotoSyncNS = nm;
class sm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  checkSignupQueue(e, r) {
    return this._service.xrpc.call("com.atproto.temp.checkSignupQueue", e, void 0, r).catch((i) => {
      throw CI.toKnownErr(i);
    });
  }
  fetchLabels(e, r) {
    return this._service.xrpc.call("com.atproto.temp.fetchLabels", e, void 0, r).catch((i) => {
      throw LI.toKnownErr(i);
    });
  }
  requestPhoneVerification(e, r) {
    return this._service.xrpc.call("com.atproto.temp.requestPhoneVerification", r?.qp, e, r).catch((i) => {
      throw kI.toKnownErr(i);
    });
  }
}
x.ComAtprotoTempNS = sm;
class am {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "bsky", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.bsky = new om(e);
  }
}
x.AppNS = am;
class om {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "actor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "embed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "feed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "graph", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "labeler", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "notification", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "richtext", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "unspecced", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.actor = new lm(e), this.embed = new cm(e), this.feed = new dm(e), this.graph = new bm(e), this.labeler = new _m(e), this.notification = new Tm(e), this.richtext = new Sm(e), this.unspecced = new Cm(e);
  }
}
x.AppBskyNS = om;
class lm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "profile", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.profile = new um(e);
  }
  getPreferences(e, r) {
    return this._service.xrpc.call("app.bsky.actor.getPreferences", e, void 0, r).catch((i) => {
      throw DI.toKnownErr(i);
    });
  }
  getProfile(e, r) {
    return this._service.xrpc.call("app.bsky.actor.getProfile", e, void 0, r).catch((i) => {
      throw PI.toKnownErr(i);
    });
  }
  getProfiles(e, r) {
    return this._service.xrpc.call("app.bsky.actor.getProfiles", e, void 0, r).catch((i) => {
      throw BI.toKnownErr(i);
    });
  }
  getSuggestions(e, r) {
    return this._service.xrpc.call("app.bsky.actor.getSuggestions", e, void 0, r).catch((i) => {
      throw II.toKnownErr(i);
    });
  }
  putPreferences(e, r) {
    return this._service.xrpc.call("app.bsky.actor.putPreferences", r?.qp, e, r).catch((i) => {
      throw UI.toKnownErr(i);
    });
  }
  searchActors(e, r) {
    return this._service.xrpc.call("app.bsky.actor.searchActors", e, void 0, r).catch((i) => {
      throw OI.toKnownErr(i);
    });
  }
  searchActorsTypeahead(e, r) {
    return this._service.xrpc.call("app.bsky.actor.searchActorsTypeahead", e, void 0, r).catch((i) => {
      throw KI.toKnownErr(i);
    });
  }
}
x.AppBskyActorNS = lm;
class um {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.actor.profile",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.actor.profile",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.actor.profile", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.actor.profile", rkey: "self", ...e, record: r }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.actor.profile", ...e }, { headers: r });
  }
}
x.ProfileRecord = um;
class cm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
}
x.AppBskyEmbedNS = cm;
class dm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "generator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "like", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "post", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "repost", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "threadgate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.generator = new fm(e), this.like = new pm(e), this.post = new hm(e), this.repost = new mm(e), this.threadgate = new ym(e);
  }
  describeFeedGenerator(e, r) {
    return this._service.xrpc.call("app.bsky.feed.describeFeedGenerator", e, void 0, r).catch((i) => {
      throw MI.toKnownErr(i);
    });
  }
  getActorFeeds(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getActorFeeds", e, void 0, r).catch((i) => {
      throw NI.toKnownErr(i);
    });
  }
  getActorLikes(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getActorLikes", e, void 0, r).catch((i) => {
      throw VI.toKnownErr(i);
    });
  }
  getAuthorFeed(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getAuthorFeed", e, void 0, r).catch((i) => {
      throw jI.toKnownErr(i);
    });
  }
  getFeed(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getFeed", e, void 0, r).catch((i) => {
      throw FI.toKnownErr(i);
    });
  }
  getFeedGenerator(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getFeedGenerator", e, void 0, r).catch((i) => {
      throw $I.toKnownErr(i);
    });
  }
  getFeedGenerators(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getFeedGenerators", e, void 0, r).catch((i) => {
      throw GI.toKnownErr(i);
    });
  }
  getFeedSkeleton(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getFeedSkeleton", e, void 0, r).catch((i) => {
      throw qI.toKnownErr(i);
    });
  }
  getLikes(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getLikes", e, void 0, r).catch((i) => {
      throw zI.toKnownErr(i);
    });
  }
  getListFeed(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getListFeed", e, void 0, r).catch((i) => {
      throw XI.toKnownErr(i);
    });
  }
  getPostThread(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getPostThread", e, void 0, r).catch((i) => {
      throw HI.toKnownErr(i);
    });
  }
  getPosts(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getPosts", e, void 0, r).catch((i) => {
      throw ZI.toKnownErr(i);
    });
  }
  getRepostedBy(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getRepostedBy", e, void 0, r).catch((i) => {
      throw WI.toKnownErr(i);
    });
  }
  getSuggestedFeeds(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getSuggestedFeeds", e, void 0, r).catch((i) => {
      throw YI.toKnownErr(i);
    });
  }
  getTimeline(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getTimeline", e, void 0, r).catch((i) => {
      throw JI.toKnownErr(i);
    });
  }
  searchPosts(e, r) {
    return this._service.xrpc.call("app.bsky.feed.searchPosts", e, void 0, r).catch((i) => {
      throw QI.toKnownErr(i);
    });
  }
  sendInteractions(e, r) {
    return this._service.xrpc.call("app.bsky.feed.sendInteractions", r?.qp, e, r).catch((i) => {
      throw eU.toKnownErr(i);
    });
  }
}
x.AppBskyFeedNS = dm;
class fm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.feed.generator",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.feed.generator",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.feed.generator", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.generator", ...e, record: r }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.generator", ...e }, { headers: r });
  }
}
x.GeneratorRecord = fm;
class pm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.feed.like",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.feed.like",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.feed.like", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.like", ...e, record: r }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.like", ...e }, { headers: r });
  }
}
x.LikeRecord = pm;
class hm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.feed.post",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.feed.post",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.feed.post", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.post", ...e, record: r }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.post", ...e }, { headers: r });
  }
}
x.PostRecord = hm;
class mm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.feed.repost",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.feed.repost",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.feed.repost", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.repost", ...e, record: r }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.repost", ...e }, { headers: r });
  }
}
x.RepostRecord = mm;
class ym {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.feed.threadgate",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.feed.threadgate",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.feed.threadgate", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.threadgate", ...e, record: r }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.threadgate", ...e }, { headers: r });
  }
}
x.ThreadgateRecord = ym;
class bm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "block", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "follow", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "list", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "listblock", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "listitem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "starterpack", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.block = new gm(e), this.follow = new xm(e), this.list = new Em(e), this.listblock = new vm(e), this.listitem = new Rm(e), this.starterpack = new Am(e);
  }
  getActorStarterPacks(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getActorStarterPacks", e, void 0, r).catch((i) => {
      throw tU.toKnownErr(i);
    });
  }
  getBlocks(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getBlocks", e, void 0, r).catch((i) => {
      throw rU.toKnownErr(i);
    });
  }
  getFollowers(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getFollowers", e, void 0, r).catch((i) => {
      throw iU.toKnownErr(i);
    });
  }
  getFollows(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getFollows", e, void 0, r).catch((i) => {
      throw nU.toKnownErr(i);
    });
  }
  getKnownFollowers(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getKnownFollowers", e, void 0, r).catch((i) => {
      throw sU.toKnownErr(i);
    });
  }
  getList(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getList", e, void 0, r).catch((i) => {
      throw aU.toKnownErr(i);
    });
  }
  getListBlocks(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getListBlocks", e, void 0, r).catch((i) => {
      throw oU.toKnownErr(i);
    });
  }
  getListMutes(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getListMutes", e, void 0, r).catch((i) => {
      throw lU.toKnownErr(i);
    });
  }
  getLists(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getLists", e, void 0, r).catch((i) => {
      throw uU.toKnownErr(i);
    });
  }
  getMutes(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getMutes", e, void 0, r).catch((i) => {
      throw cU.toKnownErr(i);
    });
  }
  getRelationships(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getRelationships", e, void 0, r).catch((i) => {
      throw dU.toKnownErr(i);
    });
  }
  getStarterPack(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getStarterPack", e, void 0, r).catch((i) => {
      throw fU.toKnownErr(i);
    });
  }
  getStarterPacks(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getStarterPacks", e, void 0, r).catch((i) => {
      throw pU.toKnownErr(i);
    });
  }
  getSuggestedFollowsByActor(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getSuggestedFollowsByActor", e, void 0, r).catch((i) => {
      throw hU.toKnownErr(i);
    });
  }
  muteActor(e, r) {
    return this._service.xrpc.call("app.bsky.graph.muteActor", r?.qp, e, r).catch((i) => {
      throw mU.toKnownErr(i);
    });
  }
  muteActorList(e, r) {
    return this._service.xrpc.call("app.bsky.graph.muteActorList", r?.qp, e, r).catch((i) => {
      throw yU.toKnownErr(i);
    });
  }
  muteThread(e, r) {
    return this._service.xrpc.call("app.bsky.graph.muteThread", r?.qp, e, r).catch((i) => {
      throw bU.toKnownErr(i);
    });
  }
  unmuteActor(e, r) {
    return this._service.xrpc.call("app.bsky.graph.unmuteActor", r?.qp, e, r).catch((i) => {
      throw gU.toKnownErr(i);
    });
  }
  unmuteActorList(e, r) {
    return this._service.xrpc.call("app.bsky.graph.unmuteActorList", r?.qp, e, r).catch((i) => {
      throw xU.toKnownErr(i);
    });
  }
  unmuteThread(e, r) {
    return this._service.xrpc.call("app.bsky.graph.unmuteThread", r?.qp, e, r).catch((i) => {
      throw EU.toKnownErr(i);
    });
  }
}
x.AppBskyGraphNS = bm;
class gm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.block",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.block",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.graph.block", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.block", ...e, record: r }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.block", ...e }, { headers: r });
  }
}
x.BlockRecord = gm;
class xm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.follow",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.follow",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.graph.follow", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.follow", ...e, record: r }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.follow", ...e }, { headers: r });
  }
}
x.FollowRecord = xm;
class Em {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.list",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.list",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.graph.list", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.list", ...e, record: r }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.list", ...e }, { headers: r });
  }
}
x.ListRecord = Em;
class vm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.listblock",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.listblock",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.graph.listblock", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.listblock", ...e, record: r }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.listblock", ...e }, { headers: r });
  }
}
x.ListblockRecord = vm;
class Rm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.listitem",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.listitem",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.graph.listitem", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.listitem", ...e, record: r }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.listitem", ...e }, { headers: r });
  }
}
x.ListitemRecord = Rm;
class Am {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.starterpack",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.starterpack",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.graph.starterpack", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.starterpack", ...e, record: r }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.starterpack", ...e }, { headers: r });
  }
}
x.StarterpackRecord = Am;
class _m {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.service = new wm(e);
  }
  getServices(e, r) {
    return this._service.xrpc.call("app.bsky.labeler.getServices", e, void 0, r).catch((i) => {
      throw vU.toKnownErr(i);
    });
  }
}
x.AppBskyLabelerNS = _m;
class wm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.labeler.service",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.labeler.service",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "app.bsky.labeler.service", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, {
      collection: "app.bsky.labeler.service",
      rkey: "self",
      ...e,
      record: r
    }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.labeler.service", ...e }, { headers: r });
  }
}
x.ServiceRecord = wm;
class Tm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getUnreadCount(e, r) {
    return this._service.xrpc.call("app.bsky.notification.getUnreadCount", e, void 0, r).catch((i) => {
      throw RU.toKnownErr(i);
    });
  }
  listNotifications(e, r) {
    return this._service.xrpc.call("app.bsky.notification.listNotifications", e, void 0, r).catch((i) => {
      throw AU.toKnownErr(i);
    });
  }
  putPreferences(e, r) {
    return this._service.xrpc.call("app.bsky.notification.putPreferences", r?.qp, e, r).catch((i) => {
      throw _U.toKnownErr(i);
    });
  }
  registerPush(e, r) {
    return this._service.xrpc.call("app.bsky.notification.registerPush", r?.qp, e, r).catch((i) => {
      throw wU.toKnownErr(i);
    });
  }
  updateSeen(e, r) {
    return this._service.xrpc.call("app.bsky.notification.updateSeen", r?.qp, e, r).catch((i) => {
      throw TU.toKnownErr(i);
    });
  }
}
x.AppBskyNotificationNS = Tm;
class Sm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
}
x.AppBskyRichtextNS = Sm;
class Cm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getPopularFeedGenerators(e, r) {
    return this._service.xrpc.call("app.bsky.unspecced.getPopularFeedGenerators", e, void 0, r).catch((i) => {
      throw SU.toKnownErr(i);
    });
  }
  getSuggestionsSkeleton(e, r) {
    return this._service.xrpc.call("app.bsky.unspecced.getSuggestionsSkeleton", e, void 0, r).catch((i) => {
      throw CU.toKnownErr(i);
    });
  }
  getTaggedSuggestions(e, r) {
    return this._service.xrpc.call("app.bsky.unspecced.getTaggedSuggestions", e, void 0, r).catch((i) => {
      throw LU.toKnownErr(i);
    });
  }
  searchActorsSkeleton(e, r) {
    return this._service.xrpc.call("app.bsky.unspecced.searchActorsSkeleton", e, void 0, r).catch((i) => {
      throw kU.toKnownErr(i);
    });
  }
  searchPostsSkeleton(e, r) {
    return this._service.xrpc.call("app.bsky.unspecced.searchPostsSkeleton", e, void 0, r).catch((i) => {
      throw DU.toKnownErr(i);
    });
  }
}
x.AppBskyUnspeccedNS = Cm;
class Lm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "bsky", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.bsky = new km(e);
  }
}
x.ChatNS = Lm;
class km {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "actor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "convo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "moderation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.actor = new Dm(e), this.convo = new Bm(e), this.moderation = new Im(e);
  }
}
x.ChatBskyNS = km;
class Dm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "declaration", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.declaration = new Pm(e);
  }
  deleteAccount(e, r) {
    return this._service.xrpc.call("chat.bsky.actor.deleteAccount", r?.qp, e, r).catch((i) => {
      throw PU.toKnownErr(i);
    });
  }
  exportAccountData(e, r) {
    return this._service.xrpc.call("chat.bsky.actor.exportAccountData", e, void 0, r).catch((i) => {
      throw BU.toKnownErr(i);
    });
  }
}
x.ChatBskyActorNS = Dm;
class Pm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "chat.bsky.actor.declaration",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "chat.bsky.actor.declaration",
      ...e
    })).data;
  }
  async create(e, r, i) {
    return r.$type = "chat.bsky.actor.declaration", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, {
      collection: "chat.bsky.actor.declaration",
      rkey: "self",
      ...e,
      record: r
    }, { encoding: "application/json", headers: i })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "chat.bsky.actor.declaration", ...e }, { headers: r });
  }
}
x.DeclarationRecord = Pm;
class Bm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  deleteMessageForSelf(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.deleteMessageForSelf", r?.qp, e, r).catch((i) => {
      throw IU.toKnownErr(i);
    });
  }
  getConvo(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.getConvo", e, void 0, r).catch((i) => {
      throw UU.toKnownErr(i);
    });
  }
  getConvoForMembers(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.getConvoForMembers", e, void 0, r).catch((i) => {
      throw OU.toKnownErr(i);
    });
  }
  getLog(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.getLog", e, void 0, r).catch((i) => {
      throw KU.toKnownErr(i);
    });
  }
  getMessages(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.getMessages", e, void 0, r).catch((i) => {
      throw MU.toKnownErr(i);
    });
  }
  leaveConvo(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.leaveConvo", r?.qp, e, r).catch((i) => {
      throw NU.toKnownErr(i);
    });
  }
  listConvos(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.listConvos", e, void 0, r).catch((i) => {
      throw VU.toKnownErr(i);
    });
  }
  muteConvo(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.muteConvo", r?.qp, e, r).catch((i) => {
      throw jU.toKnownErr(i);
    });
  }
  sendMessage(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.sendMessage", r?.qp, e, r).catch((i) => {
      throw FU.toKnownErr(i);
    });
  }
  sendMessageBatch(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.sendMessageBatch", r?.qp, e, r).catch((i) => {
      throw $U.toKnownErr(i);
    });
  }
  unmuteConvo(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.unmuteConvo", r?.qp, e, r).catch((i) => {
      throw GU.toKnownErr(i);
    });
  }
  updateRead(e, r) {
    return this._service.xrpc.call("chat.bsky.convo.updateRead", r?.qp, e, r).catch((i) => {
      throw qU.toKnownErr(i);
    });
  }
}
x.ChatBskyConvoNS = Bm;
class Im {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getActorMetadata(e, r) {
    return this._service.xrpc.call("chat.bsky.moderation.getActorMetadata", e, void 0, r).catch((i) => {
      throw zU.toKnownErr(i);
    });
  }
  getMessageContext(e, r) {
    return this._service.xrpc.call("chat.bsky.moderation.getMessageContext", e, void 0, r).catch((i) => {
      throw XU.toKnownErr(i);
    });
  }
  updateActorAccess(e, r) {
    return this._service.xrpc.call("chat.bsky.moderation.updateActorAccess", r?.qp, e, r).catch((i) => {
      throw HU.toKnownErr(i);
    });
  }
}
x.ChatBskyModerationNS = Im;
class Um {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "ozone", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.ozone = new Om(e);
  }
}
x.ToolsNS = Um;
class Om {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "communication", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "moderation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "server", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "team", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.communication = new Km(e), this.moderation = new Mm(e), this.server = new Nm(e), this.team = new Vm(e);
  }
}
x.ToolsOzoneNS = Om;
class Km {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  createTemplate(e, r) {
    return this._service.xrpc.call("tools.ozone.communication.createTemplate", r?.qp, e, r).catch((i) => {
      throw ZU.toKnownErr(i);
    });
  }
  deleteTemplate(e, r) {
    return this._service.xrpc.call("tools.ozone.communication.deleteTemplate", r?.qp, e, r).catch((i) => {
      throw WU.toKnownErr(i);
    });
  }
  listTemplates(e, r) {
    return this._service.xrpc.call("tools.ozone.communication.listTemplates", e, void 0, r).catch((i) => {
      throw YU.toKnownErr(i);
    });
  }
  updateTemplate(e, r) {
    return this._service.xrpc.call("tools.ozone.communication.updateTemplate", r?.qp, e, r).catch((i) => {
      throw JU.toKnownErr(i);
    });
  }
}
x.ToolsOzoneCommunicationNS = Km;
class Mm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  emitEvent(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.emitEvent", r?.qp, e, r).catch((i) => {
      throw QU.toKnownErr(i);
    });
  }
  getEvent(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.getEvent", e, void 0, r).catch((i) => {
      throw eO.toKnownErr(i);
    });
  }
  getRecord(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.getRecord", e, void 0, r).catch((i) => {
      throw tO.toKnownErr(i);
    });
  }
  getRepo(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.getRepo", e, void 0, r).catch((i) => {
      throw rO.toKnownErr(i);
    });
  }
  queryEvents(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.queryEvents", e, void 0, r).catch((i) => {
      throw iO.toKnownErr(i);
    });
  }
  queryStatuses(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.queryStatuses", e, void 0, r).catch((i) => {
      throw nO.toKnownErr(i);
    });
  }
  searchRepos(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.searchRepos", e, void 0, r).catch((i) => {
      throw sO.toKnownErr(i);
    });
  }
}
x.ToolsOzoneModerationNS = Mm;
class Nm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getConfig(e, r) {
    return this._service.xrpc.call("tools.ozone.server.getConfig", e, void 0, r).catch((i) => {
      throw aO.toKnownErr(i);
    });
  }
}
x.ToolsOzoneServerNS = Nm;
class Vm {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  addMember(e, r) {
    return this._service.xrpc.call("tools.ozone.team.addMember", r?.qp, e, r).catch((i) => {
      throw oO.toKnownErr(i);
    });
  }
  deleteMember(e, r) {
    return this._service.xrpc.call("tools.ozone.team.deleteMember", r?.qp, e, r).catch((i) => {
      throw lO.toKnownErr(i);
    });
  }
  listMembers(e, r) {
    return this._service.xrpc.call("tools.ozone.team.listMembers", e, void 0, r).catch((i) => {
      throw uO.toKnownErr(i);
    });
  }
  updateMember(e, r) {
    return this._service.xrpc.call("tools.ozone.team.updateMember", r?.qp, e, r).catch((i) => {
      throw cO.toKnownErr(i);
    });
  }
}
x.ToolsOzoneTeamNS = Vm;
var js = {};
Object.defineProperty(js, "__esModule", { value: !0 });
js.AtpAgent = void 0;
const fO = q, au = q, hf = vi, pO = x, hO = ka, mO = "com.atproto.server.refreshSession";
class vr {
  get com() {
    return this.api.com;
  }
  /**
   * Configures the API globally.
   */
  static configure(e) {
    e.fetch && (vr.fetch = e.fetch), e.appLabelers && (vr.appLabelers = e.appLabelers);
  }
  constructor(e) {
    Object.defineProperty(this, "service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "api", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "session", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "labelersHeader", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "proxyHeader", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "pdsUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_baseClient", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_persistSession", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_refreshSessionPromise", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "uploadBlob", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (r, i) => this.api.com.atproto.repo.uploadBlob(r, i)
    }), Object.defineProperty(this, "resolveHandle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (r, i) => this.api.com.atproto.identity.resolveHandle(r, i)
    }), Object.defineProperty(this, "updateHandle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (r, i) => this.api.com.atproto.identity.updateHandle(r, i)
    }), Object.defineProperty(this, "createModerationReport", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (r, i) => this.api.com.atproto.moderation.createReport(r, i)
    }), this.service = e.service instanceof URL ? e.service : new URL(e.service), this._persistSession = e.persistSession, this._baseClient = new pO.AtpBaseClient(), this._baseClient.xrpc.fetch = this._fetch.bind(this), this.api = this._baseClient.service(e.service);
  }
  clone() {
    const e = new vr({
      service: this.service
    });
    return this.copyInto(e), e;
  }
  copyInto(e) {
    e.session = this.session, e.labelersHeader = this.labelersHeader, e.proxyHeader = this.proxyHeader, e.pdsUrl = this.pdsUrl, e.api.xrpc.uri = this.pdsUrl || this.service;
  }
  withProxy(e, r) {
    const i = this.clone();
    return i.configureProxyHeader(e, r), i;
  }
  /**
   * Is there any active session?
   */
  get hasSession() {
    return !!this.session;
  }
  /**
   * Sets the "Persist Session" method which can be used to store access tokens
   * as they change.
   */
  setPersistSessionHandler(e) {
    this._persistSession = e;
  }
  /**
   * Configures the moderation services to be applied on requests.
   * NOTE: this is called automatically by getPreferences() and the relevant moderation config
   * methods in BskyAgent instances.
   */
  configureLabelersHeader(e) {
    this.labelersHeader = e;
  }
  /**
   * Configures the atproto-proxy header to be applied on requests
   */
  configureProxyHeader(e, r) {
    r.startsWith("did:") && (this.proxyHeader = `${r}#${e}`);
  }
  /**
   * Create a new account and hydrate its session in this agent.
   */
  async createAccount(e) {
    try {
      const r = await this.api.com.atproto.server.createAccount(e);
      return this.session = {
        accessJwt: r.data.accessJwt,
        refreshJwt: r.data.refreshJwt,
        handle: r.data.handle,
        did: r.data.did,
        email: e.email,
        emailConfirmed: !1,
        emailAuthFactor: !1,
        active: !0
      }, this._updateApiEndpoint(r.data.didDoc), r;
    } catch (r) {
      throw this.session = void 0, r;
    } finally {
      this.session ? this._persistSession?.("create", this.session) : this._persistSession?.("create-failed", void 0);
    }
  }
  /**
   * Start a new session with this agent.
   */
  async login(e) {
    try {
      const r = await this.api.com.atproto.server.createSession({
        identifier: e.identifier,
        password: e.password,
        authFactorToken: e.authFactorToken
      });
      return this.session = {
        accessJwt: r.data.accessJwt,
        refreshJwt: r.data.refreshJwt,
        handle: r.data.handle,
        did: r.data.did,
        email: r.data.email,
        emailConfirmed: r.data.emailConfirmed,
        emailAuthFactor: r.data.emailAuthFactor,
        active: r.data.active ?? !0,
        status: r.data.status
      }, this._updateApiEndpoint(r.data.didDoc), r;
    } catch (r) {
      throw this.session = void 0, r;
    } finally {
      this.session ? this._persistSession?.("create", this.session) : this._persistSession?.("create-failed", void 0);
    }
  }
  /**
   * Resume a pre-existing session with this agent.
   */
  async resumeSession(e) {
    try {
      this.session = e;
      const r = await this.api.com.atproto.server.getSession();
      if (r.data.did !== this.session.did)
        throw new au.XRPCError(au.ResponseType.InvalidRequest, "Invalid session", "InvalidDID");
      return this.session.email = r.data.email, this.session.handle = r.data.handle, this.session.emailConfirmed = r.data.emailConfirmed, this.session.emailAuthFactor = r.data.emailAuthFactor, this.session.active = r.data.active ?? !0, this.session.status = r.data.status, this._updateApiEndpoint(r.data.didDoc), this._persistSession?.("update", this.session), r;
    } catch (r) {
      throw this.session = void 0, r instanceof au.XRPCError ? [1, 408, 425, 429, 500, 502, 503, 504, 522, 524].includes(r.status) ? this._persistSession?.("network-error", void 0) : this._persistSession?.("expired", void 0) : this._persistSession?.("network-error", void 0), r;
    }
  }
  /**
   * Internal helper to add authorization headers to requests.
   */
  _addHeaders(e) {
    !e.authorization && this.session?.accessJwt && (e = {
      ...e,
      authorization: `Bearer ${this.session.accessJwt}`
    }), this.proxyHeader && (e = {
      ...e,
      "atproto-proxy": this.proxyHeader
    });
    const r = "atproto-accept-labelers", i = vr.appLabelers.map((a) => `${a};redact`).concat(this.labelersHeader.filter((a) => a.startsWith("did:")));
    return e[r] && i.push(
      ...e[r].split(",").map((a) => a.trim())
    ), e = {
      ...e,
      [r]: i.join(", ")
    }, e;
  }
  /**
   * Internal fetch handler which adds access-token management
   */
  async _fetch(e, r, i, a) {
    if (!vr.fetch)
      throw new Error("AtpAgent fetch() method not configured");
    await this._refreshSessionPromise;
    let c = await vr.fetch(e, r, this._addHeaders(i), a);
    return mf(c, ["ExpiredToken"]) && this.session?.refreshJwt && (await this.refreshSession(), c = await vr.fetch(e, r, this._addHeaders(i), a)), c;
  }
  /**
   * Internal helper to refresh sessions
   * - Wraps the actual implementation in a promise-guard to ensure only
   *   one refresh is attempted at a time.
   */
  async refreshSession() {
    if (this._refreshSessionPromise)
      return this._refreshSessionPromise;
    this._refreshSessionPromise = this._refreshSessionInner();
    try {
      await this._refreshSessionPromise;
    } finally {
      this._refreshSessionPromise = void 0;
    }
  }
  /**
   * Internal helper to refresh sessions (actual behavior)
   */
  async _refreshSessionInner() {
    if (!vr.fetch)
      throw new Error("AtpAgent fetch() method not configured");
    if (!this.session?.refreshJwt)
      return;
    const e = new URL((this.pdsUrl || this.service).origin);
    e.pathname = `/xrpc/${mO}`;
    const r = await vr.fetch(e.toString(), "POST", {
      authorization: `Bearer ${this.session.refreshJwt}`
    }, void 0);
    mf(r, ["ExpiredToken", "InvalidToken"]) ? (this.session = void 0, this._persistSession?.("expired", void 0)) : bO(this._baseClient, r.body) && (this.session = {
      ...this.session || {},
      accessJwt: r.body.accessJwt,
      refreshJwt: r.body.refreshJwt,
      handle: r.body.handle,
      did: r.body.did
    }, this._updateApiEndpoint(r.body.didDoc), this._persistSession?.("update", this.session));
  }
  /**
   * Helper to update the pds endpoint dynamically.
   *
   * The session methods (create, resume, refresh) may respond with the user's
   * did document which contains the user's canonical PDS endpoint. That endpoint
   * may differ from the endpoint used to contact the server. We capture that
   * PDS endpoint and update the client to use that given endpoint for future
   * requests. (This helps ensure smooth migrations between PDSes, especially
   * when the PDSes are operated by a single org.)
   */
  _updateApiEndpoint(e) {
    if ((0, hf.isValidDidDoc)(e)) {
      const r = (0, hf.getPdsEndpoint)(e);
      this.pdsUrl = r ? new URL(r) : void 0;
    }
    this.api.xrpc.uri = this.pdsUrl || this.service;
  }
}
js.AtpAgent = vr;
Object.defineProperty(vr, "fetch", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: au.defaultFetchHandler
});
Object.defineProperty(vr, "appLabelers", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: [hO.BSKY_LABELER_DID]
});
function yO(t) {
  return fO.errorResponseBody.safeParse(t).success;
}
function mf(t, e) {
  return t.status !== 400 || !yO(t.body) ? !1 : typeof t.body.error == "string" && e.includes(t.body.error);
}
function bO(t, e) {
  try {
    return t.xrpc.lex.assertValidXrpcOutput("com.atproto.server.refreshSession", e), !0;
  } catch {
    return !1;
  }
}
var Fs = {}, Hs = {};
Object.defineProperty(Hs, "__esModule", { value: !0 });
Hs.UnicodeString = void 0;
const gO = vi, yf = new TextEncoder(), xO = new TextDecoder();
class EO {
  constructor(e) {
    Object.defineProperty(this, "utf16", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "utf8", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_graphemeLen", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.utf16 = e, this.utf8 = yf.encode(e);
  }
  get length() {
    return this.utf8.byteLength;
  }
  get graphemeLength() {
    return this._graphemeLen || (this._graphemeLen = (0, gO.graphemeLen)(this.utf16)), this._graphemeLen;
  }
  slice(e, r) {
    return xO.decode(this.utf8.slice(e, r));
  }
  utf16IndexToUtf8Index(e) {
    return yf.encode(this.utf16.slice(0, e)).byteLength;
  }
  toString() {
    return this.utf16;
  }
}
Hs.UnicodeString = EO;
var jl = {};
Object.defineProperty(jl, "__esModule", { value: !0 });
jl.sanitizeRichText = void 0;
const vO = Hs, RO = /[\r\n]([\u00AD\u2060\u200D\u200C\u200B\s]*[\r\n]){2,}/, AO = `

`;
function _O(t, e) {
  return e.cleanNewlines && (t = wO(t, RO, AO)), t;
}
jl.sanitizeRichText = _O;
function wO(t, e, r) {
  t = t.clone();
  let i = t.unicodeText.utf16.match(e);
  for (; i && typeof i.index < "u"; ) {
    const a = t.unicodeText, c = t.unicodeText.utf16IndexToUtf8Index(i.index), h = c + new vO.UnicodeString(i[0]).length;
    if (t.delete(c, h), t.unicodeText.utf16 === a.utf16)
      break;
    t.insert(c, r), i = t.unicodeText.utf16.match(e);
  }
  return t;
}
var $u = {};
const TO = [
  "aaa",
  "aarp",
  "abb",
  "abbott",
  "abbvie",
  "abc",
  "able",
  "abogado",
  "abudhabi",
  "ac",
  "academy",
  "accenture",
  "accountant",
  "accountants",
  "aco",
  "actor",
  "ad",
  "ads",
  "adult",
  "ae",
  "aeg",
  "aero",
  "aetna",
  "af",
  "afl",
  "africa",
  "ag",
  "agakhan",
  "agency",
  "ai",
  "aig",
  "airbus",
  "airforce",
  "airtel",
  "akdn",
  "al",
  "alibaba",
  "alipay",
  "allfinanz",
  "allstate",
  "ally",
  "alsace",
  "alstom",
  "am",
  "amazon",
  "americanexpress",
  "americanfamily",
  "amex",
  "amfam",
  "amica",
  "amsterdam",
  "analytics",
  "android",
  "anquan",
  "anz",
  "ao",
  "aol",
  "apartments",
  "app",
  "apple",
  "aq",
  "aquarelle",
  "ar",
  "arab",
  "aramco",
  "archi",
  "army",
  "arpa",
  "art",
  "arte",
  "as",
  "asda",
  "asia",
  "associates",
  "at",
  "athleta",
  "attorney",
  "au",
  "auction",
  "audi",
  "audible",
  "audio",
  "auspost",
  "author",
  "auto",
  "autos",
  "aw",
  "aws",
  "ax",
  "axa",
  "az",
  "azure",
  "ba",
  "baby",
  "baidu",
  "banamex",
  "band",
  "bank",
  "bar",
  "barcelona",
  "barclaycard",
  "barclays",
  "barefoot",
  "bargains",
  "baseball",
  "basketball",
  "bauhaus",
  "bayern",
  "bb",
  "bbc",
  "bbt",
  "bbva",
  "bcg",
  "bcn",
  "bd",
  "be",
  "beats",
  "beauty",
  "beer",
  "bentley",
  "berlin",
  "best",
  "bestbuy",
  "bet",
  "bf",
  "bg",
  "bh",
  "bharti",
  "bi",
  "bible",
  "bid",
  "bike",
  "bing",
  "bingo",
  "bio",
  "biz",
  "bj",
  "black",
  "blackfriday",
  "blockbuster",
  "blog",
  "bloomberg",
  "blue",
  "bm",
  "bms",
  "bmw",
  "bn",
  "bnpparibas",
  "bo",
  "boats",
  "boehringer",
  "bofa",
  "bom",
  "bond",
  "boo",
  "book",
  "booking",
  "bosch",
  "bostik",
  "boston",
  "bot",
  "boutique",
  "box",
  "br",
  "bradesco",
  "bridgestone",
  "broadway",
  "broker",
  "brother",
  "brussels",
  "bs",
  "bt",
  "build",
  "builders",
  "business",
  "buy",
  "buzz",
  "bv",
  "bw",
  "by",
  "bz",
  "bzh",
  "ca",
  "cab",
  "cafe",
  "cal",
  "call",
  "calvinklein",
  "cam",
  "camera",
  "camp",
  "canon",
  "capetown",
  "capital",
  "capitalone",
  "car",
  "caravan",
  "cards",
  "care",
  "career",
  "careers",
  "cars",
  "casa",
  "case",
  "cash",
  "casino",
  "cat",
  "catering",
  "catholic",
  "cba",
  "cbn",
  "cbre",
  "cc",
  "cd",
  "center",
  "ceo",
  "cern",
  "cf",
  "cfa",
  "cfd",
  "cg",
  "ch",
  "chanel",
  "channel",
  "charity",
  "chase",
  "chat",
  "cheap",
  "chintai",
  "christmas",
  "chrome",
  "church",
  "ci",
  "cipriani",
  "circle",
  "cisco",
  "citadel",
  "citi",
  "citic",
  "city",
  "ck",
  "cl",
  "claims",
  "cleaning",
  "click",
  "clinic",
  "clinique",
  "clothing",
  "cloud",
  "club",
  "clubmed",
  "cm",
  "cn",
  "co",
  "coach",
  "codes",
  "coffee",
  "college",
  "cologne",
  "com",
  "commbank",
  "community",
  "company",
  "compare",
  "computer",
  "comsec",
  "condos",
  "construction",
  "consulting",
  "contact",
  "contractors",
  "cooking",
  "cool",
  "coop",
  "corsica",
  "country",
  "coupon",
  "coupons",
  "courses",
  "cpa",
  "cr",
  "credit",
  "creditcard",
  "creditunion",
  "cricket",
  "crown",
  "crs",
  "cruise",
  "cruises",
  "cu",
  "cuisinella",
  "cv",
  "cw",
  "cx",
  "cy",
  "cymru",
  "cyou",
  "cz",
  "dad",
  "dance",
  "data",
  "date",
  "dating",
  "datsun",
  "day",
  "dclk",
  "dds",
  "de",
  "deal",
  "dealer",
  "deals",
  "degree",
  "delivery",
  "dell",
  "deloitte",
  "delta",
  "democrat",
  "dental",
  "dentist",
  "desi",
  "design",
  "dev",
  "dhl",
  "diamonds",
  "diet",
  "digital",
  "direct",
  "directory",
  "discount",
  "discover",
  "dish",
  "diy",
  "dj",
  "dk",
  "dm",
  "dnp",
  "do",
  "docs",
  "doctor",
  "dog",
  "domains",
  "dot",
  "download",
  "drive",
  "dtv",
  "dubai",
  "dunlop",
  "dupont",
  "durban",
  "dvag",
  "dvr",
  "dz",
  "earth",
  "eat",
  "ec",
  "eco",
  "edeka",
  "edu",
  "education",
  "ee",
  "eg",
  "email",
  "emerck",
  "energy",
  "engineer",
  "engineering",
  "enterprises",
  "epson",
  "equipment",
  "er",
  "ericsson",
  "erni",
  "es",
  "esq",
  "estate",
  "et",
  "eu",
  "eurovision",
  "eus",
  "events",
  "exchange",
  "expert",
  "exposed",
  "express",
  "extraspace",
  "fage",
  "fail",
  "fairwinds",
  "faith",
  "family",
  "fan",
  "fans",
  "farm",
  "farmers",
  "fashion",
  "fast",
  "fedex",
  "feedback",
  "ferrari",
  "ferrero",
  "fi",
  "fidelity",
  "fido",
  "film",
  "final",
  "finance",
  "financial",
  "fire",
  "firestone",
  "firmdale",
  "fish",
  "fishing",
  "fit",
  "fitness",
  "fj",
  "fk",
  "flickr",
  "flights",
  "flir",
  "florist",
  "flowers",
  "fly",
  "fm",
  "fo",
  "foo",
  "food",
  "football",
  "ford",
  "forex",
  "forsale",
  "forum",
  "foundation",
  "fox",
  "fr",
  "free",
  "fresenius",
  "frl",
  "frogans",
  "frontier",
  "ftr",
  "fujitsu",
  "fun",
  "fund",
  "furniture",
  "futbol",
  "fyi",
  "ga",
  "gal",
  "gallery",
  "gallo",
  "gallup",
  "game",
  "games",
  "gap",
  "garden",
  "gay",
  "gb",
  "gbiz",
  "gd",
  "gdn",
  "ge",
  "gea",
  "gent",
  "genting",
  "george",
  "gf",
  "gg",
  "ggee",
  "gh",
  "gi",
  "gift",
  "gifts",
  "gives",
  "giving",
  "gl",
  "glass",
  "gle",
  "global",
  "globo",
  "gm",
  "gmail",
  "gmbh",
  "gmo",
  "gmx",
  "gn",
  "godaddy",
  "gold",
  "goldpoint",
  "golf",
  "goo",
  "goodyear",
  "goog",
  "google",
  "gop",
  "got",
  "gov",
  "gp",
  "gq",
  "gr",
  "grainger",
  "graphics",
  "gratis",
  "green",
  "gripe",
  "grocery",
  "group",
  "gs",
  "gt",
  "gu",
  "gucci",
  "guge",
  "guide",
  "guitars",
  "guru",
  "gw",
  "gy",
  "hair",
  "hamburg",
  "hangout",
  "haus",
  "hbo",
  "hdfc",
  "hdfcbank",
  "health",
  "healthcare",
  "help",
  "helsinki",
  "here",
  "hermes",
  "hiphop",
  "hisamitsu",
  "hitachi",
  "hiv",
  "hk",
  "hkt",
  "hm",
  "hn",
  "hockey",
  "holdings",
  "holiday",
  "homedepot",
  "homegoods",
  "homes",
  "homesense",
  "honda",
  "horse",
  "hospital",
  "host",
  "hosting",
  "hot",
  "hotels",
  "hotmail",
  "house",
  "how",
  "hr",
  "hsbc",
  "ht",
  "hu",
  "hughes",
  "hyatt",
  "hyundai",
  "ibm",
  "icbc",
  "ice",
  "icu",
  "id",
  "ie",
  "ieee",
  "ifm",
  "ikano",
  "il",
  "im",
  "imamat",
  "imdb",
  "immo",
  "immobilien",
  "in",
  "inc",
  "industries",
  "infiniti",
  "info",
  "ing",
  "ink",
  "institute",
  "insurance",
  "insure",
  "int",
  "international",
  "intuit",
  "investments",
  "io",
  "ipiranga",
  "iq",
  "ir",
  "irish",
  "is",
  "ismaili",
  "ist",
  "istanbul",
  "it",
  "itau",
  "itv",
  "jaguar",
  "java",
  "jcb",
  "je",
  "jeep",
  "jetzt",
  "jewelry",
  "jio",
  "jll",
  "jm",
  "jmp",
  "jnj",
  "jo",
  "jobs",
  "joburg",
  "jot",
  "joy",
  "jp",
  "jpmorgan",
  "jprs",
  "juegos",
  "juniper",
  "kaufen",
  "kddi",
  "ke",
  "kerryhotels",
  "kerrylogistics",
  "kerryproperties",
  "kfh",
  "kg",
  "kh",
  "ki",
  "kia",
  "kids",
  "kim",
  "kindle",
  "kitchen",
  "kiwi",
  "km",
  "kn",
  "koeln",
  "komatsu",
  "kosher",
  "kp",
  "kpmg",
  "kpn",
  "kr",
  "krd",
  "kred",
  "kuokgroup",
  "kw",
  "ky",
  "kyoto",
  "kz",
  "la",
  "lacaixa",
  "lamborghini",
  "lamer",
  "lancaster",
  "land",
  "landrover",
  "lanxess",
  "lasalle",
  "lat",
  "latino",
  "latrobe",
  "law",
  "lawyer",
  "lb",
  "lc",
  "lds",
  "lease",
  "leclerc",
  "lefrak",
  "legal",
  "lego",
  "lexus",
  "lgbt",
  "li",
  "lidl",
  "life",
  "lifeinsurance",
  "lifestyle",
  "lighting",
  "like",
  "lilly",
  "limited",
  "limo",
  "lincoln",
  "link",
  "lipsy",
  "live",
  "living",
  "lk",
  "llc",
  "llp",
  "loan",
  "loans",
  "locker",
  "locus",
  "lol",
  "london",
  "lotte",
  "lotto",
  "love",
  "lpl",
  "lplfinancial",
  "lr",
  "ls",
  "lt",
  "ltd",
  "ltda",
  "lu",
  "lundbeck",
  "luxe",
  "luxury",
  "lv",
  "ly",
  "ma",
  "madrid",
  "maif",
  "maison",
  "makeup",
  "man",
  "management",
  "mango",
  "map",
  "market",
  "marketing",
  "markets",
  "marriott",
  "marshalls",
  "mattel",
  "mba",
  "mc",
  "mckinsey",
  "md",
  "me",
  "med",
  "media",
  "meet",
  "melbourne",
  "meme",
  "memorial",
  "men",
  "menu",
  "merckmsd",
  "mg",
  "mh",
  "miami",
  "microsoft",
  "mil",
  "mini",
  "mint",
  "mit",
  "mitsubishi",
  "mk",
  "ml",
  "mlb",
  "mls",
  "mm",
  "mma",
  "mn",
  "mo",
  "mobi",
  "mobile",
  "moda",
  "moe",
  "moi",
  "mom",
  "monash",
  "money",
  "monster",
  "mormon",
  "mortgage",
  "moscow",
  "moto",
  "motorcycles",
  "mov",
  "movie",
  "mp",
  "mq",
  "mr",
  "ms",
  "msd",
  "mt",
  "mtn",
  "mtr",
  "mu",
  "museum",
  "music",
  "mv",
  "mw",
  "mx",
  "my",
  "mz",
  "na",
  "nab",
  "nagoya",
  "name",
  "navy",
  "nba",
  "nc",
  "ne",
  "nec",
  "net",
  "netbank",
  "netflix",
  "network",
  "neustar",
  "new",
  "news",
  "next",
  "nextdirect",
  "nexus",
  "nf",
  "nfl",
  "ng",
  "ngo",
  "nhk",
  "ni",
  "nico",
  "nike",
  "nikon",
  "ninja",
  "nissan",
  "nissay",
  "nl",
  "no",
  "nokia",
  "norton",
  "now",
  "nowruz",
  "nowtv",
  "np",
  "nr",
  "nra",
  "nrw",
  "ntt",
  "nu",
  "nyc",
  "nz",
  "obi",
  "observer",
  "office",
  "okinawa",
  "olayan",
  "olayangroup",
  "ollo",
  "om",
  "omega",
  "one",
  "ong",
  "onl",
  "online",
  "ooo",
  "open",
  "oracle",
  "orange",
  "org",
  "organic",
  "origins",
  "osaka",
  "otsuka",
  "ott",
  "ovh",
  "pa",
  "page",
  "panasonic",
  "paris",
  "pars",
  "partners",
  "parts",
  "party",
  "pay",
  "pccw",
  "pe",
  "pet",
  "pf",
  "pfizer",
  "pg",
  "ph",
  "pharmacy",
  "phd",
  "philips",
  "phone",
  "photo",
  "photography",
  "photos",
  "physio",
  "pics",
  "pictet",
  "pictures",
  "pid",
  "pin",
  "ping",
  "pink",
  "pioneer",
  "pizza",
  "pk",
  "pl",
  "place",
  "play",
  "playstation",
  "plumbing",
  "plus",
  "pm",
  "pn",
  "pnc",
  "pohl",
  "poker",
  "politie",
  "porn",
  "post",
  "pr",
  "pramerica",
  "praxi",
  "press",
  "prime",
  "pro",
  "prod",
  "productions",
  "prof",
  "progressive",
  "promo",
  "properties",
  "property",
  "protection",
  "pru",
  "prudential",
  "ps",
  "pt",
  "pub",
  "pw",
  "pwc",
  "py",
  "qa",
  "qpon",
  "quebec",
  "quest",
  "racing",
  "radio",
  "re",
  "read",
  "realestate",
  "realtor",
  "realty",
  "recipes",
  "red",
  "redstone",
  "redumbrella",
  "rehab",
  "reise",
  "reisen",
  "reit",
  "reliance",
  "ren",
  "rent",
  "rentals",
  "repair",
  "report",
  "republican",
  "rest",
  "restaurant",
  "review",
  "reviews",
  "rexroth",
  "rich",
  "richardli",
  "ricoh",
  "ril",
  "rio",
  "rip",
  "ro",
  "rocks",
  "rodeo",
  "rogers",
  "room",
  "rs",
  "rsvp",
  "ru",
  "rugby",
  "ruhr",
  "run",
  "rw",
  "rwe",
  "ryukyu",
  "sa",
  "saarland",
  "safe",
  "safety",
  "sakura",
  "sale",
  "salon",
  "samsclub",
  "samsung",
  "sandvik",
  "sandvikcoromant",
  "sanofi",
  "sap",
  "sarl",
  "sas",
  "save",
  "saxo",
  "sb",
  "sbi",
  "sbs",
  "sc",
  "scb",
  "schaeffler",
  "schmidt",
  "scholarships",
  "school",
  "schule",
  "schwarz",
  "science",
  "scot",
  "sd",
  "se",
  "search",
  "seat",
  "secure",
  "security",
  "seek",
  "select",
  "sener",
  "services",
  "seven",
  "sew",
  "sex",
  "sexy",
  "sfr",
  "sg",
  "sh",
  "shangrila",
  "sharp",
  "shell",
  "shia",
  "shiksha",
  "shoes",
  "shop",
  "shopping",
  "shouji",
  "show",
  "si",
  "silk",
  "sina",
  "singles",
  "site",
  "sj",
  "sk",
  "ski",
  "skin",
  "sky",
  "skype",
  "sl",
  "sling",
  "sm",
  "smart",
  "smile",
  "sn",
  "sncf",
  "so",
  "soccer",
  "social",
  "softbank",
  "software",
  "sohu",
  "solar",
  "solutions",
  "song",
  "sony",
  "soy",
  "spa",
  "space",
  "sport",
  "spot",
  "sr",
  "srl",
  "ss",
  "st",
  "stada",
  "staples",
  "star",
  "statebank",
  "statefarm",
  "stc",
  "stcgroup",
  "stockholm",
  "storage",
  "store",
  "stream",
  "studio",
  "study",
  "style",
  "su",
  "sucks",
  "supplies",
  "supply",
  "support",
  "surf",
  "surgery",
  "suzuki",
  "sv",
  "swatch",
  "swiss",
  "sx",
  "sy",
  "sydney",
  "systems",
  "sz",
  "tab",
  "taipei",
  "talk",
  "taobao",
  "target",
  "tatamotors",
  "tatar",
  "tattoo",
  "tax",
  "taxi",
  "tc",
  "tci",
  "td",
  "tdk",
  "team",
  "tech",
  "technology",
  "tel",
  "temasek",
  "tennis",
  "teva",
  "tf",
  "tg",
  "th",
  "thd",
  "theater",
  "theatre",
  "tiaa",
  "tickets",
  "tienda",
  "tips",
  "tires",
  "tirol",
  "tj",
  "tjmaxx",
  "tjx",
  "tk",
  "tkmaxx",
  "tl",
  "tm",
  "tmall",
  "tn",
  "to",
  "today",
  "tokyo",
  "tools",
  "top",
  "toray",
  "toshiba",
  "total",
  "tours",
  "town",
  "toyota",
  "toys",
  "tr",
  "trade",
  "trading",
  "training",
  "travel",
  "travelers",
  "travelersinsurance",
  "trust",
  "trv",
  "tt",
  "tube",
  "tui",
  "tunes",
  "tushu",
  "tv",
  "tvs",
  "tw",
  "tz",
  "ua",
  "ubank",
  "ubs",
  "ug",
  "uk",
  "unicom",
  "university",
  "uno",
  "uol",
  "ups",
  "us",
  "uy",
  "uz",
  "va",
  "vacations",
  "vana",
  "vanguard",
  "vc",
  "ve",
  "vegas",
  "ventures",
  "verisign",
  "vermgensberater",
  "vermgensberatung",
  "versicherung",
  "vet",
  "vg",
  "vi",
  "viajes",
  "video",
  "vig",
  "viking",
  "villas",
  "vin",
  "vip",
  "virgin",
  "visa",
  "vision",
  "viva",
  "vivo",
  "vlaanderen",
  "vn",
  "vodka",
  "volvo",
  "vote",
  "voting",
  "voto",
  "voyage",
  "vu",
  "wales",
  "walmart",
  "walter",
  "wang",
  "wanggou",
  "watch",
  "watches",
  "weather",
  "weatherchannel",
  "webcam",
  "weber",
  "website",
  "wed",
  "wedding",
  "weibo",
  "weir",
  "wf",
  "whoswho",
  "wien",
  "wiki",
  "williamhill",
  "win",
  "windows",
  "wine",
  "winners",
  "wme",
  "wolterskluwer",
  "woodside",
  "work",
  "works",
  "world",
  "wow",
  "ws",
  "wtc",
  "wtf",
  "xbox",
  "xerox",
  "xihuan",
  "xin",
  "xxx",
  "xyz",
  "yachts",
  "yahoo",
  "yamaxun",
  "yandex",
  "ye",
  "yodobashi",
  "yoga",
  "yokohama",
  "you",
  "youtube",
  "yt",
  "yun",
  "za",
  "zappos",
  "zara",
  "zero",
  "zip",
  "zm",
  "zone",
  "zuerich",
  "zw",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];
var $r = {};
Object.defineProperty($r, "__esModule", { value: !0 });
$r.TAG_REGEX = $r.TRAILING_PUNCTUATION_REGEX = $r.URL_REGEX = $r.MENTION_REGEX = void 0;
$r.MENTION_REGEX = /(^|\s|\()(@)([a-zA-Z0-9.-]+)(\b)/g;
$r.URL_REGEX = /(^|\s|\()((https?:\/\/[\S]+)|((?<domain>[a-z][a-z0-9]*(\.[a-z0-9]+)+)[\S]*))/gim;
$r.TRAILING_PUNCTUATION_REGEX = /\p{P}+$/gu;
$r.TAG_REGEX = // eslint-disable-next-line no-misleading-character-class
/(^|\s)[#]((?!\ufe0f)[^\s\u00AD\u2060\u200A\u200B\u200C\u200D\u20e2]*[^\d\s\p{P}\u00AD\u2060\u200A\u200B\u200C\u200D\u20e2]+[^\s\u00AD\u2060\u200A\u200B\u200C\u200D\u20e2]*)?/gu;
var SO = ne && ne.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty($u, "__esModule", { value: !0 });
$u.detectFacets = void 0;
const CO = SO(TO), nu = $r;
function LO(t) {
  let e;
  const r = [];
  {
    const i = nu.MENTION_REGEX;
    for (; e = i.exec(t.utf16); ) {
      if (!bf(e[3]) && !e[3].endsWith(".test"))
        continue;
      const a = t.utf16.indexOf(e[3], e.index) - 1;
      r.push({
        $type: "app.bsky.richtext.facet",
        index: {
          byteStart: t.utf16IndexToUtf8Index(a),
          byteEnd: t.utf16IndexToUtf8Index(a + e[3].length + 1)
        },
        features: [
          {
            $type: "app.bsky.richtext.facet#mention",
            did: e[3]
            // must be resolved afterwards
          }
        ]
      });
    }
  }
  {
    const i = nu.URL_REGEX;
    for (; e = i.exec(t.utf16); ) {
      let a = e[2];
      if (!a.startsWith("http")) {
        const m = e.groups?.domain;
        if (!m || !bf(m))
          continue;
        a = `https://${a}`;
      }
      const c = t.utf16.indexOf(e[2], e.index), h = { start: c, end: c + e[2].length };
      /[.,;:!?]$/.test(a) && (a = a.slice(0, -1), h.end--), /[)]$/.test(a) && !a.includes("(") && (a = a.slice(0, -1), h.end--), r.push({
        index: {
          byteStart: t.utf16IndexToUtf8Index(h.start),
          byteEnd: t.utf16IndexToUtf8Index(h.end)
        },
        features: [
          {
            $type: "app.bsky.richtext.facet#link",
            uri: a
          }
        ]
      });
    }
  }
  {
    const i = nu.TAG_REGEX;
    for (; e = i.exec(t.utf16); ) {
      const a = e[1];
      let c = e[2];
      if (!c || (c = c.trim().replace(nu.TRAILING_PUNCTUATION_REGEX, ""), c.length === 0 || c.length > 64))
        continue;
      const h = e.index + a.length;
      r.push({
        index: {
          byteStart: t.utf16IndexToUtf8Index(h),
          byteEnd: t.utf16IndexToUtf8Index(h + 1 + c.length)
        },
        features: [
          {
            $type: "app.bsky.richtext.facet#tag",
            tag: c
          }
        ]
      });
    }
  }
  return r.length > 0 ? r : void 0;
}
$u.detectFacets = LO;
function bf(t) {
  return !!CO.default.find((e) => {
    const r = t.lastIndexOf(e);
    return r === -1 ? !1 : t.charAt(r - 1) === "." && r === t.length - e.length;
  });
}
Object.defineProperty(Fs, "__esModule", { value: !0 });
Fs.RichText = Fs.RichTextSegment = void 0;
const In = x, hc = Hs, kO = jl, gf = $u;
class bs {
  constructor(e, r) {
    Object.defineProperty(this, "text", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "facet", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    });
  }
  get link() {
    const e = this.facet?.features.find(In.AppBskyRichtextFacet.isLink);
    if (In.AppBskyRichtextFacet.isLink(e))
      return e;
  }
  isLink() {
    return !!this.link;
  }
  get mention() {
    const e = this.facet?.features.find(In.AppBskyRichtextFacet.isMention);
    if (In.AppBskyRichtextFacet.isMention(e))
      return e;
  }
  isMention() {
    return !!this.mention;
  }
  get tag() {
    const e = this.facet?.features.find(In.AppBskyRichtextFacet.isTag);
    if (In.AppBskyRichtextFacet.isTag(e))
      return e;
  }
  isTag() {
    return !!this.tag;
  }
}
Fs.RichTextSegment = bs;
class id {
  constructor(e, r) {
    Object.defineProperty(this, "unicodeText", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "facets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.unicodeText = new hc.UnicodeString(e.text), this.facets = e.facets, !this.facets?.length && e.entities?.length && (this.facets = DO(this.unicodeText, e.entities)), this.facets && this.facets.sort(mc), r?.cleanNewlines && (0, kO.sanitizeRichText)(this, { cleanNewlines: !0 }).copyInto(this);
  }
  get text() {
    return this.unicodeText.toString();
  }
  get length() {
    return this.unicodeText.length;
  }
  get graphemeLength() {
    return this.unicodeText.graphemeLength;
  }
  clone() {
    return new id({
      text: this.unicodeText.utf16,
      facets: xf(this.facets)
    });
  }
  copyInto(e) {
    e.unicodeText = this.unicodeText, e.facets = xf(this.facets);
  }
  *segments() {
    const e = this.facets || [];
    if (!e.length) {
      yield new bs(this.unicodeText.utf16);
      return;
    }
    let r = 0, i = 0;
    do {
      const a = e[i];
      if (r < a.index.byteStart)
        yield new bs(this.unicodeText.slice(r, a.index.byteStart));
      else if (r > a.index.byteStart) {
        i++;
        continue;
      }
      if (a.index.byteStart < a.index.byteEnd) {
        const c = this.unicodeText.slice(a.index.byteStart, a.index.byteEnd);
        c.trim() ? yield new bs(c, a) : yield new bs(c);
      }
      r = a.index.byteEnd, i++;
    } while (i < e.length);
    r < this.unicodeText.length && (yield new bs(this.unicodeText.slice(r, this.unicodeText.length)));
  }
  insert(e, r) {
    if (this.unicodeText = new hc.UnicodeString(this.unicodeText.slice(0, e) + r + this.unicodeText.slice(e)), !this.facets?.length)
      return this;
    const i = r.length;
    for (const a of this.facets)
      e <= a.index.byteStart ? (a.index.byteStart += i, a.index.byteEnd += i) : e >= a.index.byteStart && e < a.index.byteEnd && (a.index.byteEnd += i);
    return this;
  }
  delete(e, r) {
    if (this.unicodeText = new hc.UnicodeString(this.unicodeText.slice(0, e) + this.unicodeText.slice(r)), !this.facets?.length)
      return this;
    const i = r - e;
    for (const a of this.facets)
      e <= a.index.byteStart && r >= a.index.byteEnd ? (a.index.byteStart = 0, a.index.byteEnd = 0) : e > a.index.byteEnd || (e > a.index.byteStart && e <= a.index.byteEnd && r > a.index.byteEnd ? a.index.byteEnd = e : e >= a.index.byteStart && r <= a.index.byteEnd ? a.index.byteEnd -= i : e < a.index.byteStart && r >= a.index.byteStart && r <= a.index.byteEnd ? (a.index.byteStart = e, a.index.byteEnd -= i) : r < a.index.byteStart && (a.index.byteStart -= i, a.index.byteEnd -= i));
    return this.facets = this.facets.filter((a) => a.index.byteStart < a.index.byteEnd), this;
  }
  /**
   * Detects facets such as links and mentions
   * Note: Overwrites the existing facets with auto-detected facets
   */
  async detectFacets(e) {
    if (this.facets = (0, gf.detectFacets)(this.unicodeText), this.facets) {
      for (const r of this.facets)
        for (const i of r.features)
          if (In.AppBskyRichtextFacet.isMention(i)) {
            const a = await e.resolveHandle({ handle: i.did }).catch((c) => {
            }).then((c) => c?.data.did);
            i.did = a || "";
          }
      this.facets.sort(mc);
    }
  }
  /**
   * Detects facets such as links and mentions but does not resolve them
   * Will produce invalid facets! For instance, mentions will not have their DIDs set.
   * Note: Overwrites the existing facets with auto-detected facets
   */
  detectFacetsWithoutResolution() {
    this.facets = (0, gf.detectFacets)(this.unicodeText), this.facets && this.facets.sort(mc);
  }
}
Fs.RichText = id;
const mc = (t, e) => t.index.byteStart - e.index.byteStart;
function DO(t, e) {
  const r = [];
  for (const i of e)
    i.type === "link" ? r.push({
      $type: "app.bsky.richtext.facet",
      index: {
        byteStart: t.utf16IndexToUtf8Index(i.index.start),
        byteEnd: t.utf16IndexToUtf8Index(i.index.end)
      },
      features: [{ $type: "app.bsky.richtext.facet#link", uri: i.value }]
    }) : i.type === "mention" && r.push({
      $type: "app.bsky.richtext.facet",
      index: {
        byteStart: t.utf16IndexToUtf8Index(i.index.start),
        byteEnd: t.utf16IndexToUtf8Index(i.index.end)
      },
      features: [
        { $type: "app.bsky.richtext.facet#mention", did: i.value }
      ]
    });
  return r;
}
function xf(t) {
  return typeof t > "u" ? t : JSON.parse(JSON.stringify(t));
}
var nd = {}, xi = {}, zr = {}, ur = {};
Object.defineProperty(ur, "__esModule", { value: !0 });
ur.NOOP_BEHAVIOR = ur.HIDE_BEHAVIOR = ur.MUTEWORD_BEHAVIOR = ur.MUTE_BEHAVIOR = ur.BLOCK_BEHAVIOR = ur.CUSTOM_LABEL_VALUE_RE = void 0;
ur.CUSTOM_LABEL_VALUE_RE = /^[a-z-]+$/;
ur.BLOCK_BEHAVIOR = {
  profileList: "blur",
  profileView: "alert",
  avatar: "blur",
  banner: "blur",
  contentList: "blur",
  contentView: "blur"
};
ur.MUTE_BEHAVIOR = {
  profileList: "inform",
  profileView: "alert",
  contentList: "blur",
  contentView: "inform"
};
ur.MUTEWORD_BEHAVIOR = {
  contentList: "blur",
  contentView: "blur"
};
ur.HIDE_BEHAVIOR = {
  contentList: "blur",
  contentView: "blur"
};
ur.NOOP_BEHAVIOR = {};
var Fl = {};
Object.defineProperty(Fl, "__esModule", { value: !0 });
Fl.ModerationUI = void 0;
class PO {
  constructor() {
    Object.defineProperty(this, "noOverride", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "filters", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "blurs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "alerts", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "informs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  get filter() {
    return this.filters.length !== 0;
  }
  get blur() {
    return this.blurs.length !== 0;
  }
  get alert() {
    return this.alerts.length !== 0;
  }
  get inform() {
    return this.informs.length !== 0;
  }
}
Fl.ModerationUI = PO;
var En = {};
Object.defineProperty(En, "__esModule", { value: !0 });
En.LABELS = En.DEFAULT_LABEL_SETTINGS = void 0;
En.DEFAULT_LABEL_SETTINGS = {
  porn: "hide",
  sexual: "warn",
  nudity: "ignore",
  "graphic-media": "warn"
};
En.LABELS = {
  "!hide": {
    identifier: "!hide",
    configurable: !1,
    defaultSetting: "hide",
    flags: ["no-override", "no-self"],
    severity: "alert",
    blurs: "content",
    behaviors: {
      account: {
        profileList: "blur",
        profileView: "blur",
        avatar: "blur",
        banner: "blur",
        displayName: "blur",
        contentList: "blur",
        contentView: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur",
        displayName: "blur"
      },
      content: {
        contentList: "blur",
        contentView: "blur"
      }
    },
    locales: []
  },
  "!warn": {
    identifier: "!warn",
    configurable: !1,
    defaultSetting: "warn",
    flags: ["no-self"],
    severity: "none",
    blurs: "content",
    behaviors: {
      account: {
        profileList: "blur",
        profileView: "blur",
        avatar: "blur",
        banner: "blur",
        contentList: "blur",
        contentView: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur",
        displayName: "blur"
      },
      content: {
        contentList: "blur",
        contentView: "blur"
      }
    },
    locales: []
  },
  "!no-unauthenticated": {
    identifier: "!no-unauthenticated",
    configurable: !1,
    defaultSetting: "hide",
    flags: ["no-override", "unauthed"],
    severity: "none",
    blurs: "content",
    behaviors: {
      account: {
        profileList: "blur",
        profileView: "blur",
        avatar: "blur",
        banner: "blur",
        displayName: "blur",
        contentList: "blur",
        contentView: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur",
        displayName: "blur"
      },
      content: {
        contentList: "blur",
        contentView: "blur"
      }
    },
    locales: []
  },
  porn: {
    identifier: "porn",
    configurable: !0,
    defaultSetting: "hide",
    flags: ["adult"],
    severity: "none",
    blurs: "media",
    behaviors: {
      account: {
        avatar: "blur",
        banner: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur"
      },
      content: {
        contentMedia: "blur"
      }
    },
    locales: []
  },
  sexual: {
    identifier: "sexual",
    configurable: !0,
    defaultSetting: "warn",
    flags: ["adult"],
    severity: "none",
    blurs: "media",
    behaviors: {
      account: {
        avatar: "blur",
        banner: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur"
      },
      content: {
        contentMedia: "blur"
      }
    },
    locales: []
  },
  nudity: {
    identifier: "nudity",
    configurable: !0,
    defaultSetting: "ignore",
    flags: [],
    severity: "none",
    blurs: "media",
    behaviors: {
      account: {
        avatar: "blur",
        banner: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur"
      },
      content: {
        contentMedia: "blur"
      }
    },
    locales: []
  },
  "graphic-media": {
    identifier: "graphic-media",
    flags: ["adult"],
    configurable: !0,
    defaultSetting: "warn",
    severity: "none",
    blurs: "media",
    behaviors: {
      account: {
        avatar: "blur",
        banner: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur"
      },
      content: {
        contentMedia: "blur"
      }
    },
    locales: []
  }
};
Object.defineProperty(zr, "__esModule", { value: !0 });
zr.ModerationDecision = void 0;
const mr = ur, BO = Fl, Ef = En;
var cn;
(function(t) {
  t[t.High = 0] = "High", t[t.Medium = 1] = "Medium", t[t.Low = 2] = "Low";
})(cn || (cn = {}));
class sd {
  constructor() {
    Object.defineProperty(this, "did", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "isMe", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "causes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  static merge(...e) {
    const r = e.filter((a) => !!a), i = new sd();
    return r[0] && (i.did = r[0].did, i.isMe = r[0].isMe), i.causes = r.flatMap((a) => a.causes), i;
  }
  downgrade() {
    for (const e of this.causes)
      e.downgraded = !0;
    return this;
  }
  get blocked() {
    return !!this.blockCause;
  }
  get muted() {
    return !!this.muteCause;
  }
  get blockCause() {
    return this.causes.find((e) => e.type === "blocking" || e.type === "blocked-by" || e.type === "block-other");
  }
  get muteCause() {
    return this.causes.find((e) => e.type === "muted");
  }
  get labelCauses() {
    return this.causes.filter((e) => e.type === "label");
  }
  ui(e) {
    const r = new BO.ModerationUI();
    for (const i of this.causes)
      if (i.type === "blocking" || i.type === "blocked-by" || i.type === "block-other") {
        if (this.isMe)
          continue;
        (e === "profileList" || e === "contentList") && r.filters.push(i), i.downgraded || (mr.BLOCK_BEHAVIOR[e] === "blur" ? (r.noOverride = !0, r.blurs.push(i)) : mr.BLOCK_BEHAVIOR[e] === "alert" ? r.alerts.push(i) : mr.BLOCK_BEHAVIOR[e] === "inform" && r.informs.push(i));
      } else if (i.type === "muted") {
        if (this.isMe)
          continue;
        (e === "profileList" || e === "contentList") && r.filters.push(i), i.downgraded || (mr.MUTE_BEHAVIOR[e] === "blur" ? r.blurs.push(i) : mr.MUTE_BEHAVIOR[e] === "alert" ? r.alerts.push(i) : mr.MUTE_BEHAVIOR[e] === "inform" && r.informs.push(i));
      } else if (i.type === "mute-word") {
        if (this.isMe)
          continue;
        e === "contentList" && r.filters.push(i), i.downgraded || (mr.MUTEWORD_BEHAVIOR[e] === "blur" ? r.blurs.push(i) : mr.MUTEWORD_BEHAVIOR[e] === "alert" ? r.alerts.push(i) : mr.MUTEWORD_BEHAVIOR[e] === "inform" && r.informs.push(i));
      } else i.type === "hidden" ? ((e === "profileList" || e === "contentList") && r.filters.push(i), i.downgraded || (mr.HIDE_BEHAVIOR[e] === "blur" ? r.blurs.push(i) : mr.HIDE_BEHAVIOR[e] === "alert" ? r.alerts.push(i) : mr.HIDE_BEHAVIOR[e] === "inform" && r.informs.push(i))) : i.type === "label" && (e === "profileList" && i.target === "account" ? i.setting === "hide" && !this.isMe && r.filters.push(i) : e === "contentList" && (i.target === "account" || i.target === "content") && i.setting === "hide" && !this.isMe && r.filters.push(i), i.downgraded || (i.behavior[e] === "blur" ? (r.blurs.push(i), i.noOverride && !this.isMe && (r.noOverride = !0)) : i.behavior[e] === "alert" ? r.alerts.push(i) : i.behavior[e] === "inform" && r.informs.push(i)));
    return r.filters.sort(vf), r.blurs.sort(vf), r;
  }
  setDid(e) {
    this.did = e;
  }
  setIsMe(e) {
    this.isMe = e;
  }
  addHidden(e) {
    e && this.causes.push({
      type: "hidden",
      source: { type: "user" },
      priority: 6
    });
  }
  addMutedWord(e) {
    e && this.causes.push({
      type: "mute-word",
      source: { type: "user" },
      priority: 6
    });
  }
  addBlocking(e) {
    e && this.causes.push({
      type: "blocking",
      source: { type: "user" },
      priority: 3
    });
  }
  addBlockingByList(e) {
    e && this.causes.push({
      type: "blocking",
      source: { type: "list", list: e },
      priority: 3
    });
  }
  addBlockedBy(e) {
    e && this.causes.push({
      type: "blocked-by",
      source: { type: "user" },
      priority: 4
    });
  }
  addBlockOther(e) {
    e && this.causes.push({
      type: "block-other",
      source: { type: "user" },
      priority: 4
    });
  }
  addLabel(e, r, i) {
    const a = mr.CUSTOM_LABEL_VALUE_RE.test(r.val) && i.labelDefs?.[r.src]?.find((v) => v.identifier === r.val) || Ef.LABELS[r.val];
    if (!a)
      return;
    const c = r.src === this.did, h = c ? void 0 : i.prefs.labelers.find((v) => v.did === r.src);
    if (!c && !h || c && a.flags.includes("no-self"))
      return;
    let m = a.defaultSetting || "ignore";
    if (a.configurable ? a.flags.includes("adult") && !i.prefs.adultContentEnabled ? m = "hide" : h?.labels[a.identifier] ? m = h?.labels[a.identifier] : i.prefs.labels[a.identifier] && (m = i.prefs.labels[a.identifier]) : m = a.defaultSetting || "hide", m === "ignore" || a.flags.includes("unauthed") && i.userDid)
      return;
    let p;
    const b = IO(a.behaviors[e]);
    a.flags.includes("no-override") || a.flags.includes("adult") && !i.prefs.adultContentEnabled ? p = 1 : m === "hide" ? p = 2 : b === cn.High ? p = 5 : b === cn.Medium ? p = 7 : p = 8;
    let d = !1;
    (a.flags.includes("no-override") || a.flags.includes("adult") && !i.prefs.adultContentEnabled) && (d = !0), this.causes.push({
      type: "label",
      source: c || !h ? { type: "user" } : { type: "labeler", did: h.did },
      label: r,
      labelDef: a,
      target: e,
      setting: m,
      behavior: a.behaviors[e] || mr.NOOP_BEHAVIOR,
      noOverride: d,
      priority: p
    });
  }
  addMuted(e) {
    e && this.causes.push({
      type: "muted",
      source: { type: "user" },
      priority: 6
    });
  }
  addMutedByList(e) {
    e && this.causes.push({
      type: "muted",
      source: { type: "list", list: e },
      priority: 6
    });
  }
}
zr.ModerationDecision = sd;
function IO(t) {
  return t ? t.profileView === "blur" || t.contentView === "blur" ? cn.High : t.contentList === "blur" || t.contentMedia === "blur" ? cn.Medium : cn.Low : cn.Low;
}
function vf(t, e) {
  return t.priority - e.priority;
}
Object.defineProperty(xi, "__esModule", { value: !0 });
xi.filterAccountLabels = xi.decideAccount = void 0;
const UO = zr;
function OO(t, e) {
  const r = new UO.ModerationDecision();
  r.setDid(t.did), r.setIsMe(t.did === e.userDid), t.viewer?.muted && (t.viewer?.mutedByList ? r.addMutedByList(t.viewer?.mutedByList) : r.addMuted(t.viewer?.muted)), t.viewer?.blocking && (t.viewer?.blockingByList ? r.addBlockingByList(t.viewer?.blockingByList) : r.addBlocking(t.viewer?.blocking)), r.addBlockedBy(t.viewer?.blockedBy);
  for (const i of jm(t.labels))
    r.addLabel("account", i, e);
  return r;
}
xi.decideAccount = OO;
function jm(t) {
  return t ? t.filter((e) => !e.uri.endsWith("/app.bsky.actor.profile/self") || e.val === "!no-unauthenticated") : [];
}
xi.filterAccountLabels = jm;
var Ei = {};
Object.defineProperty(Ei, "__esModule", { value: !0 });
Ei.filterProfileLabels = Ei.decideProfile = void 0;
const KO = zr;
function MO(t, e) {
  const r = new KO.ModerationDecision();
  r.setDid(t.did), r.setIsMe(t.did === e.userDid);
  for (const i of Fm(t.labels))
    r.addLabel("profile", i, e);
  return r;
}
Ei.decideProfile = MO;
function Fm(t) {
  return t ? t.filter((e) => e.uri.endsWith("/app.bsky.actor.profile/self")) : [];
}
Ei.filterProfileLabels = Fm;
var Gu = {};
Object.defineProperty(Gu, "__esModule", { value: !0 });
Gu.decideNotification = void 0;
const Rf = zr, NO = xi, VO = Ei;
function jO(t, e) {
  const r = new Rf.ModerationDecision();
  if (r.setDid(t.author.did), r.setIsMe(t.author.did === e.userDid), t.labels?.length)
    for (const i of t.labels)
      r.addLabel("content", i, e);
  return Rf.ModerationDecision.merge(r, (0, NO.decideAccount)(t.author, e), (0, VO.decideProfile)(t.author, e));
}
Gu.decideNotification = jO;
var qu = {}, $l = {};
Object.defineProperty($l, "__esModule", { value: !0 });
$l.hasMutedWord = void 0;
const FO = x, Af = {
  LEADING_TRAILING_PUNCTUATION: /(?:^\p{P}+|\p{P}+$)/gu,
  ESCAPE: /[[\]{}()*+?.\\^$|\s]/g,
  SEPARATORS: /[/\-()[\]_]+/g,
  WORD_BOUNDARY: /[\s\n\t\r\f\v]+?/g
}, $O = [
  "ja",
  // Japanese
  "zh",
  // Chinese
  "ko",
  // Korean
  "th",
  // Thai
  "vi"
  // Vietnamese
];
function GO({ mutedWords: t, text: e, facets: r, outlineTags: i, languages: a, actor: c }) {
  const h = $O.includes(a?.[0] || ""), m = [].concat(i || []).concat((r || []).flatMap((p) => p.features.filter(FO.AppBskyRichtextFacet.isTag).map((b) => b.tag))).map((p) => p.toLowerCase());
  for (const p of t) {
    const b = p.value.toLowerCase(), d = e.toLowerCase();
    if (p.expiresAt && p.expiresAt < (/* @__PURE__ */ new Date()).toISOString() || p.actorTarget === "exclude-following" && c?.viewer?.following)
      continue;
    if (m.includes(b))
      return !0;
    if (!p.targets.includes("content"))
      continue;
    if ((b.length === 1 || h) && d.includes(b))
      return !0;
    if (b.length > d.length)
      continue;
    if (b === d || /(?:\s|\p{P})+?/u.test(b) && d.includes(b))
      return !0;
    const v = d.split(Af.WORD_BOUNDARY);
    for (const P of v) {
      if (P === b)
        return !0;
      const M = P.replace(Af.LEADING_TRAILING_PUNCTUATION, "");
      if (b === M)
        return !0;
      if (!(b.length > M.length) && /\p{P}+/u.test(M)) {
        const K = M.replace(/\p{P}+/gu, " ");
        if (K === b || K.replace(/\s/gu, "") === b)
          return !0;
        const J = M.split(/\p{P}+/u);
        for (const z of J)
          if (z === b)
            return !0;
      }
    }
  }
  return !1;
}
$l.hasMutedWord = GO;
Object.defineProperty(qu, "__esModule", { value: !0 });
qu.decidePost = void 0;
const va = zr, ot = x, Qr = $l, $m = xi, Gm = Ei;
function qO(t, e) {
  const r = new va.ModerationDecision();
  if (r.setDid(t.author.did), r.setIsMe(t.author.did === e.userDid), t.labels?.length)
    for (const a of t.labels)
      r.addLabel("content", a, e);
  r.addHidden(zO(t, e.prefs.hiddenPosts)), r.isMe || r.addMutedWord(XO(t, e.prefs.mutedWords));
  let i;
  return t.embed && (ot.AppBskyEmbedRecord.isViewRecord(t.embed.record) ? i = _f(t.embed.record, e) : ot.AppBskyEmbedRecordWithMedia.isView(t.embed) && ot.AppBskyEmbedRecord.isViewRecord(t.embed.record.record) ? i = _f(t.embed.record.record, e) : ot.AppBskyEmbedRecord.isViewBlocked(t.embed.record) ? i = wf(t.embed.record, e) : ot.AppBskyEmbedRecordWithMedia.isView(t.embed) && ot.AppBskyEmbedRecord.isViewBlocked(t.embed.record.record) && (i = wf(t.embed.record.record, e))), va.ModerationDecision.merge(r, i?.downgrade(), (0, $m.decideAccount)(t.author, e), (0, Gm.decideProfile)(t.author, e));
}
qu.decidePost = qO;
function _f(t, e) {
  const r = new va.ModerationDecision();
  if (r.setDid(t.author.did), r.setIsMe(t.author.did === e.userDid), t.labels?.length)
    for (const i of t.labels)
      r.addLabel("content", i, e);
  return va.ModerationDecision.merge(r, (0, $m.decideAccount)(t.author, e), (0, Gm.decideProfile)(t.author, e));
}
function wf(t, e) {
  const r = new va.ModerationDecision();
  return r.setDid(t.author.did), r.setIsMe(t.author.did === e.userDid), t.author.viewer?.muted && (t.author.viewer?.mutedByList ? r.addMutedByList(t.author.viewer?.mutedByList) : r.addMuted(t.author.viewer?.muted)), t.author.viewer?.blocking && (t.author.viewer?.blockingByList ? r.addBlockingByList(t.author.viewer?.blockingByList) : r.addBlocking(t.author.viewer?.blocking)), r.addBlockedBy(t.author.viewer?.blockedBy), r;
}
function zO(t, e) {
  return e?.length ? !!(e.includes(t.uri) || t.embed && (ot.AppBskyEmbedRecord.isViewRecord(t.embed.record) && e.includes(t.embed.record.uri) || ot.AppBskyEmbedRecordWithMedia.isView(t.embed) && ot.AppBskyEmbedRecord.isViewRecord(t.embed.record.record) && e.includes(t.embed.record.record.uri))) : !1;
}
function XO(t, e) {
  if (!e?.length)
    return !1;
  const r = t.author;
  if (ot.AppBskyFeedPost.isRecord(t.record)) {
    if ((0, Qr.hasMutedWord)({
      mutedWords: e,
      text: t.record.text,
      facets: t.record.facets,
      outlineTags: t.record.tags,
      languages: t.record.langs,
      actor: r
    }))
      return !0;
    if (t.record.embed && ot.AppBskyEmbedImages.isMain(t.record.embed)) {
      for (const i of t.record.embed.images)
        if ((0, Qr.hasMutedWord)({
          mutedWords: e,
          text: i.alt,
          languages: t.record.langs,
          actor: r
        }))
          return !0;
    }
  }
  if (t.embed) {
    if (ot.AppBskyEmbedRecord.isViewRecord(t.embed.record)) {
      if (ot.AppBskyFeedPost.isRecord(t.embed.record.value)) {
        const i = t.embed.record.value, a = t.embed.record.author;
        if ((0, Qr.hasMutedWord)({
          mutedWords: e,
          text: i.text,
          facets: i.facets,
          outlineTags: i.tags,
          languages: i.langs,
          actor: a
        }))
          return !0;
        if (ot.AppBskyEmbedImages.isMain(i.embed)) {
          for (const c of i.embed.images)
            if ((0, Qr.hasMutedWord)({
              mutedWords: e,
              text: c.alt,
              languages: i.langs,
              actor: a
            }))
              return !0;
        }
        if (ot.AppBskyEmbedExternal.isMain(i.embed)) {
          const { external: c } = i.embed;
          if ((0, Qr.hasMutedWord)({
            mutedWords: e,
            text: c.title + " " + c.description,
            languages: [],
            actor: a
          }))
            return !0;
        }
        if (ot.AppBskyEmbedRecordWithMedia.isMain(i.embed)) {
          if (ot.AppBskyEmbedExternal.isMain(i.embed.media)) {
            const { external: c } = i.embed.media;
            if ((0, Qr.hasMutedWord)({
              mutedWords: e,
              text: c.title + " " + c.description,
              languages: [],
              actor: a
            }))
              return !0;
          }
          if (ot.AppBskyEmbedImages.isMain(i.embed.media)) {
            for (const c of i.embed.media.images)
              if ((0, Qr.hasMutedWord)({
                mutedWords: e,
                text: c.alt,
                languages: ot.AppBskyFeedPost.isRecord(i.record) ? i.langs : [],
                actor: a
              }))
                return !0;
          }
        }
      }
    } else if (ot.AppBskyEmbedExternal.isView(t.embed)) {
      const { external: i } = t.embed;
      if ((0, Qr.hasMutedWord)({
        mutedWords: e,
        text: i.title + " " + i.description,
        languages: [],
        actor: r
      }))
        return !0;
    } else if (ot.AppBskyEmbedRecordWithMedia.isView(t.embed) && ot.AppBskyEmbedRecord.isViewRecord(t.embed.record.record)) {
      const i = t.embed.record.record.author;
      if (ot.AppBskyFeedPost.isRecord(t.embed.record.record.value)) {
        const a = t.embed.record.record.value;
        if ((0, Qr.hasMutedWord)({
          mutedWords: e,
          text: a.text,
          facets: a.facets,
          outlineTags: a.tags,
          languages: a.langs,
          actor: i
        }))
          return !0;
      }
      if (ot.AppBskyEmbedImages.isView(t.embed.media)) {
        for (const a of t.embed.media.images)
          if ((0, Qr.hasMutedWord)({
            mutedWords: e,
            text: a.alt,
            languages: ot.AppBskyFeedPost.isRecord(t.record) ? t.record.langs : [],
            actor: i
          }))
            return !0;
      }
    }
  }
  return !1;
}
var zu = {};
Object.defineProperty(zu, "__esModule", { value: !0 });
zu.decideFeedGenerator = void 0;
const Tf = zr, HO = xi, ZO = Ei;
function WO(t, e) {
  const r = new Tf.ModerationDecision();
  if (r.setDid(t.creator.did), r.setIsMe(t.creator.did === e.userDid), t.labels?.length)
    for (const i of t.labels)
      r.addLabel("content", i, e);
  return Tf.ModerationDecision.merge(r, (0, HO.decideAccount)(t.creator, e), (0, ZO.decideProfile)(t.creator, e));
}
zu.decideFeedGenerator = WO;
var Xu = {};
Object.defineProperty(Xu, "__esModule", { value: !0 });
Xu.decideUserList = void 0;
const YO = as, Sf = zr, JO = xi, QO = Ei;
function eK(t, e) {
  const r = new Sf.ModerationDecision(), i = tK(t.creator) ? t.creator : void 0;
  if (i) {
    if (r.setDid(i.did), r.setIsMe(i.did === e.userDid), t.labels?.length)
      for (const c of t.labels)
        r.addLabel("content", c, e);
    return Sf.ModerationDecision.merge(r, (0, JO.decideAccount)(i, e), (0, QO.decideProfile)(i, e));
  }
  const a = new YO.AtUri(t.uri).hostname;
  if (r.setDid(a), r.setIsMe(a === e.userDid), t.labels?.length)
    for (const c of t.labels)
      r.addLabel("content", c, e);
  return r;
}
Xu.decideUserList = eK;
function tK(t) {
  return t && typeof t == "object" && "did" in t;
}
var ui = {};
Object.defineProperty(ui, "__esModule", { value: !0 });
ui.interpretLabelValueDefinitions = ui.interpretLabelValueDefinition = ui.isQuotedPostWithMedia = ui.isQuotedPost = void 0;
const ad = x;
function rK(t) {
  return !!(t && ad.AppBskyEmbedRecord.isView(t));
}
ui.isQuotedPost = rK;
function iK(t) {
  return !!(t && ad.AppBskyEmbedRecordWithMedia.isView(t));
}
ui.isQuotedPostWithMedia = iK;
function qm(t, e) {
  const r = {
    account: {},
    profile: {},
    content: {}
  }, i = t.severity === "alert" ? "alert" : t.severity === "inform" ? "inform" : void 0;
  t.blurs === "content" ? (r.account.profileList = i, r.account.profileView = i, r.account.contentList = "blur", r.account.contentView = t.adultOnly ? "blur" : i, r.profile.profileList = i, r.profile.profileView = i, r.content.contentList = "blur", r.content.contentView = t.adultOnly ? "blur" : i) : t.blurs === "media" ? (r.account.profileList = i, r.account.profileView = i, r.account.avatar = "blur", r.account.banner = "blur", r.profile.profileList = i, r.profile.profileView = i, r.profile.avatar = "blur", r.profile.banner = "blur", r.content.contentMedia = "blur") : t.blurs === "none" && (r.account.profileList = i, r.account.profileView = i, r.account.contentList = i, r.account.contentView = i, r.profile.profileList = i, r.profile.profileView = i, r.content.contentList = i, r.content.contentView = i);
  let a = "warn";
  (t.defaultSetting === "hide" || t.defaultSetting === "ignore") && (a = t.defaultSetting);
  const c = ["no-self"];
  return t.adultOnly && c.push("adult"), {
    ...t,
    definedBy: e,
    configurable: !0,
    defaultSetting: a,
    flags: c,
    behaviors: r
  };
}
ui.interpretLabelValueDefinition = qm;
function nK(t) {
  return (t.policies?.labelValueDefinitions || []).filter((e) => ad.ComAtprotoLabelDefs.validateLabelValueDefinition(e).success).map((e) => qm(e, t.creator.did));
}
ui.interpretLabelValueDefinitions = nK;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.moderateUserList = t.moderateFeedGenerator = t.moderateNotification = t.moderatePost = t.moderateProfile = t.interpretLabelValueDefinitions = t.interpretLabelValueDefinition = t.hasMutedWord = t.ModerationDecision = t.ModerationUI = void 0;
  const e = xi, r = Ei, i = Gu, a = qu, c = zu, h = Xu, m = zr;
  var p = Fl;
  Object.defineProperty(t, "ModerationUI", { enumerable: !0, get: function() {
    return p.ModerationUI;
  } });
  var b = zr;
  Object.defineProperty(t, "ModerationDecision", { enumerable: !0, get: function() {
    return b.ModerationDecision;
  } });
  var d = $l;
  Object.defineProperty(t, "hasMutedWord", { enumerable: !0, get: function() {
    return d.hasMutedWord;
  } });
  var v = ui;
  Object.defineProperty(t, "interpretLabelValueDefinition", { enumerable: !0, get: function() {
    return v.interpretLabelValueDefinition;
  } }), Object.defineProperty(t, "interpretLabelValueDefinitions", { enumerable: !0, get: function() {
    return v.interpretLabelValueDefinitions;
  } });
  function P(z, U) {
    return m.ModerationDecision.merge((0, e.decideAccount)(z, U), (0, r.decideProfile)(z, U));
  }
  t.moderateProfile = P;
  function M(z, U) {
    return (0, a.decidePost)(z, U);
  }
  t.moderatePost = M;
  function K(z, U) {
    return (0, i.decideNotification)(z, U);
  }
  t.moderateNotification = K;
  function W(z, U) {
    return (0, c.decideFeedGenerator)(z, U);
  }
  t.moderateFeedGenerator = W;
  function J(z, U) {
    return (0, h.decideUserList)(z, U);
  }
  t.moderateUserList = J;
})(nd);
var Hu = {};
Object.defineProperty(Hu, "__esModule", { value: !0 });
Hu.mock = void 0;
const ta = "bafyreiclp443lavogvhj3d2ob2cxbfuscni2k5jk7bebjzg7khl3esabwq";
Hu.mock = {
  post({ text: t, facets: e, reply: r, embed: i }) {
    return {
      $type: "app.bsky.feed.post",
      text: t,
      facets: e,
      reply: r,
      embed: i,
      langs: ["en"],
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  },
  postView({ record: t, author: e, embed: r, replyCount: i, repostCount: a, likeCount: c, viewer: h, labels: m }) {
    return {
      $type: "app.bsky.feed.defs#postView",
      uri: `at://${e.did}/app.bsky.feed.post/fake`,
      cid: ta,
      author: e,
      record: t,
      embed: r,
      replyCount: i,
      repostCount: a,
      likeCount: c,
      indexedAt: (/* @__PURE__ */ new Date()).toISOString(),
      viewer: h,
      labels: m
    };
  },
  embedRecordView({ record: t, author: e, labels: r }) {
    return {
      $type: "app.bsky.embed.record#view",
      record: {
        $type: "app.bsky.embed.record#viewRecord",
        uri: `at://${e.did}/app.bsky.feed.post/fake`,
        cid: ta,
        author: e,
        value: t,
        labels: r,
        indexedAt: (/* @__PURE__ */ new Date()).toISOString()
      }
    };
  },
  profileViewBasic({ handle: t, displayName: e, description: r, viewer: i, labels: a }) {
    return {
      did: `did:web:${t}`,
      handle: t,
      displayName: e,
      description: r,
      // technically not in ProfileViewBasic but useful in some cases
      viewer: i,
      labels: a
    };
  },
  actorViewerState({ muted: t, mutedByList: e, blockedBy: r, blocking: i, blockingByList: a, following: c, followedBy: h }) {
    return {
      muted: t,
      mutedByList: e,
      blockedBy: r,
      blocking: i,
      blockingByList: a,
      following: c,
      followedBy: h
    };
  },
  listViewBasic({ name: t }) {
    return {
      uri: "at://did:plc:fake/app.bsky.graph.list/fake",
      cid: ta,
      name: t,
      purpose: "app.bsky.graph.defs#modlist",
      indexedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  },
  replyNotification({ author: t, record: e, labels: r }) {
    return {
      uri: `at://${t.did}/app.bsky.feed.post/fake`,
      cid: ta,
      author: t,
      reason: "reply",
      reasonSubject: `at://${t.did}/app.bsky.feed.post/fake-parent`,
      record: e,
      isRead: !1,
      indexedAt: (/* @__PURE__ */ new Date()).toISOString(),
      labels: r
    };
  },
  followNotification({ author: t, subjectDid: e, labels: r }) {
    return {
      uri: `at://${t.did}/app.bsky.graph.follow/fake`,
      cid: ta,
      author: t,
      reason: "follow",
      record: {
        $type: "app.bsky.graph.follow",
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        subject: e
      },
      isRead: !1,
      indexedAt: (/* @__PURE__ */ new Date()).toISOString(),
      labels: r
    };
  },
  label({ val: t, uri: e, src: r }) {
    return {
      src: r || "did:plc:fake-labeler",
      uri: e,
      val: t,
      cts: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
};
var Zu = {}, od = {}, ei = ne && ne.__classPrivateFieldGet || function(t, e, r, i) {
  if (r === "a" && !i) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? i : r === "a" ? i.call(t) : i ? i.value : e.get(t);
}, yc = ne && ne.__classPrivateFieldSet || function(t, e, r, i, a) {
  if (i === "m") throw new TypeError("Private method is not writable");
  if (i === "a" && !a) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return i === "a" ? a.call(t, r) : a ? a.value = r : e.set(t, r), r;
}, Di, an;
Object.defineProperty(od, "__esModule", { value: !0 });
class sK {
  constructor() {
    Di.set(this, !1), an.set(this, /* @__PURE__ */ new Set());
  }
  /**
   * Whether the lock is currently acquired or not. Accessing this property does not affect the
   * status of the lock.
   */
  get acquired() {
    return ei(this, Di, "f");
  }
  /**
   * Acquires the lock, waiting if necessary for it to become free if it is already locked. The
   * returned promise is fulfilled once the lock is acquired.
   *
   * A timeout (in milliseconds) may be optionally provided. If the lock cannot be acquired before
   * the timeout elapses, the returned promise is rejected with an error. The behavior of invalid
   * timeout values depends on how `setTimeout` handles those values.
   *
   * After acquiring the lock, you **must** call `release` when you are done with it.
   */
  acquireAsync({ timeout: e } = {}) {
    if (!ei(this, Di, "f"))
      return yc(this, Di, !0, "f"), Promise.resolve();
    if (e == null)
      return new Promise((a) => {
        ei(this, an, "f").add(a);
      });
    let r, i;
    return Promise.race([
      new Promise((a) => {
        r = () => {
          clearTimeout(i), a();
        }, ei(this, an, "f").add(r);
      }),
      new Promise((a, c) => {
        i = setTimeout(() => {
          ei(this, an, "f").delete(r), c(new Error("Timed out waiting for lock"));
        }, e);
      })
    ]);
  }
  /**
   * Acquires the lock if it is free and otherwise returns immediately without waiting. Returns
   * `true` if the lock was free and is now acquired, and `false` otherwise.
   *
   * This method differs from calling `acquireAsync` with a zero-millisecond timeout in that it runs
   * synchronously without waiting for the JavaScript task queue.
   */
  tryAcquire() {
    return ei(this, Di, "f") ? !1 : (yc(this, Di, !0, "f"), !0);
  }
  /**
   * Releases the lock and gives it to the next waiting acquirer, if there is one. Each acquirer
   * must release the lock exactly once.
   */
  release() {
    if (!ei(this, Di, "f"))
      throw new Error("Cannot release an unacquired lock");
    if (ei(this, an, "f").size > 0) {
      const [e] = ei(this, an, "f");
      ei(this, an, "f").delete(e), e();
    } else
      yc(this, Di, !1, "f");
  }
}
od.default = sK;
Di = /* @__PURE__ */ new WeakMap(), an = /* @__PURE__ */ new WeakMap();
var aK = ne && ne.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(Zu, "__esModule", { value: !0 });
Zu.BskyAgent = void 0;
const ms = as, on = vi, oK = aK(od), lK = js, ae = x, uK = En, ln = Nr, cK = nd, Cf = {
  hideReplies: !1,
  hideRepliesByUnfollowed: !0,
  hideRepliesByLikeCount: 0,
  hideReposts: !1,
  hideQuotePosts: !1
}, dK = {
  sort: "oldest",
  prioritizeFollowedUsers: !0
};
class gs extends lK.AtpAgent {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_prefsLock", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new oK.default()
    }), Object.defineProperty(this, "getTimeline", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getTimeline(e, r)
    }), Object.defineProperty(this, "getAuthorFeed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getAuthorFeed(e, r)
    }), Object.defineProperty(this, "getActorLikes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getActorLikes(e, r)
    }), Object.defineProperty(this, "getPostThread", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getPostThread(e, r)
    }), Object.defineProperty(this, "getPost", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e) => this.api.app.bsky.feed.post.get(e)
    }), Object.defineProperty(this, "getPosts", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getPosts(e, r)
    }), Object.defineProperty(this, "getLikes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getLikes(e, r)
    }), Object.defineProperty(this, "getRepostedBy", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getRepostedBy(e, r)
    }), Object.defineProperty(this, "getFollows", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.graph.getFollows(e, r)
    }), Object.defineProperty(this, "getFollowers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.graph.getFollowers(e, r)
    }), Object.defineProperty(this, "getProfile", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.actor.getProfile(e, r)
    }), Object.defineProperty(this, "getProfiles", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.actor.getProfiles(e, r)
    }), Object.defineProperty(this, "getSuggestions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.actor.getSuggestions(e, r)
    }), Object.defineProperty(this, "searchActors", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.actor.searchActors(e, r)
    }), Object.defineProperty(this, "searchActorsTypeahead", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.actor.searchActorsTypeahead(e, r)
    }), Object.defineProperty(this, "listNotifications", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.notification.listNotifications(e, r)
    }), Object.defineProperty(this, "countUnreadNotifications", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.notification.getUnreadCount(e, r)
    }), Object.defineProperty(this, "getLabelers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.labeler.getServices(e, r)
    });
  }
  clone() {
    const e = new gs({
      service: this.service
    });
    return this.copyInto(e), e;
  }
  get app() {
    return this.api.app;
  }
  async getLabelDefinitions(e) {
    let r = gs.appLabelers;
    hK(e) ? r = r.concat(e.moderationPrefs.labelers.map((c) => c.did)) : zm(e) ? r = r.concat(e.labelers.map((c) => c.did)) : r = r.concat(e);
    const i = await this.getLabelers({
      dids: r,
      detailed: !0
    }), a = {};
    if (i.data)
      for (const c of i.data.views)
        a[c.creator.did] = (0, cK.interpretLabelValueDefinitions)(c);
    return a;
  }
  async post(e) {
    if (!this.session)
      throw new Error("Not logged in");
    return e.createdAt = e.createdAt || (/* @__PURE__ */ new Date()).toISOString(), this.api.app.bsky.feed.post.create({ repo: this.session.did }, e);
  }
  async deletePost(e) {
    if (!this.session)
      throw new Error("Not logged in");
    const r = new ms.AtUri(e);
    return await this.api.app.bsky.feed.post.delete({
      repo: r.hostname,
      rkey: r.rkey
    });
  }
  async like(e, r) {
    if (!this.session)
      throw new Error("Not logged in");
    return await this.api.app.bsky.feed.like.create({ repo: this.session.did }, {
      subject: { uri: e, cid: r },
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  async deleteLike(e) {
    if (!this.session)
      throw new Error("Not logged in");
    const r = new ms.AtUri(e);
    return await this.api.app.bsky.feed.like.delete({
      repo: r.hostname,
      rkey: r.rkey
    });
  }
  async repost(e, r) {
    if (!this.session)
      throw new Error("Not logged in");
    return await this.api.app.bsky.feed.repost.create({ repo: this.session.did }, {
      subject: { uri: e, cid: r },
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  async deleteRepost(e) {
    if (!this.session)
      throw new Error("Not logged in");
    const r = new ms.AtUri(e);
    return await this.api.app.bsky.feed.repost.delete({
      repo: r.hostname,
      rkey: r.rkey
    });
  }
  async follow(e) {
    if (!this.session)
      throw new Error("Not logged in");
    return await this.api.app.bsky.graph.follow.create({ repo: this.session.did }, {
      subject: e,
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  async deleteFollow(e) {
    if (!this.session)
      throw new Error("Not logged in");
    const r = new ms.AtUri(e);
    return await this.api.app.bsky.graph.follow.delete({
      repo: r.hostname,
      rkey: r.rkey
    });
  }
  async upsertProfile(e) {
    if (!this.session)
      throw new Error("Not logged in");
    let r = 5;
    for (; r >= 0; ) {
      const i = await this.com.atproto.repo.getRecord({
        repo: this.session.did,
        collection: "app.bsky.actor.profile",
        rkey: "self"
      }).catch((h) => {
      }), a = await e(i?.data.value);
      a && (a.$type = "app.bsky.actor.profile");
      const c = ae.AppBskyActorProfile.validateRecord(a);
      if (!c.success)
        throw c.error;
      try {
        await this.com.atproto.repo.putRecord({
          repo: this.session.did,
          collection: "app.bsky.actor.profile",
          rkey: "self",
          record: a,
          swapRecord: i?.data.cid || null
        });
      } catch (h) {
        if (r > 0 && h instanceof ae.ComAtprotoRepoPutRecord.InvalidSwapError) {
          r--;
          continue;
        } else
          throw h;
      }
      break;
    }
  }
  async mute(e) {
    return this.api.app.bsky.graph.muteActor({ actor: e });
  }
  async unmute(e) {
    return this.api.app.bsky.graph.unmuteActor({ actor: e });
  }
  async muteModList(e) {
    return this.api.app.bsky.graph.muteActorList({
      list: e
    });
  }
  async unmuteModList(e) {
    return this.api.app.bsky.graph.unmuteActorList({
      list: e
    });
  }
  async blockModList(e) {
    if (!this.session)
      throw new Error("Not logged in");
    return await this.api.app.bsky.graph.listblock.create({ repo: this.session.did }, {
      subject: e,
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  async unblockModList(e) {
    if (!this.session)
      throw new Error("Not logged in");
    const r = await this.api.app.bsky.graph.getList({
      list: e,
      limit: 1
    });
    if (!r.data.list.viewer?.blocked)
      return;
    const { rkey: i } = new ms.AtUri(r.data.list.viewer.blocked);
    return await this.api.app.bsky.graph.listblock.delete({
      repo: this.session.did,
      rkey: i
    });
  }
  async updateSeenNotifications(e) {
    return e = e || (/* @__PURE__ */ new Date()).toISOString(), this.api.app.bsky.notification.updateSeen({
      seenAt: e
    });
  }
  async getPreferences() {
    const e = {
      feeds: {
        saved: void 0,
        pinned: void 0
      },
      // @ts-ignore populating below
      savedFeeds: void 0,
      feedViewPrefs: {
        home: {
          ...Cf
        }
      },
      threadViewPrefs: { ...dK },
      moderationPrefs: {
        adultContentEnabled: !1,
        labels: { ...uK.DEFAULT_LABEL_SETTINGS },
        labelers: gs.appLabelers.map((a) => ({ did: a, labels: {} })),
        mutedWords: [],
        hiddenPosts: []
      },
      birthDate: void 0,
      interests: {
        tags: []
      },
      bskyAppState: {
        queuedNudges: [],
        activeProgressGuide: void 0
      }
    }, r = await this.app.bsky.actor.getPreferences({}), i = [];
    for (const a of r.data.preferences)
      if (ae.AppBskyActorDefs.isAdultContentPref(a) && ae.AppBskyActorDefs.validateAdultContentPref(a).success)
        e.moderationPrefs.adultContentEnabled = a.enabled;
      else if (ae.AppBskyActorDefs.isContentLabelPref(a) && ae.AppBskyActorDefs.validateContentLabelPref(a).success) {
        const c = fK(a);
        i.push(c);
      } else if (ae.AppBskyActorDefs.isLabelersPref(a) && ae.AppBskyActorDefs.validateLabelersPref(a).success)
        e.moderationPrefs.labelers = gs.appLabelers.map((c) => ({ did: c, labels: {} })).concat(a.labelers.map((c) => ({
          ...c,
          labels: {}
        })));
      else if (ae.AppBskyActorDefs.isSavedFeedsPrefV2(a) && ae.AppBskyActorDefs.validateSavedFeedsPrefV2(a).success)
        e.savedFeeds = a.items;
      else if (ae.AppBskyActorDefs.isSavedFeedsPref(a) && ae.AppBskyActorDefs.validateSavedFeedsPref(a).success)
        e.feeds.saved = a.saved, e.feeds.pinned = a.pinned;
      else if (ae.AppBskyActorDefs.isPersonalDetailsPref(a) && ae.AppBskyActorDefs.validatePersonalDetailsPref(a).success)
        a.birthDate && (e.birthDate = new Date(a.birthDate));
      else if (ae.AppBskyActorDefs.isFeedViewPref(a) && ae.AppBskyActorDefs.validateFeedViewPref(a).success) {
        const { $type: c, feed: h, ...m } = a;
        e.feedViewPrefs[a.feed] = { ...Cf, ...m };
      } else if (ae.AppBskyActorDefs.isThreadViewPref(a) && ae.AppBskyActorDefs.validateThreadViewPref(a).success) {
        const { $type: c, ...h } = a;
        e.threadViewPrefs = { ...e.threadViewPrefs, ...h };
      } else if (ae.AppBskyActorDefs.isInterestsPref(a) && ae.AppBskyActorDefs.validateInterestsPref(a).success) {
        const { $type: c, ...h } = a;
        e.interests = { ...e.interests, ...h };
      } else if (ae.AppBskyActorDefs.isMutedWordsPref(a) && ae.AppBskyActorDefs.validateMutedWordsPref(a).success) {
        const { $type: c, ...h } = a;
        e.moderationPrefs.mutedWords = h.items, e.moderationPrefs.mutedWords.length && (e.moderationPrefs.mutedWords = e.moderationPrefs.mutedWords.map((m) => (m.actorTarget = m.actorTarget || "all", m)));
      } else if (ae.AppBskyActorDefs.isHiddenPostsPref(a) && ae.AppBskyActorDefs.validateHiddenPostsPref(a).success) {
        const { $type: c, ...h } = a;
        e.moderationPrefs.hiddenPosts = h.items;
      } else if (ae.AppBskyActorDefs.isBskyAppStatePref(a) && ae.AppBskyActorDefs.validateBskyAppStatePref(a).success) {
        const { $type: c, ...h } = a;
        e.bskyAppState.queuedNudges = h.queuedNudges || [], e.bskyAppState.activeProgressGuide = h.activeProgressGuide;
      }
    if (e.savedFeeds === void 0) {
      const { saved: a, pinned: c } = e.feeds;
      if (a && c) {
        const h = /* @__PURE__ */ new Map();
        h.set("timeline", {
          id: on.TID.nextStr(),
          type: "timeline",
          value: "following",
          pinned: !0
        });
        for (const m of c) {
          const p = (0, ln.getSavedFeedType)(m);
          p !== "unknown" && h.set(m, {
            id: on.TID.nextStr(),
            type: p,
            value: m,
            pinned: !0
          });
        }
        for (const m of a)
          if (!h.has(m)) {
            const p = (0, ln.getSavedFeedType)(m);
            if (p === "unknown")
              continue;
            h.set(m, {
              id: on.TID.nextStr(),
              type: p,
              value: m,
              pinned: !1
            });
          }
        e.savedFeeds = Array.from(h.values());
      } else
        e.savedFeeds = [
          {
            id: on.TID.nextStr(),
            type: "timeline",
            value: "following",
            pinned: !0
          }
        ];
      await this.overwriteSavedFeeds(e.savedFeeds);
    }
    for (const a of i)
      if (a.labelerDid) {
        const c = e.moderationPrefs.labelers.find((h) => h.did === a.labelerDid);
        if (!c)
          continue;
        c.labels[a.label] = a.visibility;
      } else
        e.moderationPrefs.labels[a.label] = a.visibility;
    return e.moderationPrefs.labels = pK(e.moderationPrefs.labels), this.configureLabelersHeader(bc(r.data.preferences)), e;
  }
  async overwriteSavedFeeds(e) {
    e.forEach(ln.validateSavedFeed);
    const r = /* @__PURE__ */ new Map();
    return e.forEach((i) => {
      r.has(i.id) && r.delete(i.id), r.set(i.id, i);
    }), su(this, () => Array.from(r.values()));
  }
  async updateSavedFeeds(e) {
    return e.map(ln.validateSavedFeed), su(this, (r) => r.map((i) => {
      const a = e.find((c) => i.id === c.id);
      return a ? {
        ...i,
        // only update pinned
        pinned: a.pinned
      } : i;
    }));
  }
  async addSavedFeeds(e) {
    const r = e.map((i) => ({
      ...i,
      id: on.TID.nextStr()
    }));
    return r.forEach(ln.validateSavedFeed), su(this, (i) => [
      ...i,
      ...r
    ]);
  }
  async removeSavedFeeds(e) {
    return su(this, (r) => [
      ...r.filter((i) => !e.find((a) => i.id === a))
    ]);
  }
  /**
   * @deprecated use `overwriteSavedFeeds`
   */
  async setSavedFeeds(e, r) {
    return ra(this, () => ({
      saved: e,
      pinned: r
    }));
  }
  /**
   * @deprecated use `addSavedFeeds`
   */
  async addSavedFeed(e) {
    return ra(this, (r, i) => ({
      saved: [...r.filter((a) => a !== e), e],
      pinned: i
    }));
  }
  /**
   * @deprecated use `removeSavedFeeds`
   */
  async removeSavedFeed(e) {
    return ra(this, (r, i) => ({
      saved: r.filter((a) => a !== e),
      pinned: i.filter((a) => a !== e)
    }));
  }
  /**
   * @deprecated use `addSavedFeeds` or `updateSavedFeeds`
   */
  async addPinnedFeed(e) {
    return ra(this, (r, i) => ({
      saved: [...r.filter((a) => a !== e), e],
      pinned: [...i.filter((a) => a !== e), e]
    }));
  }
  /**
   * @deprecated use `updateSavedFeeds` or `removeSavedFeeds`
   */
  async removePinnedFeed(e) {
    return ra(this, (r, i) => ({
      saved: r,
      pinned: i.filter((a) => a !== e)
    }));
  }
  async setAdultContentEnabled(e) {
    await Gt(this, (r) => {
      let i = r.findLast((a) => ae.AppBskyActorDefs.isAdultContentPref(a) && ae.AppBskyActorDefs.validateAdultContentPref(a).success);
      return i ? i.enabled = e : i = {
        $type: "app.bsky.actor.defs#adultContentPref",
        enabled: e
      }, r.filter((a) => !ae.AppBskyActorDefs.isAdultContentPref(a)).concat([i]);
    });
  }
  async setContentLabelPref(e, r, i) {
    i && (0, ms.ensureValidDid)(i), await Gt(this, (a) => {
      let c = a.findLast((m) => ae.AppBskyActorDefs.isContentLabelPref(m) && ae.AppBskyActorDefs.validateContentLabelPref(m).success && m.label === e && m.labelerDid === i), h;
      if (c ? c.visibility = r : c = {
        $type: "app.bsky.actor.defs#contentLabelPref",
        label: e,
        labelerDid: i,
        visibility: r
      }, ae.AppBskyActorDefs.isContentLabelPref(c) && !c.labelerDid) {
        const m = {
          "graphic-media": "gore",
          porn: "nsfw",
          sexual: "suggestive"
        }[c.label];
        m && (h = a.findLast((p) => ae.AppBskyActorDefs.isContentLabelPref(p) && ae.AppBskyActorDefs.validateContentLabelPref(p).success && p.label === m && p.labelerDid === void 0), h ? h.visibility = r : h = {
          $type: "app.bsky.actor.defs#contentLabelPref",
          label: m,
          labelerDid: void 0,
          visibility: r
        });
      }
      return a.filter((m) => !ae.AppBskyActorDefs.isContentLabelPref(m) || !(m.label === e && m.labelerDid === i)).concat([c]).filter((m) => h ? !ae.AppBskyActorDefs.isContentLabelPref(m) || !(m.label === h.label && m.labelerDid === void 0) : !0).concat(h ? [h] : []);
    });
  }
  async addLabeler(e) {
    const r = await Gt(this, (i) => {
      let a = i.findLast((c) => ae.AppBskyActorDefs.isLabelersPref(c) && ae.AppBskyActorDefs.validateLabelersPref(c).success);
      if (a || (a = {
        $type: "app.bsky.actor.defs#labelersPref",
        labelers: []
      }), ae.AppBskyActorDefs.isLabelersPref(a)) {
        let c = a.labelers.find((h) => h.did === e);
        c || (c = {
          did: e
        }, a.labelers.push(c));
      }
      return i.filter((c) => !ae.AppBskyActorDefs.isLabelersPref(c)).concat([a]);
    });
    this.configureLabelersHeader(bc(r));
  }
  async removeLabeler(e) {
    const r = await Gt(this, (i) => {
      let a = i.findLast((c) => ae.AppBskyActorDefs.isLabelersPref(c) && ae.AppBskyActorDefs.validateLabelersPref(c).success);
      return a || (a = {
        $type: "app.bsky.actor.defs#labelersPref",
        labelers: []
      }), ae.AppBskyActorDefs.isLabelersPref(a) && (a.labelers = a.labelers.filter((c) => c.did !== e)), i.filter((c) => !ae.AppBskyActorDefs.isLabelersPref(c)).concat([a]);
    });
    this.configureLabelersHeader(bc(r));
  }
  async setPersonalDetails({ birthDate: e }) {
    e = e instanceof Date ? e.toISOString() : e, await Gt(this, (r) => {
      let i = r.findLast((a) => ae.AppBskyActorDefs.isPersonalDetailsPref(a) && ae.AppBskyActorDefs.validatePersonalDetailsPref(a).success);
      return i ? i.birthDate = e : i = {
        $type: "app.bsky.actor.defs#personalDetailsPref",
        birthDate: e
      }, r.filter((a) => !ae.AppBskyActorDefs.isPersonalDetailsPref(a)).concat([i]);
    });
  }
  async setFeedViewPrefs(e, r) {
    await Gt(this, (i) => {
      const a = i.findLast((c) => ae.AppBskyActorDefs.isFeedViewPref(c) && ae.AppBskyActorDefs.validateFeedViewPref(c).success && c.feed === e);
      return a && (r = { ...a, ...r }), i.filter((c) => !ae.AppBskyActorDefs.isFeedViewPref(r) || c.feed !== e).concat([{ ...r, $type: "app.bsky.actor.defs#feedViewPref", feed: e }]);
    });
  }
  async setThreadViewPrefs(e) {
    await Gt(this, (r) => {
      const i = r.findLast((a) => ae.AppBskyActorDefs.isThreadViewPref(a) && ae.AppBskyActorDefs.validateThreadViewPref(a).success);
      return i && (e = { ...i, ...e }), r.filter((a) => !ae.AppBskyActorDefs.isThreadViewPref(a)).concat([{ ...e, $type: "app.bsky.actor.defs#threadViewPref" }]);
    });
  }
  async setInterestsPref(e) {
    await Gt(this, (r) => {
      const i = r.findLast((a) => ae.AppBskyActorDefs.isInterestsPref(a) && ae.AppBskyActorDefs.validateInterestsPref(a).success);
      return i && (e = { ...i, ...e }), r.filter((a) => !ae.AppBskyActorDefs.isInterestsPref(a)).concat([{ ...e, $type: "app.bsky.actor.defs#interestsPref" }]);
    });
  }
  /**
   * Add a muted word to user preferences.
   */
  async addMutedWord(e) {
    const r = (0, ln.sanitizeMutedWordValue)(e.value);
    r && await Gt(this, (i) => {
      let a = i.findLast((h) => ae.AppBskyActorDefs.isMutedWordsPref(h) && ae.AppBskyActorDefs.validateMutedWordsPref(h).success);
      const c = {
        id: on.TID.nextStr(),
        value: r,
        targets: e.targets || [],
        actorTarget: e.actorTarget || "all",
        expiresAt: e.expiresAt || void 0
      };
      return a && ae.AppBskyActorDefs.isMutedWordsPref(a) ? (a.items.push(c), a.items = gc(a.items)) : a = {
        items: [c]
      }, i.filter((h) => !ae.AppBskyActorDefs.isMutedWordsPref(h)).concat([
        { ...a, $type: "app.bsky.actor.defs#mutedWordsPref" }
      ]);
    });
  }
  /**
   * Convenience method to add muted words to user preferences
   */
  async addMutedWords(e) {
    await Promise.all(e.map((r) => this.addMutedWord(r)));
  }
  /**
   * @deprecated use `addMutedWords` or `addMutedWord` instead
   */
  async upsertMutedWords(e) {
    await this.addMutedWords(e);
  }
  /**
   * Update a muted word in user preferences.
   */
  async updateMutedWord(e) {
    await Gt(this, (r) => {
      const i = r.findLast((a) => ae.AppBskyActorDefs.isMutedWordsPref(a) && ae.AppBskyActorDefs.validateMutedWordsPref(a).success);
      return i && ae.AppBskyActorDefs.isMutedWordsPref(i) ? (i.items = i.items.map((a) => {
        if (kf(a, e)) {
          const h = {
            ...a,
            ...e
          };
          return {
            id: a.id || on.TID.nextStr(),
            value: (0, ln.sanitizeMutedWordValue)(h.value) || a.value,
            targets: h.targets || [],
            actorTarget: h.actorTarget || "all",
            expiresAt: h.expiresAt || void 0
          };
        } else
          return a;
      }), i.items = gc(i.items), r.filter((a) => !ae.AppBskyActorDefs.isMutedWordsPref(a)).concat([
        { ...i, $type: "app.bsky.actor.defs#mutedWordsPref" }
      ])) : r;
    });
  }
  /**
   * Remove a muted word from user preferences.
   */
  async removeMutedWord(e) {
    await Gt(this, (r) => {
      const i = r.findLast((a) => ae.AppBskyActorDefs.isMutedWordsPref(a) && ae.AppBskyActorDefs.validateMutedWordsPref(a).success);
      if (i && ae.AppBskyActorDefs.isMutedWordsPref(i)) {
        for (let a = 0; a < i.items.length; a++)
          if (kf(i.items[a], e)) {
            i.items.splice(a, 1);
            break;
          }
        return i.items = gc(i.items), r.filter((a) => !ae.AppBskyActorDefs.isMutedWordsPref(a)).concat([
          { ...i, $type: "app.bsky.actor.defs#mutedWordsPref" }
        ]);
      }
      return r;
    });
  }
  /**
   * Convenience method to remove muted words from user preferences
   */
  async removeMutedWords(e) {
    await Promise.all(e.map((r) => this.removeMutedWord(r)));
  }
  async hidePost(e) {
    await Lf(this, e, "hide");
  }
  async unhidePost(e) {
    await Lf(this, e, "unhide");
  }
  async bskyAppQueueNudges(e) {
    await Gt(this, (r) => {
      let i = r.findLast((a) => ae.AppBskyActorDefs.isBskyAppStatePref(a) && ae.AppBskyActorDefs.validateBskyAppStatePref(a).success);
      return i = i || {}, e = Array.isArray(e) ? e : [e], i.queuedNudges = (i.queuedNudges || []).concat(e), r.filter((a) => !ae.AppBskyActorDefs.isBskyAppStatePref(a)).concat([
        {
          ...i,
          $type: "app.bsky.actor.defs#bskyAppStatePref"
        }
      ]);
    });
  }
  async bskyAppDismissNudges(e) {
    await Gt(this, (r) => {
      let i = r.findLast((a) => ae.AppBskyActorDefs.isBskyAppStatePref(a) && ae.AppBskyActorDefs.validateBskyAppStatePref(a).success);
      return i = i || {}, e = Array.isArray(e) ? e : [e], i.queuedNudges = (i.queuedNudges || []).filter((a) => !e.includes(a)), r.filter((a) => !ae.AppBskyActorDefs.isBskyAppStatePref(a)).concat([
        {
          ...i,
          $type: "app.bsky.actor.defs#bskyAppStatePref"
        }
      ]);
    });
  }
  async bskyAppSetActiveProgressGuide(e) {
    if (e && !ae.AppBskyActorDefs.validateBskyAppProgressGuide(e).success)
      throw new Error("Invalid progress guide");
    await Gt(this, (r) => {
      let i = r.findLast((a) => ae.AppBskyActorDefs.isBskyAppStatePref(a) && ae.AppBskyActorDefs.validateBskyAppStatePref(a).success);
      return i = i || {}, i.activeProgressGuide = e, r.filter((a) => !ae.AppBskyActorDefs.isBskyAppStatePref(a)).concat([
        {
          ...i,
          $type: "app.bsky.actor.defs#bskyAppStatePref"
        }
      ]);
    });
  }
}
Zu.BskyAgent = gs;
async function Gt(t, e) {
  try {
    await t._prefsLock.acquireAsync();
    const r = await t.app.bsky.actor.getPreferences({}), i = e(r.data.preferences);
    return i === !1 ? r.data.preferences : (await t.app.bsky.actor.putPreferences({
      preferences: i
    }), i);
  } finally {
    t._prefsLock.release();
  }
}
async function ra(t, e) {
  let r;
  return await Gt(t, (i) => {
    let a = i.findLast((c) => ae.AppBskyActorDefs.isSavedFeedsPref(c) && ae.AppBskyActorDefs.validateSavedFeedsPref(c).success);
    return a ? (r = e(a.saved, a.pinned), a.saved = r.saved, a.pinned = r.pinned) : (r = e([], []), a = {
      $type: "app.bsky.actor.defs#savedFeedsPref",
      saved: r.saved,
      pinned: r.pinned
    }), i.filter((c) => !ae.AppBskyActorDefs.isSavedFeedsPref(c)).concat([a]);
  }), r;
}
async function su(t, e) {
  let r = [];
  return await Gt(t, (i) => {
    let a = i.findLast((b) => ae.AppBskyActorDefs.isSavedFeedsPrefV2(b) && ae.AppBskyActorDefs.validateSavedFeedsPrefV2(b).success), c = i.findLast((b) => ae.AppBskyActorDefs.isSavedFeedsPref(b) && ae.AppBskyActorDefs.validateSavedFeedsPref(b).success);
    a ? (r = e(a.items), a = {
      ...a,
      items: r
    }) : (r = e([]), a = {
      $type: "app.bsky.actor.defs#savedFeedsPrefV2",
      items: r
    });
    const h = a.items.filter((b) => b.pinned), m = a.items.filter((b) => !b.pinned);
    a.items = h.concat(m);
    let p = i.filter((b) => !ae.AppBskyActorDefs.isSavedFeedsPrefV2(b)).concat(a);
    if (c) {
      const { saved: b, pinned: d } = c, v = (0, ln.savedFeedsToUriArrays)(
        // v1 only supports feeds and lists
        a.items.filter((P) => ["feed", "list"].includes(P.type))
      );
      c = {
        ...c,
        saved: Array.from(/* @__PURE__ */ new Set([...b, ...v.saved])),
        pinned: Array.from(/* @__PURE__ */ new Set([...d, ...v.pinned]))
      }, p = p.filter((P) => !ae.AppBskyActorDefs.isSavedFeedsPref(P)).concat(c);
    }
    return p;
  }), r;
}
function fK(t) {
  let e = t.visibility;
  return e === "show" && (e = "ignore"), { ...t, visibility: e };
}
function pK(t) {
  const e = { ...t }, r = {
    gore: "graphic-media",
    nsfw: "porn",
    suggestive: "sexual"
  };
  for (const i in e) {
    const a = r[i];
    a && (e[a] = e[i]);
  }
  return e;
}
function bc(t) {
  const e = t.findLast((i) => ae.AppBskyActorDefs.isLabelersPref(i) && ae.AppBskyActorDefs.validateLabelersPref(i).success);
  let r = [];
  return e && (r = e.labelers.map((i) => i.did)), r;
}
async function Lf(t, e, r) {
  await Gt(t, (i) => {
    let a = i.findLast((c) => ae.AppBskyActorDefs.isHiddenPostsPref(c) && ae.AppBskyActorDefs.validateHiddenPostsPref(c).success);
    return a && ae.AppBskyActorDefs.isHiddenPostsPref(a) ? a.items = r === "hide" ? Array.from(/* @__PURE__ */ new Set([...a.items, e])) : a.items.filter((c) => c !== e) : r === "hide" && (a = {
      $type: "app.bsky.actor.defs#hiddenPostsPref",
      items: [e]
    }), i.filter((c) => !ae.AppBskyActorDefs.isInterestsPref(c)).concat([{ ...a, $type: "app.bsky.actor.defs#hiddenPostsPref" }]);
  });
}
function hK(t) {
  return t && typeof t == "object" && "moderationPrefs" in t && zm(t.moderationPrefs);
}
function zm(t) {
  return t && typeof t == "object" && "labelers" in t;
}
function gc(t) {
  return t.map((e) => ({
    ...e,
    id: e.id || on.TID.nextStr()
  }));
}
function kf(t, e) {
  const r = t.id, i = r && r === e.id, a = !r && t.value === e.value;
  return i || a;
}
(function(t) {
  var e = ne && ne.__createBinding || (Object.create ? function(b, d, v, P) {
    P === void 0 && (P = v);
    var M = Object.getOwnPropertyDescriptor(d, v);
    (!M || ("get" in M ? !d.__esModule : M.writable || M.configurable)) && (M = { enumerable: !0, get: function() {
      return d[v];
    } }), Object.defineProperty(b, P, M);
  } : function(b, d, v, P) {
    P === void 0 && (P = v), b[P] = d[v];
  }), r = ne && ne.__exportStar || function(b, d) {
    for (var v in b) v !== "default" && !Object.prototype.hasOwnProperty.call(d, v) && e(d, b, v);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.default = t.BskyAgent = t.DEFAULT_LABEL_SETTINGS = t.LABELS = t.parseLanguage = t.jsonStringToLex = t.jsonToLex = t.stringifyLex = t.lexToJson = t.BlobRef = t.AtUri = void 0;
  var i = as;
  Object.defineProperty(t, "AtUri", { enumerable: !0, get: function() {
    return i.AtUri;
  } });
  var a = wa;
  Object.defineProperty(t, "BlobRef", { enumerable: !0, get: function() {
    return a.BlobRef;
  } }), Object.defineProperty(t, "lexToJson", { enumerable: !0, get: function() {
    return a.lexToJson;
  } }), Object.defineProperty(t, "stringifyLex", { enumerable: !0, get: function() {
    return a.stringifyLex;
  } }), Object.defineProperty(t, "jsonToLex", { enumerable: !0, get: function() {
    return a.jsonToLex;
  } }), Object.defineProperty(t, "jsonStringToLex", { enumerable: !0, get: function() {
    return a.jsonStringToLex;
  } });
  var c = vi;
  Object.defineProperty(t, "parseLanguage", { enumerable: !0, get: function() {
    return c.parseLanguage;
  } }), r(Fp, t), r(ka, t), r(Nr, t), r(x, t), r(js, t), r(Fs, t), r(jl, t), r(Hs, t), r($r, t), r(nd, t), r(ur, t), r(Hu, t);
  var h = En;
  Object.defineProperty(t, "LABELS", { enumerable: !0, get: function() {
    return h.LABELS;
  } }), Object.defineProperty(t, "DEFAULT_LABEL_SETTINGS", { enumerable: !0, get: function() {
    return h.DEFAULT_LABEL_SETTINGS;
  } });
  var m = Zu;
  Object.defineProperty(t, "BskyAgent", { enumerable: !0, get: function() {
    return m.BskyAgent;
  } });
  var p = js;
  Object.defineProperty(t, "default", { enumerable: !0, get: function() {
    return p.AtpAgent;
  } });
})(Bc);
const xc = new Bc.BskyAgent({
  service: "https://api.bsky.app"
});
var Xm = { exports: {} };
(function(t, e) {
  (function(i, a) {
    t.exports = a();
  })(ne, function() {
    return (
      /******/
      function(r) {
        var i = {};
        function a(c) {
          if (i[c])
            return i[c].exports;
          var h = i[c] = {
            /******/
            i: c,
            /******/
            l: !1,
            /******/
            exports: {}
            /******/
          };
          return r[c].call(h.exports, h, h.exports, a), h.l = !0, h.exports;
        }
        return a.m = r, a.c = i, a.d = function(c, h, m) {
          a.o(c, h) || Object.defineProperty(c, h, {
            /******/
            configurable: !1,
            /******/
            enumerable: !0,
            /******/
            get: m
            /******/
          });
        }, a.n = function(c) {
          var h = c && c.__esModule ? (
            /******/
            function() {
              return c.default;
            }
          ) : (
            /******/
            function() {
              return c;
            }
          );
          return a.d(h, "a", h), h;
        }, a.o = function(c, h) {
          return Object.prototype.hasOwnProperty.call(c, h);
        }, a.p = "/dist/", a(a.s = 8);
      }([
        /* 0 */
        /***/
        function(r, i, a) {
          a.d(i, "a", function() {
            return P;
          }), a.d(i, "b", function() {
            return M;
          });
          var c = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(K) {
            return typeof K;
          } : function(K) {
            return K && typeof Symbol == "function" && K.constructor === Symbol && K !== Symbol.prototype ? "symbol" : typeof K;
          };
          function h() {
          }
          var m = {
            trace: h,
            debug: h,
            log: h,
            warn: h,
            info: h,
            error: h
          }, p = m;
          function b(K, W) {
            return W = "[" + K + "] > " + W, W;
          }
          function d(K) {
            var W = self.console[K];
            return W ? function() {
              for (var J = arguments.length, z = Array(J), U = 0; U < J; U++)
                z[U] = arguments[U];
              z[0] && (z[0] = b(K, z[0])), W.apply(self.console, z);
            } : h;
          }
          function v(K) {
            for (var W = arguments.length, J = Array(W > 1 ? W - 1 : 0), z = 1; z < W; z++)
              J[z - 1] = arguments[z];
            J.forEach(function(U) {
              p[U] = K[U] ? K[U].bind(K) : d(U);
            });
          }
          var P = function(W) {
            if (W === !0 || (typeof W > "u" ? "undefined" : c(W)) === "object") {
              v(
                W,
                // Remove out from list here to hard-disable a log-level
                //'trace',
                "debug",
                "log",
                "info",
                "warn",
                "error"
              );
              try {
                p.log();
              } catch {
                p = m;
              }
            } else
              p = m;
          }, M = p;
        },
        /* 1 */
        /***/
        function(r, i, a) {
          i.a = {
            // fired before MediaSource is attaching to media element - data: { media }
            MEDIA_ATTACHING: "hlsMediaAttaching",
            // fired when MediaSource has been succesfully attached to media element - data: { }
            MEDIA_ATTACHED: "hlsMediaAttached",
            // fired before detaching MediaSource from media element - data: { }
            MEDIA_DETACHING: "hlsMediaDetaching",
            // fired when MediaSource has been detached from media element - data: { }
            MEDIA_DETACHED: "hlsMediaDetached",
            // fired when we buffer is going to be reset - data: { }
            BUFFER_RESET: "hlsBufferReset",
            // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
            BUFFER_CODECS: "hlsBufferCodecs",
            // fired when sourcebuffers have been created - data: { tracks : tracks }
            BUFFER_CREATED: "hlsBufferCreated",
            // fired when we append a segment to the buffer - data: { segment: segment object }
            BUFFER_APPENDING: "hlsBufferAppending",
            // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}
            BUFFER_APPENDED: "hlsBufferAppended",
            // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }
            BUFFER_EOS: "hlsBufferEos",
            // fired when the media buffer should be flushed - data { startOffset, endOffset }
            BUFFER_FLUSHING: "hlsBufferFlushing",
            // fired when the media buffer has been flushed - data: { }
            BUFFER_FLUSHED: "hlsBufferFlushed",
            // fired to signal that a manifest loading starts - data: { url : manifestURL}
            MANIFEST_LOADING: "hlsManifestLoading",
            // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
            MANIFEST_LOADED: "hlsManifestLoaded",
            // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}
            MANIFEST_PARSED: "hlsManifestParsed",
            // fired when a level switch is requested - data: { level : id of new level } // deprecated in favor LEVEL_SWITCHING
            LEVEL_SWITCH: "hlsLevelSwitch",
            // fired when a level switch is requested - data: { level : id of new level }
            LEVEL_SWITCHING: "hlsLevelSwitching",
            // fired when a level switch is effective - data: { level : id of new level }
            LEVEL_SWITCHED: "hlsLevelSwitched",
            // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}
            LEVEL_LOADING: "hlsLevelLoading",
            // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
            LEVEL_LOADED: "hlsLevelLoaded",
            // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }
            LEVEL_UPDATED: "hlsLevelUpdated",
            // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
            LEVEL_PTS_UPDATED: "hlsLevelPtsUpdated",
            // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }
            AUDIO_TRACKS_UPDATED: "hlsAudioTracksUpdated",
            // fired when an audio track switch occurs - data: { id : audio track id } // deprecated in favor AUDIO_TRACK_SWITCHING
            AUDIO_TRACK_SWITCH: "hlsAudioTrackSwitch",
            // fired when an audio track switching is requested - data: { id : audio track id }
            AUDIO_TRACK_SWITCHING: "hlsAudioTrackSwitching",
            // fired when an audio track switch actually occurs - data: { id : audio track id }
            AUDIO_TRACK_SWITCHED: "hlsAudioTrackSwitched",
            // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }
            AUDIO_TRACK_LOADING: "hlsAudioTrackLoading",
            // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime } }
            AUDIO_TRACK_LOADED: "hlsAudioTrackLoaded",
            // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }
            SUBTITLE_TRACKS_UPDATED: "hlsSubtitleTracksUpdated",
            // fired when an subtitle track switch occurs - data: { id : subtitle track id }
            SUBTITLE_TRACK_SWITCH: "hlsSubtitleTrackSwitch",
            // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }
            SUBTITLE_TRACK_LOADING: "hlsSubtitleTrackLoading",
            // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : { trequest, tfirst, tload, mtime } }
            SUBTITLE_TRACK_LOADED: "hlsSubtitleTrackLoaded",
            // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }
            SUBTITLE_FRAG_PROCESSED: "hlsSubtitleFragProcessed",
            // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, frag : fragment object }
            INIT_PTS_FOUND: "hlsInitPtsFound",
            // fired when a fragment loading starts - data: { frag : fragment object }
            FRAG_LOADING: "hlsFragLoading",
            // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }
            FRAG_LOAD_PROGRESS: "hlsFragLoadProgress",
            // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }
            FRAG_LOAD_EMERGENCY_ABORTED: "hlsFragLoadEmergencyAborted",
            // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length } }
            FRAG_LOADED: "hlsFragLoaded",
            // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, payload : fragment payload, stats : { tstart, tdecrypt } }
            FRAG_DECRYPTED: "hlsFragDecrypted",
            // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }
            FRAG_PARSING_INIT_SEGMENT: "hlsFragParsingInitSegment",
            // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }
            FRAG_PARSING_USERDATA: "hlsFragParsingUserdata",
            // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }
            FRAG_PARSING_METADATA: "hlsFragParsingMetadata",
            // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
            FRAG_PARSING_DATA: "hlsFragParsingData",
            // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }
            FRAG_PARSED: "hlsFragParsed",
            // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length, bwEstimate } }
            FRAG_BUFFERED: "hlsFragBuffered",
            // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
            FRAG_CHANGED: "hlsFragChanged",
            // Identifier for a FPS drop event - data: { curentDropped, currentDecoded, totalDroppedFrames }
            FPS_DROP: "hlsFpsDrop",
            //triggered when FPS drop triggers auto level capping - data: { level, droppedlevel }
            FPS_DROP_LEVEL_CAPPING: "hlsFpsDropLevelCapping",
            // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }
            ERROR: "hlsError",
            // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }
            DESTROYING: "hlsDestroying",
            // fired when a decrypt key loading starts - data: { frag : fragment object }
            KEY_LOADING: "hlsKeyLoading",
            // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length } }
            KEY_LOADED: "hlsKeyLoaded",
            // fired upon stream controller state transitions - data: { previousState, nextState }
            STREAM_STATE_TRANSITION: "hlsStreamStateTransition"
          };
        },
        /* 2 */
        /***/
        function(r, i, a) {
          a.d(i, "b", function() {
            return c;
          }), a.d(i, "a", function() {
            return h;
          });
          var c = {
            // Identifier for a network error (loading error / timeout ...)
            NETWORK_ERROR: "networkError",
            // Identifier for a media Error (video/parsing/mediasource error)
            MEDIA_ERROR: "mediaError",
            // Identifier for a mux Error (demuxing/remuxing)
            MUX_ERROR: "muxError",
            // Identifier for all other errors
            OTHER_ERROR: "otherError"
          }, h = {
            // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}
            MANIFEST_LOAD_ERROR: "manifestLoadError",
            // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
            MANIFEST_LOAD_TIMEOUT: "manifestLoadTimeOut",
            // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}
            MANIFEST_PARSING_ERROR: "manifestParsingError",
            // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}
            MANIFEST_INCOMPATIBLE_CODECS_ERROR: "manifestIncompatibleCodecsError",
            // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}
            LEVEL_LOAD_ERROR: "levelLoadError",
            // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
            LEVEL_LOAD_TIMEOUT: "levelLoadTimeOut",
            // Identifier for a level switch error - data: { level : faulty level Id, event : error description}
            LEVEL_SWITCH_ERROR: "levelSwitchError",
            // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}
            AUDIO_TRACK_LOAD_ERROR: "audioTrackLoadError",
            // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
            AUDIO_TRACK_LOAD_TIMEOUT: "audioTrackLoadTimeOut",
            // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}
            FRAG_LOAD_ERROR: "fragLoadError",
            // Identifier for fragment loop loading error - data: { frag : fragment object}
            FRAG_LOOP_LOADING_ERROR: "fragLoopLoadingError",
            // Identifier for fragment load timeout error - data: { frag : fragment object}
            FRAG_LOAD_TIMEOUT: "fragLoadTimeOut",
            // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }
            FRAG_DECRYPT_ERROR: "fragDecryptError",
            // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }
            // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release
            FRAG_PARSING_ERROR: "fragParsingError",
            // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }
            REMUX_ALLOC_ERROR: "remuxAllocError",
            // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}
            KEY_LOAD_ERROR: "keyLoadError",
            // Identifier for decrypt key load timeout error - data: { frag : fragment object}
            KEY_LOAD_TIMEOUT: "keyLoadTimeOut",
            // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : {  err : exception , mimeType : mimeType }
            BUFFER_ADD_CODEC_ERROR: "bufferAddCodecError",
            // Identifier for a buffer append error - data: append error description
            BUFFER_APPEND_ERROR: "bufferAppendError",
            // Identifier for a buffer appending error event - data: appending error description
            BUFFER_APPENDING_ERROR: "bufferAppendingError",
            // Identifier for a buffer stalled error event
            BUFFER_STALLED_ERROR: "bufferStalledError",
            // Identifier for a buffer full event
            BUFFER_FULL_ERROR: "bufferFullError",
            // Identifier for a buffer seek over hole event
            BUFFER_SEEK_OVER_HOLE: "bufferSeekOverHole",
            // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)
            BUFFER_NUDGE_ON_STALL: "bufferNudgeOnStall",
            // Identifier for an internal exception happening inside hls.js while handling an event
            INTERNAL_EXCEPTION: "internalException"
          };
        },
        /* 3 */
        /***/
        function(r, i, a) {
          a.d(i, "b", function() {
            return m;
          });
          function c(p, b) {
            if (!(p instanceof b))
              throw new TypeError("Cannot call a class as a function");
          }
          var h = function() {
            function p() {
              c(this, p);
            }
            return p.isHeader = function(d, v) {
              return v + 10 <= d.length && d[v] === 73 && d[v + 1] === 68 && d[v + 2] === 51 && d[v + 3] < 255 && d[v + 4] < 255 && d[v + 6] < 128 && d[v + 7] < 128 && d[v + 8] < 128 && d[v + 9] < 128;
            }, p.isFooter = function(d, v) {
              return v + 10 <= d.length && d[v] === 51 && d[v + 1] === 68 && d[v + 2] === 73 && d[v + 3] < 255 && d[v + 4] < 255 && d[v + 6] < 128 && d[v + 7] < 128 && d[v + 8] < 128 && d[v + 9] < 128;
            }, p.getID3Data = function(d, v) {
              for (var P = v, M = 0; p.isHeader(d, v); ) {
                M += 10;
                var K = p._readSize(d, v + 6);
                M += K, p.isFooter(d, v + 10) && (M += 10), v += M;
              }
              if (M > 0)
                return d.subarray(P, P + M);
            }, p._readSize = function(d, v) {
              var P = 0;
              return P = (d[v] & 127) << 21, P |= (d[v + 1] & 127) << 14, P |= (d[v + 2] & 127) << 7, P |= d[v + 3] & 127, P;
            }, p.getTimeStamp = function(d) {
              for (var v = p.getID3Frames(d), P = 0; P < v.length; P++) {
                var M = v[P];
                if (p.isTimeStampFrame(M))
                  return p._readTimeStamp(M);
              }
            }, p.isTimeStampFrame = function(d) {
              return d && d.key === "PRIV" && d.info === "com.apple.streaming.transportStreamTimestamp";
            }, p._getFrameData = function(d) {
              var v = String.fromCharCode(d[0], d[1], d[2], d[3]), P = p._readSize(d, 4), M = 10;
              return { type: v, size: P, data: d.subarray(M, M + P) };
            }, p.getID3Frames = function(d) {
              for (var v = 0, P = []; p.isHeader(d, v); ) {
                var M = p._readSize(d, v + 6);
                v += 10;
                for (var K = v + M; v + 8 < K; ) {
                  var W = p._getFrameData(d.subarray(v)), J = p._decodeFrame(W);
                  J && P.push(J), v += W.size + 10;
                }
                p.isFooter(d, v) && (v += 10);
              }
              return P;
            }, p._decodeFrame = function(d) {
              if (d.type === "PRIV")
                return p._decodePrivFrame(d);
              if (d.type[0] === "T")
                return p._decodeTextFrame(d);
              if (d.type[0] === "W")
                return p._decodeURLFrame(d);
            }, p._readTimeStamp = function(d) {
              if (d.data.byteLength === 8) {
                var v = new Uint8Array(d.data), P = v[3] & 1, M = (v[4] << 23) + (v[5] << 15) + (v[6] << 7) + v[7];
                return M /= 45, P && (M += 4772185884e-2), Math.round(M);
              }
            }, p._decodePrivFrame = function(d) {
              if (!(d.size < 2)) {
                var v = p._utf8ArrayToStr(d.data, !0), P = new Uint8Array(d.data.subarray(v.length + 1));
                return { key: d.type, info: v, data: P.buffer };
              }
            }, p._decodeTextFrame = function(d) {
              if (!(d.size < 2))
                if (d.type === "TXXX") {
                  var v = 1, P = p._utf8ArrayToStr(d.data.subarray(v));
                  v += P.length + 1;
                  var M = p._utf8ArrayToStr(d.data.subarray(v));
                  return { key: d.type, info: P, data: M };
                } else {
                  var K = p._utf8ArrayToStr(d.data.subarray(1));
                  return { key: d.type, data: K };
                }
            }, p._decodeURLFrame = function(d) {
              if (d.type === "WXXX") {
                if (d.size < 2)
                  return;
                var v = 1, P = p._utf8ArrayToStr(d.data.subarray(v));
                v += P.length + 1;
                var M = p._utf8ArrayToStr(d.data.subarray(v));
                return { key: d.type, info: P, data: M };
              } else {
                var K = p._utf8ArrayToStr(d.data);
                return { key: d.type, data: K };
              }
            }, p._utf8ArrayToStr = function(d) {
              for (var v = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, P = d.length, M = void 0, K = void 0, W = void 0, J = "", z = 0; z < P; ) {
                if (M = d[z++], M === 0 && v)
                  return J;
                if (M === 0 || M === 3)
                  continue;
                switch (M >> 4) {
                  case 0:
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                  case 5:
                  case 6:
                  case 7:
                    J += String.fromCharCode(M);
                    break;
                  case 12:
                  case 13:
                    K = d[z++], J += String.fromCharCode((M & 31) << 6 | K & 63);
                    break;
                  case 14:
                    K = d[z++], W = d[z++], J += String.fromCharCode((M & 15) << 12 | (K & 63) << 6 | (W & 63) << 0);
                    break;
                }
              }
              return J;
            }, p;
          }(), m = h._utf8ArrayToStr;
          i.a = h;
        },
        /* 4 */
        /***/
        function(r, i, a) {
          function c(U, F) {
            if (!(U instanceof F))
              throw new TypeError("Cannot call a class as a function");
          }
          var h = function() {
            function U(F, Z) {
              c(this, U), this.subtle = F, this.aesIV = Z;
            }
            return U.prototype.decrypt = function(Z, de) {
              return this.subtle.decrypt({ name: "AES-CBC", iv: this.aesIV }, de, Z);
            }, U;
          }(), m = h;
          function p(U, F) {
            if (!(U instanceof F))
              throw new TypeError("Cannot call a class as a function");
          }
          var b = function() {
            function U(F, Z) {
              p(this, U), this.subtle = F, this.key = Z;
            }
            return U.prototype.expandKey = function() {
              return this.subtle.importKey("raw", this.key, { name: "AES-CBC" }, !1, ["encrypt", "decrypt"]);
            }, U;
          }(), d = b;
          function v(U, F) {
            if (!(U instanceof F))
              throw new TypeError("Cannot call a class as a function");
          }
          var P = function() {
            function U() {
              v(this, U), this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.initTable();
            }
            return U.prototype.uint8ArrayToUint32Array_ = function(Z) {
              for (var de = new DataView(Z), xe = new Uint32Array(4), ge = 0; ge < 4; ge++)
                xe[ge] = de.getUint32(ge * 4);
              return xe;
            }, U.prototype.initTable = function() {
              var Z = this.sBox, de = this.invSBox, xe = this.subMix, ge = xe[0], me = xe[1], Ee = xe[2], De = xe[3], Ke = this.invSubMix, Ge = Ke[0], Je = Ke[1], Qe = Ke[2], Et = Ke[3], nt = new Uint32Array(256), vt = 0, jt = 0, Rt = 0;
              for (Rt = 0; Rt < 256; Rt++)
                Rt < 128 ? nt[Rt] = Rt << 1 : nt[Rt] = Rt << 1 ^ 283;
              for (Rt = 0; Rt < 256; Rt++) {
                var ut = jt ^ jt << 1 ^ jt << 2 ^ jt << 3 ^ jt << 4;
                ut = ut >>> 8 ^ ut & 255 ^ 99, Z[vt] = ut, de[ut] = vt;
                var Dt = nt[vt], qe = nt[Dt], Pr = nt[qe], ct = nt[ut] * 257 ^ ut * 16843008;
                ge[vt] = ct << 24 | ct >>> 8, me[vt] = ct << 16 | ct >>> 16, Ee[vt] = ct << 8 | ct >>> 24, De[vt] = ct, ct = Pr * 16843009 ^ qe * 65537 ^ Dt * 257 ^ vt * 16843008, Ge[ut] = ct << 24 | ct >>> 8, Je[ut] = ct << 16 | ct >>> 16, Qe[ut] = ct << 8 | ct >>> 24, Et[ut] = ct, vt ? (vt = Dt ^ nt[nt[nt[Pr ^ Dt]]], jt ^= nt[nt[jt]]) : vt = jt = 1;
              }
            }, U.prototype.expandKey = function(Z) {
              for (var de = this.uint8ArrayToUint32Array_(Z), xe = !0, ge = 0; ge < de.length && xe; )
                xe = de[ge] === this.key[ge], ge++;
              if (!xe) {
                this.key = de;
                var me = this.keySize = de.length;
                if (me !== 4 && me !== 6 && me !== 8)
                  throw new Error("Invalid aes key size=" + me);
                var Ee = this.ksRows = (me + 6 + 1) * 4, De = void 0, Ke = void 0, Ge = this.keySchedule = new Uint32Array(Ee), Je = this.invKeySchedule = new Uint32Array(Ee), Qe = this.sBox, Et = this.rcon, nt = this.invSubMix, vt = nt[0], jt = nt[1], Rt = nt[2], ut = nt[3], Dt = void 0, qe = void 0;
                for (De = 0; De < Ee; De++) {
                  if (De < me) {
                    Dt = Ge[De] = de[De];
                    continue;
                  }
                  qe = Dt, De % me === 0 ? (qe = qe << 8 | qe >>> 24, qe = Qe[qe >>> 24] << 24 | Qe[qe >>> 16 & 255] << 16 | Qe[qe >>> 8 & 255] << 8 | Qe[qe & 255], qe ^= Et[De / me | 0] << 24) : me > 6 && De % me === 4 && (qe = Qe[qe >>> 24] << 24 | Qe[qe >>> 16 & 255] << 16 | Qe[qe >>> 8 & 255] << 8 | Qe[qe & 255]), Ge[De] = Dt = (Ge[De - me] ^ qe) >>> 0;
                }
                for (Ke = 0; Ke < Ee; Ke++)
                  De = Ee - Ke, Ke & 3 ? qe = Ge[De] : qe = Ge[De - 4], Ke < 4 || De <= 4 ? Je[Ke] = qe : Je[Ke] = vt[Qe[qe >>> 24]] ^ jt[Qe[qe >>> 16 & 255]] ^ Rt[Qe[qe >>> 8 & 255]] ^ ut[Qe[qe & 255]], Je[Ke] = Je[Ke] >>> 0;
              }
            }, U.prototype.networkToHostOrderSwap = function(Z) {
              return Z << 24 | (Z & 65280) << 8 | (Z & 16711680) >> 8 | Z >>> 24;
            }, U.prototype.decrypt = function(Z, de, xe) {
              for (var ge = this.keySize + 6, me = this.invKeySchedule, Ee = this.invSBox, De = this.invSubMix, Ke = De[0], Ge = De[1], Je = De[2], Qe = De[3], Et = this.uint8ArrayToUint32Array_(xe), nt = Et[0], vt = Et[1], jt = Et[2], Rt = Et[3], ut = new Int32Array(Z), Dt = new Int32Array(ut.length), qe = void 0, Pr = void 0, ct = void 0, tn = void 0, dr = void 0, fr = void 0, Ft = void 0, pr = void 0, hr = void 0, Br = void 0, kr = void 0, dt = void 0, St, Sn, rr = this.networkToHostOrderSwap; de < ut.length; ) {
                for (hr = rr(ut[de]), Br = rr(ut[de + 1]), kr = rr(ut[de + 2]), dt = rr(ut[de + 3]), dr = hr ^ me[0], fr = dt ^ me[1], Ft = kr ^ me[2], pr = Br ^ me[3], St = 4, Sn = 1; Sn < ge; Sn++)
                  qe = Ke[dr >>> 24] ^ Ge[fr >> 16 & 255] ^ Je[Ft >> 8 & 255] ^ Qe[pr & 255] ^ me[St], Pr = Ke[fr >>> 24] ^ Ge[Ft >> 16 & 255] ^ Je[pr >> 8 & 255] ^ Qe[dr & 255] ^ me[St + 1], ct = Ke[Ft >>> 24] ^ Ge[pr >> 16 & 255] ^ Je[dr >> 8 & 255] ^ Qe[fr & 255] ^ me[St + 2], tn = Ke[pr >>> 24] ^ Ge[dr >> 16 & 255] ^ Je[fr >> 8 & 255] ^ Qe[Ft & 255] ^ me[St + 3], dr = qe, fr = Pr, Ft = ct, pr = tn, St = St + 4;
                qe = Ee[dr >>> 24] << 24 ^ Ee[fr >> 16 & 255] << 16 ^ Ee[Ft >> 8 & 255] << 8 ^ Ee[pr & 255] ^ me[St], Pr = Ee[fr >>> 24] << 24 ^ Ee[Ft >> 16 & 255] << 16 ^ Ee[pr >> 8 & 255] << 8 ^ Ee[dr & 255] ^ me[St + 1], ct = Ee[Ft >>> 24] << 24 ^ Ee[pr >> 16 & 255] << 16 ^ Ee[dr >> 8 & 255] << 8 ^ Ee[fr & 255] ^ me[St + 2], tn = Ee[pr >>> 24] << 24 ^ Ee[dr >> 16 & 255] << 16 ^ Ee[fr >> 8 & 255] << 8 ^ Ee[Ft & 255] ^ me[St + 3], St = St + 3, Dt[de] = rr(qe ^ nt), Dt[de + 1] = rr(tn ^ vt), Dt[de + 2] = rr(ct ^ jt), Dt[de + 3] = rr(Pr ^ Rt), nt = hr, vt = Br, jt = kr, Rt = dt, de = de + 4;
              }
              return Dt.buffer;
            }, U.prototype.destroy = function() {
              this.key = void 0, this.keySize = void 0, this.ksRows = void 0, this.sBox = void 0, this.invSBox = void 0, this.subMix = void 0, this.invSubMix = void 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.rcon = void 0;
            }, U;
          }(), M = P, K = a(2), W = a(0);
          function J(U, F) {
            if (!(U instanceof F))
              throw new TypeError("Cannot call a class as a function");
          }
          var z = function() {
            function U(F, Z) {
              J(this, U), this.observer = F, this.config = Z, this.logEnabled = !0;
              try {
                var de = crypto || self.crypto;
                this.subtle = de.subtle || de.webkitSubtle;
              } catch {
              }
              this.disableWebCrypto = !this.subtle;
            }
            return U.prototype.isSync = function() {
              return this.disableWebCrypto && this.config.enableSoftwareAES;
            }, U.prototype.decrypt = function(Z, de, xe, ge) {
              var me = this;
              if (this.disableWebCrypto && this.config.enableSoftwareAES) {
                this.logEnabled && (W.b.log("JS AES decrypt"), this.logEnabled = !1);
                var Ee = this.decryptor;
                Ee || (this.decryptor = Ee = new M()), Ee.expandKey(de), ge(Ee.decrypt(Z, 0, xe));
              } else {
                this.logEnabled && (W.b.log("WebCrypto AES decrypt"), this.logEnabled = !1);
                var De = this.subtle;
                this.key !== de && (this.key = de, this.fastAesKey = new d(De, de)), this.fastAesKey.expandKey().then(function(Ke) {
                  var Ge = new m(De, xe);
                  Ge.decrypt(Z, Ke).catch(function(Je) {
                    me.onWebCryptoError(Je, Z, de, xe, ge);
                  }).then(function(Je) {
                    ge(Je);
                  });
                }).catch(function(Ke) {
                  me.onWebCryptoError(Ke, Z, de, xe, ge);
                });
              }
            }, U.prototype.onWebCryptoError = function(Z, de, xe, ge, me) {
              this.config.enableSoftwareAES ? (W.b.log("WebCrypto Error, disable WebCrypto API"), this.disableWebCrypto = !0, this.logEnabled = !0, this.decrypt(de, xe, ge, me)) : (W.b.error("decrypting error : " + Z.message), this.observer.trigger(Event.ERROR, { type: K.b.MEDIA_ERROR, details: K.a.FRAG_DECRYPT_ERROR, fatal: !0, reason: Z.message }));
            }, U.prototype.destroy = function() {
              var Z = this.decryptor;
              Z && (Z.destroy(), this.decryptor = void 0);
            }, U;
          }();
          i.a = z;
        },
        /* 5 */
        /***/
        function(r, i) {
          function a() {
            this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;
          }
          r.exports = a, a.EventEmitter = a, a.prototype._events = void 0, a.prototype._maxListeners = void 0, a.defaultMaxListeners = 10, a.prototype.setMaxListeners = function(b) {
            if (!h(b) || b < 0 || isNaN(b))
              throw TypeError("n must be a positive number");
            return this._maxListeners = b, this;
          }, a.prototype.emit = function(b) {
            var d, v, P, M, K, W;
            if (this._events || (this._events = {}), b === "error" && (!this._events.error || m(this._events.error) && !this._events.error.length)) {
              if (d = arguments[1], d instanceof Error)
                throw d;
              var J = new Error('Uncaught, unspecified "error" event. (' + d + ")");
              throw J.context = d, J;
            }
            if (v = this._events[b], p(v))
              return !1;
            if (c(v))
              switch (arguments.length) {
                case 1:
                  v.call(this);
                  break;
                case 2:
                  v.call(this, arguments[1]);
                  break;
                case 3:
                  v.call(this, arguments[1], arguments[2]);
                  break;
                default:
                  M = Array.prototype.slice.call(arguments, 1), v.apply(this, M);
              }
            else if (m(v))
              for (M = Array.prototype.slice.call(arguments, 1), W = v.slice(), P = W.length, K = 0; K < P; K++)
                W[K].apply(this, M);
            return !0;
          }, a.prototype.addListener = function(b, d) {
            var v;
            if (!c(d))
              throw TypeError("listener must be a function");
            return this._events || (this._events = {}), this._events.newListener && this.emit(
              "newListener",
              b,
              c(d.listener) ? d.listener : d
            ), this._events[b] ? m(this._events[b]) ? this._events[b].push(d) : this._events[b] = [this._events[b], d] : this._events[b] = d, m(this._events[b]) && !this._events[b].warned && (p(this._maxListeners) ? v = a.defaultMaxListeners : v = this._maxListeners, v && v > 0 && this._events[b].length > v && (this._events[b].warned = !0, console.error(
              "(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",
              this._events[b].length
            ), typeof console.trace == "function" && console.trace())), this;
          }, a.prototype.on = a.prototype.addListener, a.prototype.once = function(b, d) {
            if (!c(d))
              throw TypeError("listener must be a function");
            var v = !1;
            function P() {
              this.removeListener(b, P), v || (v = !0, d.apply(this, arguments));
            }
            return P.listener = d, this.on(b, P), this;
          }, a.prototype.removeListener = function(b, d) {
            var v, P, M, K;
            if (!c(d))
              throw TypeError("listener must be a function");
            if (!this._events || !this._events[b])
              return this;
            if (v = this._events[b], M = v.length, P = -1, v === d || c(v.listener) && v.listener === d)
              delete this._events[b], this._events.removeListener && this.emit("removeListener", b, d);
            else if (m(v)) {
              for (K = M; K-- > 0; )
                if (v[K] === d || v[K].listener && v[K].listener === d) {
                  P = K;
                  break;
                }
              if (P < 0)
                return this;
              v.length === 1 ? (v.length = 0, delete this._events[b]) : v.splice(P, 1), this._events.removeListener && this.emit("removeListener", b, d);
            }
            return this;
          }, a.prototype.removeAllListeners = function(b) {
            var d, v;
            if (!this._events)
              return this;
            if (!this._events.removeListener)
              return arguments.length === 0 ? this._events = {} : this._events[b] && delete this._events[b], this;
            if (arguments.length === 0) {
              for (d in this._events)
                d !== "removeListener" && this.removeAllListeners(d);
              return this.removeAllListeners("removeListener"), this._events = {}, this;
            }
            if (v = this._events[b], c(v))
              this.removeListener(b, v);
            else if (v)
              for (; v.length; )
                this.removeListener(b, v[v.length - 1]);
            return delete this._events[b], this;
          }, a.prototype.listeners = function(b) {
            var d;
            return !this._events || !this._events[b] ? d = [] : c(this._events[b]) ? d = [this._events[b]] : d = this._events[b].slice(), d;
          }, a.prototype.listenerCount = function(b) {
            if (this._events) {
              var d = this._events[b];
              if (c(d))
                return 1;
              if (d)
                return d.length;
            }
            return 0;
          }, a.listenerCount = function(b, d) {
            return b.listenerCount(d);
          };
          function c(b) {
            return typeof b == "function";
          }
          function h(b) {
            return typeof b == "number";
          }
          function m(b) {
            return typeof b == "object" && b !== null;
          }
          function p(b) {
            return b === void 0;
          }
        },
        /* 6 */
        /***/
        function(r, i, a) {
          (function(c) {
            var h = /^((?:[^\/;?#]+:)?)(\/\/[^\/\;?#]*)?(.*?)??(;.*?)?(\?.*?)?(#.*?)?$/, m = /^([^\/;?#]*)(.*)$/, p = /(?:\/|^)\.(?=\/)/g, b = /(?:\/|^)\.\.\/(?!\.\.\/).*?(?=\/)/g, d = {
              // jshint ignore:line
              // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
              // E.g
              // With opts.alwaysNormalize = false (default, spec compliant)
              // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
              // With opts.alwaysNormalize = true (default, not spec compliant)
              // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
              buildAbsoluteURL: function(v, P, M) {
                if (M = M || {}, v = v.trim(), P = P.trim(), !P) {
                  if (!M.alwaysNormalize)
                    return v;
                  var K = this.parseURL(v);
                  if (!J)
                    throw new Error("Error trying to parse base URL.");
                  return K.path = d.normalizePath(K.path), d.buildURLFromParts(K);
                }
                var W = this.parseURL(P);
                if (!W)
                  throw new Error("Error trying to parse relative URL.");
                if (W.scheme)
                  return M.alwaysNormalize ? (W.path = d.normalizePath(W.path), d.buildURLFromParts(W)) : P;
                var J = this.parseURL(v);
                if (!J)
                  throw new Error("Error trying to parse base URL.");
                if (!J.netLoc && J.path && J.path[0] !== "/") {
                  var z = m.exec(J.path);
                  J.netLoc = z[1], J.path = z[2];
                }
                J.netLoc && !J.path && (J.path = "/");
                var U = {
                  // 2c) Otherwise, the embedded URL inherits the scheme of
                  // the base URL.
                  scheme: J.scheme,
                  netLoc: W.netLoc,
                  path: null,
                  params: W.params,
                  query: W.query,
                  fragment: W.fragment
                };
                if (!W.netLoc && (U.netLoc = J.netLoc, W.path[0] !== "/"))
                  if (!W.path)
                    U.path = J.path, W.params || (U.params = J.params, W.query || (U.query = J.query));
                  else {
                    var F = J.path, Z = F.substring(0, F.lastIndexOf("/") + 1) + W.path;
                    U.path = d.normalizePath(Z);
                  }
                return U.path === null && (U.path = M.alwaysNormalize ? d.normalizePath(W.path) : W.path), d.buildURLFromParts(U);
              },
              parseURL: function(v) {
                var P = h.exec(v);
                return P ? {
                  scheme: P[1] || "",
                  netLoc: P[2] || "",
                  path: P[3] || "",
                  params: P[4] || "",
                  query: P[5] || "",
                  fragment: P[6] || ""
                } : null;
              },
              normalizePath: function(v) {
                for (v = v.split("").reverse().join("").replace(p, ""); v.length !== (v = v.replace(b, "")).length; )
                  ;
                return v.split("").reverse().join("");
              },
              buildURLFromParts: function(v) {
                return v.scheme + v.netLoc + v.path + v.params + v.query + v.fragment;
              }
            };
            r.exports = d;
          })();
        },
        /* 7 */
        /***/
        function(r, i, a) {
          var c = a(1), h = a(2), m = a(4), p = a(0);
          function b(R, I, y, T) {
            var C, L, D, V, N, X = navigator.userAgent.toLowerCase(), Q = T, H = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
            if (C = ((I[y + 2] & 192) >>> 6) + 1, L = (I[y + 2] & 60) >>> 2, L > H.length - 1) {
              R.trigger(Event.ERROR, { type: h.b.MEDIA_ERROR, details: h.a.FRAG_PARSING_ERROR, fatal: !0, reason: "invalid ADTS sampling index:" + L });
              return;
            }
            return V = (I[y + 2] & 1) << 2, V |= (I[y + 3] & 192) >>> 6, p.b.log("manifest codec:" + T + ",ADTS data:type:" + C + ",sampleingIndex:" + L + "[" + H[L] + "Hz],channelConfig:" + V), /firefox/i.test(X) ? L >= 6 ? (C = 5, N = new Array(4), D = L - 3) : (C = 2, N = new Array(2), D = L) : X.indexOf("android") !== -1 ? (C = 2, N = new Array(2), D = L) : (C = 5, N = new Array(4), T && (T.indexOf("mp4a.40.29") !== -1 || T.indexOf("mp4a.40.5") !== -1) || !T && L >= 6 ? D = L - 3 : ((T && T.indexOf("mp4a.40.2") !== -1 && (L >= 6 && V === 1 || /vivaldi/i.test(X)) || !T && V === 1) && (C = 2, N = new Array(2)), D = L)), N[0] = C << 3, N[0] |= (L & 14) >> 1, N[1] |= (L & 1) << 7, N[1] |= V << 3, C === 5 && (N[1] |= (D & 14) >> 1, N[2] = (D & 1) << 7, N[2] |= 8, N[3] = 0), { config: N, samplerate: H[L], channelCount: V, codec: "mp4a.40." + C, manifestCodec: Q };
          }
          function d(R, I) {
            return R[I] === 255 && (R[I + 1] & 246) === 240;
          }
          function v(R, I) {
            return R[I + 1] & 1 ? 7 : 9;
          }
          function P(R, I) {
            return (R[I + 3] & 3) << 11 | R[I + 4] << 3 | (R[I + 5] & 224) >>> 5;
          }
          function M(R, I) {
            return !!(I + 1 < R.length && d(R, I));
          }
          function K(R, I) {
            if (I + 1 < R.length && d(R, I)) {
              var y = v(R, I), T = y;
              I + 5 < R.length && (T = P(R, I));
              var C = I + T;
              if (C === R.length || C + 1 < R.length && d(R, C))
                return !0;
            }
            return !1;
          }
          function W(R, I, y, T, C) {
            if (!R.samplerate) {
              var L = b(I, y, T, C);
              R.config = L.config, R.samplerate = L.samplerate, R.channelCount = L.channelCount, R.codec = L.codec, R.manifestCodec = L.manifestCodec, p.b.log("parsed codec:" + R.codec + ",rate:" + L.samplerate + ",nb channel:" + L.channelCount);
            }
          }
          function J(R) {
            return 1024 * 9e4 / R;
          }
          function z(R, I, y, T, C) {
            var L, D, V, N = R.length;
            if (L = v(R, I), D = P(R, I), D -= L, D > 0 && I + L + D <= N)
              return V = y + T * C, { headerLength: L, frameLength: D, stamp: V };
          }
          function U(R, I, y, T, C) {
            var L = J(R.samplerate), D = z(I, y, T, C, L);
            if (D) {
              var V = D.stamp, N = D.headerLength, X = D.frameLength, Q = {
                unit: I.subarray(y + N, y + N + X),
                pts: V,
                dts: V
              };
              return R.samples.push(Q), R.len += X, { sample: Q, length: X + N };
            }
          }
          var F = a(3);
          function Z(R, I) {
            if (!(R instanceof I))
              throw new TypeError("Cannot call a class as a function");
          }
          var de = function() {
            function R(I, y, T) {
              Z(this, R), this.observer = I, this.config = T, this.remuxer = y;
            }
            return R.prototype.resetInitSegment = function(y, T, C, L) {
              this._audioTrack = { container: "audio/adts", type: "audio", id: 0, sequenceNumber: 0, isAAC: !0, samples: [], len: 0, manifestCodec: T, duration: L, inputTimeScale: 9e4 };
            }, R.prototype.resetTimeStamp = function() {
            }, R.probe = function(y) {
              if (!y)
                return !1;
              for (var T = F.a.getID3Data(y, 0) || [], C = T.length, L = y.length; C < L; C++)
                if (K(y, C))
                  return p.b.log("ADTS sync word found !"), !0;
              return !1;
            }, R.prototype.append = function(y, T, C, L) {
              for (var D = this._audioTrack, V = F.a.getID3Data(y, 0) || [], N = F.a.getTimeStamp(V), X = N ? 90 * N : T * 9e4, Q = 0, H = X, ie = y.length, re = V.length, fe = [{ pts: H, dts: H, data: V }]; re < ie - 1; )
                if (M(y, re) && re + 5 < ie) {
                  W(D, this.observer, y, re, D.manifestCodec);
                  var oe = U(D, y, re, X, Q);
                  if (oe)
                    re += oe.length, H = oe.sample.pts, Q++;
                  else {
                    p.b.log("Unable to parse AAC frame");
                    break;
                  }
                } else F.a.isHeader(y, re) ? (V = F.a.getID3Data(y, re), fe.push({ pts: H, dts: H, data: V }), re += V.length) : re++;
              this.remuxer.remux(D, { samples: [] }, { samples: fe, inputTimeScale: 9e4 }, { samples: [] }, T, C, L);
            }, R.prototype.destroy = function() {
            }, R;
          }(), xe = de;
          function ge(R, I) {
            if (!(R instanceof I))
              throw new TypeError("Cannot call a class as a function");
          }
          var me = Math.pow(2, 32) - 1, Ee = function() {
            function R(I, y) {
              ge(this, R), this.observer = I, this.remuxer = y;
            }
            return R.prototype.resetTimeStamp = function(y) {
              this.initPTS = y;
            }, R.prototype.resetInitSegment = function(y, T, C, L) {
              if (y && y.byteLength) {
                var D = this.initData = R.parseInitSegment(y);
                T == null && (T = "mp4a.40.5"), C == null && (C = "avc1.42e01e");
                var V = {};
                D.audio && D.video ? V.audiovideo = { container: "video/mp4", codec: T + "," + C, initSegment: L ? y : null } : (D.audio && (V.audio = { container: "audio/mp4", codec: T, initSegment: L ? y : null }), D.video && (V.video = { container: "video/mp4", codec: C, initSegment: L ? y : null })), this.observer.trigger(c.a.FRAG_PARSING_INIT_SEGMENT, { tracks: V });
              } else
                T && (this.audioCodec = T), C && (this.videoCodec = C);
            }, R.probe = function(y) {
              return R.findBox({ data: y, start: 0, end: Math.min(y.length, 16384) }, ["moof"]).length > 0;
            }, R.bin2str = function(y) {
              return String.fromCharCode.apply(null, y);
            }, R.readUint32 = function(y, T) {
              y.data && (T += y.start, y = y.data);
              var C = y[T] << 24 | y[T + 1] << 16 | y[T + 2] << 8 | y[T + 3];
              return C < 0 ? 4294967296 + C : C;
            }, R.writeUint32 = function(y, T, C) {
              y.data && (T += y.start, y = y.data), y[T] = C >> 24, y[T + 1] = C >> 16 & 255, y[T + 2] = C >> 8 & 255, y[T + 3] = C & 255;
            }, R.findBox = function(y, T) {
              var C = [], L, D, V, N, X, Q, H;
              if (y.data ? (Q = y.start, N = y.end, y = y.data) : (Q = 0, N = y.byteLength), !T.length)
                return null;
              for (L = Q; L < N; )
                D = R.readUint32(y, L), V = R.bin2str(y.subarray(L + 4, L + 8)), H = D > 1 ? L + D : N, V === T[0] && (T.length === 1 ? C.push({ data: y, start: L + 8, end: H }) : (X = R.findBox({ data: y, start: L + 8, end: H }, T.slice(1)), X.length && (C = C.concat(X)))), L = H;
              return C;
            }, R.parseInitSegment = function(y) {
              var T = [], C = R.findBox(y, ["moov", "trak"]);
              return C.forEach(function(L) {
                var D = R.findBox(L, ["tkhd"])[0];
                if (D) {
                  var V = D.data[D.start], N = V === 0 ? 12 : 20, X = R.readUint32(D, N), Q = R.findBox(L, ["mdia", "mdhd"])[0];
                  if (Q) {
                    V = Q.data[Q.start], N = V === 0 ? 12 : 20;
                    var H = R.readUint32(Q, N), ie = R.findBox(L, ["mdia", "hdlr"])[0];
                    if (ie) {
                      var re = R.bin2str(ie.data.subarray(ie.start + 8, ie.start + 12)), fe = { soun: "audio", vide: "video" }[re];
                      if (fe) {
                        var oe = R.findBox(L, ["mdia", "minf", "stbl", "stsd"]);
                        if (oe.length) {
                          oe = oe[0];
                          var le = R.bin2str(oe.data.subarray(oe.start + 12, oe.start + 16));
                          p.b.log("MP4Demuxer:" + fe + ":" + le + " found");
                        }
                        T[X] = { timescale: H, type: fe }, T[fe] = { timescale: H, id: X };
                      }
                    }
                  }
                }
              }), T;
            }, R.getStartDTS = function(y, T) {
              var C, L, D;
              return C = R.findBox(T, ["moof", "traf"]), L = [].concat.apply([], C.map(function(V) {
                return R.findBox(V, ["tfhd"]).map(function(N) {
                  var X, Q, H;
                  return X = R.readUint32(N, 4), Q = y[X].timescale || 9e4, H = R.findBox(V, ["tfdt"]).map(function(ie) {
                    var re, fe;
                    return re = ie.data[ie.start], fe = R.readUint32(ie, 4), re === 1 && (fe *= Math.pow(2, 32), fe += R.readUint32(ie, 8)), fe;
                  })[0], H / Q;
                });
              })), D = Math.min.apply(null, L), isFinite(D) ? D : 0;
            }, R.offsetStartDTS = function(y, T, C) {
              R.findBox(T, ["moof", "traf"]).map(function(L) {
                return R.findBox(L, ["tfhd"]).map(function(D) {
                  var V = R.readUint32(D, 4), N = y[V].timescale || 9e4;
                  R.findBox(L, ["tfdt"]).map(function(X) {
                    var Q = X.data[X.start], H = R.readUint32(X, 4);
                    if (Q === 0)
                      R.writeUint32(X, 4, H - C * N);
                    else {
                      H *= Math.pow(2, 32), H += R.readUint32(X, 8), H -= C * N, H = Math.max(H, 0);
                      var ie = Math.floor(H / (me + 1)), re = Math.floor(H % (me + 1));
                      R.writeUint32(X, 4, ie), R.writeUint32(X, 8, re);
                    }
                  });
                });
              });
            }, R.prototype.append = function(y, T, C, L) {
              var D = this.initData;
              D || (this.resetInitSegment(y, this.audioCodec, this.videoCodec), D = this.initData);
              var V = void 0, N = this.initPTS;
              if (N === void 0) {
                var X = R.getStartDTS(D, y);
                this.initPTS = N = X - T, this.observer.trigger(c.a.INIT_PTS_FOUND, { initPTS: N });
              }
              R.offsetStartDTS(D, y, N), V = R.getStartDTS(D, y), this.remuxer.remux(D.audio, D.video, null, null, V, C, L, y);
            }, R.prototype.destroy = function() {
            }, R;
          }(), De = Ee, Ke = {
            BitratesMap: [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],
            SamplingRateMap: [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],
            SamplesCoefficients: [
              // MPEG 2.5
              [
                0,
                // Reserved
                72,
                // Layer3
                144,
                // Layer2
                12
                // Layer1
              ],
              // Reserved
              [
                0,
                // Reserved
                0,
                // Layer3
                0,
                // Layer2
                0
                // Layer1
              ],
              // MPEG 2
              [
                0,
                // Reserved
                72,
                // Layer3
                144,
                // Layer2
                12
                // Layer1
              ],
              // MPEG 1
              [
                0,
                // Reserved
                144,
                // Layer3
                144,
                // Layer2
                12
                // Layer1
              ]
            ],
            BytesInSlot: [
              0,
              // Reserved
              1,
              // Layer3
              1,
              // Layer2
              4
              // Layer1
            ],
            appendFrame: function(I, y, T, C, L) {
              if (!(T + 24 > y.length)) {
                var D = this.parseHeader(y, T);
                if (D && T + D.frameLength <= y.length) {
                  var V = D.samplesPerFrame * 9e4 / D.sampleRate, N = C + L * V, X = { unit: y.subarray(T, T + D.frameLength), pts: N, dts: N };
                  return I.config = [], I.channelCount = D.channelCount, I.samplerate = D.sampleRate, I.samples.push(X), I.len += D.frameLength, { sample: X, length: D.frameLength };
                }
              }
            },
            parseHeader: function(I, y) {
              var T = I[y + 1] >> 3 & 3, C = I[y + 1] >> 1 & 3, L = I[y + 2] >> 4 & 15, D = I[y + 2] >> 2 & 3, V = I[y + 2] >> 1 & 1;
              if (T !== 1 && L !== 0 && L !== 15 && D !== 3) {
                var N = T === 3 ? 3 - C : C === 3 ? 3 : 4, X = Ke.BitratesMap[N * 14 + L - 1] * 1e3, Q = T === 3 ? 0 : T === 2 ? 1 : 2, H = Ke.SamplingRateMap[Q * 3 + D], ie = I[y + 3] >> 6 === 3 ? 1 : 2, re = Ke.SamplesCoefficients[T][C], fe = Ke.BytesInSlot[C], oe = re * 8 * fe, le = parseInt(re * X / H + V, 10) * fe;
                return { sampleRate: H, channelCount: ie, frameLength: le, samplesPerFrame: oe };
              }
            },
            isHeaderPattern: function(I, y) {
              return I[y] === 255 && (I[y + 1] & 224) === 224 && (I[y + 1] & 6) !== 0;
            },
            isHeader: function(I, y) {
              return !!(y + 1 < I.length && this.isHeaderPattern(I, y));
            },
            probe: function(I, y) {
              if (y + 1 < I.length && this.isHeaderPattern(I, y)) {
                var T = 4, C = this.parseHeader(I, y), L = T;
                C && C.frameLength && (L = C.frameLength);
                var D = y + L;
                if (D === I.length || D + 1 < I.length && this.isHeaderPattern(I, D))
                  return !0;
              }
              return !1;
            }
          }, Ge = Ke;
          function Je(R, I) {
            if (!(R instanceof I))
              throw new TypeError("Cannot call a class as a function");
          }
          var Qe = function() {
            function R(I) {
              Je(this, R), this.data = I, this.bytesAvailable = I.byteLength, this.word = 0, this.bitsAvailable = 0;
            }
            return R.prototype.loadWord = function() {
              var y = this.data, T = this.bytesAvailable, C = y.byteLength - T, L = new Uint8Array(4), D = Math.min(4, T);
              if (D === 0)
                throw new Error("no bytes available");
              L.set(y.subarray(C, C + D)), this.word = new DataView(L.buffer).getUint32(0), this.bitsAvailable = D * 8, this.bytesAvailable -= D;
            }, R.prototype.skipBits = function(y) {
              var T;
              this.bitsAvailable > y ? (this.word <<= y, this.bitsAvailable -= y) : (y -= this.bitsAvailable, T = y >> 3, y -= T >> 3, this.bytesAvailable -= T, this.loadWord(), this.word <<= y, this.bitsAvailable -= y);
            }, R.prototype.readBits = function(y) {
              var T = Math.min(this.bitsAvailable, y), C = this.word >>> 32 - T;
              return y > 32 && p.b.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= T, this.bitsAvailable > 0 ? this.word <<= T : this.bytesAvailable > 0 && this.loadWord(), T = y - T, T > 0 && this.bitsAvailable ? C << T | this.readBits(T) : C;
            }, R.prototype.skipLZ = function() {
              var y;
              for (y = 0; y < this.bitsAvailable; ++y)
                if (this.word & 2147483648 >>> y)
                  return this.word <<= y, this.bitsAvailable -= y, y;
              return this.loadWord(), y + this.skipLZ();
            }, R.prototype.skipUEG = function() {
              this.skipBits(1 + this.skipLZ());
            }, R.prototype.skipEG = function() {
              this.skipBits(1 + this.skipLZ());
            }, R.prototype.readUEG = function() {
              var y = this.skipLZ();
              return this.readBits(y + 1) - 1;
            }, R.prototype.readEG = function() {
              var y = this.readUEG();
              return 1 & y ? 1 + y >>> 1 : -1 * (y >>> 1);
            }, R.prototype.readBoolean = function() {
              return this.readBits(1) === 1;
            }, R.prototype.readUByte = function() {
              return this.readBits(8);
            }, R.prototype.readUShort = function() {
              return this.readBits(16);
            }, R.prototype.readUInt = function() {
              return this.readBits(32);
            }, R.prototype.skipScalingList = function(y) {
              var T = 8, C = 8, L, D;
              for (L = 0; L < y; L++)
                C !== 0 && (D = this.readEG(), C = (T + D + 256) % 256), T = C === 0 ? T : C;
            }, R.prototype.readSPS = function() {
              var y = 0, T = 0, C = 0, L = 0, D, V, N, X, Q, H, ie, re = this.readUByte.bind(this), fe = this.readBits.bind(this), oe = this.readUEG.bind(this), le = this.readBoolean.bind(this), ee = this.skipBits.bind(this), Ie = this.skipEG.bind(this), et = this.skipUEG.bind(this), tt = this.skipScalingList.bind(this);
              if (re(), D = re(), fe(5), ee(3), re(), et(), D === 100 || D === 110 || D === 122 || D === 244 || D === 44 || D === 83 || D === 86 || D === 118 || D === 128) {
                var Fe = oe();
                if (Fe === 3 && ee(1), et(), et(), ee(1), le())
                  for (H = Fe !== 3 ? 8 : 12, ie = 0; ie < H; ie++)
                    le() && (ie < 6 ? tt(16) : tt(64));
              }
              et();
              var Ze = oe();
              if (Ze === 0)
                oe();
              else if (Ze === 1)
                for (ee(1), Ie(), Ie(), V = oe(), ie = 0; ie < V; ie++)
                  Ie();
              et(), ee(1), N = oe(), X = oe(), Q = fe(1), Q === 0 && ee(1), ee(1), le() && (y = oe(), T = oe(), C = oe(), L = oe());
              var Te = [1, 1];
              if (le() && le()) {
                var st = re();
                switch (st) {
                  case 1:
                    Te = [1, 1];
                    break;
                  case 2:
                    Te = [12, 11];
                    break;
                  case 3:
                    Te = [10, 11];
                    break;
                  case 4:
                    Te = [16, 11];
                    break;
                  case 5:
                    Te = [40, 33];
                    break;
                  case 6:
                    Te = [24, 11];
                    break;
                  case 7:
                    Te = [20, 11];
                    break;
                  case 8:
                    Te = [32, 11];
                    break;
                  case 9:
                    Te = [80, 33];
                    break;
                  case 10:
                    Te = [18, 11];
                    break;
                  case 11:
                    Te = [15, 11];
                    break;
                  case 12:
                    Te = [64, 33];
                    break;
                  case 13:
                    Te = [160, 99];
                    break;
                  case 14:
                    Te = [4, 3];
                    break;
                  case 15:
                    Te = [3, 2];
                    break;
                  case 16:
                    Te = [2, 1];
                    break;
                  case 255: {
                    Te = [re() << 8 | re(), re() << 8 | re()];
                    break;
                  }
                }
              }
              return {
                width: Math.ceil((N + 1) * 16 - y * 2 - T * 2),
                height: (2 - Q) * (X + 1) * 16 - (Q ? 2 : 4) * (C + L),
                pixelRatio: Te
              };
            }, R.prototype.readSliceType = function() {
              return this.readUByte(), this.readUEG(), this.readUEG();
            }, R;
          }(), Et = Qe;
          function nt(R, I) {
            if (!(R instanceof I))
              throw new TypeError("Cannot call a class as a function");
          }
          var vt = function() {
            function R(I, y, T, C) {
              nt(this, R), this.decryptdata = T, this.discardEPB = C, this.decrypter = new m.a(I, y);
            }
            return R.prototype.decryptBuffer = function(y, T) {
              this.decrypter.decrypt(y, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, T);
            }, R.prototype.decryptAacSample = function(y, T, C, L) {
              var D = y[T].unit, V = D.subarray(16, D.length - D.length % 16), N = V.buffer.slice(V.byteOffset, V.byteOffset + V.length), X = this;
              this.decryptBuffer(N, function(Q) {
                Q = new Uint8Array(Q), D.set(Q, 16), L || X.decryptAacSamples(y, T + 1, C);
              });
            }, R.prototype.decryptAacSamples = function(y, T, C) {
              for (; ; T++) {
                if (T >= y.length) {
                  C();
                  return;
                }
                if (!(y[T].unit.length < 32)) {
                  var L = this.decrypter.isSync();
                  if (this.decryptAacSample(y, T, C, L), !L)
                    return;
                }
              }
            }, R.prototype.getAvcEncryptedData = function(y) {
              for (var T = Math.floor((y.length - 48) / 160) * 16 + 16, C = new Int8Array(T), L = 0, D = 32; D <= y.length - 16; D += 160, L += 16)
                C.set(y.subarray(D, D + 16), L);
              return C;
            }, R.prototype.getAvcDecryptedUnit = function(y, T) {
              T = new Uint8Array(T);
              for (var C = 0, L = 32; L <= y.length - 16; L += 160, C += 16)
                y.set(T.subarray(C, C + 16), L);
              return y;
            }, R.prototype.decryptAvcSample = function(y, T, C, L, D, V) {
              var N = this.discardEPB(D.data), X = this.getAvcEncryptedData(N), Q = this;
              this.decryptBuffer(X.buffer, function(H) {
                D.data = Q.getAvcDecryptedUnit(N, H), V || Q.decryptAvcSamples(y, T, C + 1, L);
              });
            }, R.prototype.decryptAvcSamples = function(y, T, C, L) {
              for (; ; T++, C = 0) {
                if (T >= y.length) {
                  L();
                  return;
                }
                for (var D = y[T].units; !(C >= D.length); C++) {
                  var V = D[C];
                  if (!(V.length <= 48 || V.type !== 1 && V.type !== 5)) {
                    var N = this.decrypter.isSync();
                    if (this.decryptAvcSample(y, T, C, L, V, N), !N)
                      return;
                  }
                }
              }
            }, R;
          }(), jt = vt;
          function Rt(R, I) {
            if (!(R instanceof I))
              throw new TypeError("Cannot call a class as a function");
          }
          var ut = {
            video: 0,
            audio: 1,
            id3: 2,
            text: 3
          }, Dt = function() {
            function R(I, y, T, C) {
              Rt(this, R), this.observer = I, this.config = T, this.typeSupported = C, this.remuxer = y, this.sampleAes = null;
            }
            return R.prototype.setDecryptData = function(y) {
              y != null && y.key != null && y.method === "SAMPLE-AES" ? this.sampleAes = new jt(this.observer, this.config, y, this.discardEPB) : this.sampleAes = null;
            }, R.probe = function(y) {
              var T = R._syncOffset(y);
              return T < 0 ? !1 : (T && p.b.warn("MPEG2-TS detected but first sync word found @ offset " + T + ", junk ahead ?"), !0);
            }, R._syncOffset = function(y) {
              for (var T = Math.min(1e3, y.length - 564), C = 0; C < T; ) {
                if (y[C] === 71 && y[C + 188] === 71 && y[C + 2 * 188] === 71)
                  return C;
                C++;
              }
              return -1;
            }, R.createTrack = function(y, T) {
              return {
                container: y === "video" || y === "audio" ? "video/mp2t" : void 0,
                type: y,
                id: ut[y],
                pid: -1,
                inputTimeScale: 9e4,
                sequenceNumber: 0,
                samples: [],
                len: 0,
                dropped: y === "video" ? 0 : void 0,
                isAAC: y === "audio" ? !0 : void 0,
                duration: y === "audio" ? T : void 0
              };
            }, R.prototype.resetInitSegment = function(y, T, C, L) {
              this.pmtParsed = !1, this._pmtId = -1, this._avcTrack = R.createTrack("video", L), this._audioTrack = R.createTrack("audio", L), this._id3Track = R.createTrack("id3", L), this._txtTrack = R.createTrack("text", L), this.aacOverFlow = null, this.aacLastPTS = null, this.avcSample = null, this.audioCodec = T, this.videoCodec = C, this._duration = L;
            }, R.prototype.resetTimeStamp = function() {
            }, R.prototype.append = function(y, T, C, L) {
              var D, V = y.length, N, X, Q, H, ie, re = !1;
              this.contiguous = C;
              var fe = this.pmtParsed, oe = this._avcTrack, le = this._audioTrack, ee = this._id3Track, Ie = oe.pid, et = le.pid, tt = ee.pid, Fe = this._pmtId, Ze = oe.pesData, Te = le.pesData, st = ee.pesData, At = this._parsePAT, rt = this._parsePMT, xt = this._parsePES, Ct = this._parseAVCPES.bind(this), ir = this._parseAACPES.bind(this), Pt = this._parseMPEGPES.bind(this), br = this._parseID3PES.bind(this), zt = R._syncOffset(y);
              for (V -= (V + zt) % 188, D = zt; D < V; D += 188)
                if (y[D] === 71) {
                  if (N = !!(y[D + 1] & 64), X = ((y[D + 1] & 31) << 8) + y[D + 2], Q = (y[D + 3] & 48) >> 4, Q > 1) {
                    if (H = D + 5 + y[D + 4], H === D + 188)
                      continue;
                  } else
                    H = D + 4;
                  switch (X) {
                    case Ie:
                      N && (Ze && (ie = xt(Ze)) && Ct(ie, !1), Ze = { data: [], size: 0 }), Ze && (Ze.data.push(y.subarray(H, D + 188)), Ze.size += D + 188 - H);
                      break;
                    case et:
                      N && (Te && (ie = xt(Te)) && (le.isAAC ? ir(ie) : Pt(ie)), Te = { data: [], size: 0 }), Te && (Te.data.push(y.subarray(H, D + 188)), Te.size += D + 188 - H);
                      break;
                    case tt:
                      N && (st && (ie = xt(st)) && br(ie), st = { data: [], size: 0 }), st && (st.data.push(y.subarray(H, D + 188)), st.size += D + 188 - H);
                      break;
                    case 0:
                      N && (H += y[H] + 1), Fe = this._pmtId = At(y, H);
                      break;
                    case Fe:
                      N && (H += y[H] + 1);
                      var nr = rt(y, H, this.typeSupported.mpeg === !0 || this.typeSupported.mp3 === !0, this.sampleAes != null);
                      Ie = nr.avc, Ie > 0 && (oe.pid = Ie), et = nr.audio, et > 0 && (le.pid = et, le.isAAC = nr.isAAC), tt = nr.id3, tt > 0 && (ee.pid = tt), re && !fe && (p.b.log("reparse from beginning"), re = !1, D = zt - 188), fe = this.pmtParsed = !0;
                      break;
                    case 17:
                    case 8191:
                      break;
                    default:
                      re = !0;
                      break;
                  }
                } else
                  this.observer.trigger(c.a.ERROR, { type: h.b.MEDIA_ERROR, details: h.a.FRAG_PARSING_ERROR, fatal: !1, reason: "TS packet did not start with 0x47" });
              Ze && (ie = xt(Ze)) ? (Ct(ie, !0), oe.pesData = null) : oe.pesData = Ze, Te && (ie = xt(Te)) ? (le.isAAC ? ir(ie) : Pt(ie), le.pesData = null) : (Te && Te.size && p.b.log("last AAC PES packet truncated,might overlap between fragments"), le.pesData = Te), st && (ie = xt(st)) ? (br(ie), ee.pesData = null) : ee.pesData = st, this.sampleAes == null ? this.remuxer.remux(le, oe, ee, this._txtTrack, T, C, L) : this.decryptAndRemux(le, oe, ee, this._txtTrack, T, C, L);
            }, R.prototype.decryptAndRemux = function(y, T, C, L, D, V, N) {
              if (y.samples && y.isAAC) {
                var X = this;
                this.sampleAes.decryptAacSamples(y.samples, 0, function() {
                  X.decryptAndRemuxAvc(y, T, C, L, D, V, N);
                });
              } else
                this.decryptAndRemuxAvc(y, T, C, L, D, V, N);
            }, R.prototype.decryptAndRemuxAvc = function(y, T, C, L, D, V, N) {
              if (T.samples) {
                var X = this;
                this.sampleAes.decryptAvcSamples(T.samples, 0, 0, function() {
                  X.remuxer.remux(y, T, C, L, D, V, N);
                });
              } else
                this.remuxer.remux(y, T, C, L, D, V, N);
            }, R.prototype.destroy = function() {
              this._initPTS = this._initDTS = void 0, this._duration = 0;
            }, R.prototype._parsePAT = function(y, T) {
              return (y[T + 10] & 31) << 8 | y[T + 11];
            }, R.prototype._parsePMT = function(y, T, C, L) {
              var D, V, N, X, Q = { audio: -1, avc: -1, id3: -1, isAAC: !0 };
              for (D = (y[T + 1] & 15) << 8 | y[T + 2], V = T + 3 + D - 4, N = (y[T + 10] & 15) << 8 | y[T + 11], T += 12 + N; T < V; ) {
                switch (X = (y[T + 1] & 31) << 8 | y[T + 2], y[T]) {
                  case 207:
                    if (!L) {
                      p.b.log("unkown stream type:" + y[T]);
                      break;
                    }
                  case 15:
                    Q.audio === -1 && (Q.audio = X);
                    break;
                  case 21:
                    Q.id3 === -1 && (Q.id3 = X);
                    break;
                  case 219:
                    if (!L) {
                      p.b.log("unkown stream type:" + y[T]);
                      break;
                    }
                  case 27:
                    Q.avc === -1 && (Q.avc = X);
                    break;
                  case 3:
                  case 4:
                    C ? Q.audio === -1 && (Q.audio = X, Q.isAAC = !1) : p.b.log("MPEG audio found, not supported in this browser for now");
                    break;
                  case 36:
                    p.b.warn("HEVC stream type found, not supported for now");
                    break;
                  default:
                    p.b.log("unkown stream type:" + y[T]);
                    break;
                }
                T += ((y[T + 3] & 15) << 8 | y[T + 4]) + 5;
              }
              return Q;
            }, R.prototype._parsePES = function(y) {
              var T = 0, C, L, D, V, N, X, Q, H, ie, re = y.data;
              if (!y || y.size === 0)
                return null;
              for (; re[0].length < 19 && re.length > 1; ) {
                var fe = new Uint8Array(re[0].length + re[1].length);
                fe.set(re[0]), fe.set(re[1], re[0].length), re[0] = fe, re.splice(1, 1);
              }
              if (C = re[0], D = (C[0] << 16) + (C[1] << 8) + C[2], D === 1) {
                if (V = (C[4] << 8) + C[5], V && V > y.size - 6)
                  return null;
                L = C[7], L & 192 && (Q = (C[9] & 14) * 536870912 + // 1 << 29
                (C[10] & 255) * 4194304 + // 1 << 22
                (C[11] & 254) * 16384 + // 1 << 14
                (C[12] & 255) * 128 + // 1 << 7
                (C[13] & 254) / 2, Q > 4294967295 && (Q -= 8589934592), L & 64 ? (H = (C[14] & 14) * 536870912 + // 1 << 29
                (C[15] & 255) * 4194304 + // 1 << 22
                (C[16] & 254) * 16384 + // 1 << 14
                (C[17] & 255) * 128 + // 1 << 7
                (C[18] & 254) / 2, H > 4294967295 && (H -= 8589934592), Q - H > 60 * 9e4 && (p.b.warn(Math.round((Q - H) / 9e4) + "s delta between PTS and DTS, align them"), Q = H)) : H = Q), N = C[8], ie = N + 9, y.size -= ie, X = new Uint8Array(y.size);
                for (var oe = 0, le = re.length; oe < le; oe++) {
                  C = re[oe];
                  var ee = C.byteLength;
                  if (ie)
                    if (ie > ee) {
                      ie -= ee;
                      continue;
                    } else
                      C = C.subarray(ie), ee -= ie, ie = 0;
                  X.set(C, T), T += ee;
                }
                return V && (V -= N + 3), { data: X, pts: Q, dts: H, len: V };
              } else
                return null;
            }, R.prototype.pushAccesUnit = function(y, T) {
              if (y.units.length && y.frame) {
                var C = T.samples, L = C.length;
                !this.config.forceKeyFrameOnDiscontinuity || y.key === !0 || T.sps && (L || this.contiguous) ? (y.id = L, C.push(y)) : T.dropped++;
              }
              y.debug.length && p.b.log(y.pts + "/" + y.dts + ":" + y.debug);
            }, R.prototype._parseAVCPES = function(y, T) {
              var C = this, L = this._avcTrack, D = this._parseAVCNALu(y.data), V, N = this.avcSample, X, Q = !1, H, ie = this.pushAccesUnit.bind(this), re = function(oe, le, ee, Ie) {
                return { key: oe, pts: le, dts: ee, units: [], debug: Ie };
              };
              y.data = null, N && D.length && !L.audFound && (ie(N, L), N = this.avcSample = re(!1, y.pts, y.dts, "")), D.forEach(function(fe) {
                switch (fe.type) {
                  case 1:
                    X = !0, N || (N = C.avcSample = re(!0, y.pts, y.dts, "")), N.frame = !0;
                    var oe = fe.data;
                    if (Q && oe.length > 4) {
                      var le = new Et(oe).readSliceType();
                      (le === 2 || le === 4 || le === 7 || le === 9) && (N.key = !0);
                    }
                    break;
                  case 5:
                    X = !0, N || (N = C.avcSample = re(!0, y.pts, y.dts, "")), N.key = !0, N.frame = !0;
                    break;
                  case 6:
                    X = !0, V = new Et(C.discardEPB(fe.data)), V.readUByte();
                    for (var ee = 0, Ie = 0, et = !1, tt = 0; !et && V.bytesAvailable > 1; ) {
                      ee = 0;
                      do
                        tt = V.readUByte(), ee += tt;
                      while (tt === 255);
                      Ie = 0;
                      do
                        tt = V.readUByte(), Ie += tt;
                      while (tt === 255);
                      if (ee === 4 && V.bytesAvailable !== 0) {
                        et = !0;
                        var Fe = V.readUByte();
                        if (Fe === 181) {
                          var Ze = V.readUShort();
                          if (Ze === 49) {
                            var Te = V.readUInt();
                            if (Te === 1195456820) {
                              var st = V.readUByte();
                              if (st === 3) {
                                var At = V.readUByte(), rt = V.readUByte(), xt = 31 & At, Ct = [At, rt];
                                for (H = 0; H < xt; H++)
                                  Ct.push(V.readUByte()), Ct.push(V.readUByte()), Ct.push(V.readUByte());
                                C._insertSampleInOrder(C._txtTrack.samples, { type: 3, pts: y.pts, bytes: Ct });
                              }
                            }
                          }
                        }
                      } else if (Ie < V.bytesAvailable)
                        for (H = 0; H < Ie; H++)
                          V.readUByte();
                    }
                    break;
                  case 7:
                    if (X = !0, Q = !0, !L.sps) {
                      V = new Et(fe.data);
                      var ir = V.readSPS();
                      L.width = ir.width, L.height = ir.height, L.pixelRatio = ir.pixelRatio, L.sps = [fe.data], L.duration = C._duration;
                      var Pt = fe.data.subarray(1, 4), br = "avc1.";
                      for (H = 0; H < 3; H++) {
                        var zt = Pt[H].toString(16);
                        zt.length < 2 && (zt = "0" + zt), br += zt;
                      }
                      L.codec = br;
                    }
                    break;
                  case 8:
                    X = !0, L.pps || (L.pps = [fe.data]);
                    break;
                  case 9:
                    X = !1, L.audFound = !0, N && ie(N, L), N = C.avcSample = re(!1, y.pts, y.dts, "");
                    break;
                  case 12:
                    X = !1;
                    break;
                  default:
                    X = !1, N && (N.debug += "unknown NAL " + fe.type + " ");
                    break;
                }
                if (N && X) {
                  var nr = N.units;
                  nr.push(fe);
                }
              }), T && N && (ie(N, L), this.avcSample = null);
            }, R.prototype._insertSampleInOrder = function(y, T) {
              var C = y.length;
              if (C > 0) {
                if (T.pts >= y[C - 1].pts)
                  y.push(T);
                else
                  for (var L = C - 1; L >= 0; L--)
                    if (T.pts < y[L].pts) {
                      y.splice(L, 0, T);
                      break;
                    }
              } else
                y.push(T);
            }, R.prototype._getLastNalUnit = function() {
              var y = this.avcSample, T = void 0;
              if (!y || y.units.length === 0) {
                var C = this._avcTrack, L = C.samples;
                y = L[L.length - 1];
              }
              if (y) {
                var D = y.units;
                T = D[D.length - 1];
              }
              return T;
            }, R.prototype._parseAVCNALu = function(y) {
              var T = 0, C = y.byteLength, L, D, V = this._avcTrack, N = V.naluState || 0, X = N, Q = [], H, ie, re = -1, fe;
              for (N === -1 && (re = 0, fe = y[0] & 31, N = 0, T = 1); T < C; ) {
                if (L = y[T++], !N) {
                  N = L ? 0 : 1;
                  continue;
                }
                if (N === 1) {
                  N = L ? 0 : 2;
                  continue;
                }
                if (!L)
                  N = 3;
                else if (L === 1) {
                  if (re >= 0)
                    H = { data: y.subarray(re, T - N - 1), type: fe }, Q.push(H);
                  else {
                    var oe = this._getLastNalUnit();
                    if (oe && (X && T <= 4 - X && oe.state && (oe.data = oe.data.subarray(0, oe.data.byteLength - X)), D = T - N - 1, D > 0)) {
                      var le = new Uint8Array(oe.data.byteLength + D);
                      le.set(oe.data, 0), le.set(y.subarray(0, D), oe.data.byteLength), oe.data = le;
                    }
                  }
                  T < C ? (ie = y[T] & 31, re = T, fe = ie, N = 0) : N = -1;
                } else
                  N = 0;
              }
              if (re >= 0 && N >= 0 && (H = { data: y.subarray(re, C), type: fe, state: N }, Q.push(H)), Q.length === 0) {
                var ee = this._getLastNalUnit();
                if (ee) {
                  var Ie = new Uint8Array(ee.data.byteLength + y.byteLength);
                  Ie.set(ee.data, 0), Ie.set(y, ee.data.byteLength), ee.data = Ie;
                }
              }
              return V.naluState = N, Q;
            }, R.prototype.discardEPB = function(y) {
              for (var T = y.byteLength, C = [], L = 1, D, V; L < T - 2; )
                y[L] === 0 && y[L + 1] === 0 && y[L + 2] === 3 ? (C.push(L + 2), L += 2) : L++;
              if (C.length === 0)
                return y;
              D = T - C.length, V = new Uint8Array(D);
              var N = 0;
              for (L = 0; L < D; N++, L++)
                N === C[0] && (N++, C.shift()), V[L] = y[N];
              return V;
            }, R.prototype._parseAACPES = function(y) {
              var T = this._audioTrack, C = y.data, L = y.pts, D = 0, V = this.aacOverFlow, N = this.aacLastPTS, X, Q, H, ie, re;
              if (V) {
                var fe = new Uint8Array(V.byteLength + C.byteLength);
                fe.set(V, 0), fe.set(C, V.byteLength), C = fe;
              }
              for (H = D, re = C.length; H < re - 1 && !M(C, H); H++)
                ;
              if (H) {
                var oe, le;
                if (H < re - 1 ? (oe = "AAC PES did not start with ADTS header,offset:" + H, le = !1) : (oe = "no ADTS header found in AAC PES", le = !0), p.b.warn("parsing error:" + oe), this.observer.trigger(c.a.ERROR, { type: h.b.MEDIA_ERROR, details: h.a.FRAG_PARSING_ERROR, fatal: le, reason: oe }), le)
                  return;
              }
              if (W(T, this.observer, C, H, this.audioCodec), Q = 0, X = J(T.samplerate), V && N) {
                var ee = N + X;
                Math.abs(ee - L) > 1 && (p.b.log("AAC: align PTS for overlapping frames by " + Math.round((ee - L) / 90)), L = ee);
              }
              for (; H < re; )
                if (M(C, H) && H + 5 < re) {
                  var Ie = U(T, C, H, L, Q);
                  if (Ie)
                    H += Ie.length, ie = Ie.sample.pts, Q++;
                  else
                    break;
                } else
                  H++;
              H < re ? V = C.subarray(H, re) : V = null, this.aacOverFlow = V, this.aacLastPTS = ie;
            }, R.prototype._parseMPEGPES = function(y) {
              for (var T = y.data, C = T.length, L = 0, D = 0, V = y.pts; D < C; )
                if (Ge.isHeader(T, D)) {
                  var N = Ge.appendFrame(this._audioTrack, T, D, V, L);
                  if (N)
                    D += N.length, L++;
                  else
                    break;
                } else
                  D++;
            }, R.prototype._parseID3PES = function(y) {
              this._id3Track.samples.push(y);
            }, R;
          }(), qe = Dt;
          function Pr(R, I) {
            if (!(R instanceof I))
              throw new TypeError("Cannot call a class as a function");
          }
          var ct = function() {
            function R(I, y, T) {
              Pr(this, R), this.observer = I, this.config = T, this.remuxer = y;
            }
            return R.prototype.resetInitSegment = function(y, T, C, L) {
              this._audioTrack = { container: "audio/mpeg", type: "audio", id: -1, sequenceNumber: 0, isAAC: !1, samples: [], len: 0, manifestCodec: T, duration: L, inputTimeScale: 9e4 };
            }, R.prototype.resetTimeStamp = function() {
            }, R.probe = function(y) {
              var T, C, L = F.a.getID3Data(y, 0);
              if (L && F.a.getTimeStamp(L) !== void 0) {
                for (T = L.length, C = Math.min(y.length - 1, T + 100); T < C; T++)
                  if (Ge.probe(y, T))
                    return p.b.log("MPEG Audio sync word found !"), !0;
              }
              return !1;
            }, R.prototype.append = function(y, T, C, L) {
              for (var D = F.a.getID3Data(y, 0), V = F.a.getTimeStamp(D), N = V ? 90 * V : T * 9e4, X = D.length, Q = y.length, H = 0, ie = 0, re = this._audioTrack, fe = [{ pts: N, dts: N, data: D }]; X < Q; )
                if (Ge.isHeader(y, X)) {
                  var oe = Ge.appendFrame(re, y, X, N, H);
                  if (oe)
                    X += oe.length, ie = oe.sample.pts, H++;
                  else
                    break;
                } else F.a.isHeader(y, X) ? (D = F.a.getID3Data(y, X), fe.push({ pts: ie, dts: ie, data: D }), X += D.length) : X++;
              this.remuxer.remux(re, { samples: [] }, { samples: fe, inputTimeScale: 9e4 }, { samples: [] }, T, C, L);
            }, R.prototype.destroy = function() {
            }, R;
          }(), tn = ct;
          function dr(R, I) {
            if (!(R instanceof I))
              throw new TypeError("Cannot call a class as a function");
          }
          var fr = function() {
            function R() {
              dr(this, R);
            }
            return R.getSilentFrame = function(y, T) {
              switch (y) {
                case "mp4a.40.2":
                  if (T === 1)
                    return new Uint8Array([0, 200, 0, 128, 35, 128]);
                  if (T === 2)
                    return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
                  if (T === 3)
                    return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
                  if (T === 4)
                    return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
                  if (T === 5)
                    return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
                  if (T === 6)
                    return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
                  break;
                default:
                  if (T === 1)
                    return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                  if (T === 2)
                    return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                  if (T === 3)
                    return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                  break;
              }
              return null;
            }, R;
          }(), Ft = fr;
          function pr(R, I) {
            if (!(R instanceof I))
              throw new TypeError("Cannot call a class as a function");
          }
          var hr = Math.pow(2, 32) - 1, Br = function() {
            function R() {
              pr(this, R);
            }
            return R.init = function() {
              R.types = {
                avc1: [],
                // codingname
                avcC: [],
                btrt: [],
                dinf: [],
                dref: [],
                esds: [],
                ftyp: [],
                hdlr: [],
                mdat: [],
                mdhd: [],
                mdia: [],
                mfhd: [],
                minf: [],
                moof: [],
                moov: [],
                mp4a: [],
                ".mp3": [],
                mvex: [],
                mvhd: [],
                pasp: [],
                sdtp: [],
                stbl: [],
                stco: [],
                stsc: [],
                stsd: [],
                stsz: [],
                stts: [],
                tfdt: [],
                tfhd: [],
                traf: [],
                trak: [],
                trun: [],
                trex: [],
                tkhd: [],
                vmhd: [],
                smhd: []
              };
              var y;
              for (y in R.types)
                R.types.hasOwnProperty(y) && (R.types[y] = [y.charCodeAt(0), y.charCodeAt(1), y.charCodeAt(2), y.charCodeAt(3)]);
              var T = new Uint8Array([
                0,
                // version 0
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                0,
                // pre_defined
                118,
                105,
                100,
                101,
                // handler_type: 'vide'
                0,
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                0,
                // reserved
                86,
                105,
                100,
                101,
                111,
                72,
                97,
                110,
                100,
                108,
                101,
                114,
                0
                // name: 'VideoHandler'
              ]), C = new Uint8Array([
                0,
                // version 0
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                0,
                // pre_defined
                115,
                111,
                117,
                110,
                // handler_type: 'soun'
                0,
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                0,
                // reserved
                83,
                111,
                117,
                110,
                100,
                72,
                97,
                110,
                100,
                108,
                101,
                114,
                0
                // name: 'SoundHandler'
              ]);
              R.HDLR_TYPES = {
                video: T,
                audio: C
              };
              var L = new Uint8Array([
                0,
                // version 0
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                1,
                // entry_count
                0,
                0,
                0,
                12,
                // entry_size
                117,
                114,
                108,
                32,
                // 'url' type
                0,
                // version 0
                0,
                0,
                1
                // entry_flags
              ]), D = new Uint8Array([
                0,
                // version
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                0
                // entry_count
              ]);
              R.STTS = R.STSC = R.STCO = D, R.STSZ = new Uint8Array([
                0,
                // version
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                0,
                // sample_size
                0,
                0,
                0,
                0
              ]), R.VMHD = new Uint8Array([
                0,
                // version
                0,
                0,
                1,
                // flags
                0,
                0,
                // graphicsmode
                0,
                0,
                0,
                0,
                0,
                0
                // opcolor
              ]), R.SMHD = new Uint8Array([
                0,
                // version
                0,
                0,
                0,
                // flags
                0,
                0,
                // balance
                0,
                0
                // reserved
              ]), R.STSD = new Uint8Array([
                0,
                // version 0
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                1
              ]);
              var V = new Uint8Array([105, 115, 111, 109]), N = new Uint8Array([97, 118, 99, 49]), X = new Uint8Array([0, 0, 0, 1]);
              R.FTYP = R.box(R.types.ftyp, V, X, V, N), R.DINF = R.box(R.types.dinf, R.box(R.types.dref, L));
            }, R.box = function(y) {
              for (var T = Array.prototype.slice.call(arguments, 1), C = 8, L = T.length, D = L, V; L--; )
                C += T[L].byteLength;
              for (V = new Uint8Array(C), V[0] = C >> 24 & 255, V[1] = C >> 16 & 255, V[2] = C >> 8 & 255, V[3] = C & 255, V.set(y, 4), L = 0, C = 8; L < D; L++)
                V.set(T[L], C), C += T[L].byteLength;
              return V;
            }, R.hdlr = function(y) {
              return R.box(R.types.hdlr, R.HDLR_TYPES[y]);
            }, R.mdat = function(y) {
              return R.box(R.types.mdat, y);
            }, R.mdhd = function(y, T) {
              T *= y;
              var C = Math.floor(T / (hr + 1)), L = Math.floor(T % (hr + 1));
              return R.box(R.types.mdhd, new Uint8Array([
                1,
                // version 1
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                2,
                // creation_time
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                3,
                // modification_time
                y >> 24 & 255,
                y >> 16 & 255,
                y >> 8 & 255,
                y & 255,
                // timescale
                C >> 24,
                C >> 16 & 255,
                C >> 8 & 255,
                C & 255,
                L >> 24,
                L >> 16 & 255,
                L >> 8 & 255,
                L & 255,
                85,
                196,
                // 'und' language (undetermined)
                0,
                0
              ]));
            }, R.mdia = function(y) {
              return R.box(R.types.mdia, R.mdhd(y.timescale, y.duration), R.hdlr(y.type), R.minf(y));
            }, R.mfhd = function(y) {
              return R.box(
                R.types.mfhd,
                new Uint8Array([
                  0,
                  0,
                  0,
                  0,
                  // flags
                  y >> 24,
                  y >> 16 & 255,
                  y >> 8 & 255,
                  y & 255
                ])
                // sequence_number
              );
            }, R.minf = function(y) {
              return y.type === "audio" ? R.box(R.types.minf, R.box(R.types.smhd, R.SMHD), R.DINF, R.stbl(y)) : R.box(R.types.minf, R.box(R.types.vmhd, R.VMHD), R.DINF, R.stbl(y));
            }, R.moof = function(y, T, C) {
              return R.box(R.types.moof, R.mfhd(y), R.traf(C, T));
            }, R.moov = function(y) {
              for (var T = y.length, C = []; T--; )
                C[T] = R.trak(y[T]);
              return R.box.apply(null, [R.types.moov, R.mvhd(y[0].timescale, y[0].duration)].concat(C).concat(R.mvex(y)));
            }, R.mvex = function(y) {
              for (var T = y.length, C = []; T--; )
                C[T] = R.trex(y[T]);
              return R.box.apply(null, [R.types.mvex].concat(C));
            }, R.mvhd = function(y, T) {
              T *= y;
              var C = Math.floor(T / (hr + 1)), L = Math.floor(T % (hr + 1)), D = new Uint8Array([
                1,
                // version 1
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                2,
                // creation_time
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                3,
                // modification_time
                y >> 24 & 255,
                y >> 16 & 255,
                y >> 8 & 255,
                y & 255,
                // timescale
                C >> 24,
                C >> 16 & 255,
                C >> 8 & 255,
                C & 255,
                L >> 24,
                L >> 16 & 255,
                L >> 8 & 255,
                L & 255,
                0,
                1,
                0,
                0,
                // 1.0 rate
                1,
                0,
                // 1.0 volume
                0,
                0,
                // reserved
                0,
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                0,
                // reserved
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                64,
                0,
                0,
                0,
                // transformation: unity matrix
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                // pre_defined
                255,
                255,
                255,
                255
                // next_track_ID
              ]);
              return R.box(R.types.mvhd, D);
            }, R.sdtp = function(y) {
              var T = y.samples || [], C = new Uint8Array(4 + T.length), L, D;
              for (D = 0; D < T.length; D++)
                L = T[D].flags, C[D + 4] = L.dependsOn << 4 | L.isDependedOn << 2 | L.hasRedundancy;
              return R.box(R.types.sdtp, C);
            }, R.stbl = function(y) {
              return R.box(R.types.stbl, R.stsd(y), R.box(R.types.stts, R.STTS), R.box(R.types.stsc, R.STSC), R.box(R.types.stsz, R.STSZ), R.box(R.types.stco, R.STCO));
            }, R.avc1 = function(y) {
              var T = [], C = [], L, D, V;
              for (L = 0; L < y.sps.length; L++)
                D = y.sps[L], V = D.byteLength, T.push(V >>> 8 & 255), T.push(V & 255), T = T.concat(Array.prototype.slice.call(D));
              for (L = 0; L < y.pps.length; L++)
                D = y.pps[L], V = D.byteLength, C.push(V >>> 8 & 255), C.push(V & 255), C = C.concat(Array.prototype.slice.call(D));
              var N = R.box(R.types.avcC, new Uint8Array([
                1,
                // version
                T[3],
                // profile
                T[4],
                // profile compat
                T[5],
                // level
                255,
                // lengthSizeMinusOne, hard-coded to 4 bytes
                224 | y.sps.length
                // 3bit reserved (111) + numOfSequenceParameterSets
              ].concat(T).concat([
                y.pps.length
                // numOfPictureParameterSets
              ]).concat(C))), X = y.width, Q = y.height, H = y.pixelRatio[0], ie = y.pixelRatio[1];
              return R.box(
                R.types.avc1,
                new Uint8Array([
                  0,
                  0,
                  0,
                  // reserved
                  0,
                  0,
                  0,
                  // reserved
                  0,
                  1,
                  // data_reference_index
                  0,
                  0,
                  // pre_defined
                  0,
                  0,
                  // reserved
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  // pre_defined
                  X >> 8 & 255,
                  X & 255,
                  // width
                  Q >> 8 & 255,
                  Q & 255,
                  // height
                  0,
                  72,
                  0,
                  0,
                  // horizresolution
                  0,
                  72,
                  0,
                  0,
                  // vertresolution
                  0,
                  0,
                  0,
                  0,
                  // reserved
                  0,
                  1,
                  // frame_count
                  18,
                  100,
                  97,
                  105,
                  108,
                  //dailymotion/hls.js
                  121,
                  109,
                  111,
                  116,
                  105,
                  111,
                  110,
                  47,
                  104,
                  108,
                  115,
                  46,
                  106,
                  115,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  // compressorname
                  0,
                  24,
                  // depth = 24
                  17,
                  17
                ]),
                // pre_defined = -1
                N,
                R.box(R.types.btrt, new Uint8Array([
                  0,
                  28,
                  156,
                  128,
                  // bufferSizeDB
                  0,
                  45,
                  198,
                  192,
                  // maxBitrate
                  0,
                  45,
                  198,
                  192
                ])),
                // avgBitrate
                R.box(R.types.pasp, new Uint8Array([
                  H >> 24,
                  // hSpacing
                  H >> 16 & 255,
                  H >> 8 & 255,
                  H & 255,
                  ie >> 24,
                  // vSpacing
                  ie >> 16 & 255,
                  ie >> 8 & 255,
                  ie & 255
                ]))
              );
            }, R.esds = function(y) {
              var T = y.config.length;
              return new Uint8Array([
                0,
                // version 0
                0,
                0,
                0,
                // flags
                3,
                // descriptor_type
                23 + T,
                // length
                0,
                1,
                //es_id
                0,
                // stream_priority
                4,
                // descriptor_type
                15 + T,
                // length
                64,
                //codec : mpeg4_audio
                21,
                // stream_type
                0,
                0,
                0,
                // buffer_size
                0,
                0,
                0,
                0,
                // maxBitrate
                0,
                0,
                0,
                0,
                // avgBitrate
                5
                // descriptor_type
              ].concat([T]).concat(y.config).concat([6, 1, 2]));
            }, R.mp4a = function(y) {
              var T = y.samplerate;
              return R.box(R.types.mp4a, new Uint8Array([
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                // reserved
                0,
                1,
                // data_reference_index
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                // reserved
                0,
                y.channelCount,
                // channelcount
                0,
                16,
                // sampleSize:16bits
                0,
                0,
                0,
                0,
                // reserved2
                T >> 8 & 255,
                T & 255,
                //
                0,
                0
              ]), R.box(R.types.esds, R.esds(y)));
            }, R.mp3 = function(y) {
              var T = y.samplerate;
              return R.box(R.types[".mp3"], new Uint8Array([
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                // reserved
                0,
                1,
                // data_reference_index
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                // reserved
                0,
                y.channelCount,
                // channelcount
                0,
                16,
                // sampleSize:16bits
                0,
                0,
                0,
                0,
                // reserved2
                T >> 8 & 255,
                T & 255,
                //
                0,
                0
              ]));
            }, R.stsd = function(y) {
              return y.type === "audio" ? !y.isAAC && y.codec === "mp3" ? R.box(R.types.stsd, R.STSD, R.mp3(y)) : R.box(R.types.stsd, R.STSD, R.mp4a(y)) : R.box(R.types.stsd, R.STSD, R.avc1(y));
            }, R.tkhd = function(y) {
              var T = y.id, C = y.duration * y.timescale, L = y.width, D = y.height, V = Math.floor(C / (hr + 1)), N = Math.floor(C % (hr + 1));
              return R.box(R.types.tkhd, new Uint8Array([
                1,
                // version 1
                0,
                0,
                7,
                // flags
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                2,
                // creation_time
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                3,
                // modification_time
                T >> 24 & 255,
                T >> 16 & 255,
                T >> 8 & 255,
                T & 255,
                // track_ID
                0,
                0,
                0,
                0,
                // reserved
                V >> 24,
                V >> 16 & 255,
                V >> 8 & 255,
                V & 255,
                N >> 24,
                N >> 16 & 255,
                N >> 8 & 255,
                N & 255,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                // reserved
                0,
                0,
                // layer
                0,
                0,
                // alternate_group
                0,
                0,
                // non-audio track volume
                0,
                0,
                // reserved
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                64,
                0,
                0,
                0,
                // transformation: unity matrix
                L >> 8 & 255,
                L & 255,
                0,
                0,
                // width
                D >> 8 & 255,
                D & 255,
                0,
                0
                // height
              ]));
            }, R.traf = function(y, T) {
              var C = R.sdtp(y), L = y.id, D = Math.floor(T / (hr + 1)), V = Math.floor(T % (hr + 1));
              return R.box(
                R.types.traf,
                R.box(
                  R.types.tfhd,
                  new Uint8Array([
                    0,
                    // version 0
                    0,
                    0,
                    0,
                    // flags
                    L >> 24,
                    L >> 16 & 255,
                    L >> 8 & 255,
                    L & 255
                  ])
                  // track_ID
                ),
                R.box(R.types.tfdt, new Uint8Array([
                  1,
                  // version 1
                  0,
                  0,
                  0,
                  // flags
                  D >> 24,
                  D >> 16 & 255,
                  D >> 8 & 255,
                  D & 255,
                  V >> 24,
                  V >> 16 & 255,
                  V >> 8 & 255,
                  V & 255
                ])),
                R.trun(y, C.length + 16 + // tfhd
                20 + // tfdt
                8 + // traf header
                16 + // mfhd
                8 + // moof header
                8),
                // mdat header
                C
              );
            }, R.trak = function(y) {
              return y.duration = y.duration || 4294967295, R.box(R.types.trak, R.tkhd(y), R.mdia(y));
            }, R.trex = function(y) {
              var T = y.id;
              return R.box(R.types.trex, new Uint8Array([
                0,
                // version 0
                0,
                0,
                0,
                // flags
                T >> 24,
                T >> 16 & 255,
                T >> 8 & 255,
                T & 255,
                // track_ID
                0,
                0,
                0,
                1,
                // default_sample_description_index
                0,
                0,
                0,
                0,
                // default_sample_duration
                0,
                0,
                0,
                0,
                // default_sample_size
                0,
                1,
                0,
                1
                // default_sample_flags
              ]));
            }, R.trun = function(y, T) {
              var C = y.samples || [], L = C.length, D = 12 + 16 * L, V = new Uint8Array(D), N, X, Q, H, ie, re;
              for (T += 8 + D, V.set([
                0,
                // version 0
                0,
                15,
                1,
                // flags
                L >>> 24 & 255,
                L >>> 16 & 255,
                L >>> 8 & 255,
                L & 255,
                // sample_count
                T >>> 24 & 255,
                T >>> 16 & 255,
                T >>> 8 & 255,
                T & 255
                // data_offset
              ], 0), N = 0; N < L; N++)
                X = C[N], Q = X.duration, H = X.size, ie = X.flags, re = X.cts, V.set([
                  Q >>> 24 & 255,
                  Q >>> 16 & 255,
                  Q >>> 8 & 255,
                  Q & 255,
                  // sample_duration
                  H >>> 24 & 255,
                  H >>> 16 & 255,
                  H >>> 8 & 255,
                  H & 255,
                  // sample_size
                  ie.isLeading << 2 | ie.dependsOn,
                  ie.isDependedOn << 6 | ie.hasRedundancy << 4 | ie.paddingValue << 1 | ie.isNonSync,
                  ie.degradPrio & 61440,
                  ie.degradPrio & 15,
                  // sample_flags
                  re >>> 24 & 255,
                  re >>> 16 & 255,
                  re >>> 8 & 255,
                  re & 255
                  // sample_composition_time_offset
                ], 12 + 16 * N);
              return R.box(R.types.trun, V);
            }, R.initSegment = function(y) {
              R.types || R.init();
              var T = R.moov(y), C;
              return C = new Uint8Array(R.FTYP.byteLength + T.byteLength), C.set(R.FTYP), C.set(T, R.FTYP.byteLength), C;
            }, R;
          }(), kr = Br;
          function dt(R, I) {
            if (!(R instanceof I))
              throw new TypeError("Cannot call a class as a function");
          }
          var St = 10 * 1e3, Sn = function() {
            function R(I, y, T, C) {
              dt(this, R), this.observer = I, this.config = y, this.typeSupported = T;
              var L = navigator.userAgent;
              this.isSafari = C && C.indexOf("Apple") > -1 && L && !L.match("CriOS"), this.ISGenerated = !1;
            }
            return R.prototype.destroy = function() {
            }, R.prototype.resetTimeStamp = function(y) {
              this._initPTS = this._initDTS = y;
            }, R.prototype.resetInitSegment = function() {
              this.ISGenerated = !1;
            }, R.prototype.remux = function(y, T, C, L, D, V, N) {
              if (this.ISGenerated || this.generateIS(y, T, D), this.ISGenerated) {
                var X = y.samples.length, Q = T.samples.length, H = D, ie = D;
                if (X && Q) {
                  var re = (y.samples[0].dts - T.samples[0].dts) / T.inputTimeScale;
                  H += Math.max(0, re), ie += Math.max(0, -re);
                }
                if (X) {
                  y.timescale || (p.b.warn("regenerate InitSegment as audio detected"), this.generateIS(y, T, D));
                  var fe = this.remuxAudio(y, H, V, N);
                  if (Q) {
                    var oe = void 0;
                    fe && (oe = fe.endPTS - fe.startPTS), T.timescale || (p.b.warn("regenerate InitSegment as video detected"), this.generateIS(y, T, D)), this.remuxVideo(T, ie, V, oe, N);
                  }
                } else {
                  var le = void 0;
                  Q && (le = this.remuxVideo(T, ie, V, N)), le && y.codec && this.remuxEmptyAudio(y, H, V, le);
                }
              }
              C.samples.length && this.remuxID3(C, D), L.samples.length && this.remuxText(L, D), this.observer.trigger(c.a.FRAG_PARSED);
            }, R.prototype.generateIS = function(y, T, C) {
              var L = this.observer, D = y.samples, V = T.samples, N = this.typeSupported, X = "audio/mp4", Q = {}, H = { tracks: Q }, ie = this._initPTS === void 0, re, fe;
              if (ie && (re = fe = 1 / 0), y.config && D.length && (y.timescale = y.samplerate, p.b.log("audio sampling rate : " + y.samplerate), y.isAAC || (N.mpeg ? (X = "audio/mpeg", y.codec = "") : N.mp3 && (y.codec = "mp3")), Q.audio = {
                container: X,
                codec: y.codec,
                initSegment: !y.isAAC && N.mpeg ? new Uint8Array() : kr.initSegment([y]),
                metadata: {
                  channelCount: y.channelCount
                }
              }, ie && (re = fe = D[0].pts - y.inputTimeScale * C)), T.sps && T.pps && V.length) {
                var oe = T.inputTimeScale;
                T.timescale = oe, Q.video = {
                  container: "video/mp4",
                  codec: T.codec,
                  initSegment: kr.initSegment([T]),
                  metadata: {
                    width: T.width,
                    height: T.height
                  }
                }, ie && (re = Math.min(re, V[0].pts - oe * C), fe = Math.min(fe, V[0].dts - oe * C), this.observer.trigger(c.a.INIT_PTS_FOUND, { initPTS: re }));
              }
              Object.keys(Q).length ? (L.trigger(c.a.FRAG_PARSING_INIT_SEGMENT, H), this.ISGenerated = !0, ie && (this._initPTS = re, this._initDTS = fe)) : L.trigger(c.a.ERROR, { type: h.b.MEDIA_ERROR, details: h.a.FRAG_PARSING_ERROR, fatal: !1, reason: "no audio/video samples found" });
            }, R.prototype.remuxVideo = function(y, T, C, L, D) {
              var V = 8, N = y.timescale, X, Q, H, ie, re, fe, oe, le = y.samples, ee = [], Ie = le.length, et = this._PTSNormalize, tt = this._initDTS, Fe = this.nextAvcDts, Ze = this.isSafari;
              Ze && (C |= le.length && Fe && (D && Math.abs(T - Fe / N) < 0.1 || Math.abs(le[0].pts - Fe - tt) < N / 5)), C || (Fe = T * N), le.forEach(function(gr) {
                gr.pts = et(gr.pts - tt, Fe), gr.dts = et(gr.dts - tt, Fe);
              }), le.sort(function(gr, nn) {
                var zl = gr.dts - nn.dts, Xl = gr.pts - nn.pts;
                return zl || Xl || gr.id - nn.id;
              });
              var Te = le.reduce(function(gr, nn) {
                return Math.max(Math.min(gr, nn.pts - nn.dts), -18e3);
              }, 0);
              if (Te < 0) {
                p.b.warn("PTS < DTS detected in video samples, shifting DTS by " + Math.round(Te / 90) + " ms to overcome this issue");
                for (var st = 0; st < le.length; st++)
                  le[st].dts += Te;
              }
              var At = le[0];
              re = Math.max(At.dts, 0), ie = Math.max(At.pts, 0);
              var rt = Math.round((re - Fe) / 90);
              C && rt && (rt > 1 ? p.b.log("AVC:" + rt + " ms hole between fragments detected,filling it") : rt < -1 && p.b.log("AVC:" + -rt + " ms overlapping between fragments detected"), re = Fe, le[0].dts = re, ie = Math.max(ie - rt, Fe), le[0].pts = ie, p.b.log("Video/PTS/DTS adjusted: " + Math.round(ie / 90) + "/" + Math.round(re / 90) + ",delta:" + rt + " ms")), At = le[le.length - 1], oe = Math.max(At.dts, 0), fe = Math.max(At.pts, 0, oe), Ze && (X = Math.round((oe - re) / (le.length - 1)));
              for (var xt = 0, Ct = 0, ir = 0; ir < Ie; ir++) {
                for (var Pt = le[ir], br = Pt.units, zt = br.length, nr = 0, _i = 0; _i < zt; _i++)
                  nr += br[_i].data.length;
                Ct += nr, xt += zt, Pt.length = nr, Ze ? Pt.dts = re + ir * X : Pt.dts = Math.max(Pt.dts, re), Pt.pts = Math.max(Pt.pts, Pt.dts);
              }
              var wi = Ct + 4 * xt + 8;
              try {
                Q = new Uint8Array(wi);
              } catch {
                this.observer.trigger(c.a.ERROR, { type: h.b.MUX_ERROR, details: h.a.REMUX_ALLOC_ERROR, fatal: !1, bytes: wi, reason: "fail allocating video mdat " + wi });
                return;
              }
              var Cn = new DataView(Q.buffer);
              Cn.setUint32(0, wi), Q.set(kr.types.mdat, 4);
              for (var Xt = 0; Xt < Ie; Xt++) {
                for (var _t = le[Xt], Ir = _t.units, Ti = 0, Hr = void 0, Ln = 0, cs = Ir.length; Ln < cs; Ln++) {
                  var kn = Ir[Ln], Dn = kn.data, Zr = kn.data.byteLength;
                  Cn.setUint32(V, Zr), V += 4, Q.set(Dn, V), V += Zr, Ti += 4 + Zr;
                }
                if (Ze)
                  Hr = Math.max(0, X * Math.round((_t.pts - _t.dts) / X));
                else {
                  if (Xt < Ie - 1)
                    X = le[Xt + 1].dts - _t.dts;
                  else {
                    var rn = this.config, Si = _t.dts - le[Xt > 0 ? Xt - 1 : Xt].dts;
                    if (rn.stretchShortVideoTrack) {
                      var ds = rn.maxBufferHole, Wr = rn.maxSeekHole, Qu = Math.floor(Math.min(ds, Wr) * N), Ys = (L ? ie + L * N : this.nextAudioPts) - _t.pts;
                      Ys > Qu ? (X = Ys - Si, X < 0 && (X = Si), p.b.log("It is approximately " + Ys / 90 + " ms to the next segment; using duration " + X / 90 + " ms for the last video frame.")) : X = Si;
                    } else
                      X = Si;
                  }
                  Hr = Math.round(_t.pts - _t.dts);
                }
                ee.push({
                  size: Ti,
                  // constant duration
                  duration: X,
                  cts: Hr,
                  flags: {
                    isLeading: 0,
                    isDependedOn: 0,
                    hasRedundancy: 0,
                    degradPrio: 0,
                    dependsOn: _t.key ? 2 : 1,
                    isNonSync: _t.key ? 0 : 1
                  }
                });
              }
              this.nextAvcDts = oe + X;
              var ec = y.dropped;
              if (y.len = 0, y.nbNalu = 0, y.dropped = 0, ee.length && navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
                var Gl = ee[0].flags;
                Gl.dependsOn = 2, Gl.isNonSync = 0;
              }
              y.samples = ee, H = kr.moof(y.sequenceNumber++, re, y), y.samples = [];
              var ql = {
                data1: H,
                data2: Q,
                startPTS: ie / N,
                endPTS: (fe + X) / N,
                startDTS: re / N,
                endDTS: this.nextAvcDts / N,
                type: "video",
                nb: ee.length,
                dropped: ec
              };
              return this.observer.trigger(c.a.FRAG_PARSING_DATA, ql), ql;
            }, R.prototype.remuxAudio = function(y, T, C, L) {
              var D = y.inputTimeScale, V = y.timescale, N = D / V, X = y.isAAC ? 1024 : 1152, Q = X * N, H = this._PTSNormalize, ie = this._initDTS, re = !y.isAAC && this.typeSupported.mpeg, fe, oe, le, ee, Ie, et, tt, Fe = y.samples, Ze = [], Te = this.nextAudioPts;
              if (C |= Fe.length && Te && (L && Math.abs(T - Te / D) < 0.1 || Math.abs(Fe[0].pts - Te - ie) < 20 * Q), Fe.forEach(function(Wr) {
                Wr.pts = Wr.dts = H(Wr.pts - ie, T * D);
              }), Fe = Fe.filter(function(Wr) {
                return Wr.pts >= 0;
              }), Fe.length !== 0) {
                if (C || (L ? Te = T * D : Te = Fe[0].pts), y.isAAC)
                  for (var st = this.config.maxAudioFramesDrift, At = 0, rt = Te; At < Fe.length; ) {
                    var xt = Fe[At], Ct, ir = xt.pts;
                    Ct = ir - rt;
                    var Pt = Math.abs(1e3 * Ct / D);
                    if (Ct <= -st * Q)
                      p.b.warn("Dropping 1 audio frame @ " + (rt / D).toFixed(3) + "s due to " + Math.round(Pt) + " ms overlap."), Fe.splice(At, 1), y.len -= xt.unit.length;
                    else if (Ct >= st * Q && Pt < St && rt) {
                      var br = Math.round(Ct / Q);
                      p.b.warn("Injecting " + br + " audio frame @ " + (rt / D).toFixed(3) + "s due to " + Math.round(1e3 * Ct / D) + " ms gap.");
                      for (var zt = 0; zt < br; zt++) {
                        var nr = Math.max(rt, 0);
                        le = Ft.getSilentFrame(y.manifestCodec || y.codec, y.channelCount), le || (p.b.log("Unable to get silent frame for given audio codec; duplicating last frame instead."), le = xt.unit.subarray()), Fe.splice(At, 0, { unit: le, pts: nr, dts: nr }), y.len += le.length, rt += Q, At++;
                      }
                      xt.pts = xt.dts = rt, rt += Q, At++;
                    } else
                      xt.pts = xt.dts = rt, rt += Q, At++;
                  }
                for (var _i = 0, wi = Fe.length; _i < wi; _i++) {
                  var Cn = Fe[_i], Xt = Cn.unit, _t = Cn.pts;
                  if (tt !== void 0)
                    oe.duration = Math.round((_t - tt) / N);
                  else {
                    var Ir = Math.round(1e3 * (_t - Te) / D), Ti = 0;
                    if (C && y.isAAC && Ir) {
                      if (Ir > 0 && Ir < St)
                        Ti = Math.round((_t - Te) / Q), p.b.log(Ir + " ms hole between AAC samples detected,filling it"), Ti > 0 && (le = Ft.getSilentFrame(y.manifestCodec || y.codec, y.channelCount), le || (le = Xt.subarray()), y.len += Ti * le.length);
                      else if (Ir < -12) {
                        p.b.log("drop overlapping AAC sample, expected/parsed/delta:" + (Te / D).toFixed(3) + "s/" + (_t / D).toFixed(3) + "s/" + -Ir + "ms"), y.len -= Xt.byteLength;
                        continue;
                      }
                      _t = Te;
                    }
                    if (et = _t, y.len > 0) {
                      var Hr = re ? y.len : y.len + 8;
                      fe = re ? 0 : 8;
                      try {
                        ee = new Uint8Array(Hr);
                      } catch {
                        this.observer.trigger(c.a.ERROR, { type: h.b.MUX_ERROR, details: h.a.REMUX_ALLOC_ERROR, fatal: !1, bytes: Hr, reason: "fail allocating audio mdat " + Hr });
                        return;
                      }
                      if (!re) {
                        var Ln = new DataView(ee.buffer);
                        Ln.setUint32(0, Hr), ee.set(kr.types.mdat, 4);
                      }
                    } else
                      return;
                    for (var cs = 0; cs < Ti; cs++)
                      le = Ft.getSilentFrame(y.manifestCodec || y.codec, y.channelCount), le || (p.b.log("Unable to get silent frame for given audio codec; duplicating this frame instead."), le = Xt.subarray()), ee.set(le, fe), fe += le.byteLength, oe = {
                        size: le.byteLength,
                        cts: 0,
                        duration: 1024,
                        flags: {
                          isLeading: 0,
                          isDependedOn: 0,
                          hasRedundancy: 0,
                          degradPrio: 0,
                          dependsOn: 1
                        }
                      }, Ze.push(oe);
                  }
                  ee.set(Xt, fe);
                  var kn = Xt.byteLength;
                  fe += kn, oe = {
                    size: kn,
                    cts: 0,
                    duration: 0,
                    flags: {
                      isLeading: 0,
                      isDependedOn: 0,
                      hasRedundancy: 0,
                      degradPrio: 0,
                      dependsOn: 1
                    }
                  }, Ze.push(oe), tt = _t;
                }
                var Dn = 0, Zr = Ze.length;
                if (Zr >= 2 && (Dn = Ze[Zr - 2].duration, oe.duration = Dn), Zr) {
                  this.nextAudioPts = Te = tt + N * Dn, y.len = 0, y.samples = Ze, re ? Ie = new Uint8Array() : Ie = kr.moof(y.sequenceNumber++, et / N, y), y.samples = [];
                  var rn = et / D, Si = Te / D, ds = {
                    data1: Ie,
                    data2: ee,
                    startPTS: rn,
                    endPTS: Si,
                    startDTS: rn,
                    endDTS: Si,
                    type: "audio",
                    nb: Zr
                  };
                  return this.observer.trigger(c.a.FRAG_PARSING_DATA, ds), ds;
                }
                return null;
              }
            }, R.prototype.remuxEmptyAudio = function(y, T, C, L) {
              var D = y.inputTimeScale, V = y.samplerate ? y.samplerate : D, N = D / V, X = this.nextAudioPts, Q = (X !== void 0 ? X : L.startDTS * D) + this._initDTS, H = L.endDTS * D + this._initDTS, ie = 1024, re = N * ie, fe = Math.ceil((H - Q) / re), oe = Ft.getSilentFrame(y.manifestCodec || y.codec, y.channelCount);
              if (p.b.warn("remux empty Audio"), !oe) {
                p.b.trace("Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!");
                return;
              }
              for (var le = [], ee = 0; ee < fe; ee++) {
                var Ie = Q + ee * re;
                le.push({ unit: oe, pts: Ie, dts: Ie }), y.len += oe.length;
              }
              y.samples = le, this.remuxAudio(y, T, C);
            }, R.prototype.remuxID3 = function(y, T) {
              var C = y.samples.length, L, D = y.inputTimeScale, V = this._initPTS, N = this._initDTS;
              if (C) {
                for (var X = 0; X < C; X++)
                  L = y.samples[X], L.pts = (L.pts - V) / D, L.dts = (L.dts - N) / D;
                this.observer.trigger(c.a.FRAG_PARSING_METADATA, {
                  samples: y.samples
                });
              }
              y.samples = [];
            }, R.prototype.remuxText = function(y, T) {
              y.samples.sort(function(X, Q) {
                return X.pts - Q.pts;
              });
              var C = y.samples.length, L, D = y.inputTimeScale, V = this._initPTS;
              if (C) {
                for (var N = 0; N < C; N++)
                  L = y.samples[N], L.pts = (L.pts - V) / D;
                this.observer.trigger(c.a.FRAG_PARSING_USERDATA, {
                  samples: y.samples
                });
              }
              y.samples = [];
            }, R.prototype._PTSNormalize = function(y, T) {
              var C;
              if (T === void 0)
                return y;
              for (T < y ? C = -8589934592 : C = 8589934592; Math.abs(y - T) > 4294967296; )
                y += C;
              return y;
            }, R;
          }(), rr = Sn;
          function Wu(R, I) {
            if (!(R instanceof I))
              throw new TypeError("Cannot call a class as a function");
          }
          var Yu = function() {
            function R(I) {
              Wu(this, R), this.observer = I;
            }
            return R.prototype.destroy = function() {
            }, R.prototype.resetTimeStamp = function() {
            }, R.prototype.resetInitSegment = function() {
            }, R.prototype.remux = function(y, T, C, L, D, V, N, X) {
              var Q = this.observer, H = "";
              y && (H += "audio"), T && (H += "video"), Q.trigger(c.a.FRAG_PARSING_DATA, {
                data1: X,
                startPTS: D,
                startDTS: D,
                type: H,
                nb: 1,
                dropped: 0
              }), Q.trigger(c.a.FRAG_PARSED);
            }, R;
          }(), Zs = Yu;
          function Ju(R, I) {
            if (!(R instanceof I))
              throw new TypeError("Cannot call a class as a function");
          }
          var Ws = function() {
            function R(I, y, T, C) {
              Ju(this, R), this.observer = I, this.typeSupported = y, this.config = T, this.vendor = C;
            }
            return R.prototype.destroy = function() {
              var y = this.demuxer;
              y && y.destroy();
            }, R.prototype.push = function(y, T, C, L, D, V, N, X, Q, H, ie, re) {
              if (y.byteLength > 0 && T != null && T.key != null && T.method === "AES-128") {
                var fe = this.decrypter;
                fe == null && (fe = this.decrypter = new m.a(this.observer, this.config));
                var oe = this, le;
                try {
                  le = performance.now();
                } catch {
                  le = Date.now();
                }
                fe.decrypt(y, T.key.buffer, T.iv.buffer, function(ee) {
                  var Ie;
                  try {
                    Ie = performance.now();
                  } catch {
                    Ie = Date.now();
                  }
                  oe.observer.trigger(c.a.FRAG_DECRYPTED, { stats: { tstart: le, tdecrypt: Ie } }), oe.pushDecrypted(new Uint8Array(ee), T, new Uint8Array(C), L, D, V, N, X, Q, H, ie, re);
                });
              } else
                this.pushDecrypted(new Uint8Array(y), T, new Uint8Array(C), L, D, V, N, X, Q, H, ie, re);
            }, R.prototype.pushDecrypted = function(y, T, C, L, D, V, N, X, Q, H, ie, re) {
              var fe = this.demuxer;
              if (!fe || // in case of continuity change, we might switch from content type (AAC container to TS container for example)
              // so let's check that current demuxer is still valid
              N && !this.probe(y)) {
                for (var oe = this.observer, le = this.typeSupported, ee = this.config, Ie = [{ demux: qe, remux: rr }, { demux: De, remux: Zs }, { demux: xe, remux: rr }, { demux: tn, remux: rr }], et = 0, tt = Ie.length; et < tt; et++) {
                  var Fe = Ie[et], Ze = Fe.demux.probe;
                  if (Ze(y)) {
                    var Te = this.remuxer = new Fe.remux(oe, ee, le, this.vendor);
                    fe = new Fe.demux(oe, Te, ee, le), this.probe = Ze;
                    break;
                  }
                }
                if (!fe) {
                  oe.trigger(c.a.ERROR, { type: h.b.MEDIA_ERROR, details: h.a.FRAG_PARSING_ERROR, fatal: !0, reason: "no demux matching with content found" });
                  return;
                }
                this.demuxer = fe;
              }
              var st = this.remuxer;
              (N || X) && (fe.resetInitSegment(C, L, D, H), st.resetInitSegment()), N && (fe.resetTimeStamp(re), st.resetTimeStamp(re)), typeof fe.setDecryptData == "function" && fe.setDecryptData(T), fe.append(y, V, Q, ie);
            }, R;
          }();
          i.a = Ws;
        },
        /* 8 */
        /***/
        function(r, i, a) {
          Object.defineProperty(i, "__esModule", { value: !0 });
          var c = {};
          a.d(c, "newCue", function() {
            return by;
          });
          var h = a(6), m = /* @__PURE__ */ a.n(h), p = a(1), b = a(2), d = a(0), v = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(g) {
            return typeof g;
          } : function(g) {
            return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
          };
          function P(g, o) {
            if (!(g instanceof o))
              throw new TypeError("Cannot call a class as a function");
          }
          var M = function() {
            function g(o) {
              P(this, g), this.hls = o, this.onEvent = this.onEvent.bind(this);
              for (var l = arguments.length, s = Array(l > 1 ? l - 1 : 0), u = 1; u < l; u++)
                s[u - 1] = arguments[u];
              this.handledEvents = s, this.useGenericHandler = !0, this.registerListeners();
            }
            return g.prototype.destroy = function() {
              this.unregisterListeners();
            }, g.prototype.isEventHandler = function() {
              return v(this.handledEvents) === "object" && this.handledEvents.length && typeof this.onEvent == "function";
            }, g.prototype.registerListeners = function() {
              this.isEventHandler() && this.handledEvents.forEach(function(l) {
                if (l === "hlsEventGeneric")
                  throw new Error("Forbidden event name: " + l);
                this.hls.on(l, this.onEvent);
              }, this);
            }, g.prototype.unregisterListeners = function() {
              this.isEventHandler() && this.handledEvents.forEach(function(l) {
                this.hls.off(l, this.onEvent);
              }, this);
            }, g.prototype.onEvent = function(l, s) {
              this.onEventGeneric(l, s);
            }, g.prototype.onEventGeneric = function(l, s) {
              var u = function(E, w) {
                var A = "on" + E.replace("hls", "");
                if (typeof this[A] != "function")
                  throw new Error("Event " + E + " has no generic handler in this " + this.constructor.name + " class (tried " + A + ")");
                return this[A].bind(this, w);
              };
              try {
                u.call(this, l, s).call();
              } catch (f) {
                d.b.error("internal error happened while processing " + l + ":" + f.message), this.hls.trigger(p.a.ERROR, { type: b.b.OTHER_ERROR, details: b.a.INTERNAL_EXCEPTION, fatal: !1, event: l, err: f });
              }
            }, g;
          }(), K = M;
          function W(g, o) {
            if (!(g instanceof o))
              throw new TypeError("Cannot call a class as a function");
          }
          var J = /^(\d+)x(\d+)$/, z = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g, U = function() {
            function g(o) {
              W(this, g), typeof o == "string" && (o = g.parseAttrList(o));
              for (var l in o)
                o.hasOwnProperty(l) && (this[l] = o[l]);
            }
            return g.prototype.decimalInteger = function(l) {
              var s = parseInt(this[l], 10);
              return s > Number.MAX_SAFE_INTEGER ? 1 / 0 : s;
            }, g.prototype.hexadecimalInteger = function(l) {
              if (this[l]) {
                var s = (this[l] || "0x").slice(2);
                s = (s.length & 1 ? "0" : "") + s;
                for (var u = new Uint8Array(s.length / 2), f = 0; f < s.length / 2; f++)
                  u[f] = parseInt(s.slice(f * 2, f * 2 + 2), 16);
                return u;
              } else
                return null;
            }, g.prototype.hexadecimalIntegerAsNumber = function(l) {
              var s = parseInt(this[l], 16);
              return s > Number.MAX_SAFE_INTEGER ? 1 / 0 : s;
            }, g.prototype.decimalFloatingPoint = function(l) {
              return parseFloat(this[l]);
            }, g.prototype.enumeratedString = function(l) {
              return this[l];
            }, g.prototype.decimalResolution = function(l) {
              var s = J.exec(this[l]);
              if (s !== null)
                return {
                  width: parseInt(s[1], 10),
                  height: parseInt(s[2], 10)
                };
            }, g.parseAttrList = function(l) {
              var s, u = {};
              for (z.lastIndex = 0; (s = z.exec(l)) !== null; ) {
                var f = s[2], E = '"';
                f.indexOf(E) === 0 && f.lastIndexOf(E) === f.length - 1 && (f = f.slice(1, -1)), u[s[1]] = f;
              }
              return u;
            }, g;
          }(), F = U, Z = {
            audio: {
              a3ds: !0,
              "ac-3": !0,
              "ac-4": !0,
              alac: !0,
              alaw: !0,
              dra1: !0,
              "dts+": !0,
              "dts-": !0,
              dtsc: !0,
              dtse: !0,
              dtsh: !0,
              "ec-3": !0,
              enca: !0,
              g719: !0,
              g726: !0,
              m4ae: !0,
              mha1: !0,
              mha2: !0,
              mhm1: !0,
              mhm2: !0,
              mlpa: !0,
              mp4a: !0,
              "raw ": !0,
              Opus: !0,
              samr: !0,
              sawb: !0,
              sawp: !0,
              sevc: !0,
              sqcp: !0,
              ssmv: !0,
              twos: !0,
              ulaw: !0
            },
            video: {
              avc1: !0,
              avc2: !0,
              avc3: !0,
              avc4: !0,
              avcp: !0,
              drac: !0,
              dvav: !0,
              dvhe: !0,
              encv: !0,
              hev1: !0,
              hvc1: !0,
              mjp2: !0,
              mp4v: !0,
              mvc1: !0,
              mvc2: !0,
              mvc3: !0,
              mvc4: !0,
              resv: !0,
              rv60: !0,
              s263: !0,
              svc1: !0,
              svc2: !0,
              "vc-1": !0,
              vp08: !0,
              vp09: !0
            }
          };
          function de(g, o) {
            var l = Z[o];
            return !!l && l[g.slice(0, 4)] === !0;
          }
          function xe(g, o) {
            return MediaSource.isTypeSupported((o || "video") + '/mp4;codecs="' + g + '"');
          }
          var ge = /* @__PURE__ */ function() {
            function g(o, l) {
              for (var s = 0; s < l.length; s++) {
                var u = l[s];
                u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(o, u.key, u);
              }
            }
            return function(o, l, s) {
              return l && g(o.prototype, l), s && g(o, s), o;
            };
          }();
          function me(g, o) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return o && (typeof o == "object" || typeof o == "function") ? o : g;
          }
          function Ee(g, o) {
            if (typeof o != "function" && o !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof o);
            g.prototype = Object.create(o && o.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), o && (Object.setPrototypeOf ? Object.setPrototypeOf(g, o) : g.__proto__ = o);
          }
          function De(g, o) {
            if (!(g instanceof o))
              throw new TypeError("Cannot call a class as a function");
          }
          var Ke = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g, Ge = /#EXT-X-MEDIA:(.*)/g, Je = new RegExp([
            /#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
            // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
            /|(?!#)(\S+)/.source,
            // segment URI, group 3 => the URI (note newline is not eaten)
            /|#EXT-X-BYTERANGE:*(.+)/.source,
            // next segment's byterange, group 4 => range spec (x@y)
            /|#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,
            // next segment's program date/time group 5 => the datetime spec
            /|#.*/.source
            // All other non-segment oriented tags will match with all groups empty
          ].join(""), "g"), Qe = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)(.*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/, Et = function() {
            function g() {
              De(this, g), this.method = null, this.key = null, this.iv = null, this._uri = null;
            }
            return ge(g, [{
              key: "uri",
              get: function() {
                return !this._uri && this.reluri && (this._uri = m.a.buildAbsoluteURL(this.baseuri, this.reluri, { alwaysNormalize: !0 })), this._uri;
              }
            }]), g;
          }(), nt = function() {
            function g() {
              De(this, g), this._url = null, this._byteRange = null, this._decryptdata = null, this.tagList = [];
            }
            return g.prototype.createInitializationVector = function(l) {
              for (var s = new Uint8Array(16), u = 12; u < 16; u++)
                s[u] = l >> 8 * (15 - u) & 255;
              return s;
            }, g.prototype.fragmentDecryptdataFromLevelkey = function(l, s) {
              var u = l;
              return l && l.method && l.uri && !l.iv && (u = new Et(), u.method = l.method, u.baseuri = l.baseuri, u.reluri = l.reluri, u.iv = this.createInitializationVector(s)), u;
            }, g.prototype.cloneObj = function(l) {
              return JSON.parse(JSON.stringify(l));
            }, ge(g, [{
              key: "url",
              get: function() {
                return !this._url && this.relurl && (this._url = m.a.buildAbsoluteURL(this.baseurl, this.relurl, { alwaysNormalize: !0 })), this._url;
              },
              set: function(l) {
                this._url = l;
              }
            }, {
              key: "programDateTime",
              get: function() {
                return !this._programDateTime && this.rawProgramDateTime && (this._programDateTime = new Date(Date.parse(this.rawProgramDateTime))), this._programDateTime;
              }
            }, {
              key: "byteRange",
              get: function() {
                if (!this._byteRange) {
                  var l = this._byteRange = [];
                  if (this.rawByteRange) {
                    var s = this.rawByteRange.split("@", 2);
                    if (s.length === 1) {
                      var u = this.lastByteRangeEndOffset;
                      l[0] = u || 0;
                    } else
                      l[0] = parseInt(s[1]);
                    l[1] = parseInt(s[0]) + l[0];
                  }
                }
                return this._byteRange;
              }
            }, {
              key: "byteRangeStartOffset",
              get: function() {
                return this.byteRange[0];
              }
            }, {
              key: "byteRangeEndOffset",
              get: function() {
                return this.byteRange[1];
              }
            }, {
              key: "decryptdata",
              get: function() {
                return this._decryptdata || (this._decryptdata = this.fragmentDecryptdataFromLevelkey(this.levelkey, this.sn)), this._decryptdata;
              }
            }]), g;
          }();
          function vt(g, o) {
            if (!g)
              return null;
            for (var l = null, s = 0; s < g.length; s++) {
              var u = g[s];
              u.id === o && (l = u);
            }
            return l;
          }
          var jt = function(g) {
            Ee(o, g);
            function o(l) {
              De(this, o);
              var s = me(this, g.call(this, l, p.a.MANIFEST_LOADING, p.a.LEVEL_LOADING, p.a.AUDIO_TRACK_LOADING, p.a.SUBTITLE_TRACK_LOADING));
              return s.loaders = {}, s;
            }
            return o.prototype.destroy = function() {
              for (var s in this.loaders) {
                var u = this.loaders[s];
                u && u.destroy();
              }
              this.loaders = {}, K.prototype.destroy.call(this);
            }, o.prototype.onManifestLoading = function(s) {
              this.load(s.url, { type: "manifest" });
            }, o.prototype.onLevelLoading = function(s) {
              this.load(s.url, { type: "level", level: s.level, id: s.id });
            }, o.prototype.onAudioTrackLoading = function(s) {
              this.load(s.url, { type: "audioTrack", id: s.id });
            }, o.prototype.onSubtitleTrackLoading = function(s) {
              this.load(s.url, { type: "subtitleTrack", id: s.id });
            }, o.prototype.load = function(s, u) {
              var f = this.loaders[u.type];
              if (f !== void 0) {
                var E = f.context;
                if (E && E.url === s) {
                  d.b.trace("playlist request ongoing");
                  return;
                } else
                  d.b.warn("abort previous loader for type:" + u.type), f.abort();
              }
              var w = this.hls.config, A = void 0, S = void 0, k = void 0, B = void 0;
              u.type === "manifest" ? (A = w.manifestLoadingMaxRetry, S = w.manifestLoadingTimeOut, k = w.manifestLoadingRetryDelay, B = w.manifestLoadingMaxRetryTimeout) : u.type === "level" ? (A = 0, S = w.levelLoadingTimeOut) : (A = w.levelLoadingMaxRetry, S = w.levelLoadingTimeOut, k = w.levelLoadingRetryDelay, B = w.levelLoadingMaxRetryTimeout, d.b.log("loading playlist for " + u.type + " " + (u.level || u.id))), f = this.loaders[u.type] = u.loader = typeof w.pLoader < "u" ? new w.pLoader(w) : new w.loader(w), u.url = s, u.responseType = "";
              var O = void 0, $ = void 0;
              O = { timeout: S, maxRetry: A, retryDelay: k, maxRetryDelay: B }, $ = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) }, f.load(u, O, $);
            }, o.prototype.resolve = function(s, u) {
              return m.a.buildAbsoluteURL(u, s, { alwaysNormalize: !0 });
            }, o.prototype.parseMasterPlaylist = function(s, u) {
              var f = [], E = void 0;
              Ke.lastIndex = 0;
              function w(B, O) {
                ["video", "audio"].forEach(function($) {
                  var te = B.filter(function(be) {
                    return de(be, $);
                  });
                  if (te.length) {
                    var pe = te.filter(function(be) {
                      return be.lastIndexOf("avc1", 0) === 0 || be.lastIndexOf("mp4a", 0) === 0;
                    });
                    O[$ + "Codec"] = pe.length > 0 ? pe[0] : te[0], B = B.filter(function(be) {
                      return te.indexOf(be) === -1;
                    });
                  }
                }), O.unknownCodecs = B;
              }
              for (; (E = Ke.exec(s)) != null; ) {
                var A = {}, S = A.attrs = new F(E[1]);
                A.url = this.resolve(E[2], u);
                var k = S.decimalResolution("RESOLUTION");
                k && (A.width = k.width, A.height = k.height), A.bitrate = S.decimalInteger("AVERAGE-BANDWIDTH") || S.decimalInteger("BANDWIDTH"), A.name = S.NAME, w([].concat((S.CODECS || "").split(/[ ,]+/)), A), A.videoCodec && A.videoCodec.indexOf("avc1") !== -1 && (A.videoCodec = this.avc1toavcoti(A.videoCodec)), f.push(A);
              }
              return f;
            }, o.prototype.parseMasterPlaylistMedia = function(s, u, f) {
              var E = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [], w = void 0, A = [], S = 0;
              for (Ge.lastIndex = 0; (w = Ge.exec(s)) !== null; ) {
                var k = {}, B = new F(w[1]);
                if (B.TYPE === f) {
                  if (k.groupId = B["GROUP-ID"], k.name = B.NAME, k.type = f, k.default = B.DEFAULT === "YES", k.autoselect = B.AUTOSELECT === "YES", k.forced = B.FORCED === "YES", B.URI && (k.url = this.resolve(B.URI, u)), k.lang = B.LANGUAGE, k.name || (k.name = k.lang), E.length) {
                    var O = vt(E, k.groupId);
                    k.audioCodec = O ? O.codec : E[0].codec;
                  }
                  k.id = S++, A.push(k);
                }
              }
              return A;
            }, o.prototype.avc1toavcoti = function(s) {
              var u, f = s.split(".");
              return f.length > 2 ? (u = f.shift() + ".", u += parseInt(f.shift()).toString(16), u += ("000" + parseInt(f.shift()).toString(16)).substr(-4)) : u = s, u;
            }, o.prototype.parseLevelPlaylist = function(s, u, f, E) {
              var w = 0, A = 0, S = { type: null, version: null, url: u, fragments: [], live: !0, startSN: 0 }, k = new Et(), B = 0, O = null, $ = new nt(), te, pe;
              for (Je.lastIndex = 0; (te = Je.exec(s)) !== null; ) {
                var be = te[1];
                if (be) {
                  $.duration = parseFloat(be);
                  var ye = (" " + te[2]).slice(1);
                  $.title = ye || null, $.tagList.push(ye ? ["INF", be, ye] : ["INF", be]);
                } else if (te[3]) {
                  if (!isNaN($.duration)) {
                    var Se = w++;
                    $.type = E, $.start = A, $.levelkey = k, $.sn = Se, $.level = f, $.cc = B, $.baseurl = u, $.relurl = (" " + te[3]).slice(1), S.fragments.push($), O = $, A += $.duration, $ = new nt();
                  }
                } else if (te[4]) {
                  if ($.rawByteRange = (" " + te[4]).slice(1), O) {
                    var Ce = O.byteRangeEndOffset;
                    Ce && ($.lastByteRangeEndOffset = Ce);
                  }
                } else if (te[5])
                  $.rawProgramDateTime = (" " + te[5]).slice(1), $.tagList.push(["PROGRAM-DATE-TIME", $.rawProgramDateTime]), S.programDateTime === void 0 && (S.programDateTime = new Date(new Date(Date.parse(te[5])) - 1e3 * A));
                else {
                  for (te = te[0].match(Qe), pe = 1; pe < te.length && te[pe] === void 0; pe++)
                    ;
                  var Be = (" " + te[pe + 1]).slice(1), He = (" " + te[pe + 2]).slice(1);
                  switch (te[pe]) {
                    case "#":
                      $.tagList.push(He ? [Be, He] : [Be]);
                      break;
                    case "PLAYLIST-TYPE":
                      S.type = Be.toUpperCase();
                      break;
                    case "MEDIA-SEQUENCE":
                      w = S.startSN = parseInt(Be);
                      break;
                    case "TARGETDURATION":
                      S.targetduration = parseFloat(Be);
                      break;
                    case "VERSION":
                      S.version = parseInt(Be);
                      break;
                    case "EXTM3U":
                      break;
                    case "ENDLIST":
                      S.live = !1;
                      break;
                    case "DIS":
                      B++, $.tagList.push(["DIS"]);
                      break;
                    case "DISCONTINUITY-SEQ":
                      B = parseInt(Be);
                      break;
                    case "KEY":
                      var ft = Be, _e = new F(ft), Bt = _e.enumeratedString("METHOD"), at = _e.URI, sn = _e.hexadecimalInteger("IV");
                      Bt && (k = new Et(), at && ["AES-128", "SAMPLE-AES"].indexOf(Bt) >= 0 && (k.method = Bt, k.baseuri = u, k.reluri = at, k.key = null, k.iv = sn));
                      break;
                    case "START":
                      var Xe = Be, Me = new F(Xe), $t = Me.decimalFloatingPoint("TIME-OFFSET");
                      isNaN($t) || (S.startTimeOffset = $t);
                      break;
                    case "MAP":
                      var Wl = new F(Be);
                      $.relurl = Wl.URI, $.rawByteRange = Wl.BYTERANGE, $.baseurl = u, $.level = f, $.type = E, $.sn = "initSegment", S.initSegment = $, $ = new nt();
                      break;
                    default:
                      d.b.warn("line parsed but not handled: " + te);
                      break;
                  }
                }
              }
              return $ = O, $ && !$.relurl && (S.fragments.pop(), A -= $.duration), S.totalduration = A, S.averagetargetduration = A / S.fragments.length, S.endSN = w - 1, S.startCC = S.fragments[0] ? S.fragments[0].cc : 0, S.endCC = B, S;
            }, o.prototype.loadsuccess = function(s, u, f) {
              var E = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, w = s.data, A = s.url, S = f.type, k = f.id, B = f.level, O = this.hls;
              if (this.loaders[S] = void 0, (A === void 0 || A.indexOf("data:") === 0) && (A = f.url), u.tload = performance.now(), w.indexOf("#EXTM3U") === 0)
                if (w.indexOf("#EXTINF:") > 0) {
                  var $ = S !== "audioTrack" && S !== "subtitleTrack", te = isNaN(B) ? isNaN(k) ? 0 : k : B, pe = this.parseLevelPlaylist(w, A, te, S === "audioTrack" ? "audio" : S === "subtitleTrack" ? "subtitle" : "main");
                  pe.tload = u.tload, S === "manifest" && O.trigger(p.a.MANIFEST_LOADED, { levels: [{ url: A, details: pe }], audioTracks: [], url: A, stats: u, networkDetails: E }), u.tparsed = performance.now(), pe.targetduration ? $ ? O.trigger(p.a.LEVEL_LOADED, { details: pe, level: B || 0, id: k || 0, stats: u, networkDetails: E }) : S === "audioTrack" ? O.trigger(p.a.AUDIO_TRACK_LOADED, { details: pe, id: k, stats: u, networkDetails: E }) : S === "subtitleTrack" && O.trigger(p.a.SUBTITLE_TRACK_LOADED, { details: pe, id: k, stats: u, networkDetails: E }) : O.trigger(p.a.ERROR, { type: b.b.NETWORK_ERROR, details: b.a.MANIFEST_PARSING_ERROR, fatal: !0, url: A, reason: "invalid targetduration", networkDetails: E });
                } else {
                  var be = this.parseMasterPlaylist(w, A);
                  if (be.length) {
                    var ye = be.map(function(He) {
                      return { id: He.attrs.AUDIO, codec: He.audioCodec };
                    }), Se = this.parseMasterPlaylistMedia(w, A, "AUDIO", ye), Ce = this.parseMasterPlaylistMedia(w, A, "SUBTITLES");
                    if (Se.length) {
                      var Be = !1;
                      Se.forEach(function(He) {
                        He.url || (Be = !0);
                      }), Be === !1 && be[0].audioCodec && !be[0].attrs.AUDIO && (d.b.log("audio codec signaled in quality level, but no embedded audio track signaled, create one"), Se.unshift({ type: "main", name: "main" }));
                    }
                    O.trigger(p.a.MANIFEST_LOADED, { levels: be, audioTracks: Se, subtitles: Ce, url: A, stats: u, networkDetails: E });
                  } else
                    O.trigger(p.a.ERROR, { type: b.b.NETWORK_ERROR, details: b.a.MANIFEST_PARSING_ERROR, fatal: !0, url: A, reason: "no level found in manifest", networkDetails: E });
                }
              else
                O.trigger(p.a.ERROR, { type: b.b.NETWORK_ERROR, details: b.a.MANIFEST_PARSING_ERROR, fatal: !0, url: A, reason: "no EXTM3U delimiter", networkDetails: E });
            }, o.prototype.loaderror = function(s, u) {
              var f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, E, w, A = u.loader;
              switch (u.type) {
                case "manifest":
                  E = b.a.MANIFEST_LOAD_ERROR, w = !0;
                  break;
                case "level":
                  E = b.a.LEVEL_LOAD_ERROR, w = !1;
                  break;
                case "audioTrack":
                  E = b.a.AUDIO_TRACK_LOAD_ERROR, w = !1;
                  break;
              }
              A && (A.abort(), this.loaders[u.type] = void 0), this.hls.trigger(p.a.ERROR, { type: b.b.NETWORK_ERROR, details: E, fatal: w, url: A.url, loader: A, response: s, context: u, networkDetails: f });
            }, o.prototype.loadtimeout = function(s, u) {
              var f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, E, w, A = u.loader;
              switch (u.type) {
                case "manifest":
                  E = b.a.MANIFEST_LOAD_TIMEOUT, w = !0;
                  break;
                case "level":
                  E = b.a.LEVEL_LOAD_TIMEOUT, w = !1;
                  break;
                case "audioTrack":
                  E = b.a.AUDIO_TRACK_LOAD_TIMEOUT, w = !1;
                  break;
              }
              A && (A.abort(), this.loaders[u.type] = void 0), this.hls.trigger(p.a.ERROR, { type: b.b.NETWORK_ERROR, details: E, fatal: w, url: A.url, loader: A, context: u, networkDetails: f });
            }, o;
          }(K), Rt = jt;
          function ut(g, o) {
            if (!(g instanceof o))
              throw new TypeError("Cannot call a class as a function");
          }
          function Dt(g, o) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return o && (typeof o == "object" || typeof o == "function") ? o : g;
          }
          function qe(g, o) {
            if (typeof o != "function" && o !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof o);
            g.prototype = Object.create(o && o.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), o && (Object.setPrototypeOf ? Object.setPrototypeOf(g, o) : g.__proto__ = o);
          }
          var Pr = function(g) {
            qe(o, g);
            function o(l) {
              ut(this, o);
              var s = Dt(this, g.call(this, l, p.a.FRAG_LOADING));
              return s.loaders = {}, s;
            }
            return o.prototype.destroy = function() {
              var s = this.loaders;
              for (var u in s) {
                var f = s[u];
                f && f.destroy();
              }
              this.loaders = {}, K.prototype.destroy.call(this);
            }, o.prototype.onFragLoading = function(s) {
              var u = s.frag, f = u.type, E = this.loaders[f], w = this.hls.config;
              u.loaded = 0, E && (d.b.warn("abort previous fragment loader for type:" + f), E.abort()), E = this.loaders[f] = u.loader = typeof w.fLoader < "u" ? new w.fLoader(w) : new w.loader(w);
              var A = void 0, S = void 0, k = void 0;
              A = { url: u.url, frag: u, responseType: "arraybuffer", progressData: !1 };
              var B = u.byteRangeStartOffset, O = u.byteRangeEndOffset;
              !isNaN(B) && !isNaN(O) && (A.rangeStart = B, A.rangeEnd = O), S = { timeout: w.fragLoadingTimeOut, maxRetry: 0, retryDelay: 0, maxRetryDelay: w.fragLoadingMaxRetryTimeout }, k = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this), onProgress: this.loadprogress.bind(this) }, E.load(A, S, k);
            }, o.prototype.loadsuccess = function(s, u, f) {
              var E = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, w = s.data, A = f.frag;
              A.loader = void 0, this.loaders[A.type] = void 0, this.hls.trigger(p.a.FRAG_LOADED, { payload: w, frag: A, stats: u, networkDetails: E });
            }, o.prototype.loaderror = function(s, u) {
              var f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, E = u.loader;
              E && E.abort(), this.loaders[u.type] = void 0, this.hls.trigger(p.a.ERROR, { type: b.b.NETWORK_ERROR, details: b.a.FRAG_LOAD_ERROR, fatal: !1, frag: u.frag, response: s, networkDetails: f });
            }, o.prototype.loadtimeout = function(s, u) {
              var f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, E = u.loader;
              E && E.abort(), this.loaders[u.type] = void 0, this.hls.trigger(p.a.ERROR, { type: b.b.NETWORK_ERROR, details: b.a.FRAG_LOAD_TIMEOUT, fatal: !1, frag: u.frag, networkDetails: f });
            }, o.prototype.loadprogress = function(s, u, f) {
              var E = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, w = u.frag;
              w.loaded = s.loaded, this.hls.trigger(p.a.FRAG_LOAD_PROGRESS, { frag: w, stats: s, networkDetails: E });
            }, o;
          }(K), ct = Pr;
          function tn(g, o) {
            if (!(g instanceof o))
              throw new TypeError("Cannot call a class as a function");
          }
          function dr(g, o) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return o && (typeof o == "object" || typeof o == "function") ? o : g;
          }
          function fr(g, o) {
            if (typeof o != "function" && o !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof o);
            g.prototype = Object.create(o && o.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), o && (Object.setPrototypeOf ? Object.setPrototypeOf(g, o) : g.__proto__ = o);
          }
          var Ft = function(g) {
            fr(o, g);
            function o(l) {
              tn(this, o);
              var s = dr(this, g.call(this, l, p.a.KEY_LOADING));
              return s.loaders = {}, s.decryptkey = null, s.decrypturl = null, s;
            }
            return o.prototype.destroy = function() {
              for (var s in this.loaders) {
                var u = this.loaders[s];
                u && u.destroy();
              }
              this.loaders = {}, K.prototype.destroy.call(this);
            }, o.prototype.onKeyLoading = function(s) {
              var u = s.frag, f = u.type, E = this.loaders[f], w = u.decryptdata, A = w.uri;
              if (A !== this.decrypturl || this.decryptkey === null) {
                var S = this.hls.config;
                E && (d.b.warn("abort previous key loader for type:" + f), E.abort()), u.loader = this.loaders[f] = new S.loader(S), this.decrypturl = A, this.decryptkey = null;
                var k = void 0, B = void 0, O = void 0;
                k = { url: A, frag: u, responseType: "arraybuffer" }, B = { timeout: S.fragLoadingTimeOut, maxRetry: S.fragLoadingMaxRetry, retryDelay: S.fragLoadingRetryDelay, maxRetryDelay: S.fragLoadingMaxRetryTimeout }, O = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) }, u.loader.load(k, B, O);
              } else this.decryptkey && (w.key = this.decryptkey, this.hls.trigger(p.a.KEY_LOADED, { frag: u }));
            }, o.prototype.loadsuccess = function(s, u, f) {
              var E = f.frag;
              this.decryptkey = E.decryptdata.key = new Uint8Array(s.data), E.loader = void 0, this.loaders[E.type] = void 0, this.hls.trigger(p.a.KEY_LOADED, { frag: E });
            }, o.prototype.loaderror = function(s, u) {
              var f = u.frag, E = f.loader;
              E && E.abort(), this.loaders[u.type] = void 0, this.hls.trigger(p.a.ERROR, { type: b.b.NETWORK_ERROR, details: b.a.KEY_LOAD_ERROR, fatal: !1, frag: f, response: s });
            }, o.prototype.loadtimeout = function(s, u) {
              var f = u.frag, E = f.loader;
              E && E.abort(), this.loaders[u.type] = void 0, this.hls.trigger(p.a.ERROR, { type: b.b.NETWORK_ERROR, details: b.a.KEY_LOAD_TIMEOUT, fatal: !1, frag: f });
            }, o;
          }(K), pr = Ft, hr = {
            /**
             * Searches for an item in an array which matches a certain condition.
             * This requires the condition to only match one item in the array,
             * and for the array to be ordered.
             *
             * @param {Array} list The array to search.
             * @param {Function} comparisonFunction
             *      Called and provided a candidate item as the first argument.
             *      Should return:
             *          > -1 if the item should be located at a lower index than the provided item.
             *          > 1 if the item should be located at a higher index than the provided item.
             *          > 0 if the item is the item you're looking for.
             *
             * @return {*} The object if it is found or null otherwise.
             */
            search: function(o, l) {
              for (var s = 0, u = o.length - 1, f = null, E = null; s <= u; ) {
                f = (s + u) / 2 | 0, E = o[f];
                var w = l(E);
                if (w > 0)
                  s = f + 1;
                else if (w < 0)
                  u = f - 1;
                else
                  return E;
              }
              return null;
            }
          }, Br = hr, kr = {
            isBuffered: function(o, l) {
              try {
                if (o) {
                  for (var s = o.buffered, u = 0; u < s.length; u++)
                    if (l >= s.start(u) && l <= s.end(u))
                      return !0;
                }
              } catch {
              }
              return !1;
            },
            bufferInfo: function(o, l, s) {
              try {
                if (o) {
                  var u = o.buffered, f = [], E;
                  for (E = 0; E < u.length; E++)
                    f.push({ start: u.start(E), end: u.end(E) });
                  return this.bufferedInfo(f, l, s);
                }
              } catch {
              }
              return { len: 0, start: l, end: l, nextStart: void 0 };
            },
            bufferedInfo: function(o, l, s) {
              var u = [], f, E, w, A, S;
              for (o.sort(function(te, pe) {
                var be = te.start - pe.start;
                return be || pe.end - te.end;
              }), S = 0; S < o.length; S++) {
                var k = u.length;
                if (k) {
                  var B = u[k - 1].end;
                  o[S].start - B < s ? o[S].end > B && (u[k - 1].end = o[S].end) : u.push(o[S]);
                } else
                  u.push(o[S]);
              }
              for (S = 0, f = 0, E = w = l; S < u.length; S++) {
                var O = u[S].start, $ = u[S].end;
                if (l + s >= O && l < $)
                  E = O, w = $, f = w - l;
                else if (l + s < O) {
                  A = O;
                  break;
                }
              }
              return { len: f, start: E, end: w, nextStart: A };
            }
          }, dt = kr, St = a(7), Sn = a(5), rr = /* @__PURE__ */ a.n(Sn), Wu = a(9), Yu = /* @__PURE__ */ a.n(Wu);
          function Zs() {
            if (typeof window < "u")
              return window.MediaSource || window.WebKitMediaSource;
          }
          function Ju(g, o) {
            if (!(g instanceof o))
              throw new TypeError("Cannot call a class as a function");
          }
          var Ws = Zs(), R = function() {
            function g(o, l) {
              Ju(this, g), this.hls = o, this.id = l;
              var s = this.observer = new rr.a(), u = o.config;
              s.trigger = function(k) {
                for (var B = arguments.length, O = Array(B > 1 ? B - 1 : 0), $ = 1; $ < B; $++)
                  O[$ - 1] = arguments[$];
                s.emit.apply(s, [k, k].concat(O));
              }, s.off = function(k) {
                for (var B = arguments.length, O = Array(B > 1 ? B - 1 : 0), $ = 1; $ < B; $++)
                  O[$ - 1] = arguments[$];
                s.removeListener.apply(s, [k].concat(O));
              };
              var f = function(S, k) {
                k = k || {}, k.frag = this.frag, k.id = this.id, o.trigger(S, k);
              }.bind(this);
              s.on(p.a.FRAG_DECRYPTED, f), s.on(p.a.FRAG_PARSING_INIT_SEGMENT, f), s.on(p.a.FRAG_PARSING_DATA, f), s.on(p.a.FRAG_PARSED, f), s.on(p.a.ERROR, f), s.on(p.a.FRAG_PARSING_METADATA, f), s.on(p.a.FRAG_PARSING_USERDATA, f), s.on(p.a.INIT_PTS_FOUND, f);
              var E = {
                mp4: Ws.isTypeSupported("video/mp4"),
                mpeg: Ws.isTypeSupported("audio/mpeg"),
                mp3: Ws.isTypeSupported('audio/mp4; codecs="mp3"')
              }, w = navigator.vendor;
              if (u.enableWorker && typeof Worker < "u") {
                d.b.log("demuxing in webworker");
                var A = void 0;
                try {
                  A = this.w = Yu()(
                    /*require.resolve*/
                    10
                  ), this.onwmsg = this.onWorkerMessage.bind(this), A.addEventListener("message", this.onwmsg), A.onerror = function(S) {
                    o.trigger(p.a.ERROR, { type: b.b.OTHER_ERROR, details: b.a.INTERNAL_EXCEPTION, fatal: !0, event: "demuxerWorker", err: { message: S.message + " (" + S.filename + ":" + S.lineno + ")" } });
                  }, A.postMessage({ cmd: "init", typeSupported: E, vendor: w, id: l, config: JSON.stringify(u) });
                } catch {
                  d.b.error("error while initializing DemuxerWorker, fallback on DemuxerInline"), A && URL.revokeObjectURL(A.objectURL), this.demuxer = new St.a(s, E, u, w), this.w = void 0;
                }
              } else
                this.demuxer = new St.a(s, E, u, w);
            }
            return g.prototype.destroy = function() {
              var l = this.w;
              if (l)
                l.removeEventListener("message", this.onwmsg), l.terminate(), this.w = null;
              else {
                var s = this.demuxer;
                s && (s.destroy(), this.demuxer = null);
              }
              var u = this.observer;
              u && (u.removeAllListeners(), this.observer = null);
            }, g.prototype.push = function(l, s, u, f, E, w, A, S) {
              var k = this.w, B = isNaN(E.startDTS) ? E.start : E.startDTS, O = E.decryptdata, $ = this.frag, te = !($ && E.cc === $.cc), pe = !($ && E.level === $.level), be = $ && E.sn === $.sn + 1, ye = !pe && be;
              if (te && d.b.log(this.id + ":discontinuity detected"), pe && d.b.log(this.id + ":switch detected"), this.frag = E, k)
                k.postMessage({ cmd: "demux", data: l, decryptdata: O, initSegment: s, audioCodec: u, videoCodec: f, timeOffset: B, discontinuity: te, trackSwitch: pe, contiguous: ye, duration: w, accurateTimeOffset: A, defaultInitPTS: S }, l instanceof ArrayBuffer ? [l] : []);
              else {
                var Se = this.demuxer;
                Se && Se.push(l, O, s, u, f, B, te, pe, ye, w, A, S);
              }
            }, g.prototype.onWorkerMessage = function(l) {
              var s = l.data, u = this.hls;
              switch (s.event) {
                case "init":
                  URL.revokeObjectURL(this.w.objectURL);
                  break;
                case p.a.FRAG_PARSING_DATA:
                  s.data.data1 = new Uint8Array(s.data1), s.data2 && (s.data.data2 = new Uint8Array(s.data2));
                default:
                  s.data = s.data || {}, s.data.frag = this.frag, s.data.id = this.id, u.trigger(s.event, s.data);
                  break;
              }
            }, g;
          }(), I = R;
          function y(g, o, l) {
            var s = g[o], u = g[l], f = u.startPTS;
            isNaN(f) ? l > o ? u.start = s.start + s.duration : u.start = Math.max(s.start - u.duration, 0) : l > o ? (s.duration = f - s.start, s.duration < 0 && d.b.warn("negative duration computed for frag " + s.sn + ",level " + s.level + ", there should be some duration drift between playlist and fragment!")) : (u.duration = s.start - f, u.duration < 0 && d.b.warn("negative duration computed for frag " + u.sn + ",level " + u.level + ", there should be some duration drift between playlist and fragment!"));
          }
          function T(g, o, l, s, u, f) {
            var E = l;
            if (!isNaN(o.startPTS)) {
              var w = Math.abs(o.startPTS - l);
              isNaN(o.deltaPTS) ? o.deltaPTS = w : o.deltaPTS = Math.max(w, o.deltaPTS), E = Math.max(l, o.startPTS), l = Math.min(l, o.startPTS), s = Math.max(s, o.endPTS), u = Math.min(u, o.startDTS), f = Math.max(f, o.endDTS);
            }
            var A = l - o.start;
            o.start = o.startPTS = l, o.maxStartPTS = E, o.endPTS = s, o.startDTS = u, o.endDTS = f, o.duration = s - l;
            var S = o.sn;
            if (!g || S < g.startSN || S > g.endSN)
              return 0;
            var k, B, O;
            for (k = S - g.startSN, B = g.fragments, B[k] = o, O = k; O > 0; O--)
              y(B, O, O - 1);
            for (O = k; O < B.length - 1; O++)
              y(B, O, O + 1);
            return g.PTSKnown = !0, A;
          }
          function C(g, o) {
            var l = Math.max(g.startSN, o.startSN) - o.startSN, s = Math.min(g.endSN, o.endSN) - o.startSN, u = o.startSN - g.startSN, f = g.fragments, E = o.fragments, w = 0, A;
            if (s < l) {
              o.PTSKnown = !1;
              return;
            }
            for (var S = l; S <= s; S++) {
              var k = f[u + S], B = E[S];
              B && k && (w = k.cc - B.cc, isNaN(k.startPTS) || (B.start = B.startPTS = k.startPTS, B.endPTS = k.endPTS, B.duration = k.duration, B.backtracked = k.backtracked, B.dropped = k.dropped, A = B));
            }
            if (w)
              for (d.b.log("discontinuity sliding from playlist, take drift into account"), S = 0; S < E.length; S++)
                E[S].cc += w;
            if (A)
              T(o, A, A.startPTS, A.endPTS, A.startDTS, A.endDTS);
            else if (u >= 0 && u < f.length) {
              var O = f[u].start;
              for (S = 0; S < E.length; S++)
                E[S].start += O;
            }
            o.PTSKnown = g.PTSKnown;
          }
          var L = {
            toString: function(o) {
              for (var l = "", s = o.length, u = 0; u < s; u++)
                l += "[" + o.start(u).toFixed(3) + "," + o.end(u).toFixed(3) + "]";
              return l;
            }
          }, D = L;
          function V(g, o) {
            for (var l = null, s = 0; s < g.length; s += 1) {
              var u = g[s];
              if (u && u.cc === o) {
                l = u;
                break;
              }
            }
            return l;
          }
          function N(g, o) {
            return Br.search(g, function(l) {
              return l.cc < o ? 1 : l.cc > o ? -1 : 0;
            });
          }
          function X(g, o, l) {
            var s = !1;
            return o && o.details && l && (l.endCC > l.startCC || g && g.cc < l.startCC) && (s = !0), s;
          }
          function Q(g, o) {
            var l = g.fragments, s = o.fragments;
            if (!s.length || !l.length) {
              d.b.log("No fragments to align");
              return;
            }
            var u = V(l, s[0].cc);
            if (!u || u && !u.startPTS) {
              d.b.log("No frag in previous level to align on");
              return;
            }
            return u;
          }
          function H(g, o) {
            o.fragments.forEach(function(l) {
              if (l) {
                var s = l.start + g;
                l.start = l.startPTS = s, l.endPTS = s + l.duration;
              }
            }), o.PTSKnown = !0;
          }
          function ie(g, o, l) {
            if (X(g, o, l)) {
              var s = Q(o.details, l);
              s && (d.b.log("Adjusting PTS using last level due to CC increase within current level"), H(s.start, l));
            }
            if (l.PTSKnown === !1 && o && o.details) {
              var u = o.details.programDateTime, f = l.programDateTime, E = (f - u) / 1e3 + o.details.fragments[0].start;
              isNaN(E) || (d.b.log("adjusting PTS using programDateTime delta, sliding:" + E.toFixed(3)), H(E, l));
            }
          }
          var re = /* @__PURE__ */ function() {
            function g(o, l) {
              for (var s = 0; s < l.length; s++) {
                var u = l[s];
                u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(o, u.key, u);
              }
            }
            return function(o, l, s) {
              return l && g(o.prototype, l), s && g(o, s), o;
            };
          }();
          function fe(g, o) {
            if (!(g instanceof o))
              throw new TypeError("Cannot call a class as a function");
          }
          function oe(g, o) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return o && (typeof o == "object" || typeof o == "function") ? o : g;
          }
          function le(g, o) {
            if (typeof o != "function" && o !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof o);
            g.prototype = Object.create(o && o.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), o && (Object.setPrototypeOf ? Object.setPrototypeOf(g, o) : g.__proto__ = o);
          }
          var ee = {
            STOPPED: "STOPPED",
            IDLE: "IDLE",
            KEY_LOADING: "KEY_LOADING",
            FRAG_LOADING: "FRAG_LOADING",
            FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
            WAITING_LEVEL: "WAITING_LEVEL",
            PARSING: "PARSING",
            PARSED: "PARSED",
            BUFFER_FLUSHING: "BUFFER_FLUSHING",
            ENDED: "ENDED",
            ERROR: "ERROR"
          }, Ie = function(g) {
            le(o, g);
            function o(l) {
              fe(this, o);
              var s = oe(this, g.call(this, l, p.a.MEDIA_ATTACHED, p.a.MEDIA_DETACHING, p.a.MANIFEST_LOADING, p.a.MANIFEST_PARSED, p.a.LEVEL_LOADED, p.a.KEY_LOADED, p.a.FRAG_LOADED, p.a.FRAG_LOAD_EMERGENCY_ABORTED, p.a.FRAG_PARSING_INIT_SEGMENT, p.a.FRAG_PARSING_DATA, p.a.FRAG_PARSED, p.a.ERROR, p.a.AUDIO_TRACK_SWITCHING, p.a.AUDIO_TRACK_SWITCHED, p.a.BUFFER_CREATED, p.a.BUFFER_APPENDED, p.a.BUFFER_FLUSHED));
              return s.config = l.config, s.audioCodecSwap = !1, s.ticks = 0, s._state = ee.STOPPED, s.ontick = s.tick.bind(s), s;
            }
            return o.prototype.destroy = function() {
              this.stopLoad(), this.timer && (clearInterval(this.timer), this.timer = null), K.prototype.destroy.call(this), this.state = ee.STOPPED;
            }, o.prototype.startLoad = function(s) {
              if (this.levels) {
                var u = this.lastCurrentTime, f = this.hls;
                if (this.stopLoad(), this.timer || (this.timer = setInterval(this.ontick, 100)), this.level = -1, this.fragLoadError = 0, !this.startFragRequested) {
                  var E = f.startLevel;
                  E === -1 && (E = 0, this.bitrateTest = !0), this.level = f.nextLoadLevel = E, this.loadedmetadata = !1;
                }
                u > 0 && s === -1 && (d.b.log("override startPosition with lastCurrentTime @" + u.toFixed(3)), s = u), this.state = ee.IDLE, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = s, this.tick();
              } else
                this.forceStartLoad = !0, this.state = ee.STOPPED;
            }, o.prototype.stopLoad = function() {
              var s = this.fragCurrent;
              s && (s.loader && s.loader.abort(), this.fragCurrent = null), this.fragPrevious = null, this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.state = ee.STOPPED, this.forceStartLoad = !1;
            }, o.prototype.tick = function() {
              this.ticks++, this.ticks === 1 && (this.doTick(), this.ticks > 1 && setTimeout(this.tick, 1), this.ticks = 0);
            }, o.prototype.doTick = function() {
              switch (this.state) {
                case ee.ERROR:
                  break;
                case ee.BUFFER_FLUSHING:
                  this.fragLoadError = 0;
                  break;
                case ee.IDLE:
                  this._doTickIdle();
                  break;
                case ee.WAITING_LEVEL:
                  var s = this.levels[this.level];
                  s && s.details && (this.state = ee.IDLE);
                  break;
                case ee.FRAG_LOADING_WAITING_RETRY:
                  var u = performance.now(), f = this.retryDate;
                  (!f || u >= f || this.media && this.media.seeking) && (d.b.log("mediaController: retryDate reached, switch back to IDLE state"), this.state = ee.IDLE);
                  break;
              }
              this._checkBuffer(), this._checkFragmentChanged();
            }, o.prototype._doTickIdle = function() {
              var s = this.hls, u = s.config, f = this.media;
              if (!(this.levelLastLoaded === void 0 || !f && (this.startFragRequested || !u.startFragPrefetch))) {
                var E = void 0;
                this.loadedmetadata ? E = f.currentTime : E = this.nextLoadPosition;
                var w = s.nextLoadLevel, A = this.levels[w];
                if (A) {
                  var S = A.bitrate, k = void 0;
                  S ? k = Math.max(8 * u.maxBufferSize / S, u.maxBufferLength) : k = u.maxBufferLength, k = Math.min(k, u.maxMaxBufferLength);
                  var B = dt.bufferInfo(this.mediaBuffer ? this.mediaBuffer : f, E, u.maxBufferHole), O = B.len;
                  if (!(O >= k)) {
                    d.b.trace("buffer length of " + O.toFixed(3) + " is below max of " + k.toFixed(3) + ". checking for more payload ..."), this.level = s.nextLoadLevel = w;
                    var $ = A.details;
                    if ($ === void 0 || $.live === !0 && this.levelLastLoaded !== w) {
                      this.state = ee.WAITING_LEVEL;
                      return;
                    }
                    var te = this.fragPrevious;
                    if (!$.live && te && !te.backtracked && te.sn === $.endSN && !B.nextStart) {
                      var pe = Math.min(f.duration, te.start + te.duration);
                      if (pe - Math.max(B.end, te.start) <= Math.max(0.2, te.duration)) {
                        var be = {};
                        this.altAudio && (be.type = "video"), this.hls.trigger(p.a.BUFFER_EOS, be), this.state = ee.ENDED;
                        return;
                      }
                    }
                    this._fetchPayloadOrEos(E, B, $);
                  }
                }
              }
            }, o.prototype._fetchPayloadOrEos = function(s, u, f) {
              var E = this.fragPrevious, w = this.level, A = f.fragments, S = A.length;
              if (S !== 0) {
                var k = A[0].start, B = A[S - 1].start + A[S - 1].duration, O = u.end, $ = void 0;
                if (f.initSegment && !f.initSegment.data)
                  $ = f.initSegment;
                else if (f.live) {
                  var te = this.config.initialLiveManifestSize;
                  if (S < te) {
                    d.b.warn("Can not start playback of a level, reason: not enough fragments " + S + " < " + te);
                    return;
                  }
                  if ($ = this._ensureFragmentAtLivePoint(f, O, k, B, E, A, S), $ === null)
                    return;
                } else
                  O < k && ($ = A[0]);
                $ || ($ = this._findFragment(k, E, S, A, O, B, f)), $ && this._loadFragmentOrKey($, w, f, s, O);
              }
            }, o.prototype._ensureFragmentAtLivePoint = function(s, u, f, E, w, A, S) {
              var k = this.hls.config, B = this.media, O = void 0, $ = k.liveMaxLatencyDuration !== void 0 ? k.liveMaxLatencyDuration : k.liveMaxLatencyDurationCount * s.targetduration;
              if (u < Math.max(f - k.maxFragLookUpTolerance, E - $)) {
                var te = this.liveSyncPosition = this.computeLivePosition(f, s);
                d.b.log("buffer end: " + u.toFixed(3) + " is located too far from the end of live sliding playlist, reset currentTime to : " + te.toFixed(3)), u = te, B && B.readyState && B.duration > te && (B.currentTime = te), this.nextLoadPosition = te;
              }
              if (s.PTSKnown && u > E && B && B.readyState)
                return null;
              if (this.startFragRequested && !s.PTSKnown) {
                if (w) {
                  var pe = w.sn + 1;
                  if (pe >= s.startSN && pe <= s.endSN) {
                    var be = A[pe - s.startSN];
                    w.cc === be.cc && (O = be, d.b.log("live playlist, switching playlist, load frag with next SN: " + O.sn));
                  }
                  O || (O = Br.search(A, function(ye) {
                    return w.cc - ye.cc;
                  }), O && d.b.log("live playlist, switching playlist, load frag with same CC: " + O.sn));
                }
                O || (O = A[Math.min(S - 1, Math.round(S / 2))], d.b.log("live playlist, switching playlist, unknown, load middle frag : " + O.sn));
              }
              return O;
            }, o.prototype._findFragment = function(s, u, f, E, w, A, S) {
              var k = this.hls.config, B = void 0, O = void 0, $ = k.maxFragLookUpTolerance, te = u ? E[u.sn - E[0].sn + 1] : void 0, pe = function(ft) {
                var _e = Math.min($, ft.duration + (ft.deltaPTS ? ft.deltaPTS : 0));
                return ft.start + ft.duration - _e <= w ? 1 : ft.start - _e > w && ft.start ? -1 : 0;
              };
              if (w < A ? (w > A - $ && ($ = 0), te && !pe(te) ? O = te : O = Br.search(E, pe)) : O = E[f - 1], O) {
                B = O;
                var be = B.sn - S.startSN, ye = u && B.level === u.level, Se = E[be - 1], Ce = E[be + 1];
                if (u && B.sn === u.sn)
                  if (ye && !B.backtracked)
                    if (B.sn < S.endSN) {
                      var Be = u.deltaPTS;
                      Be && Be > k.maxBufferHole && u.dropped && be ? (B = Se, d.b.warn("SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this"), u.loadCounter--) : (B = Ce, d.b.log("SN just loaded, load next one: " + B.sn));
                    } else
                      B = null;
                  else B.backtracked && (Ce && Ce.backtracked ? (d.b.warn("Already backtracked from fragment " + Ce.sn + ", will not backtrack to fragment " + B.sn + ". Loading fragment " + Ce.sn), B = Ce) : (d.b.warn("Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe"), B.dropped = 0, Se ? (Se.loadCounter && Se.loadCounter--, B = Se, B.backtracked = !0) : be && (B = null)));
              }
              return B;
            }, o.prototype._loadFragmentOrKey = function(s, u, f, E, w) {
              var A = this.hls, S = A.config;
              if (s.decryptdata && s.decryptdata.uri != null && s.decryptdata.key == null)
                d.b.log("Loading key for " + s.sn + " of [" + f.startSN + " ," + f.endSN + "],level " + u), this.state = ee.KEY_LOADING, A.trigger(p.a.KEY_LOADING, { frag: s });
              else {
                if (d.b.log("Loading " + s.sn + " of [" + f.startSN + " ," + f.endSN + "],level " + u + ", currentTime:" + E.toFixed(3) + ",bufferEnd:" + w.toFixed(3)), this.fragLoadIdx !== void 0 ? this.fragLoadIdx++ : this.fragLoadIdx = 0, s.loadCounter) {
                  s.loadCounter++;
                  var k = S.fragLoadingLoopThreshold;
                  if (s.loadCounter > k && Math.abs(this.fragLoadIdx - s.loadIdx) < k) {
                    A.trigger(p.a.ERROR, { type: b.b.MEDIA_ERROR, details: b.a.FRAG_LOOP_LOADING_ERROR, fatal: !1, frag: s });
                    return;
                  }
                } else
                  s.loadCounter = 1;
                s.loadIdx = this.fragLoadIdx, s.autoLevel = A.autoLevelEnabled, s.bitrateTest = this.bitrateTest, this.fragCurrent = s, this.startFragRequested = !0, !isNaN(s.sn) && !s.bitrateTest && (this.nextLoadPosition = s.start + s.duration), A.trigger(p.a.FRAG_LOADING, { frag: s }), this.demuxer || (this.demuxer = new I(A, "main")), this.state = ee.FRAG_LOADING;
                return;
              }
            }, o.prototype.getBufferedFrag = function(s) {
              return Br.search(this._bufferedFrags, function(u) {
                return s < u.startPTS ? -1 : s > u.endPTS ? 1 : 0;
              });
            }, o.prototype.followingBufferedFrag = function(s) {
              return s ? this.getBufferedFrag(s.endPTS + 0.5) : null;
            }, o.prototype._checkFragmentChanged = function() {
              var s, u, f = this.media;
              if (f && f.readyState && f.seeking === !1 && (u = f.currentTime, u > f.playbackRate * this.lastCurrentTime && (this.lastCurrentTime = u), dt.isBuffered(f, u) ? s = this.getBufferedFrag(u) : dt.isBuffered(f, u + 0.1) && (s = this.getBufferedFrag(u + 0.1)), s)) {
                var E = s;
                if (E !== this.fragPlaying) {
                  this.hls.trigger(p.a.FRAG_CHANGED, { frag: E });
                  var w = E.level;
                  (!this.fragPlaying || this.fragPlaying.level !== w) && this.hls.trigger(p.a.LEVEL_SWITCHED, { level: w }), this.fragPlaying = E;
                }
              }
            }, o.prototype.immediateLevelSwitch = function() {
              if (d.b.log("immediateLevelSwitch"), !this.immediateSwitch) {
                this.immediateSwitch = !0;
                var s = this.media, u = void 0;
                s ? (u = s.paused, s.pause()) : u = !0, this.previouslyPaused = u;
              }
              var f = this.fragCurrent;
              f && f.loader && f.loader.abort(), this.fragCurrent = null, this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold), this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
            }, o.prototype.immediateLevelSwitchEnd = function() {
              var s = this.media;
              s && s.buffered.length && (this.immediateSwitch = !1, dt.isBuffered(s, s.currentTime) && (s.currentTime -= 1e-4), this.previouslyPaused || s.play());
            }, o.prototype.nextLevelSwitch = function() {
              var s = this.media;
              if (s && s.readyState) {
                var u = void 0, f = void 0, E = void 0;
                if (this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold), f = this.getBufferedFrag(s.currentTime), f && f.startPTS > 1 && this.flushMainBuffer(0, f.startPTS - 1), s.paused)
                  u = 0;
                else {
                  var w = this.hls.nextLoadLevel, A = this.levels[w], S = this.fragLastKbps;
                  S && this.fragCurrent ? u = this.fragCurrent.duration * A.bitrate / (1e3 * S) + 1 : u = 0;
                }
                if (E = this.getBufferedFrag(s.currentTime + u), E && (E = this.followingBufferedFrag(E), E)) {
                  var k = this.fragCurrent;
                  k && k.loader && k.loader.abort(), this.fragCurrent = null, this.flushMainBuffer(E.maxStartPTS, Number.POSITIVE_INFINITY);
                }
              }
            }, o.prototype.flushMainBuffer = function(s, u) {
              this.state = ee.BUFFER_FLUSHING;
              var f = { startOffset: s, endOffset: u };
              this.altAudio && (f.type = "video"), this.hls.trigger(p.a.BUFFER_FLUSHING, f);
            }, o.prototype.onMediaAttached = function(s) {
              var u = this.media = this.mediaBuffer = s.media;
              this.onvseeking = this.onMediaSeeking.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), this.onvended = this.onMediaEnded.bind(this), u.addEventListener("seeking", this.onvseeking), u.addEventListener("seeked", this.onvseeked), u.addEventListener("ended", this.onvended);
              var f = this.config;
              this.levels && f.autoStartLoad && this.hls.startLoad(f.startPosition);
            }, o.prototype.onMediaDetaching = function() {
              var s = this.media;
              s && s.ended && (d.b.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0);
              var u = this.levels;
              u && u.forEach(function(f) {
                f.details && f.details.fragments.forEach(function(E) {
                  E.loadCounter = void 0, E.backtracked = void 0;
                });
              }), s && (s.removeEventListener("seeking", this.onvseeking), s.removeEventListener("seeked", this.onvseeked), s.removeEventListener("ended", this.onvended), this.onvseeking = this.onvseeked = this.onvended = null), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.stopLoad();
            }, o.prototype.onMediaSeeking = function() {
              var s = this.media, u = s ? s.currentTime : void 0, f = this.config;
              isNaN(u) || d.b.log("media seeking to " + u.toFixed(3));
              var E = this.mediaBuffer ? this.mediaBuffer : s, w = dt.bufferInfo(E, u, this.config.maxBufferHole);
              if (this.state === ee.FRAG_LOADING) {
                var A = this.fragCurrent;
                if (w.len === 0 && A) {
                  var S = f.maxFragLookUpTolerance, k = A.start - S, B = A.start + A.duration + S;
                  u < k || u > B ? (A.loader && (d.b.log("seeking outside of buffer while fragment load in progress, cancel fragment load"), A.loader.abort()), this.fragCurrent = null, this.fragPrevious = null, this.state = ee.IDLE) : d.b.log("seeking outside of buffer but within currently loaded fragment range");
                }
              } else this.state === ee.ENDED && (w.len === 0 && (this.fragPrevious = 0), this.state = ee.IDLE);
              s && (this.lastCurrentTime = u), this.state !== ee.FRAG_LOADING && this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * f.fragLoadingLoopThreshold), this.loadedmetadata || (this.nextLoadPosition = this.startPosition = u), this.tick();
            }, o.prototype.onMediaSeeked = function() {
              var s = this.media, u = s ? s.currentTime : void 0;
              isNaN(u) || d.b.log("media seeked to " + u.toFixed(3)), this.tick();
            }, o.prototype.onMediaEnded = function() {
              d.b.log("media ended"), this.startPosition = this.lastCurrentTime = 0;
            }, o.prototype.onManifestLoading = function() {
              d.b.log("trigger BUFFER_RESET"), this.hls.trigger(p.a.BUFFER_RESET), this._bufferedFrags = [], this.stalled = !1, this.startPosition = this.lastCurrentTime = 0;
            }, o.prototype.onManifestParsed = function(s) {
              var u = !1, f = !1, E;
              s.levels.forEach(function(A) {
                E = A.audioCodec, E && (E.indexOf("mp4a.40.2") !== -1 && (u = !0), E.indexOf("mp4a.40.5") !== -1 && (f = !0));
              }), this.audioCodecSwitch = u && f, this.audioCodecSwitch && d.b.log("both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = s.levels, this.startFragRequested = !1;
              var w = this.config;
              (w.autoStartLoad || this.forceStartLoad) && this.hls.startLoad(w.startPosition);
            }, o.prototype.onLevelLoaded = function(s) {
              var u = s.details, f = s.level, E = this.levels[this.levelLastLoaded], w = this.levels[f], A = u.totalduration, S = 0;
              if (d.b.log("level " + f + " loaded [" + u.startSN + "," + u.endSN + "],duration:" + A), u.live) {
                var k = w.details;
                k && u.fragments.length > 0 ? (C(k, u), S = u.fragments[0].start, this.liveSyncPosition = this.computeLivePosition(S, k), u.PTSKnown && !isNaN(S) ? d.b.log("live playlist sliding:" + S.toFixed(3)) : (d.b.log("live playlist - outdated PTS, unknown sliding"), ie(this.fragPrevious, E, u))) : (d.b.log("live playlist - first load, unknown sliding"), u.PTSKnown = !1, ie(this.fragPrevious, E, u));
              } else
                u.PTSKnown = !1;
              if (w.details = u, this.levelLastLoaded = f, this.hls.trigger(p.a.LEVEL_UPDATED, { details: u, level: f }), this.startFragRequested === !1) {
                if (this.startPosition === -1 || this.lastCurrentTime === -1) {
                  var B = u.startTimeOffset;
                  isNaN(B) ? u.live ? (this.startPosition = this.computeLivePosition(S, u), d.b.log("configure startPosition to " + this.startPosition)) : this.startPosition = 0 : (B < 0 && (d.b.log("negative start time offset " + B + ", count from end of last fragment"), B = S + A + B), d.b.log("start time offset found in playlist, adjust startPosition to " + B), this.startPosition = B), this.lastCurrentTime = this.startPosition;
                }
                this.nextLoadPosition = this.startPosition;
              }
              this.state === ee.WAITING_LEVEL && (this.state = ee.IDLE), this.tick();
            }, o.prototype.onKeyLoaded = function() {
              this.state === ee.KEY_LOADING && (this.state = ee.IDLE, this.tick());
            }, o.prototype.onFragLoaded = function(s) {
              var u = this.fragCurrent, f = s.frag;
              if (this.state === ee.FRAG_LOADING && u && f.type === "main" && f.level === u.level && f.sn === u.sn) {
                var E = s.stats, w = this.levels[u.level], A = w.details;
                if (d.b.log("Loaded  " + u.sn + " of [" + A.startSN + " ," + A.endSN + "],level " + u.level), this.bitrateTest = !1, this.stats = E, f.bitrateTest === !0 && this.hls.nextLoadLevel)
                  this.state = ee.IDLE, this.startFragRequested = !1, E.tparsed = E.tbuffered = performance.now(), this.hls.trigger(p.a.FRAG_BUFFERED, { stats: E, frag: u, id: "main" }), this.tick();
                else if (f.sn === "initSegment")
                  this.state = ee.IDLE, E.tparsed = E.tbuffered = performance.now(), A.initSegment.data = s.payload, this.hls.trigger(p.a.FRAG_BUFFERED, { stats: E, frag: u, id: "main" }), this.tick();
                else {
                  this.state = ee.PARSING;
                  var S = A.totalduration, k = u.level, B = u.sn, O = this.config.defaultAudioCodec || w.audioCodec;
                  this.audioCodecSwap && (d.b.log("swapping playlist audio codec"), O === void 0 && (O = this.lastAudioCodec), O && (O.indexOf("mp4a.40.5") !== -1 ? O = "mp4a.40.2" : O = "mp4a.40.5")), this.pendingBuffering = !0, this.appended = !1, d.b.log("Parsing " + B + " of [" + A.startSN + " ," + A.endSN + "],level " + k + ", cc " + u.cc);
                  var $ = this.demuxer;
                  $ || ($ = this.demuxer = new I(this.hls, "main"));
                  var te = this.media, pe = te && te.seeking, be = !pe && (A.PTSKnown || !A.live), ye = A.initSegment ? A.initSegment.data : [];
                  $.push(s.payload, ye, O, w.videoCodec, u, S, be, void 0);
                }
              }
              this.fragLoadError = 0;
            }, o.prototype.onFragParsingInitSegment = function(s) {
              var u = this.fragCurrent, f = s.frag;
              if (u && s.id === "main" && f.sn === u.sn && f.level === u.level && this.state === ee.PARSING) {
                var E = s.tracks, w, A;
                if (E.audio && this.altAudio && delete E.audio, A = E.audio, A) {
                  var S = this.levels[this.level].audioCodec, k = navigator.userAgent.toLowerCase();
                  S && this.audioCodecSwap && (d.b.log("swapping playlist audio codec"), S.indexOf("mp4a.40.5") !== -1 ? S = "mp4a.40.2" : S = "mp4a.40.5"), this.audioCodecSwitch && A.metadata.channelCount !== 1 && // don't force HE-AAC if firefox
                  k.indexOf("firefox") === -1 && (S = "mp4a.40.5"), k.indexOf("android") !== -1 && A.container !== "audio/mpeg" && (S = "mp4a.40.2", d.b.log("Android: force audio codec to " + S)), A.levelCodec = S, A.id = s.id;
                }
                A = E.video, A && (A.levelCodec = this.levels[this.level].videoCodec, A.id = s.id), this.hls.trigger(p.a.BUFFER_CODECS, E);
                for (w in E) {
                  A = E[w], d.b.log("main track:" + w + ",container:" + A.container + ",codecs[level/parsed]=[" + A.levelCodec + "/" + A.codec + "]");
                  var B = A.initSegment;
                  B && (this.appended = !0, this.pendingBuffering = !0, this.hls.trigger(p.a.BUFFER_APPENDING, { type: w, data: B, parent: "main", content: "initSegment" }));
                }
                this.tick();
              }
            }, o.prototype.onFragParsingData = function(s) {
              var u = this, f = this.fragCurrent, E = s.frag;
              if (f && s.id === "main" && E.sn === f.sn && E.level === f.level && !(s.type === "audio" && this.altAudio) && // filter out main audio if audio track is loaded through audio stream controller
              this.state === ee.PARSING) {
                var w = this.levels[this.level], A = f;
                if (isNaN(s.endPTS) && (s.endPTS = s.startPTS + f.duration, s.endDTS = s.startDTS + f.duration), d.b.log("Parsed " + s.type + ",PTS:[" + s.startPTS.toFixed(3) + "," + s.endPTS.toFixed(3) + "],DTS:[" + s.startDTS.toFixed(3) + "/" + s.endDTS.toFixed(3) + "],nb:" + s.nb + ",dropped:" + (s.dropped || 0)), s.type === "video")
                  if (A.dropped = s.dropped, A.dropped)
                    if (A.backtracked)
                      d.b.warn("Already backtracked on this fragment, appending with the gap");
                    else {
                      var S = w.details;
                      if (S && A.sn === S.startSN)
                        d.b.warn("missing video frame(s) on first frag, appending with gap");
                      else {
                        d.b.warn("missing video frame(s), backtracking fragment"), A.backtracked = !0, this.nextLoadPosition = s.startPTS, this.state = ee.IDLE, this.fragPrevious = A, this.tick();
                        return;
                      }
                    }
                  else
                    A.backtracked = !1;
                var k = T(w.details, A, s.startPTS, s.endPTS, s.startDTS, s.endDTS), B = this.hls;
                B.trigger(p.a.LEVEL_PTS_UPDATED, { details: w.details, level: this.level, drift: k, type: s.type, start: s.startPTS, end: s.endPTS }), [s.data1, s.data2].forEach(function(O) {
                  O && O.length && u.state === ee.PARSING && (u.appended = !0, u.pendingBuffering = !0, B.trigger(p.a.BUFFER_APPENDING, { type: s.type, data: O, parent: "main", content: "data" }));
                }), this.tick();
              }
            }, o.prototype.onFragParsed = function(s) {
              var u = this.fragCurrent, f = s.frag;
              u && s.id === "main" && f.sn === u.sn && f.level === u.level && this.state === ee.PARSING && (this.stats.tparsed = performance.now(), this.state = ee.PARSED, this._checkAppendedParsed());
            }, o.prototype.onAudioTrackSwitching = function(s) {
              var u = !!s.url, f = s.id;
              if (!u) {
                if (this.mediaBuffer !== this.media) {
                  d.b.log("switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media;
                  var E = this.fragCurrent;
                  E.loader && (d.b.log("switching to main audio track, cancel main fragment load"), E.loader.abort()), this.fragCurrent = null, this.fragPrevious = null, this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.state = ee.IDLE;
                }
                var w = this.hls;
                w.trigger(p.a.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: "audio" }), w.trigger(p.a.AUDIO_TRACK_SWITCHED, { id: f }), this.altAudio = !1;
              }
            }, o.prototype.onAudioTrackSwitched = function(s) {
              var u = s.id, f = !!this.hls.audioTracks[u].url;
              if (f) {
                var E = this.videoBuffer;
                E && this.mediaBuffer !== E && (d.b.log("switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = E);
              }
              this.altAudio = f, this.tick();
            }, o.prototype.onBufferCreated = function(s) {
              var u = s.tracks, f = void 0, E = void 0, w = !1;
              for (var A in u) {
                var S = u[A];
                S.id === "main" ? (E = A, f = S, A === "video" && (this.videoBuffer = u[A].buffer)) : w = !0;
              }
              w && f ? (d.b.log("alternate track found, use " + E + ".buffered to schedule main fragment loading"), this.mediaBuffer = f.buffer) : this.mediaBuffer = this.media;
            }, o.prototype.onBufferAppended = function(s) {
              if (s.parent === "main") {
                var u = this.state;
                (u === ee.PARSING || u === ee.PARSED) && (this.pendingBuffering = s.pending > 0, this._checkAppendedParsed());
              }
            }, o.prototype._checkAppendedParsed = function() {
              if (this.state === ee.PARSED && (!this.appended || !this.pendingBuffering)) {
                var s = this.fragCurrent;
                if (s) {
                  var u = this.mediaBuffer ? this.mediaBuffer : this.media;
                  d.b.log("main buffered : " + D.toString(u.buffered));
                  var f = this._bufferedFrags.filter(function(w) {
                    return dt.isBuffered(u, (w.startPTS + w.endPTS) / 2);
                  });
                  f.push(s), this._bufferedFrags = f.sort(function(w, A) {
                    return w.startPTS - A.startPTS;
                  }), this.fragPrevious = s;
                  var E = this.stats;
                  E.tbuffered = performance.now(), this.fragLastKbps = Math.round(8 * E.total / (E.tbuffered - E.tfirst)), this.hls.trigger(p.a.FRAG_BUFFERED, { stats: E, frag: s, id: "main" }), this.state = ee.IDLE;
                }
                this.tick();
              }
            }, o.prototype.onError = function(s) {
              var u = s.frag || this.fragCurrent;
              if (!(u && u.type !== "main")) {
                var f = !!this.media && dt.isBuffered(this.media, this.media.currentTime) && dt.isBuffered(this.media, this.media.currentTime + 0.5);
                switch (s.details) {
                  case b.a.FRAG_LOAD_ERROR:
                  case b.a.FRAG_LOAD_TIMEOUT:
                  case b.a.KEY_LOAD_ERROR:
                  case b.a.KEY_LOAD_TIMEOUT:
                    if (!s.fatal)
                      if (this.fragLoadError + 1 <= this.config.fragLoadingMaxRetry) {
                        var E = Math.min(Math.pow(2, this.fragLoadError) * this.config.fragLoadingRetryDelay, this.config.fragLoadingMaxRetryTimeout);
                        u.loadCounter = 0, d.b.warn("mediaController: frag loading failed, retry in " + E + " ms"), this.retryDate = performance.now() + E, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.fragLoadError++, this.state = ee.FRAG_LOADING_WAITING_RETRY;
                      } else
                        d.b.error("mediaController: " + s.details + " reaches max retry, redispatch as fatal ..."), s.fatal = !0, this.state = ee.ERROR;
                    break;
                  case b.a.FRAG_LOOP_LOADING_ERROR:
                    s.fatal || (f ? (this._reduceMaxBufferLength(u.duration), this.state = ee.IDLE) : (!u.autoLevel || u.level === 0) && (s.fatal = !0, this.state = ee.ERROR));
                    break;
                  case b.a.LEVEL_LOAD_ERROR:
                  case b.a.LEVEL_LOAD_TIMEOUT:
                    this.state !== ee.ERROR && (s.fatal ? (this.state = ee.ERROR, d.b.warn("streamController: " + s.details + ",switch to " + this.state + " state ...")) : !s.levelRetry && this.state === ee.WAITING_LEVEL && (this.state = ee.IDLE));
                    break;
                  case b.a.BUFFER_FULL_ERROR:
                    s.parent === "main" && (this.state === ee.PARSING || this.state === ee.PARSED) && (f ? (this._reduceMaxBufferLength(this.config.maxBufferLength), this.state = ee.IDLE) : (d.b.warn("buffer full error also media.currentTime is not buffered, flush everything"), this.fragCurrent = null, this.flushMainBuffer(0, Number.POSITIVE_INFINITY)));
                    break;
                }
              }
            }, o.prototype._reduceMaxBufferLength = function(s) {
              var u = this.config;
              u.maxMaxBufferLength >= s && (u.maxMaxBufferLength /= 2, d.b.warn("main:reduce max buffer length to " + u.maxMaxBufferLength + "s"), this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * u.fragLoadingLoopThreshold));
            }, o.prototype._checkBuffer = function() {
              var s = this.media, u = this.config;
              if (s && s.readyState) {
                var f = s.currentTime, E = this.mediaBuffer ? this.mediaBuffer : s, w = E.buffered;
                if (!this.loadedmetadata && w.length) {
                  this.loadedmetadata = !0;
                  var A = s.seeking ? f : this.startPosition, S = dt.isBuffered(E, A), k = w.start(0), B = !S && Math.abs(A - k) < u.maxSeekHole;
                  (f !== A || B) && (d.b.log("target start position:" + A), B && (A = k, d.b.log("target start position not buffered, seek to buffered.start(0) " + A)), d.b.log("adjust currentTime from " + f + " to " + A), s.currentTime = A);
                } else if (this.immediateSwitch)
                  this.immediateLevelSwitchEnd();
                else {
                  var O = dt.bufferInfo(s, f, 0), $ = !(s.paused || // not playing when media is paused
                  s.ended || // not playing when media is ended
                  s.buffered.length === 0), te = 0.5, pe = f !== this.lastCurrentTime;
                  if (pe)
                    this.stallReported && (d.b.warn("playback not stuck anymore @" + f + ", after " + Math.round(performance.now() - this.stalled) + "ms"), this.stallReported = !1), this.stalled = void 0, this.nudgeRetry = 0;
                  else if ($) {
                    var be = performance.now(), ye = this.hls;
                    if (!this.stalled)
                      this.stalled = be, this.stallReported = !1;
                    else {
                      var Se = be - this.stalled, Ce = O.len, Be = this.nudgeRetry || 0;
                      if (Ce <= te && Se > u.lowBufferWatchdogPeriod * 1e3) {
                        this.stallReported || (this.stallReported = !0, d.b.warn("playback stalling in low buffer @" + f), ye.trigger(p.a.ERROR, { type: b.b.MEDIA_ERROR, details: b.a.BUFFER_STALLED_ERROR, fatal: !1, buffer: Ce }));
                        var He = O.nextStart, ft = He - f;
                        if (He && ft < u.maxSeekHole && ft > 0) {
                          this.nudgeRetry = ++Be;
                          var _e = Be * u.nudgeOffset;
                          d.b.log("adjust currentTime from " + s.currentTime + " to next buffered @ " + He + " + nudge " + _e), s.currentTime = He + _e, this.stalled = void 0, ye.trigger(p.a.ERROR, { type: b.b.MEDIA_ERROR, details: b.a.BUFFER_SEEK_OVER_HOLE, fatal: !1, hole: He + _e - f });
                        }
                      } else if (Ce > te && Se > u.highBufferWatchdogPeriod * 1e3)
                        if (this.stallReported || (this.stallReported = !0, d.b.warn("playback stalling in high buffer @" + f), ye.trigger(p.a.ERROR, { type: b.b.MEDIA_ERROR, details: b.a.BUFFER_STALLED_ERROR, fatal: !1, buffer: Ce })), this.stalled = void 0, this.nudgeRetry = ++Be, Be < u.nudgeMaxRetry) {
                          var Bt = s.currentTime, at = Bt + Be * u.nudgeOffset;
                          d.b.log("adjust currentTime from " + Bt + " to " + at), s.currentTime = at, ye.trigger(p.a.ERROR, { type: b.b.MEDIA_ERROR, details: b.a.BUFFER_NUDGE_ON_STALL, fatal: !1 });
                        } else
                          d.b.error("still stuck in high buffer @" + f + " after " + u.nudgeMaxRetry + ", raise fatal error"), ye.trigger(p.a.ERROR, { type: b.b.MEDIA_ERROR, details: b.a.BUFFER_STALLED_ERROR, fatal: !0 });
                    }
                  }
                }
              }
            }, o.prototype.onFragLoadEmergencyAborted = function() {
              this.state = ee.IDLE, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tick();
            }, o.prototype.onBufferFlushed = function() {
              var s = this.mediaBuffer ? this.mediaBuffer : this.media;
              this._bufferedFrags = this._bufferedFrags.filter(function(u) {
                return dt.isBuffered(s, (u.startPTS + u.endPTS) / 2);
              }), this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold), this.state = ee.IDLE, this.fragPrevious = null;
            }, o.prototype.swapAudioCodec = function() {
              this.audioCodecSwap = !this.audioCodecSwap;
            }, o.prototype.computeLivePosition = function(s, u) {
              var f = this.config.liveSyncDuration !== void 0 ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * u.targetduration;
              return s + Math.max(0, u.totalduration - f);
            }, re(o, [{
              key: "state",
              set: function(s) {
                if (this.state !== s) {
                  var u = this.state;
                  this._state = s, d.b.log("main stream:" + u + "->" + s), this.hls.trigger(p.a.STREAM_STATE_TRANSITION, { previousState: u, nextState: s });
                }
              },
              get: function() {
                return this._state;
              }
            }, {
              key: "currentLevel",
              get: function() {
                var s = this.media;
                if (s) {
                  var u = this.getBufferedFrag(s.currentTime);
                  if (u)
                    return u.level;
                }
                return -1;
              }
            }, {
              key: "nextBufferedFrag",
              get: function() {
                var s = this.media;
                return s ? this.followingBufferedFrag(this.getBufferedFrag(s.currentTime)) : null;
              }
            }, {
              key: "nextLevel",
              get: function() {
                var s = this.nextBufferedFrag;
                return s ? s.level : -1;
              }
            }, {
              key: "liveSyncPosition",
              get: function() {
                return this._liveSyncPosition;
              },
              set: function(s) {
                this._liveSyncPosition = s;
              }
            }]), o;
          }(K), et = Ie, tt = /* @__PURE__ */ function() {
            function g(o, l) {
              for (var s = 0; s < l.length; s++) {
                var u = l[s];
                u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(o, u.key, u);
              }
            }
            return function(o, l, s) {
              return l && g(o.prototype, l), s && g(o, s), o;
            };
          }();
          function Fe(g, o) {
            if (!(g instanceof o))
              throw new TypeError("Cannot call a class as a function");
          }
          function Ze(g, o) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return o && (typeof o == "object" || typeof o == "function") ? o : g;
          }
          function Te(g, o) {
            if (typeof o != "function" && o !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof o);
            g.prototype = Object.create(o && o.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), o && (Object.setPrototypeOf ? Object.setPrototypeOf(g, o) : g.__proto__ = o);
          }
          var st = function(g) {
            Te(o, g);
            function o(l) {
              Fe(this, o);
              var s = Ze(this, g.call(this, l, p.a.MANIFEST_LOADED, p.a.LEVEL_LOADED, p.a.FRAG_LOADED, p.a.ERROR));
              return s.canload = !1, s.currentLevelIndex = null, s.manualLevelIndex = -1, s.timer = null, s;
            }
            return o.prototype.destroy = function() {
              this.cleanTimer(), this.manualLevelIndex = -1;
            }, o.prototype.cleanTimer = function() {
              this.timer !== null && (clearTimeout(this.timer), this.timer = null);
            }, o.prototype.startLoad = function() {
              var s = this._levels;
              this.canload = !0, this.levelRetryCount = 0, s && s.forEach(function(u) {
                u.loadError = 0;
                var f = u.details;
                f && f.live && (u.details = void 0);
              }), this.timer !== null && this.loadLevel();
            }, o.prototype.stopLoad = function() {
              this.canload = !1;
            }, o.prototype.onManifestLoaded = function(s) {
              var u = [], f = void 0, E = {}, w = null, A = !1, S = !1, k = /chrome|firefox/.test(navigator.userAgent.toLowerCase()), B = [];
              if (s.levels.forEach(function($) {
                $.loadError = 0, $.fragmentError = !1, A = A || !!$.videoCodec, S = S || !!$.audioCodec || !!($.attrs && $.attrs.AUDIO), k === !0 && $.audioCodec && $.audioCodec.indexOf("mp4a.40.34") !== -1 && ($.audioCodec = void 0), w = E[$.bitrate], w === void 0 ? ($.url = [$.url], $.urlId = 0, E[$.bitrate] = $, u.push($)) : w.url.push($.url);
              }), A === !0 && S === !0 && (u = u.filter(function($) {
                var te = $.videoCodec;
                return !!te;
              })), u = u.filter(function($) {
                var te = $.audioCodec, pe = $.videoCodec;
                return (!te || xe(te)) && (!pe || xe(pe));
              }), s.audioTracks && (B = s.audioTracks.filter(function($) {
                return !$.audioCodec || xe($.audioCodec, "audio");
              })), u.length > 0) {
                f = u[0].bitrate, u.sort(function($, te) {
                  return $.bitrate - te.bitrate;
                }), this._levels = u;
                for (var O = 0; O < u.length; O++)
                  if (u[O].bitrate === f) {
                    this._firstLevel = O, d.b.log("manifest loaded," + u.length + " level(s) found, first bitrate:" + f);
                    break;
                  }
                this.hls.trigger(p.a.MANIFEST_PARSED, {
                  levels: u,
                  audioTracks: B,
                  firstLevel: this._firstLevel,
                  stats: s.stats,
                  audio: S,
                  video: A,
                  altAudio: B.length > 0
                });
              } else
                this.hls.trigger(p.a.ERROR, {
                  type: b.b.MEDIA_ERROR,
                  details: b.a.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
                  fatal: !0,
                  url: this.hls.url,
                  reason: "no level with compatible codecs found in manifest"
                });
            }, o.prototype.setLevelInternal = function(s) {
              var u = this._levels, f = this.hls;
              if (s >= 0 && s < u.length) {
                if (this.cleanTimer(), this.currentLevelIndex !== s) {
                  d.b.log("switching to level " + s), this.currentLevelIndex = s;
                  var E = u[s];
                  E.level = s, f.trigger(p.a.LEVEL_SWITCH, E), f.trigger(p.a.LEVEL_SWITCHING, E);
                }
                var w = u[s], A = w.details;
                if (!A || A.live === !0) {
                  var S = w.urlId;
                  f.trigger(p.a.LEVEL_LOADING, { url: w.url[S], level: s, id: S });
                }
              } else
                f.trigger(p.a.ERROR, {
                  type: b.b.OTHER_ERROR,
                  details: b.a.LEVEL_SWITCH_ERROR,
                  level: s,
                  fatal: !1,
                  reason: "invalid level idx"
                });
            }, o.prototype.onError = function(s) {
              if (s.fatal === !0) {
                s.type === b.b.NETWORK_ERROR && this.cleanTimer();
                return;
              }
              var u = !1, f = !1, E = void 0;
              switch (s.details) {
                case b.a.FRAG_LOAD_ERROR:
                case b.a.FRAG_LOAD_TIMEOUT:
                case b.a.FRAG_LOOP_LOADING_ERROR:
                case b.a.KEY_LOAD_ERROR:
                case b.a.KEY_LOAD_TIMEOUT:
                  E = s.frag.level, f = !0;
                  break;
                case b.a.LEVEL_LOAD_ERROR:
                case b.a.LEVEL_LOAD_TIMEOUT:
                  E = s.context.level, u = !0;
                  break;
                case b.a.REMUX_ALLOC_ERROR:
                  E = s.level, u = !0;
                  break;
              }
              E !== void 0 && this.recoverLevel(s, E, u, f);
            }, o.prototype.recoverLevel = function(s, u, f, E) {
              var w = this, A = this.hls.config, S = s.details, k = this._levels[u], B = void 0, O = void 0, $ = void 0;
              if (k.loadError++, k.fragmentError = E, f === !0)
                if (this.levelRetryCount + 1 <= A.levelLoadingMaxRetry)
                  O = Math.min(Math.pow(2, this.levelRetryCount) * A.levelLoadingRetryDelay, A.levelLoadingMaxRetryTimeout), this.timer = setTimeout(function() {
                    return w.loadLevel();
                  }, O), s.levelRetry = !0, this.levelRetryCount++, d.b.warn("level controller, " + S + ", retry in " + O + " ms, current retry count is " + this.levelRetryCount);
                else {
                  d.b.error("level controller, cannot recover from " + S + " error"), this.currentLevelIndex = null, this.cleanTimer(), s.fatal = !0;
                  return;
                }
              (f === !0 || E === !0) && (B = k.url.length, B > 1 && k.loadError < B ? (d.b.warn("level controller, " + S + " for level " + u + ": switching to redundant stream id " + k.urlId), k.urlId = (k.urlId + 1) % B, k.details = void 0) : this.manualLevelIndex === -1 ? ($ = u === 0 ? this._levels.length - 1 : u - 1, d.b.warn("level controller, " + S + ": switch to " + $), this.hls.nextAutoLevel = this.currentLevelIndex = $) : E === !0 && (d.b.warn("level controller, " + S + ": reload a fragment"), this.currentLevelIndex = null));
            }, o.prototype.onFragLoaded = function(s) {
              var u = s.frag;
              if (u !== void 0 && u.type === "main") {
                var f = this._levels[u.level];
                f !== void 0 && (f.fragmentError = !1, f.loadError = 0, this.levelRetryCount = 0);
              }
            }, o.prototype.onLevelLoaded = function(s) {
              var u = this, f = s.level;
              if (f === this.currentLevelIndex) {
                var E = this._levels[f];
                E.fragmentError === !1 && (E.loadError = 0, this.levelRetryCount = 0);
                var w = s.details;
                if (w.live) {
                  var A = 1e3 * (w.averagetargetduration ? w.averagetargetduration : w.targetduration), S = E.details;
                  S && w.endSN === S.endSN && (A /= 2, d.b.log("same live playlist, reload twice faster")), A -= performance.now() - s.stats.trequest, A = Math.max(1e3, Math.round(A)), d.b.log("live playlist, reload in " + A + " ms"), this.timer = setTimeout(function() {
                    return u.loadLevel();
                  }, A);
                } else
                  this.cleanTimer();
              }
            }, o.prototype.loadLevel = function() {
              var s = void 0, u = void 0;
              this.currentLevelIndex !== null && this.canload === !0 && (s = this._levels[this.currentLevelIndex], s !== void 0 && s.url.length > 0 && (u = s.urlId, this.hls.trigger(p.a.LEVEL_LOADING, { url: s.url[u], level: this.currentLevelIndex, id: u })));
            }, tt(o, [{
              key: "levels",
              get: function() {
                return this._levels;
              }
            }, {
              key: "level",
              get: function() {
                return this.currentLevelIndex;
              },
              set: function(s) {
                var u = this._levels;
                u && (s = Math.min(s, u.length - 1), (this.currentLevelIndex !== s || u[s].details === void 0) && this.setLevelInternal(s));
              }
            }, {
              key: "manualLevel",
              get: function() {
                return this.manualLevelIndex;
              },
              set: function(s) {
                this.manualLevelIndex = s, this._startLevel === void 0 && (this._startLevel = s), s !== -1 && (this.level = s);
              }
            }, {
              key: "firstLevel",
              get: function() {
                return this._firstLevel;
              },
              set: function(s) {
                this._firstLevel = s;
              }
            }, {
              key: "startLevel",
              get: function() {
                if (this._startLevel === void 0) {
                  var s = this.hls.config.startLevel;
                  return s !== void 0 ? s : this._firstLevel;
                } else
                  return this._startLevel;
              },
              set: function(s) {
                this._startLevel = s;
              }
            }, {
              key: "nextLoadLevel",
              get: function() {
                return this.manualLevelIndex !== -1 ? this.manualLevelIndex : this.hls.nextAutoLevel;
              },
              set: function(s) {
                this.level = s, this.manualLevelIndex === -1 && (this.hls.nextAutoLevel = s);
              }
            }]), o;
          }(K), At = st, rt = a(3);
          function xt(g, o) {
            if (!(g instanceof o))
              throw new TypeError("Cannot call a class as a function");
          }
          function Ct(g, o) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return o && (typeof o == "object" || typeof o == "function") ? o : g;
          }
          function ir(g, o) {
            if (typeof o != "function" && o !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof o);
            g.prototype = Object.create(o && o.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), o && (Object.setPrototypeOf ? Object.setPrototypeOf(g, o) : g.__proto__ = o);
          }
          var Pt = function(g) {
            ir(o, g);
            function o(l) {
              xt(this, o);
              var s = Ct(this, g.call(this, l, p.a.MEDIA_ATTACHED, p.a.MEDIA_DETACHING, p.a.FRAG_PARSING_METADATA));
              return s.id3Track = void 0, s.media = void 0, s;
            }
            return o.prototype.destroy = function() {
              K.prototype.destroy.call(this);
            }, o.prototype.onMediaAttached = function(s) {
              this.media = s.media, this.media;
            }, o.prototype.onMediaDetaching = function() {
              this.media = void 0;
            }, o.prototype.onFragParsingMetadata = function(s) {
              var u = s.frag, f = s.samples;
              this.id3Track || (this.id3Track = this.media.addTextTrack("metadata", "id3"), this.id3Track.mode = "hidden");
              for (var E = window.WebKitDataCue || window.VTTCue || window.TextTrackCue, w = 0; w < f.length; w++) {
                var A = rt.a.getID3Frames(f[w].data);
                if (A) {
                  var S = f[w].pts, k = w < f.length - 1 ? f[w + 1].pts : u.endPTS;
                  S === k && (k += 1e-4);
                  for (var B = 0; B < A.length; B++) {
                    var O = A[B];
                    if (!rt.a.isTimeStampFrame(O)) {
                      var $ = new E(S, k, "");
                      $.value = O, this.id3Track.addCue($);
                    }
                  }
                }
              }
            }, o;
          }(K), br = Pt;
          function zt() {
            var g = Zs(), o = window.SourceBuffer || window.WebKitSourceBuffer, l = g && typeof g.isTypeSupported == "function" && g.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"'), s = !o || o.prototype && typeof o.prototype.appendBuffer == "function" && typeof o.prototype.remove == "function";
            return !!l && !!s;
          }
          function nr(g, o) {
            if (!(g instanceof o))
              throw new TypeError("Cannot call a class as a function");
          }
          var _i = function() {
            function g(o) {
              nr(this, g), this.alpha_ = o ? Math.exp(Math.log(0.5) / o) : 0, this.estimate_ = 0, this.totalWeight_ = 0;
            }
            return g.prototype.sample = function(l, s) {
              var u = Math.pow(this.alpha_, l);
              this.estimate_ = s * (1 - u) + u * this.estimate_, this.totalWeight_ += l;
            }, g.prototype.getTotalWeight = function() {
              return this.totalWeight_;
            }, g.prototype.getEstimate = function() {
              if (this.alpha_) {
                var l = 1 - Math.pow(this.alpha_, this.totalWeight_);
                return this.estimate_ / l;
              } else
                return this.estimate_;
            }, g;
          }(), wi = _i;
          function Cn(g, o) {
            if (!(g instanceof o))
              throw new TypeError("Cannot call a class as a function");
          }
          var Xt = function() {
            function g(o, l, s, u) {
              Cn(this, g), this.hls = o, this.defaultEstimate_ = u, this.minWeight_ = 1e-3, this.minDelayMs_ = 50, this.slow_ = new wi(l), this.fast_ = new wi(s);
            }
            return g.prototype.sample = function(l, s) {
              l = Math.max(l, this.minDelayMs_);
              var u = 8e3 * s / l, f = l / 1e3;
              this.fast_.sample(f, u), this.slow_.sample(f, u);
            }, g.prototype.canEstimate = function() {
              var l = this.fast_;
              return l && l.getTotalWeight() >= this.minWeight_;
            }, g.prototype.getEstimate = function() {
              return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_;
            }, g.prototype.destroy = function() {
            }, g;
          }(), _t = Xt, Ir = /* @__PURE__ */ function() {
            function g(o, l) {
              for (var s = 0; s < l.length; s++) {
                var u = l[s];
                u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(o, u.key, u);
              }
            }
            return function(o, l, s) {
              return l && g(o.prototype, l), s && g(o, s), o;
            };
          }();
          function Ti(g, o) {
            if (!(g instanceof o))
              throw new TypeError("Cannot call a class as a function");
          }
          function Hr(g, o) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return o && (typeof o == "object" || typeof o == "function") ? o : g;
          }
          function Ln(g, o) {
            if (typeof o != "function" && o !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof o);
            g.prototype = Object.create(o && o.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), o && (Object.setPrototypeOf ? Object.setPrototypeOf(g, o) : g.__proto__ = o);
          }
          var cs = function(g) {
            Ln(o, g);
            function o(l) {
              Ti(this, o);
              var s = Hr(this, g.call(this, l, p.a.FRAG_LOADING, p.a.FRAG_LOADED, p.a.FRAG_BUFFERED, p.a.ERROR));
              return s.lastLoadedFragLevel = 0, s._nextAutoLevel = -1, s.hls = l, s.timer = null, s._bwEstimator = null, s.onCheck = s._abandonRulesCheck.bind(s), s;
            }
            return o.prototype.destroy = function() {
              this.clearTimer(), K.prototype.destroy.call(this);
            }, o.prototype.onFragLoading = function(s) {
              var u = s.frag;
              if (u.type === "main") {
                if (this.timer || (this.timer = setInterval(this.onCheck, 100)), !this._bwEstimator) {
                  var f = this.hls, E = s.frag.level, w = f.levels[E].details.live, A = f.config, S = void 0, k = void 0;
                  w ? (S = A.abrEwmaFastLive, k = A.abrEwmaSlowLive) : (S = A.abrEwmaFastVoD, k = A.abrEwmaSlowVoD), this._bwEstimator = new _t(f, k, S, A.abrEwmaDefaultEstimate);
                }
                this.fragCurrent = u;
              }
            }, o.prototype._abandonRulesCheck = function() {
              var s = this.hls, u = s.media, f = this.fragCurrent, E = f.loader, w = s.minAutoLevel;
              if (!E || E.stats && E.stats.aborted) {
                d.b.warn("frag loader destroy or aborted, disarm abandonRules"), this.clearTimer(), this._nextAutoLevel = -1;
                return;
              }
              var A = E.stats;
              if (u && A && (!u.paused && u.playbackRate !== 0 || !u.readyState) && f.autoLevel && f.level) {
                var S = performance.now() - A.trequest, k = Math.abs(u.playbackRate);
                if (S > 500 * f.duration / k) {
                  var B = s.levels, O = Math.max(1, A.bw ? A.bw / 8 : A.loaded * 1e3 / S), $ = B[f.level], te = $.realBitrate ? Math.max($.realBitrate, $.bitrate) : $.bitrate, pe = A.total ? A.total : Math.max(A.loaded, Math.round(f.duration * te / 8)), be = u.currentTime, ye = (pe - A.loaded) / O, Se = (dt.bufferInfo(u, be, s.config.maxBufferHole).end - be) / k;
                  if (Se < 2 * f.duration / k && ye > Se) {
                    var Ce = void 0, Be = void 0;
                    for (Be = f.level - 1; Be > w; Be--) {
                      var He = B[Be].realBitrate ? Math.max(B[Be].realBitrate, B[Be].bitrate) : B[Be].bitrate;
                      if (Ce = f.duration * He / (8 * 0.8 * O), Ce < Se)
                        break;
                    }
                    Ce < ye && (d.b.warn("loading too slow, abort fragment loading and switch to level " + Be + ":fragLoadedDelay[" + Be + "]<fragLoadedDelay[" + (f.level - 1) + "];bufferStarvationDelay:" + Ce.toFixed(1) + "<" + ye.toFixed(1) + ":" + Se.toFixed(1)), s.nextLoadLevel = Be, this._bwEstimator.sample(S, A.loaded), E.abort(), this.clearTimer(), s.trigger(p.a.FRAG_LOAD_EMERGENCY_ABORTED, { frag: f, stats: A }));
                  }
                }
              }
            }, o.prototype.onFragLoaded = function(s) {
              var u = s.frag;
              if (u.type === "main" && !isNaN(u.sn)) {
                if (this.clearTimer(), this.lastLoadedFragLevel = u.level, this._nextAutoLevel = -1, this.hls.config.abrMaxWithRealBitrate) {
                  var f = this.hls.levels[u.level], E = (f.loaded ? f.loaded.bytes : 0) + s.stats.loaded, w = (f.loaded ? f.loaded.duration : 0) + s.frag.duration;
                  f.loaded = { bytes: E, duration: w }, f.realBitrate = Math.round(8 * E / w);
                }
                if (s.frag.bitrateTest) {
                  var A = s.stats;
                  A.tparsed = A.tbuffered = A.tload, this.onFragBuffered(s);
                }
              }
            }, o.prototype.onFragBuffered = function(s) {
              var u = s.stats, f = s.frag;
              if (u.aborted !== !0 && f.loadCounter === 1 && f.type === "main" && !isNaN(f.sn) && (!f.bitrateTest || u.tload === u.tbuffered)) {
                var E = u.tparsed - u.trequest;
                d.b.log("latency/loading/parsing/append/kbps:" + Math.round(u.tfirst - u.trequest) + "/" + Math.round(u.tload - u.tfirst) + "/" + Math.round(u.tparsed - u.tload) + "/" + Math.round(u.tbuffered - u.tparsed) + "/" + Math.round(8 * u.loaded / (u.tbuffered - u.trequest))), this._bwEstimator.sample(E, u.loaded), u.bwEstimate = this._bwEstimator.getEstimate(), f.bitrateTest ? this.bitrateTestDelay = E / 1e3 : this.bitrateTestDelay = 0;
              }
            }, o.prototype.onError = function(s) {
              switch (s.details) {
                case b.a.FRAG_LOAD_ERROR:
                case b.a.FRAG_LOAD_TIMEOUT:
                  this.clearTimer();
                  break;
              }
            }, o.prototype.clearTimer = function() {
              clearInterval(this.timer), this.timer = null;
            }, o.prototype._findBestLevel = function(s, u, f, E, w, A, S, k, B) {
              for (var O = w; O >= E; O--) {
                var $ = B[O], te = $.details, pe = te ? te.totalduration / te.fragments.length : u, be = te ? te.live : !1, ye = void 0;
                O <= s ? ye = S * f : ye = k * f;
                var Se = B[O].realBitrate ? Math.max(B[O].realBitrate, B[O].bitrate) : B[O].bitrate, Ce = Se * pe / ye;
                if (d.b.trace("level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: " + O + "/" + Math.round(ye) + "/" + Se + "/" + pe + "/" + A + "/" + Ce), ye > Se && // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
                // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
                // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that _findBestLevel will return -1
                (!Ce || be && !this.bitrateTestDelay || Ce < A))
                  return O;
              }
              return -1;
            }, Ir(o, [{
              key: "nextAutoLevel",
              get: function() {
                var s = this._nextAutoLevel, u = this._bwEstimator;
                if (s !== -1 && (!u || !u.canEstimate()))
                  return s;
                var f = this._nextABRAutoLevel;
                return s !== -1 && (f = Math.min(s, f)), f;
              },
              set: function(s) {
                this._nextAutoLevel = s;
              }
            }, {
              key: "_nextABRAutoLevel",
              get: function() {
                var s = this.hls, u = s.maxAutoLevel, f = s.levels, E = s.config, w = s.minAutoLevel, A = s.media, S = this.lastLoadedFragLevel, k = this.fragCurrent ? this.fragCurrent.duration : 0, B = A ? A.currentTime : 0, O = A && A.playbackRate !== 0 ? Math.abs(A.playbackRate) : 1, $ = this._bwEstimator ? this._bwEstimator.getEstimate() : E.abrEwmaDefaultEstimate, te = (dt.bufferInfo(A, B, E.maxBufferHole).end - B) / O, pe = this._findBestLevel(S, k, $, w, u, te, E.abrBandWidthFactor, E.abrBandWidthUpFactor, f);
                if (pe >= 0)
                  return pe;
                d.b.trace("rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering");
                var be = k ? Math.min(k, E.maxStarvationDelay) : E.maxStarvationDelay, ye = E.abrBandWidthFactor, Se = E.abrBandWidthUpFactor;
                if (te === 0) {
                  var Ce = this.bitrateTestDelay;
                  if (Ce) {
                    var Be = k ? Math.min(k, E.maxLoadingDelay) : E.maxLoadingDelay;
                    be = Be - Ce, d.b.trace("bitrate test took " + Math.round(1e3 * Ce) + "ms, set first fragment max fetchDuration to " + Math.round(1e3 * be) + " ms"), ye = Se = 1;
                  }
                }
                return pe = this._findBestLevel(S, k, $, w, u, te + be, ye, Se, f), Math.max(pe, 0);
              }
            }]), o;
          }(K), kn = cs;
          function Dn(g, o) {
            if (!(g instanceof o))
              throw new TypeError("Cannot call a class as a function");
          }
          function Zr(g, o) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return o && (typeof o == "object" || typeof o == "function") ? o : g;
          }
          function rn(g, o) {
            if (typeof o != "function" && o !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof o);
            g.prototype = Object.create(o && o.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), o && (Object.setPrototypeOf ? Object.setPrototypeOf(g, o) : g.__proto__ = o);
          }
          var Si = Zs(), ds = function(g) {
            rn(o, g);
            function o(l) {
              Dn(this, o);
              var s = Zr(this, g.call(this, l, p.a.MEDIA_ATTACHING, p.a.MEDIA_DETACHING, p.a.MANIFEST_PARSED, p.a.BUFFER_RESET, p.a.BUFFER_APPENDING, p.a.BUFFER_CODECS, p.a.BUFFER_EOS, p.a.BUFFER_FLUSHING, p.a.LEVEL_PTS_UPDATED, p.a.LEVEL_UPDATED));
              return s._msDuration = null, s._levelDuration = null, s._live = null, s._objectUrl = null, s.onsbue = s.onSBUpdateEnd.bind(s), s.onsbe = s.onSBUpdateError.bind(s), s.pendingTracks = {}, s.tracks = {}, s;
            }
            return o.prototype.destroy = function() {
              K.prototype.destroy.call(this);
            }, o.prototype.onLevelPtsUpdated = function(s) {
              var u = s.type, f = this.tracks.audio;
              if (u === "audio" && f && f.container === "audio/mpeg") {
                var E = this.sourceBuffer.audio, w = Math.abs(E.timestampOffset - s.start);
                if (w > 0.1) {
                  var A = E.updating;
                  try {
                    E.abort();
                  } catch (S) {
                    A = !0, d.b.warn("can not abort audio buffer: " + S);
                  }
                  A ? this.audioTimestampOffset = s.start : (d.b.warn("change mpeg audio timestamp offset from " + E.timestampOffset + " to " + s.start), E.timestampOffset = s.start);
                }
              }
            }, o.prototype.onManifestParsed = function(s) {
              var u = s.audio, f = s.video || s.levels.length && s.audio, E = 0;
              s.altAudio && (u || f) && (E = (u ? 1 : 0) + (f ? 1 : 0), d.b.log(E + " sourceBuffer(s) expected")), this.sourceBufferNb = E;
            }, o.prototype.onMediaAttaching = function(s) {
              var u = this.media = s.media;
              if (u) {
                var f = this.mediaSource = new Si();
                this.onmso = this.onMediaSourceOpen.bind(this), this.onmse = this.onMediaSourceEnded.bind(this), this.onmsc = this.onMediaSourceClose.bind(this), f.addEventListener("sourceopen", this.onmso), f.addEventListener("sourceended", this.onmse), f.addEventListener("sourceclose", this.onmsc), u.src = URL.createObjectURL(f), this._objectUrl = u.src;
              }
            }, o.prototype.onMediaDetaching = function() {
              d.b.log("media source detaching");
              var s = this.mediaSource;
              if (s) {
                if (s.readyState === "open")
                  try {
                    s.endOfStream();
                  } catch (u) {
                    d.b.warn("onMediaDetaching:" + u.message + " while calling endOfStream");
                  }
                s.removeEventListener("sourceopen", this.onmso), s.removeEventListener("sourceended", this.onmse), s.removeEventListener("sourceclose", this.onmsc), this.media && (URL.revokeObjectURL(this._objectUrl), this.media.src === this._objectUrl ? (this.media.removeAttribute("src"), this.media.load()) : d.b.warn("media.src was changed by a third party - skip cleanup")), this.mediaSource = null, this.media = null, this._objectUrl = null, this.pendingTracks = {}, this.tracks = {}, this.sourceBuffer = {}, this.flushRange = [], this.segments = [], this.appended = 0;
              }
              this.onmso = this.onmse = this.onmsc = null, this.hls.trigger(p.a.MEDIA_DETACHED);
            }, o.prototype.onMediaSourceOpen = function() {
              d.b.log("media source opened"), this.hls.trigger(p.a.MEDIA_ATTACHED, { media: this.media });
              var s = this.mediaSource;
              s && s.removeEventListener("sourceopen", this.onmso), this.checkPendingTracks();
            }, o.prototype.checkPendingTracks = function() {
              var s = this.pendingTracks, u = Object.keys(s).length;
              u && (this.sourceBufferNb <= u || this.sourceBufferNb === 0) && (this.createSourceBuffers(s), this.pendingTracks = {}, this.doAppending());
            }, o.prototype.onMediaSourceClose = function() {
              d.b.log("media source closed");
            }, o.prototype.onMediaSourceEnded = function() {
              d.b.log("media source ended");
            }, o.prototype.onSBUpdateEnd = function() {
              if (this.audioTimestampOffset) {
                var s = this.sourceBuffer.audio;
                d.b.warn("change mpeg audio timestamp offset from " + s.timestampOffset + " to " + this.audioTimestampOffset), s.timestampOffset = this.audioTimestampOffset, delete this.audioTimestampOffset;
              }
              this._needsFlush && this.doFlush(), this._needsEos && this.checkEos(), this.appending = !1;
              var u = this.parent, f = this.segments.reduce(function(E, w) {
                return w.parent === u ? E + 1 : E;
              }, 0);
              this.hls.trigger(p.a.BUFFER_APPENDED, { parent: u, pending: f }), this._needsFlush || this.doAppending(), this.updateMediaElementDuration();
            }, o.prototype.onSBUpdateError = function(s) {
              d.b.error("sourceBuffer error:", s), this.hls.trigger(p.a.ERROR, { type: b.b.MEDIA_ERROR, details: b.a.BUFFER_APPENDING_ERROR, fatal: !1 });
            }, o.prototype.onBufferReset = function() {
              var s = this.sourceBuffer;
              for (var u in s) {
                var f = s[u];
                try {
                  this.mediaSource.removeSourceBuffer(f), f.removeEventListener("updateend", this.onsbue), f.removeEventListener("error", this.onsbe);
                } catch {
                }
              }
              this.sourceBuffer = {}, this.flushRange = [], this.segments = [], this.appended = 0;
            }, o.prototype.onBufferCodecs = function(s) {
              if (Object.keys(this.sourceBuffer).length === 0) {
                for (var u in s)
                  this.pendingTracks[u] = s[u];
                var f = this.mediaSource;
                f && f.readyState === "open" && this.checkPendingTracks();
              }
            }, o.prototype.createSourceBuffers = function(s) {
              var u = this.sourceBuffer, f = this.mediaSource;
              for (var E in s)
                if (!u[E]) {
                  var w = s[E], A = w.levelCodec || w.codec, S = w.container + ";codecs=" + A;
                  d.b.log("creating sourceBuffer(" + S + ")");
                  try {
                    var k = u[E] = f.addSourceBuffer(S);
                    k.addEventListener("updateend", this.onsbue), k.addEventListener("error", this.onsbe), this.tracks[E] = { codec: A, container: w.container }, w.buffer = k;
                  } catch (B) {
                    d.b.error("error while trying to add sourceBuffer:" + B.message), this.hls.trigger(p.a.ERROR, { type: b.b.MEDIA_ERROR, details: b.a.BUFFER_ADD_CODEC_ERROR, fatal: !1, err: B, mimeType: S });
                  }
                }
              this.hls.trigger(p.a.BUFFER_CREATED, { tracks: s });
            }, o.prototype.onBufferAppending = function(s) {
              this._needsFlush || (this.segments ? this.segments.push(s) : this.segments = [s], this.doAppending());
            }, o.prototype.onBufferAppendFail = function(s) {
              d.b.error("sourceBuffer error:", s.event), this.hls.trigger(p.a.ERROR, { type: b.b.MEDIA_ERROR, details: b.a.BUFFER_APPENDING_ERROR, fatal: !1 });
            }, o.prototype.onBufferEos = function(s) {
              var u = this.sourceBuffer, f = s.type;
              for (var E in u)
                (!f || E === f) && (u[E].ended || (u[E].ended = !0, d.b.log(E + " sourceBuffer now EOS")));
              this.checkEos();
            }, o.prototype.checkEos = function() {
              var s = this.sourceBuffer, u = this.mediaSource;
              if (!u || u.readyState !== "open") {
                this._needsEos = !1;
                return;
              }
              for (var f in s) {
                var E = s[f];
                if (!E.ended)
                  return;
                if (E.updating) {
                  this._needsEos = !0;
                  return;
                }
              }
              d.b.log("all media data available, signal endOfStream() to MediaSource and stop loading fragment");
              try {
                u.endOfStream();
              } catch {
                d.b.warn("exception while calling mediaSource.endOfStream()");
              }
              this._needsEos = !1;
            }, o.prototype.onBufferFlushing = function(s) {
              this.flushRange.push({ start: s.startOffset, end: s.endOffset, type: s.type }), this.flushBufferCounter = 0, this.doFlush();
            }, o.prototype.onLevelUpdated = function(s) {
              var u = s.details;
              u.fragments.length > 0 && (this._levelDuration = u.totalduration + u.fragments[0].start, this._live = u.live, this.updateMediaElementDuration());
            }, o.prototype.updateMediaElementDuration = function() {
              var s = this.hls.config, u = void 0;
              if (!(this._levelDuration === null || !this.media || !this.mediaSource || !this.sourceBuffer || this.media.readyState === 0 || this.mediaSource.readyState !== "open")) {
                for (var f in this.sourceBuffer)
                  if (this.sourceBuffer[f].updating === !0)
                    return;
                u = this.media.duration, this._msDuration === null && (this._msDuration = this.mediaSource.duration), this._live === !0 && s.liveDurationInfinity === !0 ? (d.b.log("Media Source duration is set to Infinity"), this._msDuration = this.mediaSource.duration = 1 / 0) : (this._levelDuration > this._msDuration && this._levelDuration > u || u === 1 / 0 || isNaN(u)) && (d.b.log("Updating Media Source duration to " + this._levelDuration.toFixed(3)), this._msDuration = this.mediaSource.duration = this._levelDuration);
              }
            }, o.prototype.doFlush = function() {
              for (; this.flushRange.length; ) {
                var s = this.flushRange[0];
                if (this.flushBuffer(s.start, s.end, s.type))
                  this.flushRange.shift(), this.flushBufferCounter = 0;
                else {
                  this._needsFlush = !0;
                  return;
                }
              }
              if (this.flushRange.length === 0) {
                this._needsFlush = !1;
                var u = 0, f = this.sourceBuffer;
                try {
                  for (var E in f)
                    u += f[E].buffered.length;
                } catch {
                  d.b.error("error while accessing sourceBuffer.buffered");
                }
                this.appended = u, this.hls.trigger(p.a.BUFFER_FLUSHED);
              }
            }, o.prototype.doAppending = function() {
              var s = this.hls, u = this.sourceBuffer, f = this.segments;
              if (Object.keys(u).length) {
                if (this.media.error) {
                  this.segments = [], d.b.error("trying to append although a media error occured, flush segment and abort");
                  return;
                }
                if (this.appending)
                  return;
                if (f && f.length) {
                  var E = f.shift();
                  try {
                    var w = E.type, A = u[w];
                    A ? A.updating ? f.unshift(E) : (A.ended = !1, this.parent = E.parent, A.appendBuffer(E.data), this.appendError = 0, this.appended++, this.appending = !0) : this.onSBUpdateEnd();
                  } catch (k) {
                    d.b.error("error while trying to append buffer:" + k.message), f.unshift(E);
                    var S = { type: b.b.MEDIA_ERROR, parent: E.parent };
                    if (k.code !== 22)
                      if (this.appendError ? this.appendError++ : this.appendError = 1, S.details = b.a.BUFFER_APPEND_ERROR, this.appendError > s.config.appendErrorMaxRetry) {
                        d.b.log("fail " + s.config.appendErrorMaxRetry + " times to append segment in sourceBuffer"), f = [], S.fatal = !0, s.trigger(p.a.ERROR, S);
                        return;
                      } else
                        S.fatal = !1, s.trigger(p.a.ERROR, S);
                    else {
                      this.segments = [], S.details = b.a.BUFFER_FULL_ERROR, S.fatal = !1, s.trigger(p.a.ERROR, S);
                      return;
                    }
                  }
                }
              }
            }, o.prototype.flushBuffer = function(s, u, f) {
              var E, w, A, S, k, B, O = this.sourceBuffer;
              if (Object.keys(O).length) {
                if (d.b.log("flushBuffer,pos/start/end: " + this.media.currentTime.toFixed(3) + "/" + s + "/" + u), this.flushBufferCounter < this.appended) {
                  for (var $ in O)
                    if (!(f && $ !== f)) {
                      if (E = O[$], E.ended = !1, E.updating)
                        return d.b.warn("cannot flush, sb updating in progress"), !1;
                      try {
                        for (w = 0; w < E.buffered.length; w++)
                          if (A = E.buffered.start(w), S = E.buffered.end(w), navigator.userAgent.toLowerCase().indexOf("firefox") !== -1 && u === Number.POSITIVE_INFINITY ? (k = s, B = u) : (k = Math.max(A, s), B = Math.min(S, u)), Math.min(B, S) - k > 0.5)
                            return this.flushBufferCounter++, d.b.log("flush " + $ + " [" + k + "," + B + "], of [" + A + "," + S + "], pos:" + this.media.currentTime), E.remove(k, B), !1;
                      } catch {
                        d.b.warn("exception while accessing sourcebuffer, it might have been removed from MediaSource");
                      }
                    }
                } else
                  d.b.warn("abort flushing too many retries");
                d.b.log("buffer flushed");
              }
              return !0;
            }, o;
          }(K), Wr = ds, Qu = /* @__PURE__ */ function() {
            function g(o, l) {
              for (var s = 0; s < l.length; s++) {
                var u = l[s];
                u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(o, u.key, u);
              }
            }
            return function(o, l, s) {
              return l && g(o.prototype, l), s && g(o, s), o;
            };
          }();
          function Ys(g, o) {
            if (!(g instanceof o))
              throw new TypeError("Cannot call a class as a function");
          }
          function ec(g, o) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return o && (typeof o == "object" || typeof o == "function") ? o : g;
          }
          function Gl(g, o) {
            if (typeof o != "function" && o !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof o);
            g.prototype = Object.create(o && o.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), o && (Object.setPrototypeOf ? Object.setPrototypeOf(g, o) : g.__proto__ = o);
          }
          var ql = function(g) {
            Gl(o, g);
            function o(l) {
              return Ys(this, o), ec(this, g.call(this, l, p.a.FPS_DROP_LEVEL_CAPPING, p.a.MEDIA_ATTACHING, p.a.MANIFEST_PARSED));
            }
            return o.prototype.destroy = function() {
              this.hls.config.capLevelToPlayerSize && (this.media = this.restrictedLevels = null, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (this.timer = clearInterval(this.timer)));
            }, o.prototype.onFpsDropLevelCapping = function(s) {
              o.isLevelAllowed(s.droppedLevel, this.restrictedLevels) && this.restrictedLevels.push(s.droppedLevel);
            }, o.prototype.onMediaAttaching = function(s) {
              this.media = s.media instanceof HTMLVideoElement ? s.media : null;
            }, o.prototype.onManifestParsed = function(s) {
              var u = this.hls;
              this.restrictedLevels = [], u.config.capLevelToPlayerSize && (this.autoLevelCapping = Number.POSITIVE_INFINITY, this.levels = s.levels, u.firstLevel = this.getMaxLevel(s.firstLevel), clearInterval(this.timer), this.timer = setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize());
            }, o.prototype.detectPlayerSize = function() {
              if (this.media) {
                var s = this.levels ? this.levels.length : 0;
                if (s) {
                  var u = this.hls;
                  u.autoLevelCapping = this.getMaxLevel(s - 1), u.autoLevelCapping > this.autoLevelCapping && u.streamController.nextLevelSwitch(), this.autoLevelCapping = u.autoLevelCapping;
                }
              }
            }, o.prototype.getMaxLevel = function(s) {
              var u = this;
              if (!this.levels)
                return -1;
              var f = this.levels.filter(function(E, w) {
                return o.isLevelAllowed(w, u.restrictedLevels) && w <= s;
              });
              return o.getMaxLevelByMediaSize(f, this.mediaWidth, this.mediaHeight);
            }, o.isLevelAllowed = function(s) {
              var u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
              return u.indexOf(s) === -1;
            }, o.getMaxLevelByMediaSize = function(s, u, f) {
              if (!s || s && !s.length)
                return -1;
              for (var E = function(B, O) {
                return O ? B.width !== O.width || B.height !== O.height : !0;
              }, w = s.length - 1, A = 0; A < s.length; A += 1) {
                var S = s[A];
                if ((S.width >= u || S.height >= f) && E(S, s[A + 1])) {
                  w = A;
                  break;
                }
              }
              return w;
            }, Qu(o, [{
              key: "mediaWidth",
              get: function() {
                var s = void 0, u = this.media;
                return u && (s = u.width || u.clientWidth || u.offsetWidth, s *= o.contentScaleFactor), s;
              }
            }, {
              key: "mediaHeight",
              get: function() {
                var s = void 0, u = this.media;
                return u && (s = u.height || u.clientHeight || u.offsetHeight, s *= o.contentScaleFactor), s;
              }
            }], [{
              key: "contentScaleFactor",
              get: function() {
                var s = 1;
                try {
                  s = window.devicePixelRatio;
                } catch {
                }
                return s;
              }
            }]), o;
          }(K), gr = ql;
          function nn(g, o) {
            if (!(g instanceof o))
              throw new TypeError("Cannot call a class as a function");
          }
          function zl(g, o) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return o && (typeof o == "object" || typeof o == "function") ? o : g;
          }
          function Xl(g, o) {
            if (typeof o != "function" && o !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof o);
            g.prototype = Object.create(o && o.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), o && (Object.setPrototypeOf ? Object.setPrototypeOf(g, o) : g.__proto__ = o);
          }
          var Wm = function(g) {
            Xl(o, g);
            function o(l) {
              return nn(this, o), zl(this, g.call(this, l, p.a.MEDIA_ATTACHING));
            }
            return o.prototype.destroy = function() {
              this.timer && clearInterval(this.timer), this.isVideoPlaybackQualityAvailable = !1;
            }, o.prototype.onMediaAttaching = function(s) {
              var u = this.hls.config;
              if (u.capLevelOnFPSDrop) {
                var f = this.video = s.media instanceof HTMLVideoElement ? s.media : null;
                typeof f.getVideoPlaybackQuality == "function" && (this.isVideoPlaybackQualityAvailable = !0), clearInterval(this.timer), this.timer = setInterval(this.checkFPSInterval.bind(this), u.fpsDroppedMonitoringPeriod);
              }
            }, o.prototype.checkFPS = function(s, u, f) {
              var E = performance.now();
              if (u) {
                if (this.lastTime) {
                  var w = E - this.lastTime, A = f - this.lastDroppedFrames, S = u - this.lastDecodedFrames, k = 1e3 * A / w, B = this.hls;
                  if (B.trigger(p.a.FPS_DROP, { currentDropped: A, currentDecoded: S, totalDroppedFrames: f }), k > 0 && A > B.config.fpsDroppedMonitoringThreshold * S) {
                    var O = B.currentLevel;
                    d.b.warn("drop FPS ratio greater than max allowed value for currentLevel: " + O), O > 0 && (B.autoLevelCapping === -1 || B.autoLevelCapping >= O) && (O = O - 1, B.trigger(p.a.FPS_DROP_LEVEL_CAPPING, { level: O, droppedLevel: B.currentLevel }), B.autoLevelCapping = O, B.streamController.nextLevelSwitch());
                  }
                }
                this.lastTime = E, this.lastDroppedFrames = f, this.lastDecodedFrames = u;
              }
            }, o.prototype.checkFPSInterval = function() {
              var s = this.video;
              if (s)
                if (this.isVideoPlaybackQualityAvailable) {
                  var u = s.getVideoPlaybackQuality();
                  this.checkFPS(s, u.totalVideoFrames, u.droppedVideoFrames);
                } else
                  this.checkFPS(s, s.webkitDecodedFrameCount, s.webkitDroppedFrameCount);
            }, o;
          }(K), Ym = Wm;
          function Jm(g, o) {
            if (!(g instanceof o))
              throw new TypeError("Cannot call a class as a function");
          }
          var Qm = function() {
            function g(o) {
              Jm(this, g), o && o.xhrSetup && (this.xhrSetup = o.xhrSetup);
            }
            return g.prototype.destroy = function() {
              this.abort(), this.loader = null;
            }, g.prototype.abort = function() {
              var l = this.loader;
              l && l.readyState !== 4 && (this.stats.aborted = !0, l.abort()), window.clearTimeout(this.requestTimeout), this.requestTimeout = null, window.clearTimeout(this.retryTimeout), this.retryTimeout = null;
            }, g.prototype.load = function(l, s, u) {
              this.context = l, this.config = s, this.callbacks = u, this.stats = { trequest: performance.now(), retry: 0 }, this.retryDelay = s.retryDelay, this.loadInternal();
            }, g.prototype.loadInternal = function() {
              var l, s = this.context;
              l = this.loader = new XMLHttpRequest();
              var u = this.stats;
              u.tfirst = 0, u.loaded = 0;
              var f = this.xhrSetup;
              try {
                if (f)
                  try {
                    f(l, s.url);
                  } catch {
                    l.open("GET", s.url, !0), f(l, s.url);
                  }
                l.readyState || l.open("GET", s.url, !0);
              } catch (E) {
                this.callbacks.onError({ code: l.status, text: E.message }, s, l);
                return;
              }
              s.rangeEnd && l.setRequestHeader("Range", "bytes=" + s.rangeStart + "-" + (s.rangeEnd - 1)), l.onreadystatechange = this.readystatechange.bind(this), l.onprogress = this.loadprogress.bind(this), l.responseType = s.responseType, this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout), l.send();
            }, g.prototype.readystatechange = function(l) {
              var s = l.currentTarget, u = s.readyState, f = this.stats, E = this.context, w = this.config;
              if (!f.aborted && u >= 2)
                if (window.clearTimeout(this.requestTimeout), f.tfirst === 0 && (f.tfirst = Math.max(performance.now(), f.trequest)), u === 4) {
                  var A = s.status;
                  if (A >= 200 && A < 300) {
                    f.tload = Math.max(f.tfirst, performance.now());
                    var S = void 0, k = void 0;
                    E.responseType === "arraybuffer" ? (S = s.response, k = S.byteLength) : (S = s.responseText, k = S.length), f.loaded = f.total = k;
                    var B = { url: s.responseURL, data: S };
                    this.callbacks.onSuccess(B, f, E, s);
                  } else
                    f.retry >= w.maxRetry || A >= 400 && A < 499 ? (d.b.error(A + " while loading " + E.url), this.callbacks.onError({ code: A, text: s.statusText }, E, s)) : (d.b.warn(A + " while loading " + E.url + ", retrying in " + this.retryDelay + "..."), this.destroy(), this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay), this.retryDelay = Math.min(2 * this.retryDelay, w.maxRetryDelay), f.retry++);
                } else
                  this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), w.timeout);
            }, g.prototype.loadtimeout = function() {
              d.b.warn("timeout while loading " + this.context.url), this.callbacks.onTimeout(this.stats, this.context, null);
            }, g.prototype.loadprogress = function(l) {
              var s = l.currentTarget, u = this.stats;
              u.loaded = l.loaded, l.lengthComputable && (u.total = l.total);
              var f = this.callbacks.onProgress;
              f && f(u, this.context, null, s);
            }, g;
          }(), ey = Qm, ty = /* @__PURE__ */ function() {
            function g(o, l) {
              for (var s = 0; s < l.length; s++) {
                var u = l[s];
                u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(o, u.key, u);
              }
            }
            return function(o, l, s) {
              return l && g(o.prototype, l), s && g(o, s), o;
            };
          }();
          function ry(g, o) {
            if (!(g instanceof o))
              throw new TypeError("Cannot call a class as a function");
          }
          function iy(g, o) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return o && (typeof o == "object" || typeof o == "function") ? o : g;
          }
          function ny(g, o) {
            if (typeof o != "function" && o !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof o);
            g.prototype = Object.create(o && o.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), o && (Object.setPrototypeOf ? Object.setPrototypeOf(g, o) : g.__proto__ = o);
          }
          var sy = function(g) {
            ny(o, g);
            function o(l) {
              ry(this, o);
              var s = iy(this, g.call(this, l, p.a.MANIFEST_LOADING, p.a.MANIFEST_PARSED, p.a.AUDIO_TRACK_LOADED, p.a.ERROR));
              return s.ticks = 0, s.ontick = s.tick.bind(s), s;
            }
            return o.prototype.destroy = function() {
              this.cleanTimer(), K.prototype.destroy.call(this);
            }, o.prototype.cleanTimer = function() {
              this.timer && (clearTimeout(this.timer), this.timer = null);
            }, o.prototype.tick = function() {
              this.ticks++, this.ticks === 1 && (this.doTick(), this.ticks > 1 && setTimeout(this.tick, 1), this.ticks = 0);
            }, o.prototype.doTick = function() {
              this.updateTrack(this.trackId);
            }, o.prototype.onError = function(s) {
              s.fatal && s.type === b.b.NETWORK_ERROR && this.cleanTimer();
            }, o.prototype.onManifestLoading = function() {
              this.tracks = [], this.trackId = -1;
            }, o.prototype.onManifestParsed = function(s) {
              var u = this, f = s.audioTracks || [], E = !1;
              this.tracks = f, this.hls.trigger(p.a.AUDIO_TRACKS_UPDATED, { audioTracks: f });
              var w = 0;
              f.forEach(function(A) {
                if (A.default && !E) {
                  u.audioTrack = w, E = !0;
                  return;
                }
                w++;
              }), E === !1 && f.length && (d.b.log("no default audio track defined, use first audio track as default"), this.audioTrack = 0);
            }, o.prototype.onAudioTrackLoaded = function(s) {
              s.id < this.tracks.length && (d.b.log("audioTrack " + s.id + " loaded"), this.tracks[s.id].details = s.details, s.details.live && !this.timer && (this.timer = setInterval(this.ontick, 1e3 * s.details.targetduration)), !s.details.live && this.timer && this.cleanTimer());
            }, o.prototype.setAudioTrackInternal = function(s) {
              if (s >= 0 && s < this.tracks.length) {
                this.cleanTimer(), this.trackId = s, d.b.log("switching to audioTrack " + s);
                var u = this.tracks[s], f = this.hls, E = u.type, w = u.url, A = { id: s, type: E, url: w };
                f.trigger(p.a.AUDIO_TRACK_SWITCH, A), f.trigger(p.a.AUDIO_TRACK_SWITCHING, A);
                var S = u.details;
                w && (S === void 0 || S.live === !0) && (d.b.log("(re)loading playlist for audioTrack " + s), f.trigger(p.a.AUDIO_TRACK_LOADING, { url: w, id: s }));
              }
            }, o.prototype.updateTrack = function(s) {
              if (s >= 0 && s < this.tracks.length) {
                this.cleanTimer(), this.trackId = s, d.b.log("updating audioTrack " + s);
                var u = this.tracks[s], f = u.url, E = u.details;
                f && (E === void 0 || E.live === !0) && (d.b.log("(re)loading playlist for audioTrack " + s), this.hls.trigger(p.a.AUDIO_TRACK_LOADING, { url: f, id: s }));
              }
            }, ty(o, [{
              key: "audioTracks",
              get: function() {
                return this.tracks;
              }
              /** get index of the selected audio track (index in audio track lists) **/
            }, {
              key: "audioTrack",
              get: function() {
                return this.trackId;
              },
              set: function(s) {
                (this.trackId !== s || this.tracks[s].details === void 0) && this.setAudioTrackInternal(s);
              }
            }]), o;
          }(K), ay = sy, oy = /* @__PURE__ */ function() {
            function g(o, l) {
              for (var s = 0; s < l.length; s++) {
                var u = l[s];
                u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(o, u.key, u);
              }
            }
            return function(o, l, s) {
              return l && g(o.prototype, l), s && g(o, s), o;
            };
          }();
          function ly(g, o) {
            if (!(g instanceof o))
              throw new TypeError("Cannot call a class as a function");
          }
          function uy(g, o) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return o && (typeof o == "object" || typeof o == "function") ? o : g;
          }
          function cy(g, o) {
            if (typeof o != "function" && o !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof o);
            g.prototype = Object.create(o && o.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), o && (Object.setPrototypeOf ? Object.setPrototypeOf(g, o) : g.__proto__ = o);
          }
          var ve = {
            STOPPED: "STOPPED",
            STARTING: "STARTING",
            IDLE: "IDLE",
            PAUSED: "PAUSED",
            KEY_LOADING: "KEY_LOADING",
            FRAG_LOADING: "FRAG_LOADING",
            FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
            WAITING_TRACK: "WAITING_TRACK",
            PARSING: "PARSING",
            PARSED: "PARSED",
            BUFFER_FLUSHING: "BUFFER_FLUSHING",
            ENDED: "ENDED",
            ERROR: "ERROR",
            WAITING_INIT_PTS: "WAITING_INIT_PTS"
          }, dy = function(g) {
            cy(o, g);
            function o(l) {
              ly(this, o);
              var s = uy(this, g.call(this, l, p.a.MEDIA_ATTACHED, p.a.MEDIA_DETACHING, p.a.AUDIO_TRACKS_UPDATED, p.a.AUDIO_TRACK_SWITCHING, p.a.AUDIO_TRACK_LOADED, p.a.KEY_LOADED, p.a.FRAG_LOADED, p.a.FRAG_PARSING_INIT_SEGMENT, p.a.FRAG_PARSING_DATA, p.a.FRAG_PARSED, p.a.ERROR, p.a.BUFFER_RESET, p.a.BUFFER_CREATED, p.a.BUFFER_APPENDED, p.a.BUFFER_FLUSHED, p.a.INIT_PTS_FOUND));
              return s.config = l.config, s.audioCodecSwap = !1, s.ticks = 0, s._state = ve.STOPPED, s.ontick = s.tick.bind(s), s.initPTS = [], s.waitingFragment = null, s.videoTrackCC = null, s;
            }
            return o.prototype.destroy = function() {
              this.stopLoad(), this.timer && (clearInterval(this.timer), this.timer = null), K.prototype.destroy.call(this), this.state = ve.STOPPED;
            }, o.prototype.onInitPtsFound = function(s) {
              var u = s.id, f = s.frag.cc, E = s.initPTS;
              u === "main" && (this.initPTS[f] = E, this.videoTrackCC = f, d.b.log("InitPTS for cc:" + f + " found from video track:" + E), this.state === ve.WAITING_INIT_PTS && this.tick());
            }, o.prototype.startLoad = function(s) {
              if (this.tracks) {
                var u = this.lastCurrentTime;
                this.stopLoad(), this.timer || (this.timer = setInterval(this.ontick, 100)), this.fragLoadError = 0, u > 0 && s === -1 ? (d.b.log("audio:override startPosition with lastCurrentTime @" + u.toFixed(3)), this.state = ve.IDLE) : (this.lastCurrentTime = this.startPosition ? this.startPosition : s, this.state = ve.STARTING), this.nextLoadPosition = this.startPosition = this.lastCurrentTime, this.tick();
              } else
                this.startPosition = s, this.state = ve.STOPPED;
            }, o.prototype.stopLoad = function() {
              var s = this.fragCurrent;
              s && (s.loader && s.loader.abort(), this.fragCurrent = null), this.fragPrevious = null, this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.state = ve.STOPPED;
            }, o.prototype.tick = function() {
              this.ticks++, this.ticks === 1 && (this.doTick(), this.ticks > 1 && setTimeout(this.tick, 1), this.ticks = 0);
            }, o.prototype.doTick = function() {
              var s, u, f, E = this.hls, w = E.config;
              switch (this.state) {
                case ve.ERROR:
                case ve.PAUSED:
                case ve.BUFFER_FLUSHING:
                  break;
                case ve.STARTING:
                  this.state = ve.WAITING_TRACK, this.loadedmetadata = !1;
                  break;
                case ve.IDLE:
                  var A = this.tracks;
                  if (!A || !this.media && (this.startFragRequested || !w.startFragPrefetch))
                    break;
                  if (this.loadedmetadata)
                    s = this.media.currentTime;
                  else if (s = this.nextLoadPosition, s === void 0)
                    break;
                  var S = this.mediaBuffer ? this.mediaBuffer : this.media, k = this.videoBuffer ? this.videoBuffer : this.media, B = dt.bufferInfo(S, s, w.maxBufferHole), O = dt.bufferInfo(k, s, w.maxBufferHole), $ = B.len, te = B.end, pe = this.fragPrevious, be = Math.max(w.maxBufferLength, O.len), ye = this.audioSwitch, Se = this.trackId;
                  if (($ < be || ye) && Se < A.length) {
                    if (f = A[Se].details, typeof f > "u") {
                      this.state = ve.WAITING_TRACK;
                      break;
                    }
                    if (!ye && !f.live && pe && pe.sn === f.endSN && !B.nextStart && (!this.media.seeking || this.media.duration - te < pe.duration / 2)) {
                      this.hls.trigger(p.a.BUFFER_EOS, { type: "audio" }), this.state = ve.ENDED;
                      break;
                    }
                    var Ce = f.fragments, Be = Ce.length, He = Ce[0].start, ft = Ce[Be - 1].start + Ce[Be - 1].duration, _e = void 0;
                    if (ye) {
                      if (f.live && !f.PTSKnown)
                        d.b.log("switching audiotrack, live stream, unknown PTS,load first fragment"), te = 0;
                      else if (te = s, f.PTSKnown && s < He)
                        if (B.end > He || B.nextStart)
                          d.b.log("alt audio track ahead of main track, seek to start of alt audio track"), this.media.currentTime = He + 0.05;
                        else
                          return;
                    }
                    if (f.initSegment && !f.initSegment.data)
                      _e = f.initSegment;
                    else if (te <= He) {
                      if (_e = Ce[0], this.videoTrackCC !== null && _e.cc !== this.videoTrackCC && (_e = N(Ce, this.videoTrackCC)), f.live && _e.loadIdx && _e.loadIdx === this.fragLoadIdx) {
                        var Bt = B.nextStart ? B.nextStart : He;
                        d.b.log("no alt audio available @currentTime:" + this.media.currentTime + ", seeking @" + (Bt + 0.05)), this.media.currentTime = Bt + 0.05;
                        return;
                      }
                    } else {
                      var at = void 0, sn = w.maxFragLookUpTolerance, Xe = pe ? Ce[pe.sn - Ce[0].sn + 1] : void 0, Me = function(Js) {
                        var Ad = Math.min(sn, Js.duration);
                        return Js.start + Js.duration - Ad <= te ? 1 : Js.start - Ad > te && Js.start ? -1 : 0;
                      };
                      te < ft ? (te > ft - sn && (sn = 0), Xe && !Me(Xe) ? at = Xe : at = Br.search(Ce, Me)) : at = Ce[Be - 1], at && (_e = at, He = at.start, pe && _e.level === pe.level && _e.sn === pe.sn && (_e.sn < f.endSN ? (_e = Ce[_e.sn + 1 - f.startSN], d.b.log("SN just loaded, load next one: " + _e.sn)) : _e = null));
                    }
                    if (_e)
                      if (_e.decryptdata && _e.decryptdata.uri != null && _e.decryptdata.key == null)
                        d.b.log("Loading key for " + _e.sn + " of [" + f.startSN + " ," + f.endSN + "],track " + Se), this.state = ve.KEY_LOADING, E.trigger(p.a.KEY_LOADING, { frag: _e });
                      else {
                        if (d.b.log("Loading " + _e.sn + ", cc: " + _e.cc + " of [" + f.startSN + " ," + f.endSN + "],track " + Se + ", currentTime:" + s + ",bufferEnd:" + te.toFixed(3)), this.fragLoadIdx !== void 0 ? this.fragLoadIdx++ : this.fragLoadIdx = 0, _e.loadCounter) {
                          _e.loadCounter++;
                          var $t = w.fragLoadingLoopThreshold;
                          if (_e.loadCounter > $t && Math.abs(this.fragLoadIdx - _e.loadIdx) < $t) {
                            E.trigger(p.a.ERROR, { type: b.b.MEDIA_ERROR, details: b.a.FRAG_LOOP_LOADING_ERROR, fatal: !1, frag: _e });
                            return;
                          }
                        } else
                          _e.loadCounter = 1;
                        _e.loadIdx = this.fragLoadIdx, this.fragCurrent = _e, this.startFragRequested = !0, isNaN(_e.sn) || (this.nextLoadPosition = _e.start + _e.duration), E.trigger(p.a.FRAG_LOADING, { frag: _e }), this.state = ve.FRAG_LOADING;
                      }
                  }
                  break;
                case ve.WAITING_TRACK:
                  u = this.tracks[this.trackId], u && u.details && (this.state = ve.IDLE);
                  break;
                case ve.FRAG_LOADING_WAITING_RETRY:
                  var Wl = performance.now(), Ed = this.retryDate;
                  S = this.media;
                  var eb = S && S.seeking;
                  (!Ed || Wl >= Ed || eb) && (d.b.log("audioStreamController: retryDate reached, switch back to IDLE state"), this.state = ve.IDLE);
                  break;
                case ve.WAITING_INIT_PTS:
                  var sc = this.videoTrackCC;
                  if (this.initPTS[sc] === void 0)
                    break;
                  var vd = this.waitingFragment;
                  if (vd) {
                    var Rd = vd.frag.cc;
                    sc !== Rd ? (u = this.tracks[this.trackId], u.details && u.details.live && (d.b.warn("Waiting fragment CC (" + Rd + ") does not match video track CC (" + sc + ")"), this.waitingFragment = null, this.state = ve.IDLE)) : (this.state = ve.FRAG_LOADING, this.onFragLoaded(this.waitingFragment), this.waitingFragment = null);
                  } else
                    this.state = ve.IDLE;
                  break;
              }
            }, o.prototype.onMediaAttached = function(s) {
              var u = this.media = this.mediaBuffer = s.media;
              this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), u.addEventListener("seeking", this.onvseeking), u.addEventListener("ended", this.onvended);
              var f = this.config;
              this.tracks && f.autoStartLoad && this.startLoad(f.startPosition);
            }, o.prototype.onMediaDetaching = function() {
              var s = this.media;
              s && s.ended && (d.b.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0);
              var u = this.tracks;
              u && u.forEach(function(f) {
                f.details && f.details.fragments.forEach(function(E) {
                  E.loadCounter = void 0;
                });
              }), s && (s.removeEventListener("seeking", this.onvseeking), s.removeEventListener("ended", this.onvended), this.onvseeking = this.onvseeked = this.onvended = null), this.media = this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1, this.stopLoad();
            }, o.prototype.onMediaSeeking = function() {
              this.state === ve.ENDED && (this.state = ve.IDLE), this.media && (this.lastCurrentTime = this.media.currentTime), this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold), this.tick();
            }, o.prototype.onMediaEnded = function() {
              this.startPosition = this.lastCurrentTime = 0;
            }, o.prototype.onAudioTracksUpdated = function(s) {
              d.b.log("audio tracks updated"), this.tracks = s.audioTracks;
            }, o.prototype.onAudioTrackSwitching = function(s) {
              var u = !!s.url;
              this.trackId = s.id, this.fragCurrent = null, this.state = ve.PAUSED, this.waitingFragment = null, u ? this.timer || (this.timer = setInterval(this.ontick, 100)) : this.demuxer && (this.demuxer.destroy(), this.demuxer = null), u && (this.audioSwitch = !0, this.state = ve.IDLE, this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold)), this.tick();
            }, o.prototype.onAudioTrackLoaded = function(s) {
              var u = s.details, f = s.id, E = this.tracks[f], w = u.totalduration, A = 0;
              if (d.b.log("track " + f + " loaded [" + u.startSN + "," + u.endSN + "],duration:" + w), u.live) {
                var S = E.details;
                S && u.fragments.length > 0 ? (C(S, u), A = u.fragments[0].start, u.PTSKnown ? d.b.log("live audio playlist sliding:" + A.toFixed(3)) : d.b.log("live audio playlist - outdated PTS, unknown sliding")) : (u.PTSKnown = !1, d.b.log("live audio playlist - first load, unknown sliding"));
              } else
                u.PTSKnown = !1;
              if (E.details = u, !this.startFragRequested) {
                if (this.startPosition === -1) {
                  var k = u.startTimeOffset;
                  isNaN(k) ? this.startPosition = 0 : (d.b.log("start time offset found in playlist, adjust startPosition to " + k), this.startPosition = k);
                }
                this.nextLoadPosition = this.startPosition;
              }
              this.state === ve.WAITING_TRACK && (this.state = ve.IDLE), this.tick();
            }, o.prototype.onKeyLoaded = function() {
              this.state === ve.KEY_LOADING && (this.state = ve.IDLE, this.tick());
            }, o.prototype.onFragLoaded = function(s) {
              var u = this.fragCurrent, f = s.frag;
              if (this.state === ve.FRAG_LOADING && u && f.type === "audio" && f.level === u.level && f.sn === u.sn) {
                var E = this.tracks[this.trackId], w = E.details, A = w.totalduration, S = u.level, k = u.sn, B = u.cc, O = this.config.defaultAudioCodec || E.audioCodec || "mp4a.40.2", $ = this.stats = s.stats;
                if (k === "initSegment")
                  this.state = ve.IDLE, $.tparsed = $.tbuffered = performance.now(), w.initSegment.data = s.payload, this.hls.trigger(p.a.FRAG_BUFFERED, { stats: $, frag: u, id: "audio" }), this.tick();
                else {
                  this.state = ve.PARSING, this.appended = !1, this.demuxer || (this.demuxer = new I(this.hls, "audio"));
                  var te = this.initPTS[B], pe = w.initSegment ? w.initSegment.data : [];
                  if (w.initSegment || te !== void 0) {
                    this.pendingBuffering = !0, d.b.log("Demuxing " + k + " of [" + w.startSN + " ," + w.endSN + "],track " + S);
                    var be = !1;
                    this.demuxer.push(s.payload, pe, O, null, u, A, be, te);
                  } else
                    d.b.log("unknown video PTS for continuity counter " + B + ", waiting for video PTS before demuxing audio frag " + k + " of [" + w.startSN + " ," + w.endSN + "],track " + S), this.waitingFragment = s, this.state = ve.WAITING_INIT_PTS;
                }
              }
              this.fragLoadError = 0;
            }, o.prototype.onFragParsingInitSegment = function(s) {
              var u = this.fragCurrent, f = s.frag;
              if (u && s.id === "audio" && f.sn === u.sn && f.level === u.level && this.state === ve.PARSING) {
                var E = s.tracks, w = void 0;
                if (E.video && delete E.video, w = E.audio, w) {
                  w.levelCodec = w.codec, w.id = s.id, this.hls.trigger(p.a.BUFFER_CODECS, E), d.b.log("audio track:audio,container:" + w.container + ",codecs[level/parsed]=[" + w.levelCodec + "/" + w.codec + "]");
                  var A = w.initSegment;
                  if (A) {
                    var S = { type: "audio", data: A, parent: "audio", content: "initSegment" };
                    this.audioSwitch ? this.pendingData = [S] : (this.appended = !0, this.pendingBuffering = !0, this.hls.trigger(p.a.BUFFER_APPENDING, S));
                  }
                  this.tick();
                }
              }
            }, o.prototype.onFragParsingData = function(s) {
              var u = this, f = this.fragCurrent, E = s.frag;
              if (f && s.id === "audio" && s.type === "audio" && E.sn === f.sn && E.level === f.level && this.state === ve.PARSING) {
                var w = this.trackId, A = this.tracks[w], S = this.hls;
                isNaN(s.endPTS) && (s.endPTS = s.startPTS + f.duration, s.endDTS = s.startDTS + f.duration), d.b.log("parsed " + s.type + ",PTS:[" + s.startPTS.toFixed(3) + "," + s.endPTS.toFixed(3) + "],DTS:[" + s.startDTS.toFixed(3) + "/" + s.endDTS.toFixed(3) + "],nb:" + s.nb), T(A.details, f, s.startPTS, s.endPTS);
                var k = this.audioSwitch, B = this.media, O = !1;
                if (k && B)
                  if (B.readyState) {
                    var $ = B.currentTime;
                    d.b.log("switching audio track : currentTime:" + $), $ >= s.startPTS && (d.b.log("switching audio track : flushing all audio"), this.state = ve.BUFFER_FLUSHING, S.trigger(p.a.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: "audio" }), O = !0, this.audioSwitch = !1, S.trigger(p.a.AUDIO_TRACK_SWITCHED, { id: w }));
                  } else
                    this.audioSwitch = !1, S.trigger(p.a.AUDIO_TRACK_SWITCHED, { id: w });
                var te = this.pendingData;
                this.audioSwitch || ([s.data1, s.data2].forEach(function(pe) {
                  pe && pe.length && te.push({ type: s.type, data: pe, parent: "audio", content: "data" });
                }), !O && te.length && (te.forEach(function(pe) {
                  u.state === ve.PARSING && (u.pendingBuffering = !0, u.hls.trigger(p.a.BUFFER_APPENDING, pe));
                }), this.pendingData = [], this.appended = !0)), this.tick();
              }
            }, o.prototype.onFragParsed = function(s) {
              var u = this.fragCurrent, f = s.frag;
              u && s.id === "audio" && f.sn === u.sn && f.level === u.level && this.state === ve.PARSING && (this.stats.tparsed = performance.now(), this.state = ve.PARSED, this._checkAppendedParsed());
            }, o.prototype.onBufferReset = function() {
              this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1;
            }, o.prototype.onBufferCreated = function(s) {
              var u = s.tracks.audio;
              u && (this.mediaBuffer = u.buffer, this.loadedmetadata = !0), s.tracks.video && (this.videoBuffer = s.tracks.video.buffer);
            }, o.prototype.onBufferAppended = function(s) {
              if (s.parent === "audio") {
                var u = this.state;
                (u === ve.PARSING || u === ve.PARSED) && (this.pendingBuffering = s.pending > 0, this._checkAppendedParsed());
              }
            }, o.prototype._checkAppendedParsed = function() {
              if (this.state === ve.PARSED && (!this.appended || !this.pendingBuffering)) {
                var s = this.fragCurrent, u = this.stats, f = this.hls;
                if (s) {
                  this.fragPrevious = s, u.tbuffered = performance.now(), f.trigger(p.a.FRAG_BUFFERED, { stats: u, frag: s, id: "audio" });
                  var E = this.mediaBuffer ? this.mediaBuffer : this.media;
                  d.b.log("audio buffered : " + D.toString(E.buffered)), this.audioSwitch && this.appended && (this.audioSwitch = !1, f.trigger(p.a.AUDIO_TRACK_SWITCHED, { id: this.trackId })), this.state = ve.IDLE;
                }
                this.tick();
              }
            }, o.prototype.onError = function(s) {
              var u = s.frag;
              if (!(u && u.type !== "audio"))
                switch (s.details) {
                  case b.a.FRAG_LOAD_ERROR:
                  case b.a.FRAG_LOAD_TIMEOUT:
                    if (!s.fatal) {
                      var f = this.fragLoadError;
                      f ? f++ : f = 1;
                      var E = this.config;
                      if (f <= E.fragLoadingMaxRetry) {
                        this.fragLoadError = f, u.loadCounter = 0;
                        var w = Math.min(Math.pow(2, f - 1) * E.fragLoadingRetryDelay, E.fragLoadingMaxRetryTimeout);
                        d.b.warn("audioStreamController: frag loading failed, retry in " + w + " ms"), this.retryDate = performance.now() + w, this.state = ve.FRAG_LOADING_WAITING_RETRY;
                      } else
                        d.b.error("audioStreamController: " + s.details + " reaches max retry, redispatch as fatal ..."), s.fatal = !0, this.state = ve.ERROR;
                    }
                    break;
                  case b.a.FRAG_LOOP_LOADING_ERROR:
                  case b.a.AUDIO_TRACK_LOAD_ERROR:
                  case b.a.AUDIO_TRACK_LOAD_TIMEOUT:
                  case b.a.KEY_LOAD_ERROR:
                  case b.a.KEY_LOAD_TIMEOUT:
                    this.state !== ve.ERROR && (this.state = s.fatal ? ve.ERROR : ve.IDLE, d.b.warn("audioStreamController: " + s.details + " while loading frag,switch to " + this.state + " state ..."));
                    break;
                  case b.a.BUFFER_FULL_ERROR:
                    if (s.parent === "audio" && (this.state === ve.PARSING || this.state === ve.PARSED)) {
                      var A = this.mediaBuffer, S = this.media.currentTime, k = A && dt.isBuffered(A, S) && dt.isBuffered(A, S + 0.5);
                      if (k) {
                        var B = this.config;
                        B.maxMaxBufferLength >= B.maxBufferLength && (B.maxMaxBufferLength /= 2, d.b.warn("audio:reduce max buffer length to " + B.maxMaxBufferLength + "s"), this.fragLoadIdx += 2 * B.fragLoadingLoopThreshold), this.state = ve.IDLE;
                      } else
                        d.b.warn("buffer full error also media.currentTime is not buffered, flush audio buffer"), this.fragCurrent = null, this.state = ve.BUFFER_FLUSHING, this.hls.trigger(p.a.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: "audio" });
                    }
                    break;
                }
            }, o.prototype.onBufferFlushed = function() {
              var s = this, u = this.pendingData;
              u && u.length ? (d.b.log("appending pending audio data on Buffer Flushed"), u.forEach(function(f) {
                s.hls.trigger(p.a.BUFFER_APPENDING, f);
              }), this.appended = !0, this.pendingData = [], this.state = ve.PARSED) : (this.state = ve.IDLE, this.fragPrevious = null, this.tick());
            }, oy(o, [{
              key: "state",
              set: function(s) {
                if (this.state !== s) {
                  var u = this.state;
                  this._state = s, d.b.log("audio stream:" + u + "->" + s);
                }
              },
              get: function() {
                return this._state;
              }
            }]), o;
          }(K), fy = dy, ld = function() {
            if (typeof window < "u" && window.VTTCue)
              return window.VTTCue;
            var g = "auto", o = {
              "": !0,
              lr: !0,
              rl: !0
            }, l = {
              start: !0,
              middle: !0,
              end: !0,
              left: !0,
              right: !0
            };
            function s(w) {
              if (typeof w != "string")
                return !1;
              var A = o[w.toLowerCase()];
              return A ? w.toLowerCase() : !1;
            }
            function u(w) {
              if (typeof w != "string")
                return !1;
              var A = l[w.toLowerCase()];
              return A ? w.toLowerCase() : !1;
            }
            function f(w) {
              for (var A = 1; A < arguments.length; A++) {
                var S = arguments[A];
                for (var k in S)
                  w[k] = S[k];
              }
              return w;
            }
            function E(w, A, S) {
              var k = this, B = function() {
                if (!(typeof navigator > "u"))
                  return /MSIE\s8\.0/.test(navigator.userAgent);
              }(), O = {};
              B ? k = document.createElement("custom") : O.enumerable = !0, k.hasBeenReset = !1;
              var $ = "", te = !1, pe = w, be = A, ye = S, Se = null, Ce = "", Be = !0, He = "auto", ft = "start", _e = 50, Bt = "middle", at = 50, sn = "middle";
              if (Object.defineProperty(k, "id", f({}, O, {
                get: function() {
                  return $;
                },
                set: function(Me) {
                  $ = "" + Me;
                }
              })), Object.defineProperty(k, "pauseOnExit", f({}, O, {
                get: function() {
                  return te;
                },
                set: function(Me) {
                  te = !!Me;
                }
              })), Object.defineProperty(k, "startTime", f({}, O, {
                get: function() {
                  return pe;
                },
                set: function(Me) {
                  if (typeof Me != "number")
                    throw new TypeError("Start time must be set to a number.");
                  pe = Me, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(k, "endTime", f({}, O, {
                get: function() {
                  return be;
                },
                set: function(Me) {
                  if (typeof Me != "number")
                    throw new TypeError("End time must be set to a number.");
                  be = Me, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(k, "text", f({}, O, {
                get: function() {
                  return ye;
                },
                set: function(Me) {
                  ye = "" + Me, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(k, "region", f({}, O, {
                get: function() {
                  return Se;
                },
                set: function(Me) {
                  Se = Me, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(k, "vertical", f({}, O, {
                get: function() {
                  return Ce;
                },
                set: function(Me) {
                  var $t = s(Me);
                  if ($t === !1)
                    throw new SyntaxError("An invalid or illegal string was specified.");
                  Ce = $t, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(k, "snapToLines", f({}, O, {
                get: function() {
                  return Be;
                },
                set: function(Me) {
                  Be = !!Me, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(k, "line", f({}, O, {
                get: function() {
                  return He;
                },
                set: function(Me) {
                  if (typeof Me != "number" && Me !== g)
                    throw new SyntaxError("An invalid number or illegal string was specified.");
                  He = Me, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(k, "lineAlign", f({}, O, {
                get: function() {
                  return ft;
                },
                set: function(Me) {
                  var $t = u(Me);
                  if (!$t)
                    throw new SyntaxError("An invalid or illegal string was specified.");
                  ft = $t, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(k, "position", f({}, O, {
                get: function() {
                  return _e;
                },
                set: function(Me) {
                  if (Me < 0 || Me > 100)
                    throw new Error("Position must be between 0 and 100.");
                  _e = Me, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(k, "positionAlign", f({}, O, {
                get: function() {
                  return Bt;
                },
                set: function(Me) {
                  var $t = u(Me);
                  if (!$t)
                    throw new SyntaxError("An invalid or illegal string was specified.");
                  Bt = $t, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(k, "size", f({}, O, {
                get: function() {
                  return at;
                },
                set: function(Me) {
                  if (Me < 0 || Me > 100)
                    throw new Error("Size must be between 0 and 100.");
                  at = Me, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(k, "align", f({}, O, {
                get: function() {
                  return sn;
                },
                set: function(Me) {
                  var $t = u(Me);
                  if (!$t)
                    throw new SyntaxError("An invalid or illegal string was specified.");
                  sn = $t, this.hasBeenReset = !0;
                }
              })), k.displayState = void 0, B)
                return k;
            }
            return E.prototype.getCueAsHTML = function() {
              var w = window.WebVTT;
              return w.convertCueToDOMTree(window, this.text);
            }, E;
          }(), py = function() {
            return {
              decode: function(l) {
                if (!l)
                  return "";
                if (typeof l != "string")
                  throw new Error("Error - expected string data.");
                return decodeURIComponent(encodeURIComponent(l));
              }
            };
          };
          function ud() {
            this.window = window, this.state = "INITIAL", this.buffer = "", this.decoder = new py(), this.regionList = [];
          }
          function hy(g) {
            function o(s, u, f, E) {
              return (s | 0) * 3600 + (u | 0) * 60 + (f | 0) + (E | 0) / 1e3;
            }
            var l = g.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
            return l ? l[3] ? o(l[1], l[2], l[3].replace(":", ""), l[4]) : l[1] > 59 ? o(l[1], l[2], 0, l[4]) : o(0, l[1], l[2], l[4]) : null;
          }
          function cd() {
            this.values = /* @__PURE__ */ Object.create(null);
          }
          cd.prototype = {
            // Only accept the first assignment to any key.
            set: function(o, l) {
              !this.get(o) && l !== "" && (this.values[o] = l);
            },
            // Return the value for a key, or a default value.
            // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
            // a number of possible default values as properties where 'defaultKey' is
            // the key of the property that will be chosen; otherwise it's assumed to be
            // a single value.
            get: function(o, l, s) {
              return s ? this.has(o) ? this.values[o] : l[s] : this.has(o) ? this.values[o] : l;
            },
            // Check whether we have a value for a key.
            has: function(o) {
              return o in this.values;
            },
            // Accept a setting if its one of the given alternatives.
            alt: function(o, l, s) {
              for (var u = 0; u < s.length; ++u)
                if (l === s[u]) {
                  this.set(o, l);
                  break;
                }
            },
            // Accept a setting if its a valid (signed) integer.
            integer: function(o, l) {
              /^-?\d+$/.test(l) && this.set(o, parseInt(l, 10));
            },
            // Accept a setting if its a valid percentage.
            percent: function(o, l) {
              return l.match(/^([\d]{1,3})(\.[\d]*)?%$/) && (l = parseFloat(l), l >= 0 && l <= 100) ? (this.set(o, l), !0) : !1;
            }
          };
          function dd(g, o, l, s) {
            var u = s ? g.split(s) : [g];
            for (var f in u)
              if (typeof u[f] == "string") {
                var E = u[f].split(l);
                if (E.length === 2) {
                  var w = E[0], A = E[1];
                  o(w, A);
                }
              }
          }
          var tc = new ld(0, 0, 0), Hl = tc.align === "middle" ? "middle" : "center";
          function my(g, o, l) {
            var s = g;
            function u() {
              var w = hy(g);
              if (w === null)
                throw new Error("Malformed timestamp: " + s);
              return g = g.replace(/^[^\sa-zA-Z-]+/, ""), w;
            }
            function f(w, A) {
              var S = new cd();
              dd(w, function(O, $) {
                switch (O) {
                  case "region":
                    for (var te = l.length - 1; te >= 0; te--)
                      if (l[te].id === $) {
                        S.set(O, l[te].region);
                        break;
                      }
                    break;
                  case "vertical":
                    S.alt(O, $, ["rl", "lr"]);
                    break;
                  case "line":
                    var pe = $.split(","), be = pe[0];
                    S.integer(O, be), S.percent(O, be) && S.set("snapToLines", !1), S.alt(O, be, ["auto"]), pe.length === 2 && S.alt("lineAlign", pe[1], ["start", Hl, "end"]);
                    break;
                  case "position":
                    pe = $.split(","), S.percent(O, pe[0]), pe.length === 2 && S.alt("positionAlign", pe[1], ["start", Hl, "end", "line-left", "line-right", "auto"]);
                    break;
                  case "size":
                    S.percent(O, $);
                    break;
                  case "align":
                    S.alt(O, $, ["start", Hl, "end", "left", "right"]);
                    break;
                }
              }, /:/, /\s/), A.region = S.get("region", null), A.vertical = S.get("vertical", "");
              var k = S.get("line", "auto");
              k === "auto" && tc.line === -1 && (k = -1), A.line = k, A.lineAlign = S.get("lineAlign", "start"), A.snapToLines = S.get("snapToLines", !0), A.size = S.get("size", 100), A.align = S.get("align", Hl);
              var B = S.get("position", "auto");
              B === "auto" && tc.position === 50 && (B = A.align === "start" || A.align === "left" ? 0 : A.align === "end" || A.align === "right" ? 100 : 50), A.position = B;
            }
            function E() {
              g = g.replace(/^\s+/, "");
            }
            if (E(), o.startTime = u(), E(), g.substr(0, 3) !== "-->")
              throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + s);
            g = g.substr(3), E(), o.endTime = u(), E(), f(g, o);
          }
          function fd(g) {
            return g.replace(/<br(?: \/)?>/gi, `
`);
          }
          ud.prototype = {
            parse: function(o) {
              var l = this;
              o && (l.buffer += l.decoder.decode(o, { stream: !0 }));
              function s() {
                var S = l.buffer, k = 0;
                for (S = fd(S); k < S.length && S[k] !== "\r" && S[k] !== `
`; )
                  ++k;
                var B = S.substr(0, k);
                return S[k] === "\r" && ++k, S[k] === `
` && ++k, l.buffer = S.substr(k), B;
              }
              function u(S) {
                dd(S, function(k, B) {
                  switch (k) {
                    case "Region":
                      console.log("parse region", B);
                      break;
                  }
                }, /:/);
              }
              try {
                var f;
                if (l.state === "INITIAL") {
                  if (!/\r\n|\n/.test(l.buffer))
                    return this;
                  f = s();
                  var E = f.match(/^()?WEBVTT([ \t].*)?$/);
                  if (!E || !E[0])
                    throw new Error("Malformed WebVTT signature.");
                  l.state = "HEADER";
                }
                for (var w = !1; l.buffer; ) {
                  if (!/\r\n|\n/.test(l.buffer))
                    return this;
                  switch (w ? w = !1 : f = s(), l.state) {
                    case "HEADER":
                      /:/.test(f) ? u(f) : f || (l.state = "ID");
                      continue;
                    case "NOTE":
                      f || (l.state = "ID");
                      continue;
                    case "ID":
                      if (/^NOTE($|[ \t])/.test(f)) {
                        l.state = "NOTE";
                        break;
                      }
                      if (!f)
                        continue;
                      if (l.cue = new ld(0, 0, ""), l.state = "CUE", f.indexOf("-->") === -1) {
                        l.cue.id = f;
                        continue;
                      }
                    case "CUE":
                      try {
                        my(f, l.cue, l.regionList);
                      } catch {
                        l.cue = null, l.state = "BADCUE";
                        continue;
                      }
                      l.state = "CUETEXT";
                      continue;
                    case "CUETEXT":
                      var A = f.indexOf("-->") !== -1;
                      if (!f || A && (w = !0)) {
                        l.oncue && l.oncue(l.cue), l.cue = null, l.state = "ID";
                        continue;
                      }
                      l.cue.text && (l.cue.text += `
`), l.cue.text += f;
                      continue;
                    case "BADCUE":
                      f || (l.state = "ID");
                      continue;
                  }
                }
              } catch {
                l.state === "CUETEXT" && l.cue && l.oncue && l.oncue(l.cue), l.cue = null, l.state = l.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
              }
              return this;
            },
            flush: function() {
              var o = this;
              try {
                if (o.buffer += o.decoder.decode(), (o.cue || o.state === "HEADER") && (o.buffer += `

`, o.parse()), o.state === "INITIAL")
                  throw new Error("Malformed WebVTT signature.");
              } catch (l) {
                throw l;
              }
              return o.onflush && o.onflush(), this;
            }
          };
          var yy = ud;
          function by(g, o, l, s) {
            for (var u, f, E, w, A, S = window.VTTCue || window.TextTrackCue, k = 0; k < s.rows.length; k++)
              if (u = s.rows[k], E = !0, w = 0, A = "", !u.isEmpty()) {
                for (var B = 0; B < u.chars.length; B++)
                  u.chars[B].uchar.match(/\s/) && E ? w++ : (A += u.chars[B].uchar, E = !1);
                u.cueStartTime = o, o === l && (l += 1e-4), f = new S(o, l, fd(A.trim())), w >= 16 ? w-- : w++, navigator.userAgent.match(/Firefox\//) ? f.line = k + 1 : f.line = k > 7 ? k - 2 : k + 1, f.align = "left", f.position = Math.max(0, Math.min(100, 100 * (w / 32) + (navigator.userAgent.match(/Firefox\//) ? 50 : 0))), g.addCue(f);
              }
          }
          function fs(g, o) {
            if (!(g instanceof o))
              throw new TypeError("Cannot call a class as a function");
          }
          var pd = {
            42: 225,
            // lowercase a, acute accent
            92: 233,
            // lowercase e, acute accent
            94: 237,
            // lowercase i, acute accent
            95: 243,
            // lowercase o, acute accent
            96: 250,
            // lowercase u, acute accent
            123: 231,
            // lowercase c with cedilla
            124: 247,
            // division symbol
            125: 209,
            // uppercase N tilde
            126: 241,
            // lowercase n tilde
            127: 9608,
            // Full block
            // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
            // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
            // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
            128: 174,
            // Registered symbol (R)
            129: 176,
            // degree sign
            130: 189,
            // 1/2 symbol
            131: 191,
            // Inverted (open) question mark
            132: 8482,
            // Trademark symbol (TM)
            133: 162,
            // Cents symbol
            134: 163,
            // Pounds sterling
            135: 9834,
            // Music 8'th note
            136: 224,
            // lowercase a, grave accent
            137: 32,
            // transparent space (regular)
            138: 232,
            // lowercase e, grave accent
            139: 226,
            // lowercase a, circumflex accent
            140: 234,
            // lowercase e, circumflex accent
            141: 238,
            // lowercase i, circumflex accent
            142: 244,
            // lowercase o, circumflex accent
            143: 251,
            // lowercase u, circumflex accent
            // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
            // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
            144: 193,
            // capital letter A with acute
            145: 201,
            // capital letter E with acute
            146: 211,
            // capital letter O with acute
            147: 218,
            // capital letter U with acute
            148: 220,
            // capital letter U with diaresis
            149: 252,
            // lowercase letter U with diaeresis
            150: 8216,
            // opening single quote
            151: 161,
            // inverted exclamation mark
            152: 42,
            // asterisk
            153: 8217,
            // closing single quote
            154: 9473,
            // box drawings heavy horizontal
            155: 169,
            // copyright sign
            156: 8480,
            // Service mark
            157: 8226,
            // (round) bullet
            158: 8220,
            // Left double quotation mark
            159: 8221,
            // Right double quotation mark
            160: 192,
            // uppercase A, grave accent
            161: 194,
            // uppercase A, circumflex
            162: 199,
            // uppercase C with cedilla
            163: 200,
            // uppercase E, grave accent
            164: 202,
            // uppercase E, circumflex
            165: 203,
            // capital letter E with diaresis
            166: 235,
            // lowercase letter e with diaresis
            167: 206,
            // uppercase I, circumflex
            168: 207,
            // uppercase I, with diaresis
            169: 239,
            // lowercase i, with diaresis
            170: 212,
            // uppercase O, circumflex
            171: 217,
            // uppercase U, grave accent
            172: 249,
            // lowercase u, grave accent
            173: 219,
            // uppercase U, circumflex
            174: 171,
            // left-pointing double angle quotation mark
            175: 187,
            // right-pointing double angle quotation mark
            // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
            // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
            176: 195,
            // Uppercase A, tilde
            177: 227,
            // Lowercase a, tilde
            178: 205,
            // Uppercase I, acute accent
            179: 204,
            // Uppercase I, grave accent
            180: 236,
            // Lowercase i, grave accent
            181: 210,
            // Uppercase O, grave accent
            182: 242,
            // Lowercase o, grave accent
            183: 213,
            // Uppercase O, tilde
            184: 245,
            // Lowercase o, tilde
            185: 123,
            // Open curly brace
            186: 125,
            // Closing curly brace
            187: 92,
            // Backslash
            188: 94,
            // Caret
            189: 95,
            // Underscore
            190: 124,
            // Pipe (vertical line)
            191: 8764,
            // Tilde operator
            192: 196,
            // Uppercase A, umlaut
            193: 228,
            // Lowercase A, umlaut
            194: 214,
            // Uppercase O, umlaut
            195: 246,
            // Lowercase o, umlaut
            196: 223,
            // Esszett (sharp S)
            197: 165,
            // Yen symbol
            198: 164,
            // Generic currency sign
            199: 9475,
            // Box drawings heavy vertical
            200: 197,
            // Uppercase A, ring
            201: 229,
            // Lowercase A, ring
            202: 216,
            // Uppercase O, stroke
            203: 248,
            // Lowercase o, strok
            204: 9487,
            // Box drawings heavy down and right
            205: 9491,
            // Box drawings heavy down and left
            206: 9495,
            // Box drawings heavy up and right
            207: 9499
            // Box drawings heavy up and left
          }, hd = function(o) {
            var l = o;
            return pd.hasOwnProperty(o) && (l = pd[o]), String.fromCharCode(l);
          }, Ur = 15, Ci = 100, gy = { 17: 1, 18: 3, 21: 5, 22: 7, 23: 9, 16: 11, 19: 12, 20: 14 }, xy = { 17: 2, 18: 4, 21: 6, 22: 8, 23: 10, 19: 13, 20: 15 }, Ey = { 25: 1, 26: 3, 29: 5, 30: 7, 31: 9, 24: 11, 27: 12, 28: 14 }, vy = { 25: 2, 26: 4, 29: 6, 30: 8, 31: 10, 27: 13, 28: 15 }, Ry = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"], je = {
            verboseFilter: { DATA: 3, DEBUG: 3, INFO: 2, WARNING: 2, TEXT: 1, ERROR: 0 },
            time: null,
            verboseLevel: 0,
            // Only write errors
            setTime: function(o) {
              this.time = o;
            },
            log: function(o, l) {
              var s = this.verboseFilter[o];
              this.verboseLevel >= s && console.log(this.time + " [" + o + "] " + l);
            }
          }, Pn = function(o) {
            for (var l = [], s = 0; s < o.length; s++)
              l.push(o[s].toString(16));
            return l;
          }, md = function() {
            function g(o, l, s, u, f) {
              fs(this, g), this.foreground = o || "white", this.underline = l || !1, this.italics = s || !1, this.background = u || "black", this.flash = f || !1;
            }
            return g.prototype.reset = function() {
              this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1;
            }, g.prototype.setStyles = function(l) {
              for (var s = ["foreground", "underline", "italics", "background", "flash"], u = 0; u < s.length; u++) {
                var f = s[u];
                l.hasOwnProperty(f) && (this[f] = l[f]);
              }
            }, g.prototype.isDefault = function() {
              return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash;
            }, g.prototype.equals = function(l) {
              return this.foreground === l.foreground && this.underline === l.underline && this.italics === l.italics && this.background === l.background && this.flash === l.flash;
            }, g.prototype.copy = function(l) {
              this.foreground = l.foreground, this.underline = l.underline, this.italics = l.italics, this.background = l.background, this.flash = l.flash;
            }, g.prototype.toString = function() {
              return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash;
            }, g;
          }(), Ay = function() {
            function g(o, l, s, u, f, E) {
              fs(this, g), this.uchar = o || " ", this.penState = new md(l, s, u, f, E);
            }
            return g.prototype.reset = function() {
              this.uchar = " ", this.penState.reset();
            }, g.prototype.setChar = function(l, s) {
              this.uchar = l, this.penState.copy(s);
            }, g.prototype.setPenState = function(l) {
              this.penState.copy(l);
            }, g.prototype.equals = function(l) {
              return this.uchar === l.uchar && this.penState.equals(l.penState);
            }, g.prototype.copy = function(l) {
              this.uchar = l.uchar, this.penState.copy(l.penState);
            }, g.prototype.isEmpty = function() {
              return this.uchar === " " && this.penState.isDefault();
            }, g;
          }(), _y = function() {
            function g() {
              fs(this, g), this.chars = [];
              for (var o = 0; o < Ci; o++)
                this.chars.push(new Ay());
              this.pos = 0, this.currPenState = new md();
            }
            return g.prototype.equals = function(l) {
              for (var s = !0, u = 0; u < Ci; u++)
                if (!this.chars[u].equals(l.chars[u])) {
                  s = !1;
                  break;
                }
              return s;
            }, g.prototype.copy = function(l) {
              for (var s = 0; s < Ci; s++)
                this.chars[s].copy(l.chars[s]);
            }, g.prototype.isEmpty = function() {
              for (var l = !0, s = 0; s < Ci; s++)
                if (!this.chars[s].isEmpty()) {
                  l = !1;
                  break;
                }
              return l;
            }, g.prototype.setCursor = function(l) {
              this.pos !== l && (this.pos = l), this.pos < 0 ? (je.log("ERROR", "Negative cursor position " + this.pos), this.pos = 0) : this.pos > Ci && (je.log("ERROR", "Too large cursor position " + this.pos), this.pos = Ci);
            }, g.prototype.moveCursor = function(l) {
              var s = this.pos + l;
              if (l > 1)
                for (var u = this.pos + 1; u < s + 1; u++)
                  this.chars[u].setPenState(this.currPenState);
              this.setCursor(s);
            }, g.prototype.backSpace = function() {
              this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState);
            }, g.prototype.insertChar = function(l) {
              l >= 144 && this.backSpace();
              var s = hd(l);
              if (this.pos >= Ci) {
                je.log("ERROR", "Cannot insert " + l.toString(16) + " (" + s + ") at position " + this.pos + ". Skipping it!");
                return;
              }
              this.chars[this.pos].setChar(s, this.currPenState), this.moveCursor(1);
            }, g.prototype.clearFromPos = function(l) {
              var s;
              for (s = l; s < Ci; s++)
                this.chars[s].reset();
            }, g.prototype.clear = function() {
              this.clearFromPos(0), this.pos = 0, this.currPenState.reset();
            }, g.prototype.clearToEndOfRow = function() {
              this.clearFromPos(this.pos);
            }, g.prototype.getTextString = function() {
              for (var l = [], s = !0, u = 0; u < Ci; u++) {
                var f = this.chars[u].uchar;
                f !== " " && (s = !1), l.push(f);
              }
              return s ? "" : l.join("");
            }, g.prototype.setPenStyles = function(l) {
              this.currPenState.setStyles(l);
              var s = this.chars[this.pos];
              s.setPenState(this.currPenState);
            }, g;
          }(), rc = function() {
            function g() {
              fs(this, g), this.rows = [];
              for (var o = 0; o < Ur; o++)
                this.rows.push(new _y());
              this.currRow = Ur - 1, this.nrRollUpRows = null, this.reset();
            }
            return g.prototype.reset = function() {
              for (var l = 0; l < Ur; l++)
                this.rows[l].clear();
              this.currRow = Ur - 1;
            }, g.prototype.equals = function(l) {
              for (var s = !0, u = 0; u < Ur; u++)
                if (!this.rows[u].equals(l.rows[u])) {
                  s = !1;
                  break;
                }
              return s;
            }, g.prototype.copy = function(l) {
              for (var s = 0; s < Ur; s++)
                this.rows[s].copy(l.rows[s]);
            }, g.prototype.isEmpty = function() {
              for (var l = !0, s = 0; s < Ur; s++)
                if (!this.rows[s].isEmpty()) {
                  l = !1;
                  break;
                }
              return l;
            }, g.prototype.backSpace = function() {
              var l = this.rows[this.currRow];
              l.backSpace();
            }, g.prototype.clearToEndOfRow = function() {
              var l = this.rows[this.currRow];
              l.clearToEndOfRow();
            }, g.prototype.insertChar = function(l) {
              var s = this.rows[this.currRow];
              s.insertChar(l);
            }, g.prototype.setPen = function(l) {
              var s = this.rows[this.currRow];
              s.setPenStyles(l);
            }, g.prototype.moveCursor = function(l) {
              var s = this.rows[this.currRow];
              s.moveCursor(l);
            }, g.prototype.setCursor = function(l) {
              je.log("INFO", "setCursor: " + l);
              var s = this.rows[this.currRow];
              s.setCursor(l);
            }, g.prototype.setPAC = function(l) {
              je.log("INFO", "pacData = " + JSON.stringify(l));
              var s = l.row - 1;
              if (this.nrRollUpRows && s < this.nrRollUpRows - 1 && (s = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== s) {
                for (var u = 0; u < Ur; u++)
                  this.rows[u].clear();
                var f = this.currRow + 1 - this.nrRollUpRows, E = this.lastOutputScreen;
                if (E) {
                  var w = E.rows[f].cueStartTime;
                  if (w && w < je.time)
                    for (var A = 0; A < this.nrRollUpRows; A++)
                      this.rows[s - this.nrRollUpRows + A + 1].copy(E.rows[f + A]);
                }
              }
              this.currRow = s;
              var S = this.rows[this.currRow];
              if (l.indent !== null) {
                var k = l.indent, B = Math.max(k - 1, 0);
                S.setCursor(l.indent), l.color = S.chars[B].penState.foreground;
              }
              var O = { foreground: l.color, underline: l.underline, italics: l.italics, background: "black", flash: !1 };
              this.setPen(O);
            }, g.prototype.setBkgData = function(l) {
              je.log("INFO", "bkgData = " + JSON.stringify(l)), this.backSpace(), this.setPen(l), this.insertChar(32);
            }, g.prototype.setRollUpRows = function(l) {
              this.nrRollUpRows = l;
            }, g.prototype.rollUp = function() {
              if (this.nrRollUpRows === null) {
                je.log("DEBUG", "roll_up but nrRollUpRows not set yet");
                return;
              }
              je.log("TEXT", this.getDisplayText());
              var l = this.currRow + 1 - this.nrRollUpRows, s = this.rows.splice(l, 1)[0];
              s.clear(), this.rows.splice(this.currRow, 0, s), je.log("INFO", "Rolling up");
            }, g.prototype.getDisplayText = function(l) {
              l = l || !1;
              for (var s = [], u = "", f = -1, E = 0; E < Ur; E++) {
                var w = this.rows[E].getTextString();
                w && (f = E + 1, l ? s.push("Row " + f + ": '" + w + "'") : s.push(w.trim()));
              }
              return s.length > 0 && (l ? u = "[" + s.join(" | ") + "]" : u = s.join(`
`)), u;
            }, g.prototype.getTextAndFormat = function() {
              return this.rows;
            }, g;
          }(), yd = function() {
            function g(o, l) {
              fs(this, g), this.chNr = o, this.outputFilter = l, this.mode = null, this.verbose = 0, this.displayedMemory = new rc(), this.nonDisplayedMemory = new rc(), this.lastOutputScreen = new rc(), this.currRollUpRow = this.displayedMemory.rows[Ur - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null;
            }
            return g.prototype.reset = function() {
              this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.currRollUpRow = this.displayedMemory.rows[Ur - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.lastCueEndTime = null;
            }, g.prototype.getHandler = function() {
              return this.outputFilter;
            }, g.prototype.setHandler = function(l) {
              this.outputFilter = l;
            }, g.prototype.setPAC = function(l) {
              this.writeScreen.setPAC(l);
            }, g.prototype.setBkgData = function(l) {
              this.writeScreen.setBkgData(l);
            }, g.prototype.setMode = function(l) {
              l !== this.mode && (this.mode = l, je.log("INFO", "MODE=" + l), this.mode === "MODE_POP-ON" ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), this.mode !== "MODE_ROLL-UP" && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = l);
            }, g.prototype.insertChars = function(l) {
              for (var s = 0; s < l.length; s++)
                this.writeScreen.insertChar(l[s]);
              var u = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
              je.log("INFO", u + ": " + this.writeScreen.getDisplayText(!0)), (this.mode === "MODE_PAINT-ON" || this.mode === "MODE_ROLL-UP") && (je.log("TEXT", "DISPLAYED: " + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate());
            }, g.prototype.ccRCL = function() {
              je.log("INFO", "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON");
            }, g.prototype.ccBS = function() {
              je.log("INFO", "BS - BackSpace"), this.mode !== "MODE_TEXT" && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate());
            }, g.prototype.ccAOF = function() {
            }, g.prototype.ccAON = function() {
            }, g.prototype.ccDER = function() {
              je.log("INFO", "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate();
            }, g.prototype.ccRU = function(l) {
              je.log("INFO", "RU(" + l + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(l);
            }, g.prototype.ccFON = function() {
              je.log("INFO", "FON - Flash On"), this.writeScreen.setPen({ flash: !0 });
            }, g.prototype.ccRDC = function() {
              je.log("INFO", "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON");
            }, g.prototype.ccTR = function() {
              je.log("INFO", "TR"), this.setMode("MODE_TEXT");
            }, g.prototype.ccRTD = function() {
              je.log("INFO", "RTD"), this.setMode("MODE_TEXT");
            }, g.prototype.ccEDM = function() {
              je.log("INFO", "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0);
            }, g.prototype.ccCR = function() {
              je.log("CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0);
            }, g.prototype.ccENM = function() {
              je.log("INFO", "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset();
            }, g.prototype.ccEOC = function() {
              if (je.log("INFO", "EOC - End Of Caption"), this.mode === "MODE_POP-ON") {
                var l = this.displayedMemory;
                this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = l, this.writeScreen = this.nonDisplayedMemory, je.log("TEXT", "DISP: " + this.displayedMemory.getDisplayText());
              }
              this.outputDataUpdate(!0);
            }, g.prototype.ccTO = function(l) {
              je.log("INFO", "TO(" + l + ") - Tab Offset"), this.writeScreen.moveCursor(l);
            }, g.prototype.ccMIDROW = function(l) {
              var s = { flash: !1 };
              if (s.underline = l % 2 === 1, s.italics = l >= 46, s.italics)
                s.foreground = "white";
              else {
                var u = Math.floor(l / 2) - 16, f = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
                s.foreground = f[u];
              }
              je.log("INFO", "MIDROW: " + JSON.stringify(s)), this.writeScreen.setPen(s);
            }, g.prototype.outputDataUpdate = function() {
              var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, s = je.time;
              s !== null && this.outputFilter && (this.cueStartTime === null && !this.displayedMemory.isEmpty() ? this.cueStartTime = s : this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue && (this.outputFilter.newCue(this.cueStartTime, s, this.lastOutputScreen), l === !0 && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue()), this.cueStartTime = this.displayedMemory.isEmpty() ? null : s), this.lastOutputScreen.copy(this.displayedMemory));
            }, g.prototype.cueSplitAtTime = function(l) {
              this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, l, this.displayedMemory), this.cueStartTime = l));
            }, g;
          }(), wy = function() {
            function g(o, l, s) {
              fs(this, g), this.field = o || 1, this.outputs = [l, s], this.channels = [new yd(1, l), new yd(2, s)], this.currChNr = -1, this.lastCmdA = null, this.lastCmdB = null, this.bufferedData = [], this.startTime = null, this.lastTime = null, this.dataCounters = { padding: 0, char: 0, cmd: 0, other: 0 };
            }
            return g.prototype.getHandler = function(l) {
              return this.channels[l].getHandler();
            }, g.prototype.setHandler = function(l, s) {
              this.channels[l].setHandler(s);
            }, g.prototype.addData = function(l, s) {
              var u, f, E, w = !1;
              this.lastTime = l, je.setTime(l);
              for (var A = 0; A < s.length; A += 2) {
                if (f = s[A] & 127, E = s[A + 1] & 127, f === 0 && E === 0) {
                  this.dataCounters.padding += 2;
                  continue;
                } else
                  je.log("DATA", "[" + Pn([s[A], s[A + 1]]) + "] -> (" + Pn([f, E]) + ")");
                if (u = this.parseCmd(f, E), u || (u = this.parseMidrow(f, E)), u || (u = this.parsePAC(f, E)), u || (u = this.parseBackgroundAttributes(f, E)), !u && (w = this.parseChars(f, E), w))
                  if (this.currChNr && this.currChNr >= 0) {
                    var S = this.channels[this.currChNr - 1];
                    S.insertChars(w);
                  } else
                    je.log("WARNING", "No channel found yet. TEXT-MODE?");
                u ? this.dataCounters.cmd += 2 : w ? this.dataCounters.char += 2 : (this.dataCounters.other += 2, je.log("WARNING", "Couldn't parse cleaned data " + Pn([f, E]) + " orig: " + Pn([s[A], s[A + 1]])));
              }
            }, g.prototype.parseCmd = function(l, s) {
              var u = null, f = (l === 20 || l === 28) && 32 <= s && s <= 47, E = (l === 23 || l === 31) && 33 <= s && s <= 35;
              if (!(f || E))
                return !1;
              if (l === this.lastCmdA && s === this.lastCmdB)
                return this.lastCmdA = null, this.lastCmdB = null, je.log("DEBUG", "Repeated command (" + Pn([l, s]) + ") is dropped"), !0;
              l === 20 || l === 23 ? u = 1 : u = 2;
              var w = this.channels[u - 1];
              return l === 20 || l === 28 ? s === 32 ? w.ccRCL() : s === 33 ? w.ccBS() : s === 34 ? w.ccAOF() : s === 35 ? w.ccAON() : s === 36 ? w.ccDER() : s === 37 ? w.ccRU(2) : s === 38 ? w.ccRU(3) : s === 39 ? w.ccRU(4) : s === 40 ? w.ccFON() : s === 41 ? w.ccRDC() : s === 42 ? w.ccTR() : s === 43 ? w.ccRTD() : s === 44 ? w.ccEDM() : s === 45 ? w.ccCR() : s === 46 ? w.ccENM() : s === 47 && w.ccEOC() : w.ccTO(s - 32), this.lastCmdA = l, this.lastCmdB = s, this.currChNr = u, !0;
            }, g.prototype.parseMidrow = function(l, s) {
              var u = null;
              if ((l === 17 || l === 25) && 32 <= s && s <= 47) {
                if (l === 17 ? u = 1 : u = 2, u !== this.currChNr)
                  return je.log("ERROR", "Mismatch channel in midrow parsing"), !1;
                var f = this.channels[u - 1];
                return f.ccMIDROW(s), je.log("DEBUG", "MIDROW (" + Pn([l, s]) + ")"), !0;
              }
              return !1;
            }, g.prototype.parsePAC = function(l, s) {
              var u = null, f = null, E = (17 <= l && l <= 23 || 25 <= l && l <= 31) && 64 <= s && s <= 127, w = (l === 16 || l === 24) && 64 <= s && s <= 95;
              if (!(E || w))
                return !1;
              if (l === this.lastCmdA && s === this.lastCmdB)
                return this.lastCmdA = null, this.lastCmdB = null, !0;
              u = l <= 23 ? 1 : 2, 64 <= s && s <= 95 ? f = u === 1 ? gy[l] : Ey[l] : f = u === 1 ? xy[l] : vy[l];
              var A = this.interpretPAC(f, s), S = this.channels[u - 1];
              return S.setPAC(A), this.lastCmdA = l, this.lastCmdB = s, this.currChNr = u, !0;
            }, g.prototype.interpretPAC = function(l, s) {
              var u = s, f = { color: null, italics: !1, indent: null, underline: !1, row: l };
              return s > 95 ? u = s - 96 : u = s - 64, f.underline = (u & 1) === 1, u <= 13 ? f.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(u / 2)] : u <= 15 ? (f.italics = !0, f.color = "white") : f.indent = Math.floor((u - 16) / 2) * 4, f;
            }, g.prototype.parseChars = function(l, s) {
              var u = null, f = null, E = null;
              if (l >= 25 ? (u = 2, E = l - 8) : (u = 1, E = l), 17 <= E && E <= 19) {
                var w = s;
                E === 17 ? w = s + 80 : E === 18 ? w = s + 112 : w = s + 144, je.log("INFO", "Special char '" + hd(w) + "' in channel " + u), f = [w];
              } else 32 <= l && l <= 127 && (f = s === 0 ? [l] : [l, s]);
              if (f) {
                var A = Pn(f);
                je.log("DEBUG", "Char codes =  " + A.join(",")), this.lastCmdA = null, this.lastCmdB = null;
              }
              return f;
            }, g.prototype.parseBackgroundAttributes = function(l, s) {
              var u, f, E, w, A = (l === 16 || l === 24) && 32 <= s && s <= 47, S = (l === 23 || l === 31) && 45 <= s && s <= 47;
              return A || S ? (u = {}, l === 16 || l === 24 ? (f = Math.floor((s - 32) / 2), u.background = Ry[f], s % 2 === 1 && (u.background = u.background + "_semi")) : s === 45 ? u.background = "transparent" : (u.foreground = "black", s === 47 && (u.underline = !0)), E = l < 24 ? 1 : 2, w = this.channels[E - 1], w.setBkgData(u), this.lastCmdA = null, this.lastCmdB = null, !0) : !1;
            }, g.prototype.reset = function() {
              for (var l = 0; l < this.channels.length; l++)
                this.channels[l] && this.channels[l].reset();
              this.lastCmdA = null, this.lastCmdB = null;
            }, g.prototype.cueSplitAtTime = function(l) {
              for (var s = 0; s < this.channels.length; s++)
                this.channels[s] && this.channels[s].cueSplitAtTime(l);
            }, g;
          }(), Ty = wy;
          function Sy(g, o) {
            if (!(g instanceof o))
              throw new TypeError("Cannot call a class as a function");
          }
          var Cy = function() {
            function g(o, l) {
              Sy(this, g), this.timelineController = o, this.track = l, this.startTime = null, this.endTime = null, this.screen = null;
            }
            return g.prototype.dispatchCue = function() {
              this.startTime !== null && (this.timelineController.addCues("textTrack" + this.track, this.startTime, this.endTime, this.screen), this.startTime = null);
            }, g.prototype.newCue = function(l, s, u) {
              (this.startTime === null || this.startTime > l) && (this.startTime = l), this.endTime = s, this.screen = u, this.timelineController.createCaptionsTrack(this.track);
            }, g;
          }(), bd = Cy, ic = function(o, l, s) {
            return o.substr(0, l.length) === l;
          }, Ly = function(o) {
            var l = parseInt(o.substr(-3)), s = parseInt(o.substr(-6, 2)), u = parseInt(o.substr(-9, 2)), f = o.length > 9 ? parseInt(o.substr(0, o.indexOf(":"))) : 0;
            return isNaN(l) || isNaN(s) || isNaN(u) || isNaN(f) ? -1 : (l += 1e3 * s, l += 60 * 1e3 * u, l += 60 * 60 * 1e3 * f, l);
          }, nc = function(o) {
            for (var l = 5381, s = o.length; s; )
              l = l * 33 ^ o.charCodeAt(--s);
            return (l >>> 0).toString();
          }, ky = function(o, l, s) {
            var u = o[l], f = o[u.prevCC];
            if (!f || !f.new && u.new) {
              o.ccOffset = o.presentationOffset = u.start, u.new = !1;
              return;
            }
            for (; f && f.new; )
              o.ccOffset += u.start - f.start, u.new = !1, u = f, f = o[u.prevCC];
            o.presentationOffset = s;
          }, Dy = {
            parse: function(o, l, s, u, f, E) {
              var w = /\r\n|\n\r|\n|\r/g, A = Object(rt.b)(new Uint8Array(o)).trim().replace(w, `
`).split(`
`), S = "00:00.000", k = 0, B = 0, O = 0, $ = [], te = void 0, pe = !0, be = new yy();
              be.oncue = function(ye) {
                var Se = s[u], Ce = s.ccOffset;
                Se && Se.new && (B !== void 0 ? Ce = s.ccOffset = Se.start : ky(s, u, O)), O && (Ce = O + s.ccOffset - s.presentationOffset), ye.startTime += Ce - B, ye.endTime += Ce - B, ye.id = nc(ye.startTime.toString()) + nc(ye.endTime.toString()) + nc(ye.text), ye.text = decodeURIComponent(encodeURIComponent(ye.text)), ye.endTime > 0 && $.push(ye);
              }, be.onparsingerror = function(ye) {
                te = ye;
              }, be.onflush = function() {
                if (te && E) {
                  E(te);
                  return;
                }
                f($);
              }, A.forEach(function(ye) {
                if (pe)
                  if (ic(ye, "X-TIMESTAMP-MAP=")) {
                    pe = !1, ye.substr(16).split(",").forEach(function(Se) {
                      ic(Se, "LOCAL:") ? S = Se.substr(6) : ic(Se, "MPEGTS:") && (k = parseInt(Se.substr(7)));
                    });
                    try {
                      l = l < 0 ? l + 8589934592 : l, k -= l, B = Ly(S) / 1e3, O = k / 9e4, B === -1 && (te = new Error("Malformed X-TIMESTAMP-MAP: " + ye));
                    } catch {
                      te = new Error("Malformed X-TIMESTAMP-MAP: " + ye);
                    }
                    return;
                  } else ye === "" && (pe = !1);
                be.parse(ye + `
`);
              }), be.flush();
            }
          }, Py = Dy;
          function By(g, o) {
            if (!(g instanceof o))
              throw new TypeError("Cannot call a class as a function");
          }
          function Iy(g, o) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return o && (typeof o == "object" || typeof o == "function") ? o : g;
          }
          function Uy(g, o) {
            if (typeof o != "function" && o !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof o);
            g.prototype = Object.create(o && o.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), o && (Object.setPrototypeOf ? Object.setPrototypeOf(g, o) : g.__proto__ = o);
          }
          function Zl(g) {
            if (g && g.cues)
              for (; g.cues.length > 0; )
                g.removeCue(g.cues[0]);
          }
          function Oy(g, o) {
            return g && g.label === o.name && !(g.textTrack1 || g.textTrack2);
          }
          function Ky(g, o, l, s) {
            return Math.min(o, s) - Math.max(g, l);
          }
          var My = function(g) {
            Uy(o, g);
            function o(l) {
              By(this, o);
              var s = Iy(this, g.call(this, l, p.a.MEDIA_ATTACHING, p.a.MEDIA_DETACHING, p.a.FRAG_PARSING_USERDATA, p.a.FRAG_DECRYPTED, p.a.MANIFEST_LOADING, p.a.MANIFEST_LOADED, p.a.FRAG_LOADED, p.a.LEVEL_SWITCHING, p.a.INIT_PTS_FOUND));
              if (s.hls = l, s.config = l.config, s.enabled = !0, s.Cues = l.config.cueHandler, s.textTracks = [], s.tracks = [], s.unparsedVttFrags = [], s.initPTS = void 0, s.cueRanges = [], s.config.enableCEA708Captions) {
                var u = new bd(s, 1), f = new bd(s, 2);
                s.cea608Parser = new Ty(0, u, f);
              }
              return s;
            }
            return o.prototype.addCues = function(s, u, f, E) {
              for (var w = this.cueRanges, A = !1, S = w.length; S--; ) {
                var k = w[S], B = Ky(k[0], k[1], u, f);
                if (B >= 0 && (k[0] = Math.min(k[0], u), k[1] = Math.max(k[1], f), A = !0, B / (f - u) > 0.5))
                  return;
              }
              A || w.push([u, f]), this.Cues.newCue(this[s], u, f, E);
            }, o.prototype.onInitPtsFound = function(s) {
              var u = this;
              typeof this.initPTS > "u" && (this.initPTS = s.initPTS), this.unparsedVttFrags.length && (this.unparsedVttFrags.forEach(function(f) {
                u.onFragLoaded(f);
              }), this.unparsedVttFrags = []);
            }, o.prototype.getExistingTrack = function(s) {
              var u = this.media;
              if (u)
                for (var f = 0; f < u.textTracks.length; f++) {
                  var E = u.textTracks[f], w = "textTrack" + s;
                  if (E[w] === !0)
                    return E;
                }
              return null;
            }, o.prototype.sendAddTrackEvent = function(s, u) {
              var f = null;
              try {
                f = new window.Event("addtrack");
              } catch {
                f = document.createEvent("Event"), f.initEvent("addtrack", !1, !1);
              }
              f.track = s, u.dispatchEvent(f);
            }, o.prototype.createCaptionsTrack = function(s) {
              var u = "textTrack" + s;
              if (!this[u]) {
                var f = this.getExistingTrack(s);
                if (f)
                  this[u] = f, Zl(this[u]), this.sendAddTrackEvent(this[u], this.media);
                else {
                  var E = this.createTextTrack("captions", this.config["captionsTextTrack" + s + "Label"], this.config.captionsTextTrack1LanguageCode);
                  E && (E[u] = !0, this[u] = E);
                }
              }
            }, o.prototype.createTextTrack = function(s, u, f) {
              var E = this.media;
              if (E)
                return E.addTextTrack(s, u, f);
            }, o.prototype.destroy = function() {
              K.prototype.destroy.call(this);
            }, o.prototype.onMediaAttaching = function(s) {
              this.media = s.media, this._cleanTracks();
            }, o.prototype.onMediaDetaching = function() {
              Zl(this.textTrack1), Zl(this.textTrack2);
            }, o.prototype.onManifestLoading = function() {
              this.lastSn = -1, this.prevCC = -1, this.vttCCs = { ccOffset: 0, presentationOffset: 0 }, this._cleanTracks();
            }, o.prototype._cleanTracks = function() {
              var s = this.media;
              if (s) {
                var u = s.textTracks;
                if (u)
                  for (var f = 0; f < u.length; f++)
                    Zl(u[f]);
              }
            }, o.prototype.onManifestLoaded = function(s) {
              var u = this;
              if (this.textTracks = [], this.unparsedVttFrags = this.unparsedVttFrags || [], this.initPTS = void 0, this.cueRanges = [], this.config.enableWebVTT) {
                this.tracks = s.subtitles || [];
                var f = this.media ? this.media.textTracks : [];
                this.tracks.forEach(function(E, w) {
                  var A = void 0;
                  if (w < f.length) {
                    var S = f[w];
                    Oy(S, E) && (A = S);
                  }
                  A || (A = u.createTextTrack("subtitles", E.name, E.lang)), A.mode = E.default ? "showing" : "hidden", u.textTracks.push(A);
                });
              }
            }, o.prototype.onLevelSwitching = function() {
              this.enabled = this.hls.currentLevel.closedCaptions !== "NONE";
            }, o.prototype.onFragLoaded = function(s) {
              var u = s.frag, f = s.payload;
              if (u.type === "main") {
                var E = u.sn;
                if (E !== this.lastSn + 1) {
                  var w = this.cea608Parser;
                  w && w.reset();
                }
                this.lastSn = E;
              } else if (u.type === "subtitle")
                if (f.byteLength) {
                  if (typeof this.initPTS > "u") {
                    this.unparsedVttFrags.push(s);
                    return;
                  }
                  var A = u.decryptdata;
                  (A == null || A.key == null || A.method !== "AES-128") && this._parseVTTs(u, f);
                } else
                  this.hls.trigger(p.a.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: u });
            }, o.prototype._parseVTTs = function(s, u) {
              var f = this.vttCCs;
              f[s.cc] || (f[s.cc] = { start: s.start, prevCC: this.prevCC, new: !0 }, this.prevCC = s.cc);
              var E = this.textTracks, w = this.hls;
              Py.parse(u, this.initPTS, f, s.cc, function(A) {
                var S = E[s.trackId];
                A.forEach(function(k) {
                  if (!S.cues.getCueById(k.id))
                    try {
                      S.addCue(k);
                    } catch {
                      var B = new window.TextTrackCue(k.startTime, k.endTime, k.text);
                      B.id = k.id, S.addCue(B);
                    }
                }), w.trigger(p.a.SUBTITLE_FRAG_PROCESSED, { success: !0, frag: s });
              }, function(A) {
                d.b.log("Failed to parse VTT cue: " + A), w.trigger(p.a.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: s });
              });
            }, o.prototype.onFragDecrypted = function(s) {
              var u = s.payload, f = s.frag;
              if (f.type === "subtitle") {
                if (typeof this.initPTS > "u") {
                  this.unparsedVttFrags.push(s);
                  return;
                }
                this._parseVTTs(f, u);
              }
            }, o.prototype.onFragParsingUserdata = function(s) {
              if (this.enabled && this.config.enableCEA708Captions)
                for (var u = 0; u < s.samples.length; u++) {
                  var f = this.extractCea608Data(s.samples[u].bytes);
                  this.cea608Parser.addData(s.samples[u].pts, f);
                }
            }, o.prototype.extractCea608Data = function(s) {
              for (var u = s[0] & 31, f = 2, E, w, A, S, k, B = [], O = 0; O < u; O++)
                E = s[f++], w = 127 & s[f++], A = 127 & s[f++], S = (4 & E) !== 0, k = 3 & E, !(w === 0 && A === 0) && S && k === 0 && (B.push(w), B.push(A));
              return B;
            }, o;
          }(K), Ny = My, Vy = /* @__PURE__ */ function() {
            function g(o, l) {
              for (var s = 0; s < l.length; s++) {
                var u = l[s];
                u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(o, u.key, u);
              }
            }
            return function(o, l, s) {
              return l && g(o.prototype, l), s && g(o, s), o;
            };
          }();
          function jy(g, o) {
            if (!(g instanceof o))
              throw new TypeError("Cannot call a class as a function");
          }
          function Fy(g, o) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return o && (typeof o == "object" || typeof o == "function") ? o : g;
          }
          function $y(g, o) {
            if (typeof o != "function" && o !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof o);
            g.prototype = Object.create(o && o.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), o && (Object.setPrototypeOf ? Object.setPrototypeOf(g, o) : g.__proto__ = o);
          }
          function gd(g) {
            for (var o = [], l = 0; l < g.length; l++)
              g[l].kind === "subtitles" && o.push(g[l]);
            return o;
          }
          var Gy = function(g) {
            $y(o, g);
            function o(l) {
              jy(this, o);
              var s = Fy(this, g.call(this, l, p.a.MEDIA_ATTACHED, p.a.MEDIA_DETACHING, p.a.MANIFEST_LOADING, p.a.MANIFEST_LOADED, p.a.SUBTITLE_TRACK_LOADED));
              return s.tracks = [], s.trackId = -1, s.media = void 0, s.subtitleDisplay = !1, s;
            }
            return o.prototype._onTextTracksChanged = function() {
              if (this.media) {
                for (var s = -1, u = gd(this.media.textTracks), f = 0; f < u.length; f++)
                  u[f].mode === "showing" && (s = f);
                this.subtitleTrack = s;
              }
            }, o.prototype.destroy = function() {
              K.prototype.destroy.call(this);
            }, o.prototype.onMediaAttached = function(s) {
              var u = this;
              this.media = s.media, this.media && (this.queuedDefaultTrack !== void 0 && (this.subtitleTrack = this.queuedDefaultTrack, delete this.queuedDefaultTrack), this.trackChangeListener = this._onTextTracksChanged.bind(this), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.subtitlePollingInterval = setInterval(function() {
                u.trackChangeListener();
              }, 500) : this.media.textTracks.addEventListener("change", this.trackChangeListener));
            }, o.prototype.onMediaDetaching = function() {
              this.media && (this.useTextTrackPolling ? clearInterval(this.subtitlePollingInterval) : this.media.textTracks.removeEventListener("change", this.trackChangeListener), this.media = void 0);
            }, o.prototype.onManifestLoading = function() {
              this.tracks = [], this.trackId = -1;
            }, o.prototype.onManifestLoaded = function(s) {
              var u = this, f = s.subtitles || [];
              this.tracks = f, this.trackId = -1, this.hls.trigger(p.a.SUBTITLE_TRACKS_UPDATED, { subtitleTracks: f }), f.forEach(function(E) {
                E.default && (u.media ? u.subtitleTrack = E.id : u.queuedDefaultTrack = E.id);
              });
            }, o.prototype.onTick = function() {
              var s = this.trackId, u = this.tracks[s];
              if (u) {
                var f = u.details;
                (f === void 0 || f.live === !0) && (d.b.log("(re)loading playlist for subtitle track " + s), this.hls.trigger(p.a.SUBTITLE_TRACK_LOADING, { url: u.url, id: s }));
              }
            }, o.prototype.onSubtitleTrackLoaded = function(s) {
              var u = this;
              s.id < this.tracks.length && (d.b.log("subtitle track " + s.id + " loaded"), this.tracks[s.id].details = s.details, s.details.live && !this.timer && (this.timer = setInterval(function() {
                u.onTick();
              }, 1e3 * s.details.targetduration, this)), !s.details.live && this.timer && (clearInterval(this.timer), this.timer = null));
            }, o.prototype.setSubtitleTrackInternal = function(s) {
              if (!(s < -1 || s >= this.tracks.length)) {
                this.timer && (clearInterval(this.timer), this.timer = null);
                var u = gd(this.media.textTracks);
                if (this.trackId !== -1 && this.subtitleDisplay && (u[this.trackId].mode = "hidden"), this.trackId = s, d.b.log("switching to subtitle track " + s), this.hls.trigger(p.a.SUBTITLE_TRACK_SWITCH, { id: s }), s !== -1) {
                  var f = this.tracks[s];
                  this.subtitleDisplay && (u[s].mode = "showing");
                  var E = f.details;
                  (E === void 0 || E.live === !0) && (d.b.log("(re)loading playlist for subtitle track " + s), this.hls.trigger(p.a.SUBTITLE_TRACK_LOADING, { url: f.url, id: s }));
                }
              }
            }, Vy(o, [{
              key: "subtitleTracks",
              get: function() {
                return this.tracks;
              }
              /** get index of the selected subtitle track (index in subtitle track lists) **/
            }, {
              key: "subtitleTrack",
              get: function() {
                return this.trackId;
              },
              set: function(s) {
                this.trackId !== s && this.setSubtitleTrackInternal(s);
              }
            }]), o;
          }(K), qy = Gy, zy = a(4);
          function Xy(g, o) {
            if (!(g instanceof o))
              throw new TypeError("Cannot call a class as a function");
          }
          function Hy(g, o) {
            if (!g)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return o && (typeof o == "object" || typeof o == "function") ? o : g;
          }
          function Zy(g, o) {
            if (typeof o != "function" && o !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof o);
            g.prototype = Object.create(o && o.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), o && (Object.setPrototypeOf ? Object.setPrototypeOf(g, o) : g.__proto__ = o);
          }
          var Yr = {
            STOPPED: "STOPPED",
            IDLE: "IDLE",
            KEY_LOADING: "KEY_LOADING",
            FRAG_LOADING: "FRAG_LOADING"
          }, Wy = function(g) {
            Zy(o, g);
            function o(l) {
              Xy(this, o);
              var s = Hy(this, g.call(this, l, p.a.MEDIA_ATTACHED, p.a.ERROR, p.a.KEY_LOADED, p.a.FRAG_LOADED, p.a.SUBTITLE_TRACKS_UPDATED, p.a.SUBTITLE_TRACK_SWITCH, p.a.SUBTITLE_TRACK_LOADED, p.a.SUBTITLE_FRAG_PROCESSED));
              return s.config = l.config, s.vttFragSNsProcessed = {}, s.vttFragQueues = void 0, s.currentlyProcessing = null, s.state = Yr.STOPPED, s.currentTrackId = -1, s.ticks = 0, s.decrypter = new zy.a(l.observer, l.config), s;
            }
            return o.prototype.destroy = function() {
              K.prototype.destroy.call(this), this.state = Yr.STOPPED;
            }, o.prototype.clearVttFragQueues = function() {
              var s = this;
              this.vttFragQueues = {}, this.tracks.forEach(function(u) {
                s.vttFragQueues[u.id] = [];
              });
            }, o.prototype.nextFrag = function() {
              if (this.currentlyProcessing === null && this.currentTrackId > -1 && this.vttFragQueues[this.currentTrackId].length) {
                var s = this.currentlyProcessing = this.vttFragQueues[this.currentTrackId].shift();
                this.fragCurrent = s, this.hls.trigger(p.a.FRAG_LOADING, { frag: s }), this.state = Yr.FRAG_LOADING;
              }
            }, o.prototype.onSubtitleFragProcessed = function(s) {
              s.success && this.vttFragSNsProcessed[s.frag.trackId].push(s.frag.sn), this.currentlyProcessing = null, this.state = Yr.IDLE, this.nextFrag();
            }, o.prototype.onMediaAttached = function() {
              this.state = Yr.IDLE;
            }, o.prototype.onError = function(s) {
              var u = s.frag;
              u && u.type !== "subtitle" || this.currentlyProcessing && (this.currentlyProcessing = null, this.nextFrag());
            }, o.prototype.tick = function() {
              var s = this;
              this.ticks++, this.ticks === 1 && (this.doTick(), this.ticks > 1 && setTimeout(function() {
                s.tick();
              }, 1), this.ticks = 0);
            }, o.prototype.doTick = function() {
              var s = this;
              switch (this.state) {
                case Yr.IDLE:
                  var u = this.tracks, f = this.currentTrackId, E = this.vttFragSNsProcessed[f], w = this.vttFragQueues[f], A = this.currentlyProcessing ? this.currentlyProcessing.sn : -1, S = function($) {
                    return E.indexOf($.sn) > -1;
                  }, k = function($) {
                    return w.some(function(te) {
                      return te.sn === $.sn;
                    });
                  };
                  if (!u)
                    break;
                  var B;
                  if (f < u.length && (B = u[f].details), typeof B > "u")
                    break;
                  B.fragments.forEach(function(O) {
                    S(O) || O.sn === A || k(O) || (O.decryptdata && O.decryptdata.uri != null && O.decryptdata.key == null ? (d.b.log("Loading key for " + O.sn), s.state = Yr.KEY_LOADING, s.hls.trigger(p.a.KEY_LOADING, { frag: O })) : (O.trackId = f, w.push(O), s.nextFrag()));
                  });
              }
            }, o.prototype.onSubtitleTracksUpdated = function(s) {
              var u = this;
              d.b.log("subtitle tracks updated"), this.tracks = s.subtitleTracks, this.clearVttFragQueues(), this.vttFragSNsProcessed = {}, this.tracks.forEach(function(f) {
                u.vttFragSNsProcessed[f.id] = [];
              });
            }, o.prototype.onSubtitleTrackSwitch = function(s) {
              this.currentTrackId = s.id, this.clearVttFragQueues();
            }, o.prototype.onSubtitleTrackLoaded = function() {
              this.tick();
            }, o.prototype.onKeyLoaded = function() {
              this.state === Yr.KEY_LOADING && (this.state = Yr.IDLE, this.tick());
            }, o.prototype.onFragLoaded = function(s) {
              var u = this.fragCurrent, f = s.frag.decryptdata, E = s.frag, w = this.hls;
              if (this.state === Yr.FRAG_LOADING && u && s.frag.type === "subtitle" && u.sn === s.frag.sn && s.payload.byteLength > 0 && f != null && f.key != null && f.method === "AES-128") {
                var A;
                try {
                  A = performance.now();
                } catch {
                  A = Date.now();
                }
                this.decrypter.decrypt(s.payload, f.key.buffer, f.iv.buffer, function(S) {
                  var k;
                  try {
                    k = performance.now();
                  } catch {
                    k = Date.now();
                  }
                  w.trigger(p.a.FRAG_DECRYPTED, { frag: E, payload: S, stats: { tstart: A, tdecrypt: k } });
                });
              }
            }, o;
          }(K), Yy = Wy, xr = {
            autoStartLoad: !0,
            // used by stream-controller
            startPosition: -1,
            // used by stream-controller
            defaultAudioCodec: void 0,
            // used by stream-controller
            debug: !1,
            // used by logger
            capLevelOnFPSDrop: !1,
            // used by fps-controller
            capLevelToPlayerSize: !1,
            // used by cap-level-controller
            initialLiveManifestSize: 1,
            // used by stream-controller
            maxBufferLength: 30,
            // used by stream-controller
            maxBufferSize: 60 * 1e3 * 1e3,
            // used by stream-controller
            maxBufferHole: 0.5,
            // used by stream-controller
            maxSeekHole: 2,
            // used by stream-controller
            lowBufferWatchdogPeriod: 0.5,
            // used by stream-controller
            highBufferWatchdogPeriod: 3,
            // used by stream-controller
            nudgeOffset: 0.1,
            // used by stream-controller
            nudgeMaxRetry: 3,
            // used by stream-controller
            maxFragLookUpTolerance: 0.25,
            // used by stream-controller
            liveSyncDurationCount: 3,
            // used by stream-controller
            liveMaxLatencyDurationCount: 1 / 0,
            // used by stream-controller
            liveSyncDuration: void 0,
            // used by stream-controller
            liveMaxLatencyDuration: void 0,
            // used by stream-controller
            liveDurationInfinity: !1,
            // used by buffer-controller
            maxMaxBufferLength: 600,
            // used by stream-controller
            enableWorker: !0,
            // used by demuxer
            enableSoftwareAES: !0,
            // used by decrypter
            manifestLoadingTimeOut: 1e4,
            // used by playlist-loader
            manifestLoadingMaxRetry: 1,
            // used by playlist-loader
            manifestLoadingRetryDelay: 1e3,
            // used by playlist-loader
            manifestLoadingMaxRetryTimeout: 64e3,
            // used by playlist-loader
            startLevel: void 0,
            // used by level-controller
            levelLoadingTimeOut: 1e4,
            // used by playlist-loader
            levelLoadingMaxRetry: 4,
            // used by playlist-loader
            levelLoadingRetryDelay: 1e3,
            // used by playlist-loader
            levelLoadingMaxRetryTimeout: 64e3,
            // used by playlist-loader
            fragLoadingTimeOut: 2e4,
            // used by fragment-loader
            fragLoadingMaxRetry: 6,
            // used by fragment-loader
            fragLoadingRetryDelay: 1e3,
            // used by fragment-loader
            fragLoadingMaxRetryTimeout: 64e3,
            // used by fragment-loader
            fragLoadingLoopThreshold: 3,
            // used by stream-controller
            startFragPrefetch: !1,
            // used by stream-controller
            fpsDroppedMonitoringPeriod: 5e3,
            // used by fps-controller
            fpsDroppedMonitoringThreshold: 0.2,
            // used by fps-controller
            appendErrorMaxRetry: 3,
            // used by buffer-controller
            loader: ey,
            //loader: FetchLoader,
            fLoader: void 0,
            pLoader: void 0,
            xhrSetup: void 0,
            fetchSetup: void 0,
            abrController: kn,
            bufferController: Wr,
            capLevelController: gr,
            fpsController: Ym,
            stretchShortVideoTrack: !1,
            // used by mp4-remuxer
            maxAudioFramesDrift: 1,
            // used by mp4-remuxer
            forceKeyFrameOnDiscontinuity: !0,
            // used by ts-demuxer
            abrEwmaFastLive: 3,
            // used by abr-controller
            abrEwmaSlowLive: 9,
            // used by abr-controller
            abrEwmaFastVoD: 3,
            // used by abr-controller
            abrEwmaSlowVoD: 9,
            // used by abr-controller
            abrEwmaDefaultEstimate: 5e5,
            // 500 kbps  // used by abr-controller
            abrBandWidthFactor: 0.95,
            // used by abr-controller
            abrBandWidthUpFactor: 0.7,
            // used by abr-controller
            abrMaxWithRealBitrate: !1,
            // used by abr-controller
            maxStarvationDelay: 4,
            // used by abr-controller
            maxLoadingDelay: 4,
            // used by abr-controller
            minAutoBitrate: 0
            // used by hls
          };
          xr.subtitleStreamController = Yy, xr.subtitleTrackController = qy, xr.timelineController = Ny, xr.cueHandler = c, xr.enableCEA708Captions = !0, xr.enableWebVTT = !0, xr.captionsTextTrack1Label = "English", xr.captionsTextTrack1LanguageCode = "en", xr.captionsTextTrack2Label = "Spanish", xr.captionsTextTrack2LanguageCode = "es", xr.audioStreamController = fy, xr.audioTrackController = ay;
          var xd = /* @__PURE__ */ function() {
            function g(o, l) {
              for (var s = 0; s < l.length; s++) {
                var u = l[s];
                u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(o, u.key, u);
              }
            }
            return function(o, l, s) {
              return l && g(o.prototype, l), s && g(o, s), o;
            };
          }();
          function Jy(g, o) {
            if (!(g instanceof o))
              throw new TypeError("Cannot call a class as a function");
          }
          var Qy = function() {
            g.isSupported = function() {
              return zt();
            }, xd(g, null, [{
              key: "version",
              get: function() {
                return "0.8.9";
              }
            }, {
              key: "Events",
              get: function() {
                return p.a;
              }
            }, {
              key: "ErrorTypes",
              get: function() {
                return b.b;
              }
            }, {
              key: "ErrorDetails",
              get: function() {
                return b.a;
              }
            }, {
              key: "DefaultConfig",
              get: function() {
                return g.defaultConfig ? g.defaultConfig : xr;
              },
              set: function(l) {
                g.defaultConfig = l;
              }
            }]);
            function g() {
              var o = this, l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              Jy(this, g);
              var s = g.DefaultConfig;
              if ((l.liveSyncDurationCount || l.liveMaxLatencyDurationCount) && (l.liveSyncDuration || l.liveMaxLatencyDuration))
                throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
              for (var u in s)
                u in l || (l[u] = s[u]);
              if (l.liveMaxLatencyDurationCount !== void 0 && l.liveMaxLatencyDurationCount <= l.liveSyncDurationCount)
                throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');
              if (l.liveMaxLatencyDuration !== void 0 && (l.liveMaxLatencyDuration <= l.liveSyncDuration || l.liveSyncDuration === void 0))
                throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');
              Object(d.a)(l.debug), this.config = l, this._autoLevelCapping = -1;
              var f = this.observer = new rr.a();
              f.trigger = function(ft) {
                for (var _e = arguments.length, Bt = Array(_e > 1 ? _e - 1 : 0), at = 1; at < _e; at++)
                  Bt[at - 1] = arguments[at];
                f.emit.apply(f, [ft, ft].concat(Bt));
              }, f.off = function(ft) {
                for (var _e = arguments.length, Bt = Array(_e > 1 ? _e - 1 : 0), at = 1; at < _e; at++)
                  Bt[at - 1] = arguments[at];
                f.removeListener.apply(f, [ft].concat(Bt));
              }, this.on = f.on.bind(f), this.off = f.off.bind(f), this.trigger = f.trigger.bind(f);
              var E = this.abrController = new l.abrController(this), w = new l.bufferController(this), A = new l.capLevelController(this), S = new l.fpsController(this), k = new Rt(this), B = new ct(this), O = new pr(this), $ = new br(this), te = this.levelController = new At(this), pe = this.streamController = new et(this), be = [te, pe], ye = l.audioStreamController;
              ye && be.push(new ye(this)), this.networkControllers = be;
              var Se = [k, B, O, E, w, A, S, $];
              if (ye = l.audioTrackController, ye) {
                var Ce = new ye(this);
                this.audioTrackController = Ce, Se.push(Ce);
              }
              if (ye = l.subtitleTrackController, ye) {
                var Be = new ye(this);
                this.subtitleTrackController = Be, Se.push(Be);
              }
              [l.subtitleStreamController, l.timelineController].forEach(function(He) {
                He && Se.push(new He(o));
              }), this.coreComponents = Se;
            }
            return g.prototype.destroy = function() {
              d.b.log("destroy"), this.trigger(p.a.DESTROYING), this.detachMedia(), this.coreComponents.concat(this.networkControllers).forEach(function(l) {
                l.destroy();
              }), this.url = null, this.observer.removeAllListeners(), this._autoLevelCapping = -1;
            }, g.prototype.attachMedia = function(l) {
              d.b.log("attachMedia"), this.media = l, this.trigger(p.a.MEDIA_ATTACHING, { media: l });
            }, g.prototype.detachMedia = function() {
              d.b.log("detachMedia"), this.trigger(p.a.MEDIA_DETACHING), this.media = null;
            }, g.prototype.loadSource = function(l) {
              l = m.a.buildAbsoluteURL(window.location.href, l, { alwaysNormalize: !0 }), d.b.log("loadSource:" + l), this.url = l, this.trigger(p.a.MANIFEST_LOADING, { url: l });
            }, g.prototype.startLoad = function() {
              var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
              d.b.log("startLoad(" + l + ")"), this.networkControllers.forEach(function(s) {
                s.startLoad(l);
              });
            }, g.prototype.stopLoad = function() {
              d.b.log("stopLoad"), this.networkControllers.forEach(function(l) {
                l.stopLoad();
              });
            }, g.prototype.swapAudioCodec = function() {
              d.b.log("swapAudioCodec"), this.streamController.swapAudioCodec();
            }, g.prototype.recoverMediaError = function() {
              d.b.log("recoverMediaError");
              var l = this.media;
              this.detachMedia(), this.attachMedia(l);
            }, xd(g, [{
              key: "levels",
              get: function() {
                return this.levelController.levels;
              }
              /** Return current playback quality level **/
            }, {
              key: "currentLevel",
              get: function() {
                return this.streamController.currentLevel;
              },
              set: function(l) {
                d.b.log("set currentLevel:" + l), this.loadLevel = l, this.streamController.immediateLevelSwitch();
              }
              /** Return next playback quality level (quality level of next fragment) **/
            }, {
              key: "nextLevel",
              get: function() {
                return this.streamController.nextLevel;
              },
              set: function(l) {
                d.b.log("set nextLevel:" + l), this.levelController.manualLevel = l, this.streamController.nextLevelSwitch();
              }
              /** Return the quality level of current/last loaded fragment **/
            }, {
              key: "loadLevel",
              get: function() {
                return this.levelController.level;
              },
              set: function(l) {
                d.b.log("set loadLevel:" + l), this.levelController.manualLevel = l;
              }
              /** Return the quality level of next loaded fragment **/
            }, {
              key: "nextLoadLevel",
              get: function() {
                return this.levelController.nextLoadLevel;
              },
              set: function(l) {
                this.levelController.nextLoadLevel = l;
              }
              /** Return first level (index of first level referenced in manifest)
              **/
            }, {
              key: "firstLevel",
              get: function() {
                return Math.max(this.levelController.firstLevel, this.minAutoLevel);
              },
              set: function(l) {
                d.b.log("set firstLevel:" + l), this.levelController.firstLevel = l;
              }
              /** Return start level (level of first fragment that will be played back)
                  if not overrided by user, first level appearing in manifest will be used as start level
                  if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
              **/
            }, {
              key: "startLevel",
              get: function() {
                return this.levelController.startLevel;
              },
              set: function(l) {
                d.b.log("set startLevel:" + l);
                var s = this;
                l !== -1 && (l = Math.max(l, s.minAutoLevel)), s.levelController.startLevel = l;
              }
              /** Return the capping/max level value that could be used by automatic level selection algorithm **/
            }, {
              key: "autoLevelCapping",
              get: function() {
                return this._autoLevelCapping;
              },
              set: function(l) {
                d.b.log("set autoLevelCapping:" + l), this._autoLevelCapping = l;
              }
              /* check if we are in automatic level selection mode */
            }, {
              key: "autoLevelEnabled",
              get: function() {
                return this.levelController.manualLevel === -1;
              }
              /* return manual level */
            }, {
              key: "manualLevel",
              get: function() {
                return this.levelController.manualLevel;
              }
              /* return min level selectable in auto mode according to config.minAutoBitrate */
            }, {
              key: "minAutoLevel",
              get: function() {
                for (var l = this, s = l.levels, u = l.config.minAutoBitrate, f = s ? s.length : 0, E = 0; E < f; E++) {
                  var w = s[E].realBitrate ? Math.max(s[E].realBitrate, s[E].bitrate) : s[E].bitrate;
                  if (w > u)
                    return E;
                }
                return 0;
              }
              /* return max level selectable in auto mode according to autoLevelCapping */
            }, {
              key: "maxAutoLevel",
              get: function() {
                var l = this, s = l.levels, u = l.autoLevelCapping, f = void 0;
                return u === -1 && s && s.length ? f = s.length - 1 : f = u, f;
              }
              // return next auto level
            }, {
              key: "nextAutoLevel",
              get: function() {
                var l = this;
                return Math.min(Math.max(l.abrController.nextAutoLevel, l.minAutoLevel), l.maxAutoLevel);
              },
              set: function(l) {
                var s = this;
                s.abrController.nextAutoLevel = Math.max(s.minAutoLevel, l);
              }
              /** get alternate audio tracks list from playlist **/
            }, {
              key: "audioTracks",
              get: function() {
                var l = this.audioTrackController;
                return l ? l.audioTracks : [];
              }
              /** get index of the selected audio track (index in audio track lists) **/
            }, {
              key: "audioTrack",
              get: function() {
                var l = this.audioTrackController;
                return l ? l.audioTrack : -1;
              },
              set: function(l) {
                var s = this.audioTrackController;
                s && (s.audioTrack = l);
              }
            }, {
              key: "liveSyncPosition",
              get: function() {
                return this.streamController.liveSyncPosition;
              }
              /** get alternate subtitle tracks list from playlist **/
            }, {
              key: "subtitleTracks",
              get: function() {
                var l = this.subtitleTrackController;
                return l ? l.subtitleTracks : [];
              }
              /** get index of the selected subtitle track (index in subtitle track lists) **/
            }, {
              key: "subtitleTrack",
              get: function() {
                var l = this.subtitleTrackController;
                return l ? l.subtitleTrack : -1;
              },
              set: function(l) {
                var s = this.subtitleTrackController;
                s && (s.subtitleTrack = l);
              }
            }, {
              key: "subtitleDisplay",
              get: function() {
                var l = this.subtitleTrackController;
                return l ? l.subtitleDisplay : !1;
              },
              set: function(l) {
                var s = this.subtitleTrackController;
                s && (s.subtitleDisplay = l);
              }
            }]), g;
          }();
          i.default = Qy;
        },
        /* 9 */
        /***/
        function(r, i, a) {
          function c(b) {
            var d = {};
            function v(M) {
              if (d[M])
                return d[M].exports;
              var K = d[M] = {
                /******/
                i: M,
                /******/
                l: !1,
                /******/
                exports: {}
                /******/
              };
              return b[M].call(K.exports, K, K.exports, v), K.l = !0, K.exports;
            }
            v.m = b, v.c = d, v.i = function(M) {
              return M;
            }, v.d = function(M, K, W) {
              v.o(M, K) || Object.defineProperty(M, K, {
                /******/
                configurable: !1,
                /******/
                enumerable: !0,
                /******/
                get: W
                /******/
              });
            }, v.n = function(M) {
              var K = M && M.__esModule ? (
                /******/
                function() {
                  return M.default;
                }
              ) : (
                /******/
                function() {
                  return M;
                }
              );
              return v.d(K, "a", K), K;
            }, v.o = function(M, K) {
              return Object.prototype.hasOwnProperty.call(M, K);
            }, v.p = "/", v.oe = function(M) {
              throw console.error(M), M;
            };
            var P = v(v.s = ENTRY_MODULE);
            return P.default || P;
          }
          function h(b) {
            return (b + "").replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
          }
          function m(b) {
            var d = [], v = b.toString(), P = v.match(/^function\s?\(\w+,\s*\w+,\s*(\w+)\)/);
            if (!P) return d;
            for (var M = P[1], K = new RegExp("(\\\\n|\\W)" + h(M) + "\\((/\\*.*?\\*/)?s?.*?([\\.|\\-|\\w|/|@]+).*?\\)", "g"), W; W = K.exec(v); )
              d.push(W[3]);
            return d;
          }
          function p(b, d) {
            for (var v = [d], P = [], M = {}; v.length; ) {
              var K = v.pop();
              if (!(M[K] || !b[K])) {
                M[K] = !0, P.push(K);
                var W = m(b[K]);
                v = v.concat(W);
              }
            }
            return P;
          }
          r.exports = function(b, d) {
            d = d || {};
            var v = a.m, P = d.all ? Object.keys(v) : p(v, b), M = "(" + c.toString().replace("ENTRY_MODULE", JSON.stringify(b)) + ")({" + P.map(function(U) {
              return "" + JSON.stringify(U) + ": " + v[U].toString();
            }).join(",") + "})(self);", K = new window.Blob([M], { type: "text/javascript" });
            if (d.bare)
              return K;
            var W = window.URL || window.webkitURL || window.mozURL || window.msURL, J = W.createObjectURL(K), z = new window.Worker(J);
            return z.objectURL = J, z;
          };
        },
        /* 10 */
        /***/
        function(r, i, a) {
          Object.defineProperty(i, "__esModule", { value: !0 });
          var c = a(7), h = a(1), m = a(0), p = a(5), b = a.n(p), d = function(P) {
            var M = new b.a();
            M.trigger = function(J) {
              for (var z = arguments.length, U = Array(z > 1 ? z - 1 : 0), F = 1; F < z; F++)
                U[F - 1] = arguments[F];
              M.emit.apply(M, [J, J].concat(U));
            }, M.off = function(J) {
              for (var z = arguments.length, U = Array(z > 1 ? z - 1 : 0), F = 1; F < z; F++)
                U[F - 1] = arguments[F];
              M.removeListener.apply(M, [J].concat(U));
            };
            var K = function(J, z) {
              P.postMessage({ event: J, data: z });
            };
            P.addEventListener("message", function(W) {
              var J = W.data;
              switch (J.cmd) {
                case "init":
                  var z = JSON.parse(J.config);
                  P.demuxer = new c.a(M, J.typeSupported, z, J.vendor);
                  try {
                    Object(m.a)(z.debug === !0);
                  } catch {
                    console.warn("demuxerWorker: unable to enable logs");
                  }
                  K("init", null);
                  break;
                case "demux":
                  P.demuxer.push(J.data, J.decryptdata, J.initSegment, J.audioCodec, J.videoCodec, J.timeOffset, J.discontinuity, J.trackSwitch, J.contiguous, J.duration, J.accurateTimeOffset, J.defaultInitPTS);
                  break;
              }
            }), M.on(h.a.FRAG_DECRYPTED, K), M.on(h.a.FRAG_PARSING_INIT_SEGMENT, K), M.on(h.a.FRAG_PARSED, K), M.on(h.a.ERROR, K), M.on(h.a.FRAG_PARSING_METADATA, K), M.on(h.a.FRAG_PARSING_USERDATA, K), M.on(h.a.INIT_PTS_FOUND, K), M.on(h.a.FRAG_PARSING_DATA, function(W, J) {
              var z = [], U = { event: W, data: J };
              J.data1 && (U.data1 = J.data1.buffer, z.push(J.data1.buffer), delete J.data1), J.data2 && (U.data2 = J.data2.buffer, z.push(J.data2.buffer), delete J.data2), P.postMessage(U, z);
            });
          };
          i.default = d;
        }
        /******/
      ]).default
    );
  });
})(Xm);
var mK = Xm.exports;
const Ec = /* @__PURE__ */ Lb(mK), Hm = ({
  post: t,
  reason: e,
  isRoot: r
}) => {
  if (t.$type === "app.bsky.graph.defs#listView")
    return {
      username: t.creator.displayName,
      handle: t.creator.handle,
      avatar: t.creator.avatar,
      text: [{
        val: t.description,
        setInnerHtml: !1
      }],
      createdAt: t.indexedAt,
      uri: t.uri,
      images: [],
      card: null,
      replyPost: null,
      isRepost: !1,
      repostBy: null
    };
  const i = t.record.facets || [], a = t.record.text, c = new Bc.RichText({
    text: a,
    facets: i
  }), h = [];
  for (const d of c.segments())
    d.isLink() ? h.push({
      val: `<a href="${d.link?.uri}" target="_blank" rel="noopener" class="text-blue-500 underline">${d.text}</a>`,
      setInnerHtml: !0
    }) : d.isMention() ? h.push({
      val: `<a href="https://bsky.app/profile/${d.mention?.did}" target="_blank" rel="noopener" class="text-blue-500 underline">${d.text}</a>`,
      setInnerHtml: !0
    }) : d.isTag() ? h.push({
      val: `<a href="https://bsky.app/hashtag/${d.tag?.tag}" target="_blank" rel="noopener" class="text-blue-500 underline">${d.text}</a>`,
      setInnerHtml: !0
    }) : h.push({
      val: d.text,
      setInnerHtml: !1
    });
  const m = t.embed?.$type === "app.bsky.embed.record#view" ? t.embed.record : t.embed?.record?.record?.$type === "app.bsky.embed.record#viewRecord" && t.embed.record.record, p = m && {
    ...m,
    record: m.value || m.record,
    embed: (m?.embeds || [])[0]
  }, b = t.author || t.creator;
  return {
    username: b.displayName,
    handle: b.handle,
    avatar: b.avatar,
    // todo fallback
    text: h,
    createdAt: t.record.createdAt,
    uri: t.uri,
    images: [...t.embed?.images || [], ...t.embed?.media?.images || [], ...[t.embed?.media?.external].filter(Boolean).map((d) => ({
      ...d,
      alt: d.title,
      thumb: d.uri
    }))],
    video: t.embed?.$type === "app.bsky.embed.video#view" && t.embed,
    card: t.embed?.$type === "app.bsky.embed.external#view" && t.embed?.external,
    replyPost: r && p && Hm({
      post: p,
      reason: {
        $type: "",
        by: {
          displayName: ""
        }
      },
      isRoot: !1
    }),
    isRepost: e?.$type === "app.bsky.feed.defs#reasonRepost",
    repostBy: e?.by?.displayName
  };
}, vc = (t) => (t.feed || []).map((e) => Hm({
  ...e,
  isRoot: !0
})), Df = (t) => {
  const e = t.lastIndexOf("/");
  return e !== -1 ? t.substring(e + 1) : t;
}, yK = (t) => {
  const e = /* @__PURE__ */ new Date(), r = 60 * 1e3, i = r * 60, a = i * 24, c = a * 30, h = a * 365, m = e.getTime() - t.getTime();
  return m < r ? Math.floor(m / 1e3) + "s" : m < i ? Math.floor(m / r) + "m" : m < a ? Math.floor(m / i) + "h" : m < c ? Math.floor(m / a) + "d" : m < h ? Math.floor(m / c) + " mo" : Math.floor(m / h) + " yr";
}, bK = async (t, e) => {
  if (!("IntersectionObserver" in window)) {
    console.error("IntersectionObserver not supported");
    return;
  }
  if (!e) {
    console.error("Video element not found");
    return;
  }
  const r = {
    root: null,
    // Viewport is the root by default
    threshold: 0.5
    // 50% of the video must be visible to trigger playback
  }, i = async (c, h) => {
    c.forEach((m) => {
      if (m.isIntersecting) {
        if (Ec.isSupported()) {
          var p = new Ec();
          p.loadSource(t.playlist), p.attachMedia(e), p.on(Ec.Events.MANIFEST_PARSED, () => {
            e.play();
          });
        } else e.canPlayType("application/vnd.apple.mpegurl") && (e.src = t.playlist, e.addEventListener("loadedmetadata", () => {
          e.play();
        }));
        h.unobserve(e);
      }
    });
  };
  new IntersectionObserver(i, r).observe(e);
};
var gK = /* @__PURE__ */ tr('<article class="p-4 border-b border-slate-300 dark:border-slate-800"><div class="flex gap-2"><div class=w-full><div class="flex max-w-[calc(100vw-96px)] items-center"><a class="text-ellipsis overflow-hidden whitespace-nowrap hover:underline dark:text-white"><span class="font-bold dark:text-white"></span><span> </span><span class="text-slate-500 dark:text-slate-400 text-sm">@</span></a><span class="text-slate-500 dark:text-slate-400 text-sm"><span class=mx-1></span><a class=hover:underline></a></span></div><p class="whitespace-pre-wrap dark:text-white">'), xK = /* @__PURE__ */ tr('<p class="flex gap-1 items-center ml-10 text-slate-600 dark:text-slate-400"><svg viewBox="0 0 576 512"height=16 width=16 tabindex=-1 class=mr-1><path fill=currentColor d="M272 416c17.7 0 32-14.3 32-32s-14.3-32-32-32H160c-17.7 0-32-14.3-32-32V192h32c12.9 0 24.6-7.8 29.6-19.8s2.2-25.7-6.9-34.9l-64-64c-12.5-12.5-32.8-12.5-45.3 0l-64 64c-9.2 9.2-11.9 22.9-6.9 34.9s16.6 19.8 29.6 19.8l32 0 0 128c0 53 43 96 96 96H272zM304 96c-17.7 0-32 14.3-32 32s14.3 32 32 32l112 0c17.7 0 32 14.3 32 32l0 128H416c-12.9 0-24.6 7.8-29.6 19.8s-2.2 25.7 6.9 34.9l64 64c12.5 12.5 32.8 12.5 45.3 0l64-64c9.2-9.2 11.9-22.9 6.9-34.9s-16.6-19.8-29.6-19.8l-32 0V192c0-53-43-96-96-96L304 96z"></path></svg><span class="text-sm text-slate-500 font-semibold">Reposted by '), EK = /* @__PURE__ */ tr('<img alt="profile picture"class="w-14 h-14 rounded-full">'), vK = /* @__PURE__ */ tr('<img alt="profile picture"class="w-4 h-4 mr-1 rounded-full">'), Pf = /* @__PURE__ */ tr("<span>"), RK = /* @__PURE__ */ tr("<div>"), AK = /* @__PURE__ */ tr("<a><img class=rounded-md>"), _K = /* @__PURE__ */ tr('<div class="mt-4 w-full"><video width=100% class="rounded-md w-full h-full object-cover"preload=none>'), wK = /* @__PURE__ */ tr('<a target=_blank rel=noopener class="mt-4 rounded-md border border-slate-300 block"><div class=p-3><p class="text-slate-500 dark:text-slate-400 text-sm"></p><p class="font-bold dark:text-white mb-1"></p><p class="whitespace-pre-wrap dark:text-white">'), TK = /* @__PURE__ */ tr('<img class=rounded-t-md alt="Post Thumbnail">'), SK = /* @__PURE__ */ tr('<a target=_blank rel=noopener class="mt-4 rounded-md border border-slate-300 block">');
const Zm = ({
  linkTarget: t = "_self",
  post: e,
  handleModalContent: r,
  isCard: i = !1,
  dateFormat: a
}) => {
  let c;
  return hb(() => {
    e.video && e.video.cid && bK(e.video, c);
  }), (() => {
    var h = gK(), m = h.firstChild, p = m.firstChild, b = p.firstChild, d = b.firstChild, v = d.firstChild, P = v.nextSibling, M = P.nextSibling;
    M.firstChild;
    var K = d.nextSibling, W = K.firstChild, J = W.nextSibling, z = b.nextSibling;
    return it(h, (() => {
      var U = Kr(() => !!e.isRepost);
      return () => U() && (() => {
        var F = xK(), Z = F.firstChild, de = Z.nextSibling;
        return de.firstChild, it(de, () => e.repostBy, null), F;
      })();
    })(), m), it(m, !i && (() => {
      var U = EK();
      return Er(() => It(U, "src", e.avatar)), U;
    })(), p), it(b, i && (() => {
      var U = vK();
      return Er(() => It(U, "src", e.avatar)), U;
    })(), d), It(d, "target", t), It(d, "rel", t === "_blank" ? "noopeener" : ""), it(v, () => e.username), it(M, () => e.handle, null), It(J, "target", t), It(J, "rel", t === "_blank" ? "noopeener" : ""), it(J, (() => {
      var U = Kr(() => !!(a && a.type === "absolute"));
      return () => U() ? new Date(e.createdAt).toLocaleDateString(a.locale, a.options) : yK(new Date(e.createdAt));
    })()), it(z, () => e.text.map((U) => U.setInnerHtml ? (() => {
      var F = Pf();
      return Er(() => F.innerHTML = U.val), F;
    })() : (() => {
      var F = Pf();
      return it(F, () => U.val), F;
    })())), it(p, (() => {
      var U = Kr(() => e.images.length > 0);
      return () => U() && (() => {
        var F = RK();
        return it(F, () => e.images.map((Z) => (() => {
          var de = AK(), xe = de.firstChild;
          return de.$$click = (ge) => r(ge, Z), It(de, "target", t), It(de, "rel", t === "_blank" ? "noopeener" : ""), Er((ge) => {
            var me = `https://bsky.app/profile/${e.handle}/post/${Df(e.uri)}`, Ee = Z.thumb, De = Z.alt;
            return me !== ge.e && It(de, "href", ge.e = me), Ee !== ge.t && It(xe, "src", ge.t = Ee), De !== ge.a && It(xe, "alt", ge.a = De), ge;
          }, {
            e: void 0,
            t: void 0,
            a: void 0
          }), de;
        })())), Er(() => zf(F, e.images.length > 1 ? "mt-4 grid grid-cols-2 gap-2" : "mt-4")), F;
      })();
    })(), null), it(p, (() => {
      var U = Kr(() => !!e.video);
      return () => U() && (() => {
        var F = _K(), Z = F.firstChild, de = c;
        return typeof de == "function" ? Ac(de, Z) : c = Z, Z.autoplay = !1, Z.controls = !0, Z.muted = !0, Er(() => It(Z, "poster", e.video.thumbnail)), F;
      })();
    })(), null), it(p, (() => {
      var U = Kr(() => !!e.card);
      return () => U() && (() => {
        var F = wK(), Z = F.firstChild, de = Z.firstChild, xe = de.nextSibling, ge = xe.nextSibling;
        return it(F, (() => {
          var me = Kr(() => !!e.card.thumb);
          return () => me() && (() => {
            var Ee = TK();
            return Er(() => It(Ee, "src", e.card.thumb)), Ee;
          })();
        })(), Z), it(de, () => new URL(e.card.uri).hostname), it(xe, () => e.card.title), it(ge, () => e.card.description), Er(() => It(F, "href", e.card.uri)), F;
      })();
    })(), null), it(p, (() => {
      var U = Kr(() => !!e.replyPost);
      return () => U() && (() => {
        var F = SK();
        return it(F, Gf(Zm, vb({
          linkTarget: t,
          handleModalContent: r
        }, {
          get post() {
            return e.replyPost;
          },
          isCard: !0
        }))), Er(() => It(F, "href", e.card.uri)), F;
      })();
    })(), null), Er((U) => {
      var F = `https://bsky.app/profile/${e.handle}`, Z = `https://bsky.app/profile/${e.handle}/post/${Df(e.uri)}`;
      return F !== U.e && It(d, "href", U.e = F), Z !== U.t && It(J, "href", U.t = Z), U;
    }, {
      e: void 0,
      t: void 0
    }), h;
  })();
};
qf(["click"]);
var CK = /* @__PURE__ */ tr('<section><dialog class="backdrop:bg-gray-800 backdrop:opacity-90"><form class="fixed top-5 right-5"><button type=submit aria-label=close formmethod=dialog formnovalidate class="bg-gray-900 rounded-full w-10 h-10 text-white flex items-center justify-center">X</button></form><img src=""alt=""class=max-h-[90vh]>'), Bf = /* @__PURE__ */ tr("<style>"), LK = /* @__PURE__ */ tr("<div class=w-full>"), kK = /* @__PURE__ */ tr('<article class="w-full flex gap-2 p-4 border-b border-slate-300 dark:border-slate-800 animate-pulse"><div class="bg-slate-200 w-14 h-14 rounded-full dark:bg-slate-800"></div><div class="flex-1 space-y-2 py-1"><div class="grid grid-cols-4 gap-4"><div class="h-2 bg-slate-200 rounded col-span-2 dark:bg-slate-800"></div></div><div class="h-2 bg-slate-200 rounded dark:bg-slate-800"></div><div class="h-2 bg-slate-200 rounded dark:bg-slate-800"></div><div class="h-2 bg-slate-200 rounded dark:bg-slate-800">'), DK = /* @__PURE__ */ tr('<div class="mt-8 mb-16"><button id=bsky-load-more class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Load More Posts');
const PK = ({
  username: t,
  feed: e,
  limit: r = 10,
  mode: i = "",
  linkTarget: a = "_self",
  linkImage: c = !1,
  customStyles: h = "",
  disableStyles: m = !1,
  search: p,
  loadMore: b = !1,
  dateFormat: d
}) => {
  let v = null, P = null;
  const [M, K] = ia(!1), [W, J] = ia([]), [z] = ia(r), [U, F] = ia(void 0);
  Mf(() => {
    K(!0), Z();
  }, [t, e, p, z]);
  const Z = async (me) => {
    t ? xc.app.bsky.feed.getAuthorFeed({
      limit: z(),
      actor: t,
      filter: "posts_no_replies",
      cursor: me
    }).then(({
      success: Ee,
      data: De
    }) => {
      if (Ee) {
        const Ke = vc(De);
        ge(Ke), K(!1), F(De.cursor);
      }
    }) : e ? xc.app.bsky.feed.getFeed({
      limit: z(),
      feed: e,
      cursor: me
    }).then(({
      success: Ee,
      data: De
    }) => {
      if (Ee) {
        const Ke = vc(De);
        ge(Ke), K(!1), F(De.cursor);
      }
    }) : p && xc.app.bsky.feed.searchPosts({
      limit: z(),
      q: p,
      cursor: me
    }).then(({
      success: Ee,
      data: De
    }) => {
      if (Ee) {
        const Ke = {
          ...De,
          feed: De.posts.map((Je) => ({
            post: Je
          }))
        }, Ge = vc(Ke);
        ge(Ge), K(!1), F(De.cursor);
      }
    });
  }, de = (me, Ee) => {
    !c && v && P && (me.preventDefault(), P.src = Ee.fullsize, P.alt = Ee.alt, v.showModal());
  }, xe = () => {
    K(!0), Z(U());
  }, ge = (me) => {
    const Ee = [...W(), ...me];
    J(Ee);
  };
  return [!m && (() => {
    var me = Bf();
    return it(me, Cb), me;
  })(), h && (() => {
    var me = Bf();
    return it(me, h), me;
  })(), (() => {
    var me = CK(), Ee = me.firstChild, De = Ee.firstChild, Ke = De.nextSibling;
    return zf(me, `${i} max-w-screen-sm mx-auto flex flex-col items-center`), it(me, (() => {
      var Ge = Kr(() => W().length > 0);
      return () => Ge() && W().map((Je, Qe) => (() => {
        var Et = LK();
        return It(Et, "id", `post-${Qe}`), it(Et, Gf(Zm, {
          post: Je,
          handleModalContent: de,
          linkTarget: a,
          dateFormat: d
        })), Et;
      })());
    })(), Ee), it(me, (() => {
      var Ge = Kr(() => !!M());
      return () => Ge() && Array.from(Array(r)).map(() => kK());
    })(), Ee), Ac((Ge) => v = Ge, Ee), Ac((Ge) => P = Ge, Ke), it(me, (() => {
      var Ge = Kr(() => !!(b && U()));
      return () => Ge() && (() => {
        var Je = DK(), Qe = Je.firstChild;
        return Qe.$$click = xe, Je;
      })();
    })(), null), me;
  })()];
};
qf(["click"]);
Sb("bsky-embed", {
  username: "",
  feed: "",
  limit: 10,
  mode: "",
  linkTarget: "_self",
  linkImage: !1,
  customStyles: "",
  disableStyles: !1,
  search: "",
  loadMore: !1,
  dateFormat: {}
}, PK);
