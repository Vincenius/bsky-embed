function Ch(t) {
  return Object.keys(t).reduce((r, a) => {
    const u = t[a];
    return r[a] = Object.assign({}, u), Pf(u.value) && !Ih(u.value) && !Array.isArray(u.value) && (r[a].value = Object.assign({}, u.value)), Array.isArray(u.value) && (r[a].value = u.value.slice(0)), r;
  }, {});
}
function Dh(t) {
  return t ? Object.keys(t).reduce((r, a) => {
    const u = t[a];
    return r[a] = Pf(u) && "value" in u ? u : {
      value: u
    }, r[a].attribute || (r[a].attribute = Bh(a)), r[a].parse = "parse" in r[a] ? r[a].parse : typeof r[a].value != "string", r;
  }, {}) : {};
}
function kh(t) {
  return Object.keys(t).reduce((r, a) => (r[a] = t[a].value, r), {});
}
function Ph(t, e) {
  const r = Ch(e);
  return Object.keys(e).forEach((u) => {
    const x = r[u], y = t.getAttribute(x.attribute), p = t[u];
    y && (x.value = x.parse ? kf(y) : y), p != null && (x.value = Array.isArray(p) ? p.slice(0) : p), x.reflect && Au(t, x.attribute, x.value), Object.defineProperty(t, u, {
      get() {
        return x.value;
      },
      set(h) {
        const m = x.value;
        x.value = h, x.reflect && Au(this, x.attribute, x.value);
        for (let d = 0, T = this.__propertyChangedCallbacks.length; d < T; d++)
          this.__propertyChangedCallbacks[d](u, h, m);
      },
      enumerable: !0,
      configurable: !0
    });
  }), r;
}
function kf(t) {
  if (t)
    try {
      return JSON.parse(t);
    } catch {
      return t;
    }
}
function Au(t, e, r) {
  if (r == null || r === !1) return t.removeAttribute(e);
  let a = JSON.stringify(r);
  t.__updating[e] = !0, a === "true" && (a = ""), t.setAttribute(e, a), Promise.resolve().then(() => delete t.__updating[e]);
}
function Bh(t) {
  return t.replace(/\.?([A-Z]+)/g, (e, r) => "-" + r.toLowerCase()).replace("_", "-").replace(/^-/, "");
}
function Pf(t) {
  return t != null && (typeof t == "object" || typeof t == "function");
}
function Ih(t) {
  return Object.prototype.toString.call(t) === "[object Function]";
}
function Uh(t) {
  return typeof t == "function" && t.toString().indexOf("class") === 0;
}
let xl;
function Oh(t, e) {
  const r = Object.keys(e);
  return class extends t {
    static get observedAttributes() {
      return r.map((u) => e[u].attribute);
    }
    constructor() {
      super(), this.__initialized = !1, this.__released = !1, this.__releaseCallbacks = [], this.__propertyChangedCallbacks = [], this.__updating = {}, this.props = {};
    }
    connectedCallback() {
      if (this.__initialized) return;
      this.__releaseCallbacks = [], this.__propertyChangedCallbacks = [], this.__updating = {}, this.props = Ph(this, e);
      const u = kh(this.props), x = this.Component, y = xl;
      try {
        xl = this, this.__initialized = !0, Uh(x) ? new x(u, {
          element: this
        }) : x(u, {
          element: this
        });
      } finally {
        xl = y;
      }
    }
    async disconnectedCallback() {
      if (await Promise.resolve(), this.isConnected) return;
      this.__propertyChangedCallbacks.length = 0;
      let u = null;
      for (; u = this.__releaseCallbacks.pop(); ) u(this);
      delete this.__initialized, this.__released = !0;
    }
    attributeChangedCallback(u, x, y) {
      if (this.__initialized && !this.__updating[u] && (u = this.lookupProp(u), u in e)) {
        if (y == null && !this[u]) return;
        this[u] = e[u].parse ? kf(y) : y;
      }
    }
    lookupProp(u) {
      if (e)
        return r.find((x) => u === x || u === e[x].attribute);
    }
    get renderRoot() {
      return this.shadowRoot || this.attachShadow({
        mode: "open"
      });
    }
    addReleaseCallback(u) {
      this.__releaseCallbacks.push(u);
    }
    addPropertyChangedCallback(u) {
      this.__propertyChangedCallbacks.push(u);
    }
  };
}
function Kh(t, e = {}, r = {}) {
  const {
    BaseElement: a = HTMLElement,
    extension: u
  } = r;
  return (x) => {
    let y = customElements.get(t);
    return y ? (y.prototype.Component = x, y) : (y = Oh(a, Dh(e)), y.prototype.Component = x, y.prototype.registeredTag = t, customElements.define(t, y, u), y);
  };
}
const Nh = (t, e) => t === e, kl = Symbol("solid-proxy"), Co = {
  equals: Nh
};
let Bf = Nf;
const Yi = 1, Do = 2, If = {
  owned: null,
  cleanups: null,
  context: null,
  owner: null
};
var dr = null;
let El = null, Vh = null, Bt = null, lr = null, Ai = null, Go = 0;
function Mh(t, e) {
  const r = Bt, a = dr, u = t.length === 0, x = e === void 0 ? a : e, y = u ? If : {
    owned: null,
    cleanups: null,
    context: x ? x.context : null,
    owner: x
  }, p = u ? t : () => t(() => ba(() => qo(y)));
  dr = y, Bt = null;
  try {
    return Ea(p, !0);
  } finally {
    Bt = r, dr = a;
  }
}
function pa(t, e) {
  e = e ? Object.assign({}, Co, e) : Co;
  const r = {
    value: t,
    observers: null,
    observerSlots: null,
    comparator: e.equals || void 0
  }, a = (u) => (typeof u == "function" && (u = u(r.value)), Kf(r, u));
  return [Of.bind(r), a];
}
function wr(t, e, r) {
  const a = Vl(t, e, !1, Yi);
  xa(a);
}
function Uf(t, e, r) {
  Bf = Gh;
  const a = Vl(t, e, !1, Yi);
  a.user = !0, Ai ? Ai.push(a) : xa(a);
}
function jr(t, e, r) {
  r = r ? Object.assign({}, Co, r) : Co;
  const a = Vl(t, e, !0, 0);
  return a.observers = null, a.observerSlots = null, a.comparator = r.equals || void 0, xa(a), Of.bind(a);
}
function ba(t) {
  if (Bt === null) return t();
  const e = Bt;
  Bt = null;
  try {
    return t();
  } finally {
    Bt = e;
  }
}
function jh(t) {
  Uf(() => ba(t));
}
function Of() {
  if (this.sources && this.state)
    if (this.state === Yi) xa(this);
    else {
      const t = lr;
      lr = null, Ea(() => Po(this), !1), lr = t;
    }
  if (Bt) {
    const t = this.observers ? this.observers.length : 0;
    Bt.sources ? (Bt.sources.push(this), Bt.sourceSlots.push(t)) : (Bt.sources = [this], Bt.sourceSlots = [t]), this.observers ? (this.observers.push(Bt), this.observerSlots.push(Bt.sources.length - 1)) : (this.observers = [Bt], this.observerSlots = [Bt.sources.length - 1]);
  }
  return this.value;
}
function Kf(t, e, r) {
  let a = t.value;
  return (!t.comparator || !t.comparator(a, e)) && (t.value = e, t.observers && t.observers.length && Ea(() => {
    for (let u = 0; u < t.observers.length; u += 1) {
      const x = t.observers[u], y = El && El.running;
      y && El.disposed.has(x), (y ? !x.tState : !x.state) && (x.pure ? lr.push(x) : Ai.push(x), x.observers && Vf(x)), y || (x.state = Yi);
    }
    if (lr.length > 1e6)
      throw lr = [], new Error();
  }, !1)), e;
}
function xa(t) {
  if (!t.fn) return;
  qo(t);
  const e = Go;
  Fh(
    t,
    t.value,
    e
  );
}
function Fh(t, e, r) {
  let a;
  const u = dr, x = Bt;
  Bt = dr = t;
  try {
    a = t.fn(e);
  } catch (y) {
    return t.pure && (t.state = Yi, t.owned && t.owned.forEach(qo), t.owned = null), t.updatedAt = r + 1, Mf(y);
  } finally {
    Bt = x, dr = u;
  }
  (!t.updatedAt || t.updatedAt <= r) && (t.updatedAt != null && "observers" in t ? Kf(t, a) : t.value = a, t.updatedAt = r);
}
function Vl(t, e, r, a = Yi, u) {
  const x = {
    fn: t,
    state: a,
    updatedAt: null,
    owned: null,
    sources: null,
    sourceSlots: null,
    cleanups: null,
    value: e,
    owner: dr,
    context: dr ? dr.context : null,
    pure: r
  };
  return dr === null || dr !== If && (dr.owned ? dr.owned.push(x) : dr.owned = [x]), x;
}
function ko(t) {
  if (t.state === 0) return;
  if (t.state === Do) return Po(t);
  if (t.suspense && ba(t.suspense.inFallback)) return t.suspense.effects.push(t);
  const e = [t];
  for (; (t = t.owner) && (!t.updatedAt || t.updatedAt < Go); )
    t.state && e.push(t);
  for (let r = e.length - 1; r >= 0; r--)
    if (t = e[r], t.state === Yi)
      xa(t);
    else if (t.state === Do) {
      const a = lr;
      lr = null, Ea(() => Po(t, e[0]), !1), lr = a;
    }
}
function Ea(t, e) {
  if (lr) return t();
  let r = !1;
  e || (lr = []), Ai ? r = !0 : Ai = [], Go++;
  try {
    const a = t();
    return $h(r), a;
  } catch (a) {
    r || (Ai = null), lr = null, Mf(a);
  }
}
function $h(t) {
  if (lr && (Nf(lr), lr = null), t) return;
  const e = Ai;
  Ai = null, e.length && Ea(() => Bf(e), !1);
}
function Nf(t) {
  for (let e = 0; e < t.length; e++) ko(t[e]);
}
function Gh(t) {
  let e, r = 0;
  for (e = 0; e < t.length; e++) {
    const a = t[e];
    a.user ? t[r++] = a : ko(a);
  }
  for (e = 0; e < r; e++) ko(t[e]);
}
function Po(t, e) {
  t.state = 0;
  for (let r = 0; r < t.sources.length; r += 1) {
    const a = t.sources[r];
    if (a.sources) {
      const u = a.state;
      u === Yi ? a !== e && (!a.updatedAt || a.updatedAt < Go) && ko(a) : u === Do && Po(a, e);
    }
  }
}
function Vf(t) {
  for (let e = 0; e < t.observers.length; e += 1) {
    const r = t.observers[e];
    r.state || (r.state = Do, r.pure ? lr.push(r) : Ai.push(r), r.observers && Vf(r));
  }
}
function qo(t) {
  let e;
  if (t.sources)
    for (; t.sources.length; ) {
      const r = t.sources.pop(), a = t.sourceSlots.pop(), u = r.observers;
      if (u && u.length) {
        const x = u.pop(), y = r.observerSlots.pop();
        a < u.length && (x.sourceSlots[y] = a, u[a] = x, r.observerSlots[a] = y);
      }
    }
  if (t.owned) {
    for (e = t.owned.length - 1; e >= 0; e--) qo(t.owned[e]);
    t.owned = null;
  }
  if (t.cleanups) {
    for (e = t.cleanups.length - 1; e >= 0; e--) t.cleanups[e]();
    t.cleanups = null;
  }
  t.state = 0;
}
function qh(t) {
  return t instanceof Error ? t : new Error(typeof t == "string" ? t : "Unknown error", {
    cause: t
  });
}
function Mf(t, e = dr) {
  throw qh(t);
}
function jf(t, e) {
  return ba(() => t(e || {}));
}
function vo() {
  return !0;
}
const Xh = {
  get(t, e, r) {
    return e === kl ? r : t.get(e);
  },
  has(t, e) {
    return e === kl ? !0 : t.has(e);
  },
  set: vo,
  deleteProperty: vo,
  getOwnPropertyDescriptor(t, e) {
    return {
      configurable: !0,
      enumerable: !0,
      get() {
        return t.get(e);
      },
      set: vo,
      deleteProperty: vo
    };
  },
  ownKeys(t) {
    return t.keys();
  }
};
function gl(t) {
  return (t = typeof t == "function" ? t() : t) ? t : {};
}
function zh() {
  for (let t = 0, e = this.length; t < e; ++t) {
    const r = this[t]();
    if (r !== void 0) return r;
  }
}
function Hh(...t) {
  let e = !1;
  for (let y = 0; y < t.length; y++) {
    const p = t[y];
    e = e || !!p && kl in p, t[y] = typeof p == "function" ? (e = !0, jr(p)) : p;
  }
  if (e)
    return new Proxy(
      {
        get(y) {
          for (let p = t.length - 1; p >= 0; p--) {
            const m = gl(t[p])[y];
            if (m !== void 0) return m;
          }
        },
        has(y) {
          for (let p = t.length - 1; p >= 0; p--)
            if (y in gl(t[p])) return !0;
          return !1;
        },
        keys() {
          const y = [];
          for (let p = 0; p < t.length; p++)
            y.push(...Object.keys(gl(t[p])));
          return [...new Set(y)];
        }
      },
      Xh
    );
  const r = {}, a = /* @__PURE__ */ Object.create(null);
  for (let y = t.length - 1; y >= 0; y--) {
    const p = t[y];
    if (!p) continue;
    const m = Object.getOwnPropertyNames(p);
    for (let h = m.length - 1; h >= 0; h--) {
      const d = m[h];
      if (d === "__proto__" || d === "constructor") continue;
      const T = Object.getOwnPropertyDescriptor(p, d);
      if (!a[d])
        a[d] = T.get ? {
          enumerable: !0,
          configurable: !0,
          get: zh.bind(r[d] = [T.get.bind(p)])
        } : T.value !== void 0 ? T : void 0;
      else {
        const S = r[d];
        S && (T.get ? S.push(T.get.bind(p)) : T.value !== void 0 && S.push(() => T.value));
      }
    }
  }
  const u = {}, x = Object.keys(a);
  for (let y = x.length - 1; y >= 0; y--) {
    const p = x[y], h = a[p];
    h && h.get ? Object.defineProperty(u, p, h) : u[p] = h ? h.value : void 0;
  }
  return u;
}
function Zh(t, e, r) {
  let a = r.length, u = e.length, x = a, y = 0, p = 0, m = e[u - 1].nextSibling, h = null;
  for (; y < u || p < x; ) {
    if (e[y] === r[p]) {
      y++, p++;
      continue;
    }
    for (; e[u - 1] === r[x - 1]; )
      u--, x--;
    if (u === y) {
      const d = x < a ? p ? r[p - 1].nextSibling : r[x - p] : m;
      for (; p < x; ) t.insertBefore(r[p++], d);
    } else if (x === p)
      for (; y < u; )
        (!m || !m.has(e[y])) && e[y].remove(), y++;
    else if (e[y] === r[x - 1] && r[p] === e[u - 1]) {
      const d = e[--u].nextSibling;
      t.insertBefore(r[p++], e[y++].nextSibling), t.insertBefore(r[--x], d), e[u] = r[x];
    } else {
      if (!m) {
        m = /* @__PURE__ */ new Map();
        let T = p;
        for (; T < x; ) h.set(r[T], T++);
      }
      const d = m.get(e[y]);
      if (d != null)
        if (p < d && d < x) {
          let T = y, S = 1, B;
          for (; ++T < u && T < x && !((B = h.get(e[T])) == null || B !== d + S); )
            S++;
          if (S > d - p) {
            const I = e[y];
            for (; p < d; ) t.insertBefore(r[p++], I);
          } else t.replaceChild(r[p++], e[y++]);
        } else y++;
      else e[y++].remove();
    }
  }
}
const _u = "_$DX_DELEGATE";
function ur(t, e, r) {
  let a;
  const u = () => {
    const y = document.createElement("template");
    return y.innerHTML = t, y.content.firstChild;
  }, x = () => (a || (a = u())).cloneNode(!0);
  return x.cloneNode = x, x;
}
function Ff(t, e = window.document) {
  const r = e[_u] || (e[_u] = /* @__PURE__ */ new Set());
  for (let a = 0, u = t.length; a < u; a++) {
    const x = t[a];
    r.has(x) || (r.add(x), e.addEventListener(x, Wh));
  }
}
function Gt(t, e, r) {
  r == null ? t.removeAttribute(e) : t.setAttribute(e, r);
}
function $f(t, e) {
  e == null ? t.removeAttribute("class") : t.className = e;
}
function Pl(t, e, r) {
  return ba(() => t(e, r));
}
function yt(t, e, r, a) {
  if (r !== void 0 && !a && (a = []), typeof e != "function") return Bo(t, e, a, r);
  wr((u) => Bo(t, e(), u, r), a);
}
function Wh(t) {
  const e = `$$${t.type}`;
  let r = t.composedPath && t.composedPath()[0] || t.target;
  for (t.target !== r && Object.defineProperty(t, "target", {
    configurable: !0,
    value: r
  }), Object.defineProperty(t, "currentTarget", {
    configurable: !0,
    get() {
      return r || document;
    }
  }); r; ) {
    const a = r[e];
    if (a && !r.disabled) {
      const u = r[`${e}Data`];
      if (u !== void 0 ? a.call(r, u, t) : a.call(r, t), t.cancelBubble) return;
    }
    r = r._$host || r.parentNode || r.host;
  }
}
function Bo(t, e, r, a, u) {
  for (; typeof r == "function"; ) r = r();
  if (e === r) return r;
  const x = typeof e, y = a !== void 0;
  if (t = y && r[0] && r[0].parentNode || t, x === "string" || x === "number")
    if (x === "number" && (e = e.toString()), y) {
      let p = r[0];
      p && p.nodeType === 3 ? p.data !== e && (p.data = e) : p = document.createTextNode(e), r = kn(t, r, a, p);
    } else
      r !== "" && typeof r == "string" ? r = t.firstChild.data = e : r = t.textContent = e;
  else if (e == null || x === "boolean")
    r = kn(t, r, a);
  else {
    if (x === "function")
      return wr(() => {
        let p = e();
        for (; typeof p == "function"; ) p = p();
        r = Bo(t, p, r, a);
      }), () => r;
    if (Array.isArray(e)) {
      const p = [], h = r && Array.isArray(r);
      if (Bl(p, e, r, u))
        return wr(() => r = Bo(t, p, r, a, !0)), () => r;
      if (p.length === 0) {
        if (r = kn(t, r, a), y) return r;
      } else m ? r.length === 0 ? Tu(t, p, a) : Zh(t, r, p) : (r && kn(t), Tu(t, p));
      r = p;
    } else if (e.nodeType) {
      if (Array.isArray(r)) {
        if (y) return r = kn(t, r, a, e);
        kn(t, r, null, e);
      } else r == null || r === "" || !t.firstChild ? t.appendChild(e) : t.replaceChild(e, t.firstChild);
      r = e;
    }
  }
  return r;
}
function Bl(t, e, r, a) {
  let u = !1;
  for (let x = 0, y = e.length; x < y; x++) {
    let p = e[x], m = r && r[t.length], h;
    if (!(p == null || p === !0 || p === !1)) if ((h = typeof p) == "object" && p.nodeType)
      t.push(p);
    else if (Array.isArray(p))
      u = Bl(t, p, m) || u;
    else if (h === "function")
      if (a) {
        for (; typeof p == "function"; ) p = p();
        u = Bl(
          t,
          Array.isArray(p) ? p : [p],
          Array.isArray(m) ? m : [m]
        ) || u;
      } else
        t.push(p), u = !0;
    else {
      const d = String(p);
      m && m.nodeType === 3 && m.data === d ? t.push(m) : t.push(document.createTextNode(d));
    }
  }
  return u;
}
function Tu(t, e, r = null) {
  for (let a = 0, u = e.length; a < u; a++) t.insertBefore(e[a], r);
}
function kn(t, e, r, a) {
  if (r === void 0) return t.textContent = "";
  const u = a || document.createTextNode("");
  if (e.length) {
    let x = !1;
    for (let y = e.length - 1; y >= 0; y--) {
      const p = e[y];
      if (u !== p) {
        const m = p.parentNode === t;
        !x && !y ? m ? t.replaceChild(u, p) : t.insertBefore(u, r) : m && p.remove();
      } else x = !0;
    }
  } else t.insertBefore(u, r);
  return [u];
}
function Yh(t) {
  const e = Object.keys(t), r = {};
  for (let a = 0; a < e.length; a++) {
    const [u, x] = pa(t[e[a]]);
    Object.defineProperty(r, e[a], {
      get: u,
      set(y) {
        x(() => y);
      }
    });
  }
  return r;
}
function Jh(t) {
  if (t.assignedSlot && t.assignedSlot._$owner) return t.assignedSlot._$owner;
  let e = t.parentNode;
  for (; e && !e._$owner && !(e.assignedSlot && e.assignedSlot._$owner); )
    e = e.parentNode;
  return e && e.assignedSlot ? e.assignedSlot._$owner : t._$owner;
}
function Qh(t) {
  return (e, r) => {
    const { element: a } = r;
    return Mh((u) => {
      const x = Yh(e);
      a.addPropertyChangedCallback((p, m) => x[p] = m), a.addReleaseCallback(() => {
        a.renderRoot.textContent = "", u();
      });
      const y = t(x, r);
      return yt(a.renderRoot, y);
    }, Jh(a));
  };
}
function e0(t, e, r) {
  return arguments.length === 2 && (r = e, e = {}), Kh(t, e)(Qh(r));
}
const t0 = '*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}:before,:after{--tw-content: ""}html,:host{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }.visible{visibility:visible}.fixed{position:fixed}.right-5{right:1.25rem}.top-5{top:1.25rem}.col-span-2{grid-column:span 2 / span 2}.mx-1{margin-left:.25rem;margin-right:.25rem}.mx-auto{margin-left:auto;margin-right:auto}.mb-1{margin-bottom:.25rem}.mb-16{margin-bottom:4rem}.ml-10{margin-left:2.5rem}.mr-1{margin-right:.25rem}.mt-4{margin-top:1rem}.mt-8{margin-top:2rem}.block{display:block}.inline{display:inline}.flex{display:flex}.grid{display:grid}.h-10{height:2.5rem}.h-14{height:3.5rem}.h-2{height:.5rem}.h-4{height:1rem}.h-full{height:100%}.max-h-\\[90vh\\]{max-height:90vh}.w-10{width:2.5rem}.w-14{width:3.5rem}.w-4{width:1rem}.w-full{width:100%}.max-w-\\[calc\\(100vw-96px\\)\\]{max-width:calc(100vw - 96px)}.max-w-screen-sm{max-width:640px}.flex-1{flex:1 1 0%}@keyframes pulse{50%{opacity:.5}}.animate-pulse{animation:pulse 2s cubic-bezier(.4,0,.6,1) infinite}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.grid-cols-4{grid-template-columns:repeat(4,minmax(0,1fr))}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-center{justify-content:center}.gap-1{gap:.25rem}.gap-2{gap:.5rem}.gap-4{gap:1rem}.space-y-2>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 0;margin-top:calc(.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(.5rem * var(--tw-space-y-reverse))}.overflow-hidden{overflow:hidden}.text-ellipsis{text-overflow:ellipsis}.whitespace-nowrap{white-space:nowrap}.whitespace-pre-wrap{white-space:pre-wrap}.rounded{border-radius:.25rem}.rounded-full{border-radius:9999px}.rounded-md{border-radius:.375rem}.rounded-t-md{border-top-left-radius:.375rem;border-top-right-radius:.375rem}.border{border-width:1px}.border-b{border-bottom-width:1px}.border-slate-300{--tw-border-opacity: 1;border-color:rgb(203 213 225 / var(--tw-border-opacity))}.bg-blue-500{--tw-bg-opacity: 1;background-color:rgb(59 130 246 / var(--tw-bg-opacity))}.bg-gray-900{--tw-bg-opacity: 1;background-color:rgb(17 24 39 / var(--tw-bg-opacity))}.bg-slate-100{--tw-bg-opacity: 1;background-color:rgb(241 245 249 / var(--tw-bg-opacity))}.bg-slate-200{--tw-bg-opacity: 1;background-color:rgb(226 232 240 / var(--tw-bg-opacity))}.bg-slate-900{--tw-bg-opacity: 1;background-color:rgb(15 23 42 / var(--tw-bg-opacity))}.object-cover{-o-object-fit:cover;object-fit:cover}.p-3{padding:.75rem}.p-4{padding:1rem}.px-4{padding-left:1rem;padding-right:1rem}.py-1{padding-top:.25rem;padding-bottom:.25rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.text-sm{font-size:.875rem;line-height:1.25rem}.font-bold{font-weight:700}.font-semibold{font-weight:600}.text-blue-500{--tw-text-opacity: 1;color:rgb(59 130 246 / var(--tw-text-opacity))}.text-slate-500{--tw-text-opacity: 1;color:rgb(100 116 139 / var(--tw-text-opacity))}.text-slate-600{--tw-text-opacity: 1;color:rgb(71 85 105 / var(--tw-text-opacity))}.text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}.underline{text-decoration-line:underline}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.backdrop\\:bg-gray-800::backdrop{--tw-bg-opacity: 1;background-color:rgb(31 41 55 / var(--tw-bg-opacity))}.backdrop\\:opacity-90::backdrop{opacity:.9}.hover\\:bg-blue-700:hover{--tw-bg-opacity: 1;background-color:rgb(29 78 216 / var(--tw-bg-opacity))}.hover\\:underline:hover{text-decoration-line:underline}.dark\\:border-slate-800:where(.dark,.dark *){--tw-border-opacity: 1;border-color:rgb(30 41 59 / var(--tw-border-opacity))}.dark\\:bg-slate-800:where(.dark,.dark *){--tw-bg-opacity: 1;background-color:rgb(30 41 59 / var(--tw-bg-opacity))}.dark\\:text-slate-400:where(.dark,.dark *){--tw-text-opacity: 1;color:rgb(148 163 184 / var(--tw-text-opacity))}.dark\\:text-white:where(.dark,.dark *){--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}';
var le = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function r0(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function Gf(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var r = function a() {
      return this instanceof a ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    r.prototype = e.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(t).forEach(function(a) {
    var u = Object.getOwnPropertyDescriptor(t, a);
    Object.defineProperty(r, a, u.get ? u : {
      enumerable: !0,
      get: function() {
        return t[a];
      }
    });
  }), r;
}
var Ml = {}, ea = {}, jl = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.DisallowedDomainError = t.UnsupportedDomainError = t.ReservedHandleError = t.InvalidHandleError = t.isValidTld = t.isValidHandle = t.normalizeAndEnsureValidHandle = t.normalizeHandle = t.ensureValidHandleRegex = t.ensureValidHandle = t.DISALLOWED_TLDS = t.INVALID_HANDLE = void 0, t.INVALID_HANDLE = "handle.invalid", t.DISALLOWED_TLDS = [
    ".local",
    ".arpa",
    ".invalid",
    ".localhost",
    ".internal",
    ".example",
    ".alt",
    // policy could concievably change on ".onion" some day
    ".onion"
    // NOTE: .test is allowed in testing and devopment. In practical terms
    // "should" "never" actually resolve and get registered in production
  ];
  const e = (T) => {
    if (!/^[a-zA-Z0-9.-]*$/.test(T))
      throw new p("Disallowed characters in handle (ASCII letters, digits, dashes, periods only)");
    if (T.length > 253)
      throw new p("Handle is too long (253 chars max)");
    const S = T.split(".");
    if (S.length < 2)
      throw new p("Handle domain needs at least two parts");
    for (let B = 0; B < S.length; B++) {
      const I = S[B];
      if (I.length < 1)
        throw new p("Handle parts can not be empty");
      if (I.length > 63)
        throw new p("Handle part too long (max 63 chars)");
      if (I.endsWith("-") || I.startsWith("-"))
        throw new p("Handle parts can not start or end with hyphens");
      if (B + 1 == S.length && !/^[a-zA-Z]/.test(I))
        throw new p("Handle final component (TLD) must start with ASCII letter");
    }
  };
  t.ensureValidHandle = e;
  const r = (T) => {
    if (!/^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$/.test(T))
      throw new p("Handle didn't validate via regex");
    if (T.length > 253)
      throw new p("Handle is too long (253 chars max)");
  };
  t.ensureValidHandleRegex = r;
  const a = (T) => T.toLowerCase();
  t.normalizeHandle = a;
  const u = (T) => {
    const S = (0, t.normalizeHandle)(T);
    return (0, t.ensureValidHandle)(S), S;
  };
  t.normalizeAndEnsureValidHandle = u;
  const x = (T) => {
    try {
      (0, t.ensureValidHandle)(T);
    } catch (S) {
      if (S instanceof p)
        return !1;
      throw S;
    }
    return !0;
  };
  t.isValidHandle = x;
  const y = (T) => !t.DISALLOWED_TLDS.some((S) => T.endsWith(S));
  t.isValidTld = y;
  class p extends Error {
  }
  t.InvalidHandleError = p;
  class h extends Error {
  }
  t.ReservedHandleError = h;
  class m extends Error {
  }
  t.UnsupportedDomainError = m;
  class d extends Error {
  }
  t.DisallowedDomainError = d;
})(jl);
var _i = {};
Object.defineProperty(_i, "__esModule", { value: !0 });
_i.InvalidDidError = _i.ensureValidDidRegex = _i.ensureValidDid = void 0;
const i0 = (t) => {
  if (!/^[a-zA-Z0-9._:%-]*$/.test(t))
    throw new gi("Disallowed characters in DID (ASCII letters, digits, and a couple other characters only)");
  const e = t.split(":");
  if (e.length < 3)
    throw new gi("DID requires prefix, method, and method-specific content");
  if (e[0] != "did")
    throw new gi('DID requires "did:" prefix');
  if (!/^[a-z]+$/.test(e[1]))
    throw new gi("DID method must be lower-case letters");
  if (t.endsWith(":") || t.endsWith("%"))
    throw new gi('DID can not end with ":" or "%"');
  if (t.length > 2 * 1024)
    throw new gi("DID is too long (2048 chars max)");
};
_i.ensureValidDid = i0;
const n0 = (t) => {
  if (!/^did:[a-z]+:[a-zA-Z0-9._:%-]*[a-zA-Z0-9._-]$/.test(t))
    throw new gi("DID didn't validate via regex");
  if (t.length > 2 * 1024)
    throw new gi("DID is too long (2048 chars max)");
};
_i.ensureValidDidRegex = n0;
class gi extends Error {
}
_i.InvalidDidError = gi;
var Fl = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.InvalidNsidError = t.ensureValidNsidRegex = t.ensureValidNsid = t.NSID = void 0;
  class e {
    static parse(y) {
      return new e(y);
    }
    static create(y, p) {
      const h = [...y.split(".").reverse(), p].join(".");
      return new e(h);
    }
    static isValid(y) {
      try {
        return e.parse(y), !0;
      } catch {
        return !1;
      }
    }
    constructor(y) {
      Object.defineProperty(this, "segments", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: []
      }), (0, t.ensureValidNsid)(y), this.segments = y.split(".");
    }
    get authority() {
      return this.segments.slice(0, this.segments.length - 1).reverse().join(".");
    }
    get name() {
      return this.segments.at(this.segments.length - 1);
    }
    toString() {
      return this.segments.join(".");
    }
  }
  t.NSID = e;
  const r = (x) => {
    const y = x;
    if (!/^[a-zA-Z0-9.-]*$/.test(y))
      throw new u("Disallowed characters in NSID (ASCII letters, digits, dashes, periods only)");
    if (y.length > 317)
      throw new u("NSID is too long (317 chars max)");
    const p = y.split(".");
    if (p.length < 3)
      throw new u("NSID needs at least three parts");
    for (let h = 0; h < p.length; h++) {
      const m = p[h];
      if (m.length < 1)
        throw new u("NSID parts can not be empty");
      if (m.length > 63)
        throw new u("NSID part too long (max 63 chars)");
      if (m.endsWith("-") || m.startsWith("-"))
        throw new u("NSID parts can not start or end with hyphen");
      if (/^[0-9]/.test(m) && h == 0)
        throw new u("NSID first part may not start with a digit");
      if (!/^[a-zA-Z]+$/.test(m) && h + 1 == p.length)
        throw new u("NSID name part must be only letters");
    }
  };
  t.ensureValidNsid = r;
  const a = (x) => {
    if (!/^[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(\.[a-zA-Z]([a-zA-Z]{0,61}[a-zA-Z])?)$/.test(x))
      throw new u("NSID didn't validate via regex");
    if (x.length > 317)
      throw new u("NSID is too long (317 chars max)");
  };
  t.ensureValidNsidRegex = a;
  class u extends Error {
  }
  t.InvalidNsidError = u;
})(Fl);
var qf = {}, Un = {};
Object.defineProperty(Un, "__esModule", { value: !0 });
Un.ensureValidAtUriRegex = Un.ensureValidAtUri = void 0;
const Xf = jl, zf = _i, Hf = Fl, a0 = (t) => {
  const e = t.split("#");
  if (e.length > 2)
    throw new Error('ATURI can have at most one "#", separating fragment out');
  const r = e[1] || null;
  if (t = e[0], !/^[a-zA-Z0-9._~:@!$&')(*+,;=%/-]*$/.test(t))
    throw new Error("Disallowed characters in ATURI (ASCII)");
  const a = t.split("/");
  if (a.length >= 3 && (a[0] != "at:" || a[1].length != 0))
    throw new Error('ATURI must start with "at://"');
  if (a.length < 3)
    throw new Error("ATURI requires at least method and authority sections");
  try {
    a[2].startsWith("did:") ? (0, zf.ensureValidDid)(a[2]) : (0, Xf.ensureValidHandle)(a[2]);
  } catch {
    throw new Error("ATURI authority must be a valid handle or DID");
  }
  if (a.length >= 4) {
    if (a[3].length == 0)
      throw new Error("ATURI can not have a slash after authority without a path segment");
    try {
      (0, Hf.ensureValidNsid)(a[3]);
    } catch {
      throw new Error("ATURI requires first path segment (if supplied) to be valid NSID");
    }
  }
  if (a.length >= 5 && a[4].length == 0)
    throw new Error("ATURI can not have a slash after collection, unless record key is provided");
  if (a.length >= 6)
    throw new Error("ATURI path can have at most two parts, and no trailing slash");
  if (e.length >= 2 && r == null)
    throw new Error("ATURI fragment must be non-empty and start with slash");
  if (r != null) {
    if (r.length == 0 || r[0] != "/")
      throw new Error("ATURI fragment must be non-empty and start with slash");
    if (!/^\/[a-zA-Z0-9._~:@!$&')(*+,;=%[\]/-]*$/.test(r))
      throw new Error("Disallowed characters in ATURI fragment (ASCII)");
  }
  if (t.length > 8 * 1024)
    throw new Error("ATURI is far too long");
};
Un.ensureValidAtUri = a0;
const s0 = (t) => {
  const e = /^at:\/\/(?<authority>[a-zA-Z0-9._:%-]+)(\/(?<collection>[a-zA-Z0-9-.]+)(\/(?<rkey>[a-zA-Z0-9._~:@!$&%')(*+,;=-]+))?)?(#(?<fragment>\/[a-zA-Z0-9._~:@!$&%')(*+,;=\-[\]/\\]*))?$/, r = t.match(e);
  if (!r || !r.groups)
    throw new Error("ATURI didn't validate via regex");
  const a = r.groups;
  try {
    (0, Xf.ensureValidHandleRegex)(a.authority);
  } catch {
    try {
      (0, zf.ensureValidDidRegex)(a.authority);
    } catch {
      throw new Error("ATURI authority must be a valid handle or DID");
    }
  }
  if (a.collection)
    try {
      (0, Hf.ensureValidNsidRegex)(a.collection);
    } catch {
      throw new Error("ATURI collection path segment must be a valid NSID");
    }
  if (t.length > 8 * 1024)
    throw new Error("ATURI is far too long");
};
Un.ensureValidAtUriRegex = s0;
(function(t) {
  var e = le && le.__createBinding || (Object.create ? function(p, h, m, d) {
    d === void 0 && (d = m);
    var T = Object.getOwnPropertyDescriptor(h, m);
    (!T || ("get" in T ? !h.__esModule : T.writable || T.configurable)) && (T = { enumerable: !0, get: function() {
      return h[m];
    } }), Object.defineProperty(p, d, T);
  } : function(p, m, h, d) {
    d === void 0 && (d = h), p[d] = m[h];
  }), r = le && le.__exportStar || function(p, m) {
    for (var h in p) h !== "default" && !Object.prototype.hasOwnProperty.call(m, h) && e(m, p, h);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.AtUri = t.ATP_URI_REGEX = void 0, r(Un, t), t.ATP_URI_REGEX = // proto-    --did--------------   --name----------------   --path----   --query--   --hash--
  /^(at:\/\/)?((?:did:[a-z0-9:%-]+)|(?:[a-z0-9][a-z0-9.:-]*))(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
  const a = /^(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
  class u {
    constructor(h, m) {
      Object.defineProperty(this, "hash", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "host", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "pathname", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "searchParams", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      });
      let d;
      if (m) {
        if (d = x(m), !d)
          throw new Error(`Invalid at uri: ${m}`);
        const T = y(h);
        if (!T)
          throw new Error(`Invalid path: ${h}`);
        Object.assign(d, T);
      } else if (d = x(h), !d)
        throw new Error(`Invalid at uri: ${h}`);
      this.hash = d.hash, this.host = d.host, this.pathname = d.pathname, this.searchParams = d.searchParams;
    }
    static make(h, m, d) {
      let T = h;
      return m && (T += "/" + m), d && (T += "/" + d), new u(T);
    }
    get protocol() {
      return "at:";
    }
    get origin() {
      return `at://${this.host}`;
    }
    get hostname() {
      return this.host;
    }
    set hostname(h) {
      this.host = h;
    }
    get search() {
      return this.searchParams.toString();
    }
    set search(h) {
      this.searchParams = new URLSearchParams(h);
    }
    get collection() {
      return this.pathname.split("/").filter(Boolean)[0] || "";
    }
    set collection(h) {
      const m = this.pathname.split("/").filter(Boolean);
      m[0] = h, this.pathname = m.join("/");
    }
    get rkey() {
      return this.pathname.split("/").filter(Boolean)[1] || "";
    }
    set rkey(h) {
      const m = this.pathname.split("/").filter(Boolean);
      m[0] || (m[0] = "undefined"), m[1] = h, this.pathname = m.join("/");
    }
    get href() {
      return this.toString();
    }
    toString() {
      let h = this.pathname || "/";
      h.startsWith("/") || (h = `/${h}`);
      let m = this.searchParams.toString();
      m && !m.startsWith("?") && (m = `?${m}`);
      let d = this.hash;
      return d && !d.startsWith("#") && (d = `#${d}`), `at://${this.host}${h}${m}${d}`;
    }
  }
  t.AtUri = u;
  function x(p) {
    const h = t.ATP_URI_REGEX.exec(p);
    if (h)
      return {
        hash: h[5] || "",
        host: h[2] || "",
        pathname: h[3] || "",
        searchParams: new URLSearchParams(h[4] || "")
      };
  }
  function y(p) {
    const h = a.exec(p);
    if (h)
      return {
        hash: h[3] || "",
        pathname: h[1] || "",
        searchParams: new URLSearchParams(h[2] || "")
      };
  }
})(qf);
var Zf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.InvalidTidError = t.isValidTid = t.ensureValidTid = void 0;
  const e = (u) => {
    if (u.length != 13)
      throw new a("TID must be 13 characters");
    if (!/^[234567abcdefghij][234567abcdefghijklmnopqrstuvwxyz]{12}$/.test(u))
      throw new a("TID syntax not valid (regex)");
  };
  t.ensureValidTid = e;
  const r = (u) => {
    try {
      (0, t.ensureValidTid)(u);
    } catch (x) {
      if (x instanceof a)
        return !1;
      throw x;
    }
    return !0;
  };
  t.isValidTid = r;
  class a extends Error {
  }
  t.InvalidTidError = a;
})(Zf);
var Wf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.InvalidRecordKeyError = t.isValidRecordKey = t.ensureValidRecordKey = void 0;
  const e = (u) => {
    if (u.length > 512 || u.length < 1)
      throw new a("record key must be 1 to 512 characters");
    if (!/^[a-zA-Z0-9_~.:-]{1,512}$/.test(u))
      throw new a("record key syntax not valid (regex)");
    if (u == "." || u == "..")
      throw new a('record key can not be "." or ".."');
  };
  t.ensureValidRecordKey = e;
  const r = (u) => {
    try {
      (0, t.ensureValidRecordKey)(u);
    } catch (x) {
      if (x instanceof a)
        return !1;
      throw x;
    }
    return !0;
  };
  t.isValidRecordKey = r;
  class a extends Error {
  }
  t.InvalidRecordKeyError = a;
})(Wf);
var Yf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.InvalidDatetimeError = t.normalizeDatetimeAlways = t.normalizeDatetime = t.isValidDatetime = t.ensureValidDatetime = void 0;
  const e = (y) => {
    const p = new Date(y);
    if (isNaN(p.getTime()))
      throw new x("datetime did not parse as ISO 8601");
    if (p.toISOString().startsWith("-"))
      throw new x("datetime normalized to a negative time");
    if (!/^[0-9]{4}-[01][0-9]-[0-3][0-9]T[0-2][0-9]:[0-6][0-9]:[0-6][0-9](.[0-9]{1,20})?(Z|([+-][0-2][0-9]:[0-5][0-9]))$/.test(y))
      throw new x("datetime didn't validate via regex");
    if (y.length > 64)
      throw new x("datetime is too long (64 chars max)");
    if (y.endsWith("-00:00"))
      throw new x('datetime can not use "-00:00" for UTC timezone');
    if (y.startsWith("000"))
      throw new x("datetime so close to year zero not allowed");
  };
  t.ensureValidDatetime = e;
  const r = (y) => {
    try {
      (0, t.ensureValidDatetime)(y);
    } catch (p) {
      if (p instanceof x)
        return !1;
      throw p;
    }
    return !0;
  };
  t.isValidDatetime = r;
  const a = (y) => {
    if ((0, t.isValidDatetime)(y)) {
      const m = new Date(y).toISOString();
      if ((0, t.isValidDatetime)(m))
        return m;
    }
    if (!/.*(([+-]\d\d:?\d\d)|[a-zA-Z])$/.test(y)) {
      const m = /* @__PURE__ */ new Date(y + "Z");
      if (!isNaN(m.getTime())) {
        const d = m.toISOString();
        if ((0, t.isValidDatetime)(d))
          return d;
      }
    }
    const p = new Date(y);
    if (isNaN(p.getTime()))
      throw new x("datetime did not parse as any timestamp format");
    const h = p.toISOString();
    if ((0, t.isValidDatetime)(h))
      return h;
    throw new x("datetime normalized to invalid timestamp string");
  };
  t.normalizeDatetime = a;
  const u = (y) => {
    try {
      return (0, t.normalizeDatetime)(y);
    } catch (p) {
      if (p instanceof x)
        return (/* @__PURE__ */ new Date(0)).toISOString();
      throw p;
    }
  };
  t.normalizeDatetimeAlways = u;
  class x extends Error {
  }
  t.InvalidDatetimeError = x;
})(Yf);
(function(t) {
  var e = le && le.__createBinding || (Object.create ? function(a, u, x, y) {
    y === void 0 && (y = x);
    var p = Object.getOwnPropertyDescriptor(u, x);
    (!p || ("get" in p ? !u.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return u[x];
    } }), Object.defineProperty(a, y, p);
  } : function(a, u, x, y) {
    y === void 0 && (y = x), a[y] = u[x];
  }), r = le && le.__exportStar || function(a, u) {
    for (var x in a) x !== "default" && !Object.prototype.hasOwnProperty.call(u, x) && e(u, a, x);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), r(jl, t), r(_i, t), r(Fl, t), r(qf, t), r(Zf, t), r(Wf, t), r(Yf, t);
})(ea);
var ga = {}, vl = {}, wn = {}, Il = {}, ni = {}, Xo = {}, va = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.getParsedType = t.ZodParsedType = t.objectUtil = t.util = void 0;
  var e;
  (function(a) {
    a.assertEqual = (p) => p;
    function u(p) {
    }
    a.assertIs = u;
    function x(p) {
      throw new Error();
    }
    a.assertNever = x, a.arrayToEnum = (p) => {
      const h = {};
      for (const m of p)
        h[m] = m;
      return h;
    }, a.getValidEnumValues = (p) => {
      const h = a.objectKeys(p).filter((d) => typeof p[p[d]] != "number"), m = {};
      for (const d of h)
        m[d] = p[d];
      return a.objectValues(m);
    }, a.objectValues = (p) => a.objectKeys(p).map(function(h) {
      return p[h];
    }), a.objectKeys = typeof Object.keys == "function" ? (p) => Object.keys(p) : (p) => {
      const h = [];
      for (const m in p)
        Object.prototype.hasOwnProperty.call(p, m) && h.push(m);
      return h;
    }, a.find = (p, h) => {
      for (const m of p)
        if (h(m))
          return m;
    }, a.isInteger = typeof Number.isInteger == "function" ? (p) => Number.isInteger(p) : (p) => typeof p == "number" && isFinite(p) && Math.floor(p) === p;
    function y(p, h = " | ") {
      return p.map((m) => typeof m == "string" ? `'${m}'` : m).join(h);
    }
    a.joinValues = y, a.jsonStringifyReplacer = (p, h) => typeof h == "bigint" ? h.toString() : h;
  })(e = t.util || (t.util = {})), function(a) {
    a.mergeShapes = (u, x) => ({
      ...u,
      ...x
      // second overwrites first
    });
  }(t.objectUtil || (t.objectUtil = {})), t.ZodParsedType = e.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  const r = (a) => {
    switch (typeof a) {
      case "undefined":
        return t.ZodParsedType.undefined;
      case "string":
        return t.ZodParsedType.string;
      case "number":
        return isNaN(a) ? t.ZodParsedType.nan : t.ZodParsedType.number;
      case "boolean":
        return t.ZodParsedType.boolean;
      case "function":
        return t.ZodParsedType.function;
      case "bigint":
        return t.ZodParsedType.bigint;
      case "symbol":
        return t.ZodParsedType.symbol;
      case "object":
        return Array.isArray(a) ? t.ZodParsedType.array : a === null ? t.ZodParsedType.null : a.then && typeof a.then == "function" && a.catch && typeof a.catch == "function" ? t.ZodParsedType.promise : typeof Map < "u" && a instanceof Map ? t.ZodParsedType.map : typeof Set < "u" && a instanceof Set ? t.ZodParsedType.set : typeof Date < "u" && a instanceof Date ? t.ZodParsedType.date : t.ZodParsedType.object;
      default:
        return t.ZodParsedType.unknown;
    }
  };
  t.getParsedType = r;
})(va);
var ai = {};
Object.defineProperty(ai, "__esModule", { value: !0 });
ai.ZodError = ai.quotelessJson = ai.ZodIssueCode = void 0;
const Jf = va;
ai.ZodIssueCode = Jf.util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const o0 = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
ai.quotelessJson = o0;
class ma extends Error {
  constructor(e) {
    super(), this.issues = [], this.addIssue = (a) => {
      this.issues = [...this.issues, a];
    }, this.addIssues = (a = []) => {
      this.issues = [...this.issues, ...a];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = e;
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    const r = e || function(x) {
      return x.message;
    }, a = { _errors: [] }, u = (x) => {
      for (const y of x.issues)
        if (y.code === "invalid_union")
          y.unionErrors.map(u);
        else if (y.code === "invalid_return_type")
          u(y.returnTypeError);
        else if (y.code === "invalid_arguments")
          u(y.argumentsError);
        else if (y.path.length === 0)
          a._errors.push(r(y));
        else {
          let p = a, h = 0;
          for (; h < y.path.length; ) {
            const m = y.path[h];
            h === y.path.length - 1 ? (p[m] = p[m] || { _errors: [] }, p[m]._errors.push(r(y))) : p[m] = p[m] || { _errors: [] }, p = p[m], h++;
          }
        }
    };
    return u(this), a;
  }
  static assert(e) {
    if (!(e instanceof ma))
      throw new Error(`Not a ZodError: ${e}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, Jf.util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (r) => r.message) {
    const r = {}, a = [];
    for (const u of this.issues)
      u.path.length > 0 ? (r[u.path[0]] = r[u.path[0]] || [], r[u.path[0]].push(e(u))) : a.push(e(u));
    return { formErrors: a, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
}
ai.ZodError = ma;
ma.create = (t) => new ma(t);
Object.defineProperty(Xo, "__esModule", { value: !0 });
const an = va, nr = ai, l0 = (t, e) => {
  let r;
  switch (t.code) {
    case nr.ZodIssueCode.invalid_type:
      t.received === an.ZodParsedType.undefined ? r = "Required" : r = `Expected ${t.expected}, received ${t.received}`;
      break;
    case nr.ZodIssueCode.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(t.expected, an.util.jsonStringifyReplacer)}`;
      break;
    case nr.ZodIssueCode.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${an.util.joinValues(t.keys, ", ")}`;
      break;
    case nr.ZodIssueCode.invalid_union:
      r = "Invalid input";
      break;
    case nr.ZodIssueCode.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${an.util.joinValues(t.options)}`;
      break;
    case nr.ZodIssueCode.invalid_enum_value:
      r = `Invalid enum value. Expected ${an.util.joinValues(t.options)}, received '${t.received}'`;
      break;
    case nr.ZodIssueCode.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case nr.ZodIssueCode.invalid_return_type:
      r = "Invalid function return type";
      break;
    case nr.ZodIssueCode.invalid_date:
      r = "Invalid date";
      break;
    case nr.ZodIssueCode.invalid_string:
      typeof t.validation == "object" ? "includes" in t.validation ? (r = `Invalid input: must include "${t.validation.includes}"`, typeof t.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? r = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? r = `Invalid input: must end with "${t.validation.endsWith}"` : an.util.assertNever(t.validation) : t.validation !== "regex" ? r = `Invalid ${t.validation}` : r = "Invalid";
      break;
    case nr.ZodIssueCode.too_small:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : r = "Invalid input";
      break;
    case nr.ZodIssueCode.too_big:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? r = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : r = "Invalid input";
      break;
    case nr.ZodIssueCode.custom:
      r = "Invalid input";
      break;
    case nr.ZodIssueCode.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case nr.ZodIssueCode.not_multiple_of:
      r = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case nr.ZodIssueCode.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = e.defaultError, an.util.assertNever(t);
  }
  return { message: r };
};
Xo.default = l0;
var u0 = le && le.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(ni, "__esModule", { value: !0 });
ni.getErrorMap = ni.setErrorMap = ni.defaultErrorMap = void 0;
const Qf = u0(Xo);
ni.defaultErrorMap = Qf.default;
let ec = Qf.default;
function f0(t) {
  ec = t;
}
ni.setErrorMap = f0;
function c0() {
  return ec;
}
ni.getErrorMap = c0;
var $l = {};
(function(t) {
  var e = le && le.__importDefault || function(B) {
    return B && B.__esModule ? B : { default: B };
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.isAsync = t.isValid = t.isDirty = t.isAborted = t.OK = t.DIRTY = t.INVALID = t.ParseStatus = t.addIssueToContext = t.EMPTY_PATH = t.makeIssue = void 0;
  const r = ni, a = e(Xo), u = (B) => {
    const { data: I, path: O, errorMaps: j, issueData: $ } = B, z = [...O, ...$.path || []], Y = {
      ...$,
      path: z
    };
    if ($.message !== void 0)
      return {
        ...$,
        path: z,
        message: $.message
      };
    let ie = "";
    const ye = F.filter((ve) => !!ve).slice().reverse();
    for (const ve of ye)
      ie = ve(J, { data: I, defaultError: ie }).message;
    return {
      ...$,
      path: z,
      message: ie
    };
  };
  t.makeIssue = u, t.EMPTY_PATH = [];
  function x(B, I) {
    const O = (0, r.getErrorMap)(), j = (0, t.makeIssue)({
      issueData: I,
      data: B.data,
      path: B.path,
      errorMaps: [
        B.common.contextualErrorMap,
        B.schemaErrorMap,
        O,
        O === a.default ? void 0 : a.default
        // then global default map
      ].filter(($) => !!$)
    });
    B.common.issues.push(j);
  }
  t.addIssueToContext = x;
  class y {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      this.value === "valid" && (this.value = "dirty");
    }
    abort() {
      this.value !== "aborted" && (this.value = "aborted");
    }
    static mergeArray(I, O) {
      const j = [];
      for (const $ of O) {
        if ($.status === "aborted")
          return t.INVALID;
        $.status === "dirty" && I.dirty(), j.push($.value);
      }
      return { status: I.value, value: j };
    }
    static async mergeObjectAsync(I, O) {
      const j = [];
      for (const $ of O) {
        const z = await $.key, Y = await $.value;
        j.push({
          key: z,
          value: Y
        });
      }
      return y.mergeObjectSync(I, j);
    }
    static mergeObjectSync(I, O) {
      const j = {};
      for (const $ of O) {
        const { key: z, value: Y } = $;
        if (z.status === "aborted" || Y.status === "aborted")
          return t.INVALID;
        z.status === "dirty" && I.dirty(), Y.status === "dirty" && I.dirty(), z.value !== "__proto__" && (typeof Y.value < "u" || $.alwaysSet) && (j[z.value] = Y.value);
      }
      return { status: I.value, value: j };
    }
  }
  t.ParseStatus = y, t.INVALID = Object.freeze({
    status: "aborted"
  });
  const p = (B) => ({ status: "dirty", value: B });
  t.DIRTY = p;
  const h = (B) => ({ status: "valid", value: B });
  t.OK = h;
  const m = (B) => B.status === "aborted";
  t.isAborted = m;
  const d = (B) => B.status === "dirty";
  t.isDirty = d;
  const T = (B) => B.status === "valid";
  t.isValid = T;
  const S = (B) => typeof Promise < "u" && B instanceof Promise;
  t.isAsync = S;
})($l);
var tc = {};
Object.defineProperty(tc, "__esModule", { value: !0 });
var rc = {}, ic = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.errorUtil = void 0, function(e) {
    e.errToObj = (r) => typeof r == "string" ? { message: r } : r || {}, e.toString = (r) => typeof r == "string" ? r : r?.message;
  }(t.errorUtil || (t.errorUtil = {}));
})(ic);
(function(t) {
  var e = le && le.__classPrivateFieldGet || function(N, f, R, C) {
    if (R === "a" && !C) throw new TypeError("Private accessor was defined without a getter");
    if (typeof f == "function" ? N !== f || !C : !f.has(N)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return R === "m" ? C : R === "a" ? C.call(N) : C ? C.value : f.get(N);
  }, r = le && le.__classPrivateFieldSet || function(N, f, R, C, G) {
    if (C === "m") throw new TypeError("Private method is not writable");
    if (C === "a" && !G) throw new TypeError("Private accessor was defined without a setter");
    if (typeof f == "function" ? N !== f || !G : !f.has(N)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return C === "a" ? G.call(N, R) : G ? G.value = R : f.set(N, R), R;
  }, a, u;
  Object.defineProperty(t, "__esModule", { value: !0 }), t.boolean = t.bigint = t.array = t.any = t.coerce = t.ZodFirstPartyTypeKind = t.late = t.ZodSchema = t.Schema = t.custom = t.ZodReadonly = t.ZodPipeline = t.ZodBranded = t.BRAND = t.ZodNaN = t.ZodCatch = t.ZodDefault = t.ZodNullable = t.ZodOptional = t.ZodTransformer = t.ZodEffects = t.ZodPromise = t.ZodNativeEnum = t.ZodEnum = t.ZodLiteral = t.ZodLazy = t.ZodFunction = t.ZodSet = t.ZodMap = t.ZodRecord = t.ZodTuple = t.ZodIntersection = t.ZodDiscriminatedUnion = t.ZodUnion = t.ZodObject = t.ZodArray = t.ZodVoid = t.ZodNever = t.ZodUnknown = t.ZodAny = t.ZodNull = t.ZodUndefined = t.ZodSymbol = t.ZodDate = t.ZodBoolean = t.ZodBigInt = t.ZodNumber = t.ZodString = t.datetimeRegex = t.ZodType = void 0, t.NEVER = t.void = t.unknown = t.union = t.undefined = t.tuple = t.transformer = t.symbol = t.string = t.strictObject = t.set = t.record = t.promise = t.preprocess = t.pipeline = t.ostring = t.optional = t.onumber = t.oboolean = t.object = t.number = t.nullable = t.null = t.never = t.nativeEnum = t.nan = t.map = t.literal = t.lazy = t.intersection = t.instanceof = t.function = t.enum = t.effect = t.discriminatedUnion = t.date = void 0;
  const x = ni, y = ic, p = $l, m = va, h = ai;
  class d {
    constructor(f, R, C, G) {
      this._cachedPath = [], this.parent = f, this.data = R, this._path = C, this._key = G;
    }
    get path() {
      return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
    }
  }
  const T = (N, f) => {
    if ((0, p.isValid)(f))
      return { success: !0, data: f.value };
    if (!N.common.issues.length)
      throw new Error("Validation failed but no issues detected.");
    return {
      success: !1,
      get error() {
        if (this._error)
          return this._error;
        const R = new m.ZodError(N.common.issues);
        return this._error = R, this._error;
      }
    };
  };
  function S(N) {
    if (!N)
      return {};
    const { errorMap: f, invalid_type_error: R, required_error: C, description: G } = N;
    if (f && (R || C))
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return f ? { errorMap: f, description: G } : { errorMap: (fe, ae) => {
      var _e, Te;
      const { message: Be } = N;
      return fe.code === "invalid_enum_value" ? { message: Be ?? ae.defaultError } : typeof ae.data > "u" ? { message: (_e = Be ?? C) !== null && _e !== void 0 ? _e : ae.defaultError } : fe.code !== "invalid_type" ? { message: ae.defaultError } : { message: (Te = Be ?? R) !== null && Te !== void 0 ? Te : ae.defaultError };
    }, description: G };
  }
  class B {
    constructor(f) {
      this.spa = this.safeParseAsync, this._def = f, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
    }
    get description() {
      return this._def.description;
    }
    _getType(f) {
      return (0, h.getParsedType)(f.data);
    }
    _getOrReturnCtx(f, R) {
      return R || {
        common: f.parent.common,
        data: f.data,
        parsedType: (0, h.getParsedType)(f.data),
        schemaErrorMap: this._def.errorMap,
        path: f.path,
        parent: f.parent
      };
    }
    _processInputParams(f) {
      return {
        status: new p.ParseStatus(),
        ctx: {
          common: f.parent.common,
          data: f.data,
          parsedType: (0, h.getParsedType)(f.data),
          schemaErrorMap: this._def.errorMap,
          path: f.path,
          parent: f.parent
        }
      };
    }
    _parseSync(f) {
      const R = this._parse(f);
      if ((0, p.isAsync)(R))
        throw new Error("Synchronous parse encountered promise.");
      return R;
    }
    _parseAsync(f) {
      const R = this._parse(f);
      return Promise.resolve(R);
    }
    parse(f, R) {
      const C = this.safeParse(f, R);
      if (C.success)
        return C.data;
      throw C.error;
    }
    safeParse(f, R) {
      var C;
      const G = {
        common: {
          issues: [],
          async: (C = R?.async) !== null && C !== void 0 ? C : !1,
          contextualErrorMap: R?.errorMap
        },
        path: R?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: f,
        parsedType: (0, h.getParsedType)(f)
      }, F = this._parseSync({ data: f, path: G.path, parent: G });
      return T(G, F);
    }
    async parseAsync(f, R) {
      const C = await this.safeParseAsync(f, R);
      if (C.success)
        return C.data;
      throw C.error;
    }
    async safeParseAsync(f, R) {
      const C = {
        common: {
          issues: [],
          contextualErrorMap: R?.errorMap,
          async: !0
        },
        path: R?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: f,
        parsedType: (0, h.getParsedType)(f)
      }, G = this._parse({ data: f, path: C.path, parent: C }), F = await ((0, p.isAsync)(G) ? G : Promise.resolve(G));
      return T(C, F);
    }
    refine(f, R) {
      const C = (G) => typeof R == "string" || typeof R > "u" ? { message: R } : typeof R == "function" ? R(G) : R;
      return this._refinement((G, F) => {
        const fe = f(G), ae = () => F.addIssue({
          code: m.ZodIssueCode.custom,
          ...C(G)
        });
        return typeof Promise < "u" && fe instanceof Promise ? fe.then((_e) => _e ? !0 : (ae(), !1)) : fe ? !0 : (ae(), !1);
      });
    }
    refinement(f, R) {
      return this._refinement((C, G) => f(C) ? !0 : (G.addIssue(typeof R == "function" ? R(C, G) : R), !1));
    }
    _refinement(f) {
      return new Z({
        schema: this,
        typeName: W.ZodEffects,
        effect: { type: "refinement", refinement: f }
      });
    }
    superRefine(f) {
      return this._refinement(f);
    }
    optional() {
      return H.create(this, this._def);
    }
    nullable() {
      return ee.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return Ze.create(this, this._def);
    }
    promise() {
      return V.create(this, this._def);
    }
    or(f) {
      return ot.create([this, f], this._def);
    }
    and(f) {
      return Mt.create(this, f, this._def);
    }
    transform(f) {
      return new Z({
        ...S(this._def),
        schema: this,
        typeName: W.ZodEffects,
        effect: { type: "transform", transform: f }
      });
    }
    default(f) {
      const R = typeof f == "function" ? f : () => f;
      return new re({
        ...S(this._def),
        innerType: this,
        defaultValue: R,
        typeName: W.ZodDefault
      });
    }
    brand() {
      return new se({
        typeName: W.ZodBranded,
        type: this,
        ...S(this._def)
      });
    }
    catch(f) {
      const R = typeof f == "function" ? f : () => f;
      return new Q({
        ...S(this._def),
        innerType: this,
        catchValue: R,
        typeName: W.ZodCatch
      });
    }
    describe(f) {
      const R = this.constructor;
      return new R({
        ...this._def,
        description: f
      });
    }
    pipe(f) {
      return ce.create(this, f);
    }
    readonly() {
      return de.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  t.ZodType = B, t.Schema = B, t.ZodSchema = B;
  const I = /^c[^\s-]{8,}$/i, O = /^[0-9a-z]+$/, F = /^[0-9A-HJKMNP-TV-Z]{26}$/, V = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, z = /^[a-z0-9_-]{21}$/i, J = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, ie = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, ye = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
  let ve;
  const Ae = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, Ee = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, Ce = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, Ve = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", Ue = new RegExp(`^${Ve}$`);
  function He(N) {
    let f = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
    return N.precision ? f = `${f}\\.\\d{${N.precision}}` : N.precision == null && (f = `${f}(\\.\\d+)?`), f;
  }
  function dt(N) {
    return new RegExp(`^${He(N)}$`);
  }
  function Je(N) {
    let f = `${Ve}T${He(N)}`;
    const R = [];
    return R.push(N.local ? "Z?" : "Z"), N.offset && R.push("([+-]\\d{2}:?\\d{2})"), f = `${f}(${R.join("|")})`, new RegExp(`^${f}$`);
  }
  t.datetimeRegex = Je;
  function Nt(N, f) {
    return !!((f === "v4" || !f) && Ae.test(N) || (f === "v6" || !f) && Ee.test(N));
  }
  class $e extends B {
    _parse(f) {
      if (this._def.coerce && (f.data = String(f.data)), this._getType(f) !== h.ZodParsedType.string) {
        const F = this._getOrReturnCtx(f);
        return (0, p.addIssueToContext)(F, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.string,
          received: F.parsedType
        }), p.INVALID;
      }
      const C = new p.ParseStatus();
      let G;
      for (const F of this._def.checks)
        if (F.kind === "min")
          f.data.length < F.value && (G = this._getOrReturnCtx(f, G), (0, p.addIssueToContext)(G, {
            code: m.ZodIssueCode.too_small,
            minimum: F.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: F.message
          }), C.dirty());
        else if (F.kind === "max")
          f.data.length > F.value && (G = this._getOrReturnCtx(f, G), (0, p.addIssueToContext)(G, {
            code: m.ZodIssueCode.too_big,
            maximum: F.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: F.message
          }), C.dirty());
        else if (F.kind === "length") {
          const fe = f.data.length > F.value, ae = f.data.length < F.value;
          (fe || ae) && (G = this._getOrReturnCtx(f, G), fe ? (0, p.addIssueToContext)(G, {
            code: m.ZodIssueCode.too_big,
            maximum: F.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: F.message
          }) : ae && (0, p.addIssueToContext)(G, {
            code: m.ZodIssueCode.too_small,
            minimum: F.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: F.message
          }), C.dirty());
        } else if (F.kind === "email")
          ie.test(f.data) || (G = this._getOrReturnCtx(f, G), (0, p.addIssueToContext)(G, {
            validation: "email",
            code: m.ZodIssueCode.invalid_string,
            message: F.message
          }), C.dirty());
        else if ($.kind === "emoji")
          ve || (ve = new RegExp(ye, "u")), ve.test(f.data) || (G = this._getOrReturnCtx(f, G), (0, p.addIssueToContext)(G, {
            validation: "emoji",
            code: m.ZodIssueCode.invalid_string,
            message: F.message
          }), C.dirty());
        else if (F.kind === "uuid")
          $.test(f.data) || (G = this._getOrReturnCtx(f, G), (0, p.addIssueToContext)(G, {
            validation: "uuid",
            code: m.ZodIssueCode.invalid_string,
            message: F.message
          }), C.dirty());
        else if (F.kind === "nanoid")
          z.test(f.data) || (G = this._getOrReturnCtx(f, G), (0, p.addIssueToContext)(G, {
            validation: "nanoid",
            code: m.ZodIssueCode.invalid_string,
            message: F.message
          }), C.dirty());
        else if (F.kind === "cuid")
          I.test(f.data) || (G = this._getOrReturnCtx(f, G), (0, p.addIssueToContext)(G, {
            validation: "cuid",
            code: m.ZodIssueCode.invalid_string,
            message: F.message
          }), C.dirty());
        else if (F.kind === "cuid2")
          O.test(f.data) || (G = this._getOrReturnCtx(f, G), (0, p.addIssueToContext)(G, {
            validation: "cuid2",
            code: m.ZodIssueCode.invalid_string,
            message: F.message
          }), C.dirty());
        else if (F.kind === "ulid")
          j.test(f.data) || (G = this._getOrReturnCtx(f, G), (0, p.addIssueToContext)(G, {
            validation: "ulid",
            code: m.ZodIssueCode.invalid_string,
            message: F.message
          }), C.dirty());
        else if (F.kind === "url")
          try {
            new URL(f.data);
          } catch {
            G = this._getOrReturnCtx(f, G), (0, p.addIssueToContext)(G, {
              validation: "url",
              code: m.ZodIssueCode.invalid_string,
              message: F.message
            }), C.dirty();
          }
        else $.kind === "regex" ? ($.regex.lastIndex = 0, $.regex.test(f.data) || (G = this._getOrReturnCtx(f, G), (0, p.addIssueToContext)(G, {
          validation: "regex",
          code: h.ZodIssueCode.invalid_string,
          message: $.message
        }), C.dirty())) : $.kind === "trim" ? f.data = f.data.trim() : $.kind === "includes" ? f.data.includes($.value, $.position) || (G = this._getOrReturnCtx(f, G), (0, p.addIssueToContext)(G, {
          code: h.ZodIssueCode.invalid_string,
          validation: { includes: $.value, position: $.position },
          message: $.message
        }), C.dirty()) : $.kind === "toLowerCase" ? f.data = f.data.toLowerCase() : $.kind === "toUpperCase" ? f.data = f.data.toUpperCase() : $.kind === "startsWith" ? f.data.startsWith($.value) || (G = this._getOrReturnCtx(f, G), (0, p.addIssueToContext)(G, {
          code: h.ZodIssueCode.invalid_string,
          validation: { startsWith: $.value },
          message: $.message
        }), C.dirty()) : $.kind === "endsWith" ? f.data.endsWith($.value) || (G = this._getOrReturnCtx(f, G), (0, p.addIssueToContext)(G, {
          code: h.ZodIssueCode.invalid_string,
          validation: { endsWith: $.value },
          message: $.message
        }), C.dirty()) : $.kind === "datetime" ? Je($).test(f.data) || (G = this._getOrReturnCtx(f, G), (0, p.addIssueToContext)(G, {
          code: h.ZodIssueCode.invalid_string,
          validation: "datetime",
          message: $.message
        }), C.dirty()) : $.kind === "date" ? Ue.test(f.data) || (G = this._getOrReturnCtx(f, G), (0, p.addIssueToContext)(G, {
          code: h.ZodIssueCode.invalid_string,
          validation: "date",
          message: $.message
        }), C.dirty()) : $.kind === "time" ? dt($).test(f.data) || (G = this._getOrReturnCtx(f, G), (0, p.addIssueToContext)(G, {
          code: h.ZodIssueCode.invalid_string,
          validation: "time",
          message: $.message
        }), C.dirty()) : $.kind === "duration" ? J.test(f.data) || (G = this._getOrReturnCtx(f, G), (0, p.addIssueToContext)(G, {
          validation: "duration",
          code: h.ZodIssueCode.invalid_string,
          message: $.message
        }), C.dirty()) : $.kind === "ip" ? Nt(f.data, $.version) || (G = this._getOrReturnCtx(f, G), (0, p.addIssueToContext)(G, {
          validation: "ip",
          code: h.ZodIssueCode.invalid_string,
          message: $.message
        }), C.dirty()) : $.kind === "base64" ? Ce.test(f.data) || (G = this._getOrReturnCtx(f, G), (0, p.addIssueToContext)(G, {
          validation: "base64",
          code: h.ZodIssueCode.invalid_string,
          message: $.message
        }), C.dirty()) : m.util.assertNever($);
      return { status: C.value, value: f.data };
    }
    _regex(f, R, C) {
      return this.refinement((G) => f.test(G), {
        validation: R,
        code: m.ZodIssueCode.invalid_string,
        ...y.errorUtil.errToObj(C)
      });
    }
    _addCheck(f) {
      return new $e({
        ...this._def,
        checks: [...this._def.checks, f]
      });
    }
    email(f) {
      return this._addCheck({ kind: "email", ...y.errorUtil.errToObj(f) });
    }
    url(f) {
      return this._addCheck({ kind: "url", ...y.errorUtil.errToObj(f) });
    }
    emoji(f) {
      return this._addCheck({ kind: "emoji", ...y.errorUtil.errToObj(f) });
    }
    uuid(f) {
      return this._addCheck({ kind: "uuid", ...y.errorUtil.errToObj(f) });
    }
    nanoid(f) {
      return this._addCheck({ kind: "nanoid", ...y.errorUtil.errToObj(f) });
    }
    cuid(f) {
      return this._addCheck({ kind: "cuid", ...y.errorUtil.errToObj(f) });
    }
    cuid2(f) {
      return this._addCheck({ kind: "cuid2", ...y.errorUtil.errToObj(f) });
    }
    ulid(f) {
      return this._addCheck({ kind: "ulid", ...y.errorUtil.errToObj(f) });
    }
    base64(f) {
      return this._addCheck({ kind: "base64", ...y.errorUtil.errToObj(f) });
    }
    ip(f) {
      return this._addCheck({ kind: "ip", ...y.errorUtil.errToObj(f) });
    }
    datetime(f) {
      var R, C;
      return typeof f == "string" ? this._addCheck({
        kind: "datetime",
        precision: null,
        offset: !1,
        local: !1,
        message: f
      }) : this._addCheck({
        kind: "datetime",
        precision: typeof f?.precision > "u" ? null : f?.precision,
        offset: (R = f?.offset) !== null && R !== void 0 ? R : !1,
        local: (C = f?.local) !== null && C !== void 0 ? C : !1,
        ...y.errorUtil.errToObj(f?.message)
      });
    }
    date(f) {
      return this._addCheck({ kind: "date", message: f });
    }
    time(f) {
      return typeof f == "string" ? this._addCheck({
        kind: "time",
        precision: null,
        message: f
      }) : this._addCheck({
        kind: "time",
        precision: typeof f?.precision > "u" ? null : f?.precision,
        ...y.errorUtil.errToObj(f?.message)
      });
    }
    duration(f) {
      return this._addCheck({ kind: "duration", ...y.errorUtil.errToObj(f) });
    }
    regex(f, R) {
      return this._addCheck({
        kind: "regex",
        regex: f,
        ...y.errorUtil.errToObj(R)
      });
    }
    includes(f, R) {
      return this._addCheck({
        kind: "includes",
        value: f,
        position: R?.position,
        ...y.errorUtil.errToObj(R?.message)
      });
    }
    startsWith(f, R) {
      return this._addCheck({
        kind: "startsWith",
        value: f,
        ...y.errorUtil.errToObj(R)
      });
    }
    endsWith(f, R) {
      return this._addCheck({
        kind: "endsWith",
        value: f,
        ...y.errorUtil.errToObj(R)
      });
    }
    min(f, R) {
      return this._addCheck({
        kind: "min",
        value: f,
        ...y.errorUtil.errToObj(R)
      });
    }
    max(f, R) {
      return this._addCheck({
        kind: "max",
        value: f,
        ...y.errorUtil.errToObj(R)
      });
    }
    length(f, R) {
      return this._addCheck({
        kind: "length",
        value: f,
        ...y.errorUtil.errToObj(R)
      });
    }
    /**
     * @deprecated Use z.string().min(1) instead.
     * @see {@link ZodString.min}
     */
    nonempty(f) {
      return this.min(1, y.errorUtil.errToObj(f));
    }
    trim() {
      return new $e({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new $e({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new $e({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((f) => f.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((f) => f.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((f) => f.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((f) => f.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((f) => f.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((f) => f.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((f) => f.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((f) => f.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((f) => f.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((f) => f.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((f) => f.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((f) => f.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((f) => f.kind === "ip");
    }
    get isBase64() {
      return !!this._def.checks.find((f) => f.kind === "base64");
    }
    get minLength() {
      let f = null;
      for (const R of this._def.checks)
        R.kind === "min" && (f === null || R.value > f) && (f = R.value);
      return f;
    }
    get maxLength() {
      let f = null;
      for (const R of this._def.checks)
        R.kind === "max" && (f === null || R.value < f) && (f = R.value);
      return f;
    }
  }
  t.ZodString = $e, $e.create = (N) => {
    var f;
    return new $e({
      checks: [],
      typeName: W.ZodString,
      coerce: (f = N?.coerce) !== null && f !== void 0 ? f : !1,
      ...S(N)
    });
  };
  function vt(N, f) {
    const R = (N.toString().split(".")[1] || "").length, C = (f.toString().split(".")[1] || "").length, G = R > C ? R : C, F = parseInt(N.toFixed(G).replace(".", "")), fe = parseInt(f.toFixed(G).replace(".", ""));
    return F % fe / Math.pow(10, G);
  }
  class pt extends B {
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
    }
    _parse(f) {
      if (this._def.coerce && (f.data = Number(f.data)), this._getType(f) !== h.ZodParsedType.number) {
        const F = this._getOrReturnCtx(f);
        return (0, p.addIssueToContext)(F, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.number,
          received: F.parsedType
        }), p.INVALID;
      }
      let C;
      const G = new p.ParseStatus();
      for (const F of this._def.checks)
        F.kind === "int" ? h.util.isInteger(f.data) || (C = this._getOrReturnCtx(f, C), (0, p.addIssueToContext)(C, {
          code: m.ZodIssueCode.invalid_type,
          expected: "integer",
          received: "float",
          message: F.message
        }), G.dirty()) : F.kind === "min" ? (F.inclusive ? f.data < F.value : f.data <= F.value) && (C = this._getOrReturnCtx(f, C), (0, p.addIssueToContext)(C, {
          code: m.ZodIssueCode.too_small,
          minimum: F.value,
          type: "number",
          inclusive: F.inclusive,
          exact: !1,
          message: F.message
        }), G.dirty()) : F.kind === "max" ? (F.inclusive ? f.data > F.value : f.data >= F.value) && (C = this._getOrReturnCtx(f, C), (0, p.addIssueToContext)(C, {
          code: m.ZodIssueCode.too_big,
          maximum: F.value,
          type: "number",
          inclusive: F.inclusive,
          exact: !1,
          message: F.message
        }), G.dirty()) : F.kind === "multipleOf" ? vt(f.data, F.value) !== 0 && (C = this._getOrReturnCtx(f, C), (0, p.addIssueToContext)(C, {
          code: m.ZodIssueCode.not_multiple_of,
          multipleOf: F.value,
          message: F.message
        }), G.dirty()) : F.kind === "finite" ? Number.isFinite(f.data) || (C = this._getOrReturnCtx(f, C), (0, p.addIssueToContext)(C, {
          code: m.ZodIssueCode.not_finite,
          message: F.message
        }), G.dirty()) : h.util.assertNever(F);
      return { status: G.value, value: f.data };
    }
    gte(f, R) {
      return this.setLimit("min", f, !0, y.errorUtil.toString(R));
    }
    gt(f, R) {
      return this.setLimit("min", f, !1, y.errorUtil.toString(R));
    }
    lte(f, R) {
      return this.setLimit("max", f, !0, y.errorUtil.toString(R));
    }
    lt(f, R) {
      return this.setLimit("max", f, !1, y.errorUtil.toString(R));
    }
    setLimit(f, R, C, G) {
      return new pt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: f,
            value: R,
            inclusive: C,
            message: y.errorUtil.toString(G)
          }
        ]
      });
    }
    _addCheck(f) {
      return new pt({
        ...this._def,
        checks: [...this._def.checks, f]
      });
    }
    int(f) {
      return this._addCheck({
        kind: "int",
        message: y.errorUtil.toString(f)
      });
    }
    positive(f) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !1,
        message: y.errorUtil.toString(f)
      });
    }
    negative(f) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !1,
        message: y.errorUtil.toString(f)
      });
    }
    nonpositive(f) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !0,
        message: y.errorUtil.toString(f)
      });
    }
    nonnegative(f) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !0,
        message: y.errorUtil.toString(f)
      });
    }
    multipleOf(f, R) {
      return this._addCheck({
        kind: "multipleOf",
        value: f,
        message: y.errorUtil.toString(R)
      });
    }
    finite(f) {
      return this._addCheck({
        kind: "finite",
        message: y.errorUtil.toString(f)
      });
    }
    safe(f) {
      return this._addCheck({
        kind: "min",
        inclusive: !0,
        value: Number.MIN_SAFE_INTEGER,
        message: y.errorUtil.toString(f)
      })._addCheck({
        kind: "max",
        inclusive: !0,
        value: Number.MAX_SAFE_INTEGER,
        message: y.errorUtil.toString(f)
      });
    }
    get minValue() {
      let f = null;
      for (const R of this._def.checks)
        R.kind === "min" && (f === null || R.value > f) && (f = R.value);
      return f;
    }
    get maxValue() {
      let f = null;
      for (const R of this._def.checks)
        R.kind === "max" && (f === null || R.value < f) && (f = R.value);
      return f;
    }
    get isInt() {
      return !!this._def.checks.find((f) => f.kind === "int" || f.kind === "multipleOf" && h.util.isInteger(f.value));
    }
    get isFinite() {
      let f = null, R = null;
      for (const C of this._def.checks) {
        if (C.kind === "finite" || C.kind === "int" || C.kind === "multipleOf")
          return !0;
        C.kind === "min" ? (R === null || C.value > R) && (R = C.value) : C.kind === "max" && (f === null || C.value < f) && (f = C.value);
      }
      return Number.isFinite(R) && Number.isFinite(f);
    }
  }
  t.ZodNumber = pt, pt.create = (N) => new pt({
    checks: [],
    typeName: W.ZodNumber,
    coerce: N?.coerce || !1,
    ...S(N)
  });
  class st extends B {
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte;
    }
    _parse(f) {
      if (this._def.coerce && (f.data = BigInt(f.data)), this._getType(f) !== h.ZodParsedType.bigint) {
        const F = this._getOrReturnCtx(f);
        return (0, p.addIssueToContext)(F, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.bigint,
          received: F.parsedType
        }), p.INVALID;
      }
      let C;
      const G = new p.ParseStatus();
      for (const F of this._def.checks)
        F.kind === "min" ? (F.inclusive ? f.data < F.value : f.data <= F.value) && (C = this._getOrReturnCtx(f, C), (0, p.addIssueToContext)(C, {
          code: m.ZodIssueCode.too_small,
          type: "bigint",
          minimum: F.value,
          inclusive: F.inclusive,
          message: F.message
        }), G.dirty()) : F.kind === "max" ? (F.inclusive ? f.data > F.value : f.data >= F.value) && (C = this._getOrReturnCtx(f, C), (0, p.addIssueToContext)(C, {
          code: m.ZodIssueCode.too_big,
          type: "bigint",
          maximum: F.value,
          inclusive: F.inclusive,
          message: F.message
        }), G.dirty()) : F.kind === "multipleOf" ? f.data % F.value !== BigInt(0) && (C = this._getOrReturnCtx(f, C), (0, p.addIssueToContext)(C, {
          code: m.ZodIssueCode.not_multiple_of,
          multipleOf: F.value,
          message: F.message
        }), G.dirty()) : h.util.assertNever(F);
      return { status: G.value, value: f.data };
    }
    gte(f, R) {
      return this.setLimit("min", f, !0, y.errorUtil.toString(R));
    }
    gt(f, R) {
      return this.setLimit("min", f, !1, y.errorUtil.toString(R));
    }
    lte(f, R) {
      return this.setLimit("max", f, !0, y.errorUtil.toString(R));
    }
    lt(f, R) {
      return this.setLimit("max", f, !1, y.errorUtil.toString(R));
    }
    setLimit(f, R, C, G) {
      return new st({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: f,
            value: R,
            inclusive: C,
            message: y.errorUtil.toString(G)
          }
        ]
      });
    }
    _addCheck(f) {
      return new st({
        ...this._def,
        checks: [...this._def.checks, f]
      });
    }
    positive(f) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !1,
        message: y.errorUtil.toString(f)
      });
    }
    negative(f) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !1,
        message: y.errorUtil.toString(f)
      });
    }
    nonpositive(f) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !0,
        message: y.errorUtil.toString(f)
      });
    }
    nonnegative(f) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !0,
        message: y.errorUtil.toString(f)
      });
    }
    multipleOf(f, R) {
      return this._addCheck({
        kind: "multipleOf",
        value: f,
        message: y.errorUtil.toString(R)
      });
    }
    get minValue() {
      let f = null;
      for (const R of this._def.checks)
        R.kind === "min" && (f === null || R.value > f) && (f = R.value);
      return f;
    }
    get maxValue() {
      let f = null;
      for (const R of this._def.checks)
        R.kind === "max" && (f === null || R.value < f) && (f = R.value);
      return f;
    }
  }
  t.ZodBigInt = st, st.create = (N) => {
    var f;
    return new st({
      checks: [],
      typeName: W.ZodBigInt,
      coerce: (f = N?.coerce) !== null && f !== void 0 ? f : !1,
      ...S(N)
    });
  };
  class Qe extends B {
    _parse(f) {
      if (this._def.coerce && (f.data = !!f.data), this._getType(f) !== h.ZodParsedType.boolean) {
        const C = this._getOrReturnCtx(f);
        return (0, p.addIssueToContext)(C, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.boolean,
          received: C.parsedType
        }), p.INVALID;
      }
      return (0, p.OK)(f.data);
    }
  }
  t.ZodBoolean = Qe, Qe.create = (N) => new Qe({
    typeName: W.ZodBoolean,
    coerce: N?.coerce || !1,
    ...S(N)
  });
  class ht extends B {
    _parse(f) {
      if (this._def.coerce && (f.data = new Date(f.data)), this._getType(f) !== h.ZodParsedType.date) {
        const F = this._getOrReturnCtx(f);
        return (0, p.addIssueToContext)(F, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.date,
          received: F.parsedType
        }), p.INVALID;
      }
      if (isNaN(f.data.getTime())) {
        const F = this._getOrReturnCtx(f);
        return (0, p.addIssueToContext)(F, {
          code: m.ZodIssueCode.invalid_date
        }), p.INVALID;
      }
      const C = new p.ParseStatus();
      let G;
      for (const F of this._def.checks)
        F.kind === "min" ? f.data.getTime() < F.value && (G = this._getOrReturnCtx(f, G), (0, p.addIssueToContext)(G, {
          code: m.ZodIssueCode.too_small,
          message: F.message,
          inclusive: !0,
          exact: !1,
          minimum: F.value,
          type: "date"
        }), C.dirty()) : F.kind === "max" ? f.data.getTime() > F.value && (G = this._getOrReturnCtx(f, G), (0, p.addIssueToContext)(G, {
          code: m.ZodIssueCode.too_big,
          message: F.message,
          inclusive: !0,
          exact: !1,
          maximum: F.value,
          type: "date"
        }), C.dirty()) : h.util.assertNever(F);
      return {
        status: C.value,
        value: new Date(f.data.getTime())
      };
    }
    _addCheck(f) {
      return new ht({
        ...this._def,
        checks: [...this._def.checks, f]
      });
    }
    min(f, R) {
      return this._addCheck({
        kind: "min",
        value: f.getTime(),
        message: y.errorUtil.toString(R)
      });
    }
    max(f, R) {
      return this._addCheck({
        kind: "max",
        value: f.getTime(),
        message: y.errorUtil.toString(R)
      });
    }
    get minDate() {
      let f = null;
      for (const R of this._def.checks)
        R.kind === "min" && (f === null || R.value > f) && (f = R.value);
      return f != null ? new Date(f) : null;
    }
    get maxDate() {
      let f = null;
      for (const R of this._def.checks)
        R.kind === "max" && (f === null || R.value < f) && (f = R.value);
      return f != null ? new Date(f) : null;
    }
  }
  t.ZodDate = ht, ht.create = (N) => new ht({
    checks: [],
    coerce: N?.coerce || !1,
    typeName: W.ZodDate,
    ...S(N)
  });
  class Me extends B {
    _parse(f) {
      if (this._getType(f) !== h.ZodParsedType.symbol) {
        const C = this._getOrReturnCtx(f);
        return (0, p.addIssueToContext)(C, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.symbol,
          received: C.parsedType
        }), p.INVALID;
      }
      return (0, p.OK)(f.data);
    }
  }
  t.ZodSymbol = Me, Me.create = (N) => new Me({
    typeName: W.ZodSymbol,
    ...S(N)
  });
  class Yt extends B {
    _parse(f) {
      if (this._getType(f) !== h.ZodParsedType.undefined) {
        const C = this._getOrReturnCtx(f);
        return (0, p.addIssueToContext)(C, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.undefined,
          received: C.parsedType
        }), p.INVALID;
      }
      return (0, p.OK)(f.data);
    }
  }
  t.ZodUndefined = Yt, Yt.create = (N) => new Yt({
    typeName: W.ZodUndefined,
    ...S(N)
  });
  class et extends B {
    _parse(f) {
      if (this._getType(f) !== h.ZodParsedType.null) {
        const C = this._getOrReturnCtx(f);
        return (0, p.addIssueToContext)(C, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.null,
          received: C.parsedType
        }), p.INVALID;
      }
      return (0, p.OK)(f.data);
    }
  }
  t.ZodNull = et, et.create = (N) => new et({
    typeName: W.ZodNull,
    ...S(N)
  });
  class fr extends B {
    constructor() {
      super(...arguments), this._any = !0;
    }
    _parse(f) {
      return (0, p.OK)(f.data);
    }
  }
  t.ZodAny = fr, fr.create = (N) => new fr({
    typeName: W.ZodAny,
    ...S(N)
  });
  class Rt extends B {
    constructor() {
      super(...arguments), this._unknown = !0;
    }
    _parse(f) {
      return (0, p.OK)(f.data);
    }
  }
  t.ZodUnknown = Rt, Rt.create = (N) => new Rt({
    typeName: W.ZodUnknown,
    ...S(N)
  });
  class lt extends B {
    _parse(f) {
      const R = this._getOrReturnCtx(f);
      return (0, p.addIssueToContext)(R, {
        code: m.ZodIssueCode.invalid_type,
        expected: h.ZodParsedType.never,
        received: R.parsedType
      }), p.INVALID;
    }
  }
  t.ZodNever = lt, lt.create = (N) => new lt({
    typeName: W.ZodNever,
    ...S(N)
  });
  class It extends B {
    _parse(f) {
      if (this._getType(f) !== h.ZodParsedType.undefined) {
        const C = this._getOrReturnCtx(f);
        return (0, p.addIssueToContext)(C, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.void,
          received: C.parsedType
        }), p.INVALID;
      }
      return (0, p.OK)(f.data);
    }
  }
  t.ZodVoid = It, It.create = (N) => new It({
    typeName: W.ZodVoid,
    ...S(N)
  });
  class Ze extends B {
    _parse(f) {
      const { ctx: R, status: C } = this._processInputParams(f), G = this._def;
      if (R.parsedType !== h.ZodParsedType.array)
        return (0, p.addIssueToContext)(R, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.array,
          received: R.parsedType
        }), p.INVALID;
      if (G.exactLength !== null) {
        const fe = R.data.length > G.exactLength.value, ae = R.data.length < G.exactLength.value;
        (fe || ae) && ((0, p.addIssueToContext)(R, {
          code: fe ? m.ZodIssueCode.too_big : m.ZodIssueCode.too_small,
          minimum: ae ? G.exactLength.value : void 0,
          maximum: fe ? G.exactLength.value : void 0,
          type: "array",
          inclusive: !0,
          exact: !0,
          message: G.exactLength.message
        }), C.dirty());
      }
      if (G.minLength !== null && R.data.length < G.minLength.value && ((0, p.addIssueToContext)(R, {
        code: m.ZodIssueCode.too_small,
        minimum: G.minLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: G.minLength.message
      }), C.dirty()), G.maxLength !== null && R.data.length > G.maxLength.value && ((0, p.addIssueToContext)(R, {
        code: m.ZodIssueCode.too_big,
        maximum: G.maxLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: G.maxLength.message
      }), C.dirty()), R.common.async)
        return Promise.all([...R.data].map((fe, ae) => G.type._parseAsync(new d(R, fe, R.path, ae)))).then((fe) => p.ParseStatus.mergeArray(C, fe));
      const F = [...R.data].map((fe, ae) => G.type._parseSync(new d(R, fe, R.path, ae)));
      return p.ParseStatus.mergeArray(C, F);
    }
    get element() {
      return this._def.type;
    }
    min(f, R) {
      return new Ze({
        ...this._def,
        minLength: { value: f, message: y.errorUtil.toString(R) }
      });
    }
    max(f, R) {
      return new Ze({
        ...this._def,
        maxLength: { value: f, message: y.errorUtil.toString(R) }
      });
    }
    length(f, R) {
      return new Ze({
        ...this._def,
        exactLength: { value: f, message: y.errorUtil.toString(R) }
      });
    }
    nonempty(f) {
      return this.min(1, f);
    }
  }
  t.ZodArray = Ze, Ze.create = (N, f) => new Ze({
    type: N,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: W.ZodArray,
    ...S(f)
  });
  function Vt(N) {
    if (N instanceof qe) {
      const f = {};
      for (const R in N.shape) {
        const C = N.shape[R];
        f[R] = H.create(Vt(C));
      }
      return new qe({
        ...N._def,
        shape: () => f
      });
    } else return N instanceof Ze ? new Ze({
      ...N._def,
      type: Vt(N.element)
    }) : N instanceof H ? H.create(Vt(N.unwrap())) : N instanceof ee ? ee.create(Vt(N.unwrap())) : N instanceof yr ? yr.create(N.items.map((f) => Vt(f))) : N;
  }
  class qe extends B {
    constructor() {
      super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const f = this._def.shape(), R = h.util.objectKeys(f);
      return this._cached = { shape: f, keys: R };
    }
    _parse(f) {
      if (this._getType(f) !== m.ZodParsedType.object) {
        const Te = this._getOrReturnCtx(f);
        return (0, p.addIssueToContext)(Te, {
          code: h.ZodIssueCode.invalid_type,
          expected: m.ZodParsedType.object,
          received: Te.parsedType
        }), p.INVALID;
      }
      const { status: C, ctx: G } = this._processInputParams(f), { shape: $, keys: fe } = this._getCached(), ae = [];
      if (!(this._def.catchall instanceof lt && this._def.unknownKeys === "strip"))
        for (const Te in G.data)
          fe.includes(Te) || ae.push(Te);
      const _e = [];
      for (const Te of fe) {
        const Be = $[Te], br = G.data[Te];
        _e.push({
          key: { status: "valid", value: Te },
          value: Be._parse(new d(G, br, G.path, Te)),
          alwaysSet: Te in G.data
        });
      }
      if (this._def.catchall instanceof lt) {
        const Te = this._def.unknownKeys;
        if (Te === "passthrough")
          for (const Be of ae)
            _e.push({
              key: { status: "valid", value: Be },
              value: { status: "valid", value: G.data[Be] }
            });
        else if (Te === "strict")
          ae.length > 0 && ((0, p.addIssueToContext)(G, {
            code: m.ZodIssueCode.unrecognized_keys,
            keys: ae
          }), C.dirty());
        else if (Te !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
      } else {
        const Te = this._def.catchall;
        for (const Be of ae) {
          const br = G.data[Be];
          _e.push({
            key: { status: "valid", value: Be },
            value: Te._parse(
              new d(G, br, G.path, Be)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: Be in G.data
          });
        }
      }
      return G.common.async ? Promise.resolve().then(async () => {
        const Te = [];
        for (const Be of _e) {
          const br = await Be.key, xo = await Be.value;
          Te.push({
            key: br,
            value: xo,
            alwaysSet: Be.alwaysSet
          });
        }
        return Te;
      }).then((Te) => p.ParseStatus.mergeObjectSync(C, Te)) : p.ParseStatus.mergeObjectSync(C, _e);
    }
    get shape() {
      return this._def.shape();
    }
    strict(f) {
      return y.errorUtil.errToObj, new qe({
        ...this._def,
        unknownKeys: "strict",
        ...f !== void 0 ? {
          errorMap: (R, C) => {
            var G, $, fe, ae;
            const _e = (fe = ($ = (G = this._def).errorMap) === null || $ === void 0 ? void 0 : $.call(G, R, C).message) !== null && fe !== void 0 ? fe : C.defaultError;
            return R.code === "unrecognized_keys" ? {
              message: (ae = y.errorUtil.errToObj(f).message) !== null && ae !== void 0 ? ae : _e
            } : {
              message: _e
            };
          }
        } : {}
      });
    }
    strip() {
      return new qe({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new qe({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(f) {
      return new qe({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...f
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(f) {
      return new qe({
        unknownKeys: f._def.unknownKeys,
        catchall: f._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...f._def.shape()
        }),
        typeName: W.ZodObject
      });
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(f, R) {
      return this.augment({ [f]: R });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(f) {
      return new qe({
        ...this._def,
        catchall: f
      });
    }
    pick(f) {
      const R = {};
      return h.util.objectKeys(f).forEach((C) => {
        f[C] && this.shape[C] && (R[C] = this.shape[C]);
      }), new qe({
        ...this._def,
        shape: () => R
      });
    }
    omit(f) {
      const R = {};
      return h.util.objectKeys(this.shape).forEach((C) => {
        f[C] || (R[C] = this.shape[C]);
      }), new qe({
        ...this._def,
        shape: () => R
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return Vt(this);
    }
    partial(f) {
      const R = {};
      return h.util.objectKeys(this.shape).forEach((C) => {
        const G = this.shape[C];
        f && !f[C] ? R[C] = G : R[C] = G.optional();
      }), new qe({
        ...this._def,
        shape: () => R
      });
    }
    required(f) {
      const R = {};
      return h.util.objectKeys(this.shape).forEach((C) => {
        if (f && !f[C])
          R[C] = this.shape[C];
        else {
          let F = this.shape[C];
          for (; F instanceof H; )
            F = F._def.innerType;
          R[C] = F;
        }
      }), new qe({
        ...this._def,
        shape: () => R
      });
    }
    keyof() {
      return L(h.util.objectKeys(this.shape));
    }
  }
  t.ZodObject = qe, qe.create = (N, f) => new qe({
    shape: () => N,
    unknownKeys: "strip",
    catchall: lt.create(),
    typeName: W.ZodObject,
    ...S(f)
  }), qe.strictCreate = (N, f) => new qe({
    shape: () => N,
    unknownKeys: "strict",
    catchall: lt.create(),
    typeName: W.ZodObject,
    ...S(f)
  }), qe.lazycreate = (N, f) => new qe({
    shape: N,
    unknownKeys: "strip",
    catchall: lt.create(),
    typeName: W.ZodObject,
    ...S(f)
  });
  class ot extends B {
    _parse(f) {
      const { ctx: R } = this._processInputParams(f), C = this._def.options;
      function G(F) {
        for (const ae of F)
          if (ae.result.status === "valid")
            return ae.result;
        for (const ae of F)
          if (ae.result.status === "dirty")
            return R.common.issues.push(...ae.ctx.common.issues), ae.result;
        const fe = F.map((ae) => new m.ZodError(ae.ctx.common.issues));
        return (0, p.addIssueToContext)(R, {
          code: m.ZodIssueCode.invalid_union,
          unionErrors: fe
        }), p.INVALID;
      }
      if (R.common.async)
        return Promise.all(C.map(async (F) => {
          const fe = {
            ...R,
            common: {
              ...R.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await F._parseAsync({
              data: R.data,
              path: R.path,
              parent: fe
            }),
            ctx: fe
          };
        })).then(G);
      {
        let F;
        const fe = [];
        for (const _e of C) {
          const Te = {
            ...R,
            common: {
              ...R.common,
              issues: []
            },
            parent: null
          }, Be = _e._parseSync({
            data: R.data,
            path: R.path,
            parent: Te
          });
          if (Be.status === "valid")
            return Be;
          Be.status === "dirty" && !$ && ($ = { result: Be, ctx: Te }), Te.common.issues.length && fe.push(Te.common.issues);
        }
        if ($)
          return R.common.issues.push(...$.ctx.common.issues), $.result;
        const ae = fe.map((_e) => new h.ZodError(_e));
        return (0, p.addIssueToContext)(R, {
          code: m.ZodIssueCode.invalid_union,
          unionErrors: ae
        }), p.INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  t.ZodUnion = ot, ot.create = (N, f) => new ot({
    options: N,
    typeName: W.ZodUnion,
    ...S(f)
  });
  const Ut = (N) => N instanceof X ? Ut(N.schema) : N instanceof Z ? Ut(N.innerType()) : N instanceof b ? [N.value] : N instanceof k ? N.options : N instanceof U ? m.util.objectValues(N.enum) : N instanceof re ? Ut(N._def.innerType) : N instanceof Yt ? [void 0] : N instanceof et ? [null] : N instanceof H ? [void 0, ...Ut(N.unwrap())] : N instanceof ee ? [null, ...Ut(N.unwrap())] : N instanceof se || N instanceof de ? Ut(N.unwrap()) : N instanceof Q ? Ut(N._def.innerType) : [];
  class At extends B {
    _parse(f) {
      const { ctx: R } = this._processInputParams(f);
      if (R.parsedType !== h.ZodParsedType.object)
        return (0, p.addIssueToContext)(R, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.object,
          received: R.parsedType
        }), p.INVALID;
      const C = this.discriminator, G = R.data[C], F = this.optionsMap.get(G);
      return F ? R.common.async ? F._parseAsync({
        data: R.data,
        path: R.path,
        parent: R
      }) : F._parseSync({
        data: R.data,
        path: R.path,
        parent: R
      }) : ((0, p.addIssueToContext)(R, {
        code: m.ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [C]
      }), p.INVALID);
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(f, R, C) {
      const G = /* @__PURE__ */ new Map();
      for (const F of R) {
        const fe = Ut(F.shape[f]);
        if (!fe.length)
          throw new Error(`A discriminator value for key \`${f}\` could not be extracted from all schema options`);
        for (const ae of fe) {
          if (G.has(ae))
            throw new Error(`Discriminator property ${String(f)} has duplicate value ${String(ae)}`);
          G.set(ae, F);
        }
      }
      return new At({
        typeName: W.ZodDiscriminatedUnion,
        discriminator: f,
        options: R,
        optionsMap: G,
        ...S(C)
      });
    }
  }
  t.ZodDiscriminatedUnion = At;
  function mr(N, f) {
    const R = (0, h.getParsedType)(N), C = (0, h.getParsedType)(f);
    if (N === f)
      return { valid: !0, data: N };
    if (R === m.ZodParsedType.object && C === m.ZodParsedType.object) {
      const G = m.util.objectKeys(f), $ = m.util.objectKeys(N).filter((ae) => G.indexOf(ae) !== -1), fe = { ...N, ...f };
      for (const ae of $) {
        const _e = mr(N[ae], f[ae]);
        if (!_e.valid)
          return { valid: !1 };
        fe[ae] = _e.data;
      }
      return { valid: !0, data: fe };
    } else if (R === h.ZodParsedType.array && C === h.ZodParsedType.array) {
      if (N.length !== f.length)
        return { valid: !1 };
      const G = [];
      for (let $ = 0; $ < N.length; $++) {
        const fe = N[$], ae = f[$], _e = mr(fe, ae);
        if (!_e.valid)
          return { valid: !1 };
        G.push(_e.data);
      }
      return { valid: !0, data: G };
    } else return R === m.ZodParsedType.date && C === m.ZodParsedType.date && +N == +f ? { valid: !0, data: N } : { valid: !1 };
  }
  class Mt extends B {
    _parse(f) {
      const { status: R, ctx: C } = this._processInputParams(f), G = (F, fe) => {
        if ((0, p.isAborted)(F) || (0, p.isAborted)(fe))
          return p.INVALID;
        const ae = mr(F.value, fe.value);
        return ae.valid ? (((0, p.isDirty)(F) || (0, p.isDirty)(fe)) && R.dirty(), { status: R.value, value: ae.data }) : ((0, p.addIssueToContext)(C, {
          code: m.ZodIssueCode.invalid_intersection_types
        }), p.INVALID);
      };
      return C.common.async ? Promise.all([
        this._def.left._parseAsync({
          data: C.data,
          path: C.path,
          parent: C
        }),
        this._def.right._parseAsync({
          data: C.data,
          path: C.path,
          parent: C
        })
      ]).then(([F, fe]) => G(F, fe)) : G(this._def.left._parseSync({
        data: C.data,
        path: C.path,
        parent: C
      }), this._def.right._parseSync({
        data: C.data,
        path: C.path,
        parent: C
      }));
    }
  }
  t.ZodIntersection = Mt, Mt.create = (N, f, R) => new Mt({
    left: N,
    right: f,
    typeName: W.ZodIntersection,
    ...S(R)
  });
  class yr extends B {
    _parse(f) {
      const { status: R, ctx: C } = this._processInputParams(f);
      if (C.parsedType !== h.ZodParsedType.array)
        return (0, p.addIssueToContext)(C, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.array,
          received: C.parsedType
        }), p.INVALID;
      if (C.data.length < this._def.items.length)
        return (0, p.addIssueToContext)(C, {
          code: m.ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array"
        }), p.INVALID;
      !this._def.rest && C.data.length > this._def.items.length && ((0, p.addIssueToContext)(C, {
        code: m.ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), R.dirty());
      const $ = [...C.data].map((fe, ae) => {
        const _e = this._def.items[ae] || this._def.rest;
        return _e ? _e._parse(new d(C, fe, C.path, ae)) : null;
      }).filter((fe) => !!fe);
      return C.common.async ? Promise.all(F).then((fe) => p.ParseStatus.mergeArray(R, fe)) : p.ParseStatus.mergeArray(R, F);
    }
    get items() {
      return this._def.items;
    }
    rest(f) {
      return new yr({
        ...this._def,
        rest: f
      });
    }
  }
  t.ZodTuple = yr, yr.create = (N, f) => {
    if (!Array.isArray(N))
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new yr({
      items: N,
      typeName: W.ZodTuple,
      rest: null,
      ...S(f)
    });
  };
  class Nr extends B {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(f) {
      const { status: R, ctx: C } = this._processInputParams(f);
      if (C.parsedType !== h.ZodParsedType.object)
        return (0, p.addIssueToContext)(C, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.object,
          received: C.parsedType
        }), p.INVALID;
      const G = [], F = this._def.keyType, fe = this._def.valueType;
      for (const ae in C.data)
        G.push({
          key: F._parse(new d(C, ae, C.path, ae)),
          value: fe._parse(new d(C, C.data[ae], C.path, ae)),
          alwaysSet: ae in C.data
        });
      return C.common.async ? p.ParseStatus.mergeObjectAsync(R, G) : p.ParseStatus.mergeObjectSync(R, G);
    }
    get element() {
      return this._def.valueType;
    }
    static create(f, R, C) {
      return R instanceof B ? new Nr({
        keyType: f,
        valueType: R,
        typeName: W.ZodRecord,
        ...S(C)
      }) : new Nr({
        keyType: $e.create(),
        valueType: f,
        typeName: W.ZodRecord,
        ...S(R)
      });
    }
  }
  t.ZodRecord = Nr;
  class Ni extends B {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(f) {
      const { status: R, ctx: C } = this._processInputParams(f);
      if (C.parsedType !== h.ZodParsedType.map)
        return (0, p.addIssueToContext)(C, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.map,
          received: C.parsedType
        }), p.INVALID;
      const G = this._def.keyType, $ = this._def.valueType, fe = [...C.data.entries()].map(([ae, _e], Te) => ({
        key: G._parse(new d(C, ae, C.path, [Te, "key"])),
        value: $._parse(new d(C, _e, C.path, [Te, "value"]))
      }));
      if (C.common.async) {
        const ae = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const _e of fe) {
            const Te = await _e.key, Be = await _e.value;
            if (Te.status === "aborted" || Be.status === "aborted")
              return p.INVALID;
            (Te.status === "dirty" || Be.status === "dirty") && R.dirty(), ae.set(Te.value, Be.value);
          }
          return { status: R.value, value: ae };
        });
      } else {
        const ae = /* @__PURE__ */ new Map();
        for (const _e of fe) {
          const Te = _e.key, Be = _e.value;
          if (Te.status === "aborted" || Be.status === "aborted")
            return p.INVALID;
          (Te.status === "dirty" || Be.status === "dirty") && R.dirty(), ae.set(Te.value, Be.value);
        }
        return { status: R.value, value: ae };
      }
    }
  }
  t.ZodMap = Ni, Ni.create = (N, f, R) => new Ni({
    valueType: f,
    keyType: N,
    typeName: W.ZodMap,
    ...S(R)
  });
  class vr extends B {
    _parse(f) {
      const { status: R, ctx: C } = this._processInputParams(f);
      if (C.parsedType !== h.ZodParsedType.set)
        return (0, p.addIssueToContext)(C, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.set,
          received: C.parsedType
        }), p.INVALID;
      const G = this._def;
      G.minSize !== null && C.data.size < G.minSize.value && ((0, p.addIssueToContext)(C, {
        code: m.ZodIssueCode.too_small,
        minimum: G.minSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: G.minSize.message
      }), R.dirty()), G.maxSize !== null && C.data.size > G.maxSize.value && ((0, p.addIssueToContext)(C, {
        code: m.ZodIssueCode.too_big,
        maximum: G.maxSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: G.maxSize.message
      }), R.dirty());
      const $ = this._def.valueType;
      function fe(_e) {
        const Te = /* @__PURE__ */ new Set();
        for (const Be of _e) {
          if (Be.status === "aborted")
            return p.INVALID;
          Be.status === "dirty" && R.dirty(), Te.add(Be.value);
        }
        return { status: R.value, value: Te };
      }
      const ae = [...C.data.values()].map((_e, Te) => $._parse(new d(C, _e, C.path, Te)));
      return C.common.async ? Promise.all(ae).then((_e) => fe(_e)) : fe(ae);
    }
    min(f, R) {
      return new vr({
        ...this._def,
        minSize: { value: f, message: y.errorUtil.toString(R) }
      });
    }
    max(f, R) {
      return new vr({
        ...this._def,
        maxSize: { value: f, message: y.errorUtil.toString(R) }
      });
    }
    size(f, R) {
      return this.min(f, R).max(f, R);
    }
    nonempty(f) {
      return this.min(1, f);
    }
  }
  t.ZodSet = vr, vr.create = (N, f) => new vr({
    valueType: N,
    minSize: null,
    maxSize: null,
    typeName: W.ZodSet,
    ...S(f)
  });
  class _ extends B {
    constructor() {
      super(...arguments), this.validate = this.implement;
    }
    _parse(f) {
      const { ctx: R } = this._processInputParams(f);
      if (R.parsedType !== h.ZodParsedType.function)
        return (0, p.addIssueToContext)(R, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.function,
          received: R.parsedType
        }), p.INVALID;
      function C(ae, _e) {
        return (0, p.makeIssue)({
          data: ae,
          path: R.path,
          errorMaps: [
            R.common.contextualErrorMap,
            R.schemaErrorMap,
            (0, x.getErrorMap)(),
            x.defaultErrorMap
          ].filter((Te) => !!Te),
          issueData: {
            code: h.ZodIssueCode.invalid_arguments,
            argumentsError: _e
          }
        });
      }
      function G(ae, _e) {
        return (0, p.makeIssue)({
          data: ae,
          path: R.path,
          errorMaps: [
            R.common.contextualErrorMap,
            R.schemaErrorMap,
            (0, x.getErrorMap)(),
            x.defaultErrorMap
          ].filter((Te) => !!Te),
          issueData: {
            code: h.ZodIssueCode.invalid_return_type,
            returnTypeError: _e
          }
        });
      }
      const F = { errorMap: R.common.contextualErrorMap }, fe = R.data;
      if (this._def.returns instanceof V) {
        const ae = this;
        return (0, p.OK)(async function(..._e) {
          const Te = new h.ZodError([]), Be = await ae._def.args.parseAsync(_e, $).catch((aa) => {
            throw Te.addIssue(C(_e, aa)), Te;
          }), br = await Reflect.apply(fe, this, Be);
          return await ae._def.returns._def.type.parseAsync(br, $).catch((aa) => {
            throw Te.addIssue(G(br, aa)), Te;
          });
        });
      } else {
        const ae = this;
        return (0, p.OK)(function(..._e) {
          const Te = ae._def.args.safeParse(_e, $);
          if (!Te.success)
            throw new h.ZodError([C(_e, Te.error)]);
          const Be = Reflect.apply(fe, this, Te.data), br = ae._def.returns.safeParse(Be, $);
          if (!br.success)
            throw new m.ZodError([G(Be, br.error)]);
          return br.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...f) {
      return new _({
        ...this._def,
        args: yr.create(f).rest(Rt.create())
      });
    }
    returns(f) {
      return new _({
        ...this._def,
        returns: f
      });
    }
    implement(f) {
      return this.parse(f);
    }
    strictImplement(f) {
      return this.parse(f);
    }
    static create(f, R, C) {
      return new _({
        args: f || yr.create([]).rest(Rt.create()),
        returns: R || Rt.create(),
        typeName: W.ZodFunction,
        ...S(C)
      });
    }
  }
  t.ZodFunction = _;
  class X extends B {
    get schema() {
      return this._def.getter();
    }
    _parse(f) {
      const { ctx: R } = this._processInputParams(f);
      return this._def.getter()._parse({ data: R.data, path: R.path, parent: R });
    }
  }
  t.ZodLazy = X, X.create = (N, f) => new X({
    getter: N,
    typeName: W.ZodLazy,
    ...S(f)
  });
  class b extends B {
    _parse(f) {
      if (f.data !== this._def.value) {
        const R = this._getOrReturnCtx(f);
        return (0, p.addIssueToContext)(R, {
          received: R.data,
          code: m.ZodIssueCode.invalid_literal,
          expected: this._def.value
        }), p.INVALID;
      }
      return { status: "valid", value: f.data };
    }
    get value() {
      return this._def.value;
    }
  }
  t.ZodLiteral = b, b.create = (N, f) => new b({
    value: N,
    typeName: W.ZodLiteral,
    ...S(f)
  });
  function L(N, f) {
    return new k({
      values: N,
      typeName: W.ZodEnum,
      ...S(f)
    });
  }
  class k extends B {
    constructor() {
      super(...arguments), a.set(this, void 0);
    }
    _parse(f) {
      if (typeof f.data != "string") {
        const R = this._getOrReturnCtx(f), C = this._def.values;
        return (0, p.addIssueToContext)(R, {
          expected: h.util.joinValues(C),
          received: R.parsedType,
          code: m.ZodIssueCode.invalid_type
        }), p.INVALID;
      }
      if (e(this, a, "f") || r(this, a, new Set(this._def.values), "f"), !e(this, a, "f").has(f.data)) {
        const R = this._getOrReturnCtx(f), C = this._def.values;
        return (0, p.addIssueToContext)(R, {
          received: R.data,
          code: m.ZodIssueCode.invalid_enum_value,
          options: C
        }), p.INVALID;
      }
      return (0, p.OK)(f.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const f = {};
      for (const R of this._def.values)
        f[R] = R;
      return f;
    }
    get Values() {
      const f = {};
      for (const R of this._def.values)
        f[R] = R;
      return f;
    }
    get Enum() {
      const f = {};
      for (const R of this._def.values)
        f[R] = R;
      return f;
    }
    extract(f, R = this._def) {
      return k.create(f, {
        ...this._def,
        ...R
      });
    }
    exclude(f, R = this._def) {
      return k.create(this.options.filter((C) => !f.includes(C)), {
        ...this._def,
        ...R
      });
    }
  }
  t.ZodEnum = k, a = /* @__PURE__ */ new WeakMap(), k.create = L;
  class U extends B {
    constructor() {
      super(...arguments), u.set(this, void 0);
    }
    _parse(f) {
      const R = h.util.getValidEnumValues(this._def.values), C = this._getOrReturnCtx(f);
      if (C.parsedType !== h.ZodParsedType.string && C.parsedType !== h.ZodParsedType.number) {
        const G = h.util.objectValues(R);
        return (0, p.addIssueToContext)(C, {
          expected: h.util.joinValues(G),
          received: C.parsedType,
          code: m.ZodIssueCode.invalid_type
        }), p.INVALID;
      }
      if (e(this, u, "f") || r(this, u, new Set(h.util.getValidEnumValues(this._def.values)), "f"), !e(this, u, "f").has(f.data)) {
        const G = h.util.objectValues(R);
        return (0, p.addIssueToContext)(C, {
          received: C.data,
          code: m.ZodIssueCode.invalid_enum_value,
          options: G
        }), p.INVALID;
      }
      return (0, p.OK)(f.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  t.ZodNativeEnum = U, u = /* @__PURE__ */ new WeakMap(), U.create = (N, f) => new U({
    values: N,
    typeName: W.ZodNativeEnum,
    ...S(f)
  });
  class V extends B {
    unwrap() {
      return this._def.type;
    }
    _parse(f) {
      const { ctx: R } = this._processInputParams(f);
      if (R.parsedType !== h.ZodParsedType.promise && R.common.async === !1)
        return (0, p.addIssueToContext)(R, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.promise,
          received: R.parsedType
        }), p.INVALID;
      const C = R.parsedType === h.ZodParsedType.promise ? R.data : Promise.resolve(R.data);
      return (0, p.OK)(C.then((G) => this._def.type.parseAsync(G, {
        path: R.path,
        errorMap: R.common.contextualErrorMap
      })));
    }
  }
  t.ZodPromise = V, V.create = (N, f) => new V({
    type: N,
    typeName: W.ZodPromise,
    ...S(f)
  });
  class Z extends B {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === W.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(f) {
      const { status: R, ctx: C } = this._processInputParams(f), G = this._def.effect || null, F = {
        addIssue: (fe) => {
          (0, p.addIssueToContext)(C, fe), fe.fatal ? R.abort() : R.dirty();
        },
        get path() {
          return C.path;
        }
      };
      if (F.addIssue = F.addIssue.bind(F), G.type === "preprocess") {
        const fe = G.transform(C.data, F);
        if (C.common.async)
          return Promise.resolve(fe).then(async (ae) => {
            if (R.value === "aborted")
              return p.INVALID;
            const _e = await this._def.schema._parseAsync({
              data: ae,
              path: C.path,
              parent: C
            });
            return _e.status === "aborted" ? p.INVALID : _e.status === "dirty" || R.value === "dirty" ? (0, p.DIRTY)(_e.value) : _e;
          });
        {
          if (R.value === "aborted")
            return p.INVALID;
          const ae = this._def.schema._parseSync({
            data: fe,
            path: C.path,
            parent: C
          });
          return ae.status === "aborted" ? p.INVALID : ae.status === "dirty" || R.value === "dirty" ? (0, p.DIRTY)(ae.value) : ae;
        }
      }
      if (G.type === "refinement") {
        const fe = (ae) => {
          const _e = G.refinement(ae, $);
          if (C.common.async)
            return Promise.resolve(_e);
          if (_e instanceof Promise)
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          return ae;
        };
        if (C.common.async === !1) {
          const ae = this._def.schema._parseSync({
            data: C.data,
            path: C.path,
            parent: C
          });
          return ae.status === "aborted" ? p.INVALID : (ae.status === "dirty" && R.dirty(), fe(ae.value), { status: R.value, value: ae.value });
        } else
          return this._def.schema._parseAsync({ data: C.data, path: C.path, parent: C }).then((ae) => ae.status === "aborted" ? p.INVALID : (ae.status === "dirty" && R.dirty(), fe(ae.value).then(() => ({ status: R.value, value: ae.value }))));
      }
      if (G.type === "transform")
        if (C.common.async === !1) {
          const fe = this._def.schema._parseSync({
            data: C.data,
            path: C.path,
            parent: C
          });
          if (!(0, p.isValid)(fe))
            return fe;
          const ae = G.transform(fe.value, F);
          if (ae instanceof Promise)
            throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
          return { status: R.value, value: ae };
        } else
          return this._def.schema._parseAsync({ data: C.data, path: C.path, parent: C }).then((fe) => (0, p.isValid)(fe) ? Promise.resolve(G.transform(fe.value, F)).then((ae) => ({ status: R.value, value: ae })) : fe);
      h.util.assertNever(G);
    }
  }
  t.ZodEffects = Z, t.ZodTransformer = Z, Z.create = (N, f, R) => new Z({
    schema: N,
    typeName: W.ZodEffects,
    effect: f,
    ...S(R)
  }), Z.createWithPreprocess = (N, f, R) => new Z({
    schema: f,
    effect: { type: "preprocess", transform: N },
    typeName: W.ZodEffects,
    ...S(R)
  });
  class H extends B {
    _parse(f) {
      return this._getType(f) === h.ZodParsedType.undefined ? (0, p.OK)(void 0) : this._def.innerType._parse(f);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  t.ZodOptional = H, H.create = (N, f) => new H({
    innerType: N,
    typeName: W.ZodOptional,
    ...S(f)
  });
  class ee extends B {
    _parse(f) {
      return this._getType(f) === h.ZodParsedType.null ? (0, p.OK)(null) : this._def.innerType._parse(f);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  t.ZodNullable = ee, ee.create = (N, f) => new ee({
    innerType: N,
    typeName: W.ZodNullable,
    ...S(f)
  });
  class re extends B {
    _parse(f) {
      const { ctx: R } = this._processInputParams(f);
      let C = R.data;
      return R.parsedType === h.ZodParsedType.undefined && (C = this._def.defaultValue()), this._def.innerType._parse({
        data: C,
        path: R.path,
        parent: R
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  t.ZodDefault = re, re.create = (N, f) => new re({
    innerType: N,
    typeName: W.ZodDefault,
    defaultValue: typeof f.default == "function" ? f.default : () => f.default,
    ...S(f)
  });
  class Q extends B {
    _parse(f) {
      const { ctx: R } = this._processInputParams(f), C = {
        ...R,
        common: {
          ...R.common,
          issues: []
        }
      }, G = this._def.innerType._parse({
        data: C.data,
        path: C.path,
        parent: {
          ...C
        }
      });
      return (0, p.isAsync)(G) ? G.then((F) => ({
        status: "valid",
        value: F.status === "valid" ? F.value : this._def.catchValue({
          get error() {
            return new m.ZodError(C.common.issues);
          },
          input: C.data
        })
      })) : {
        status: "valid",
        value: G.status === "valid" ? G.value : this._def.catchValue({
          get error() {
            return new m.ZodError(C.common.issues);
          },
          input: C.data
        })
      };
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  t.ZodCatch = Q, Q.create = (N, f) => new Q({
    innerType: N,
    typeName: W.ZodCatch,
    catchValue: typeof f.catch == "function" ? f.catch : () => f.catch,
    ...S(f)
  });
  class oe extends B {
    _parse(f) {
      if (this._getType(f) !== h.ZodParsedType.nan) {
        const C = this._getOrReturnCtx(f);
        return (0, p.addIssueToContext)(C, {
          code: m.ZodIssueCode.invalid_type,
          expected: h.ZodParsedType.nan,
          received: C.parsedType
        }), p.INVALID;
      }
      return { status: "valid", value: f.data };
    }
  }
  t.ZodNaN = oe, oe.create = (N) => new oe({
    typeName: W.ZodNaN,
    ...S(N)
  }), t.BRAND = Symbol("zod_brand");
  class se extends B {
    _parse(f) {
      const { ctx: R } = this._processInputParams(f), C = R.data;
      return this._def.type._parse({
        data: C,
        path: R.path,
        parent: R
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  t.ZodBranded = se;
  class ce extends B {
    _parse(f) {
      const { status: R, ctx: C } = this._processInputParams(f);
      if (C.common.async)
        return (async () => {
          const F = await this._def.in._parseAsync({
            data: C.data,
            path: C.path,
            parent: C
          });
          return F.status === "aborted" ? p.INVALID : F.status === "dirty" ? (R.dirty(), (0, p.DIRTY)(F.value)) : this._def.out._parseAsync({
            data: F.value,
            path: C.path,
            parent: C
          });
        })();
      {
        const G = this._def.in._parseSync({
          data: C.data,
          path: C.path,
          parent: C
        });
        return G.status === "aborted" ? p.INVALID : G.status === "dirty" ? (R.dirty(), {
          status: "dirty",
          value: G.value
        }) : this._def.out._parseSync({
          data: G.value,
          path: C.path,
          parent: C
        });
      }
    }
    static create(f, R) {
      return new ce({
        in: f,
        out: R,
        typeName: W.ZodPipeline
      });
    }
  }
  t.ZodPipeline = ce;
  class de extends B {
    _parse(f) {
      const R = this._def.innerType._parse(f);
      return (0, p.isValid)(R) && (R.value = Object.freeze(R.value)), R;
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  t.ZodReadonly = de, de.create = (N, f) => new de({
    innerType: N,
    typeName: W.ZodReadonly,
    ...S(f)
  });
  function pe(N, f = {}, R) {
    return N ? fr.create().superRefine((C, G) => {
      var F, fe;
      if (!N(C)) {
        const ae = typeof f == "function" ? f(C) : typeof f == "string" ? { message: f } : f, _e = (fe = ($ = ae.fatal) !== null && $ !== void 0 ? $ : R) !== null && fe !== void 0 ? fe : !0, Te = typeof ae == "string" ? { message: ae } : ae;
        G.addIssue({ code: "custom", ...Te, fatal: _e });
      }
    }) : fr.create();
  }
  t.custom = pe, t.late = {
    object: qe.lazycreate
  };
  var W;
  (function(N) {
    N.ZodString = "ZodString", N.ZodNumber = "ZodNumber", N.ZodNaN = "ZodNaN", N.ZodBigInt = "ZodBigInt", N.ZodBoolean = "ZodBoolean", N.ZodDate = "ZodDate", N.ZodSymbol = "ZodSymbol", N.ZodUndefined = "ZodUndefined", N.ZodNull = "ZodNull", N.ZodAny = "ZodAny", N.ZodUnknown = "ZodUnknown", N.ZodNever = "ZodNever", N.ZodVoid = "ZodVoid", N.ZodArray = "ZodArray", N.ZodObject = "ZodObject", N.ZodUnion = "ZodUnion", N.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", N.ZodIntersection = "ZodIntersection", N.ZodTuple = "ZodTuple", N.ZodRecord = "ZodRecord", N.ZodMap = "ZodMap", N.ZodSet = "ZodSet", N.ZodFunction = "ZodFunction", N.ZodLazy = "ZodLazy", N.ZodLiteral = "ZodLiteral", N.ZodEnum = "ZodEnum", N.ZodEffects = "ZodEffects", N.ZodNativeEnum = "ZodNativeEnum", N.ZodOptional = "ZodOptional", N.ZodNullable = "ZodNullable", N.ZodDefault = "ZodDefault", N.ZodCatch = "ZodCatch", N.ZodPromise = "ZodPromise", N.ZodBranded = "ZodBranded", N.ZodPipeline = "ZodPipeline", N.ZodReadonly = "ZodReadonly";
  })(W = t.ZodFirstPartyTypeKind || (t.ZodFirstPartyTypeKind = {}));
  const Ke = (N, f = {
    message: `Input not instance of ${N.name}`
  }) => pe((R) => R instanceof N, f);
  t.instanceof = Oe;
  const tt = $e.create;
  t.string = tt;
  const rt = pt.create;
  t.number = rt;
  const Xe = oe.create;
  t.nan = Xe;
  const Ye = st.create;
  t.bigint = Ye;
  const Se = Qe.create;
  t.boolean = Se;
  const ut = ht.create;
  t.date = ut;
  const _t = Me.create;
  t.symbol = _t;
  const ft = Yt.create;
  t.undefined = ft;
  const Et = et.create;
  t.null = Et;
  const Dt = fr.create;
  t.any = Dt;
  const Jt = Rt.create;
  t.unknown = Jt;
  const Pt = lt.create;
  t.never = Pt;
  const cr = It.create;
  t.void = cr;
  const jt = Ze.create;
  t.array = jt;
  const Qt = qe.create;
  t.object = Qt;
  const kr = qe.strictCreate;
  t.strictObject = kr;
  const Xr = ot.create;
  t.union = Xr;
  const di = At.create;
  t.discriminatedUnion = di;
  const Ft = Mt.create;
  t.intersection = Ft;
  const Tt = yr.create;
  t.tuple = Tt;
  const Rr = Nr.create;
  t.record = Rr;
  const Vr = Ni.create;
  t.map = Vr;
  const Pr = vr.create;
  t.set = Pr;
  const pi = _.create;
  t.function = pi;
  const Vi = X.create;
  t.lazy = Vi;
  const hi = b.create;
  t.literal = hi;
  const mi = k.create;
  t.enum = mi;
  const Br = U.create;
  t.nativeEnum = Br;
  const Hr = V.create;
  t.promise = Hr;
  const Ir = Z.create;
  t.effect = Ir, t.transformer = Ir;
  const Mi = H.create;
  t.optional = Mi;
  const Ur = ee.create;
  t.nullable = Ur;
  const tn = Z.createWithPreprocess;
  t.preprocess = tn;
  const rn = ce.create;
  t.pipeline = rn;
  const na = () => tt().optional();
  t.ostring = na;
  const Ln = () => rt().optional();
  t.onumber = Ln;
  const Cn = () => Le().optional();
  t.oboolean = Cn, t.coerce = {
    string: (N) => $e.create({ ...N, coerce: !0 }),
    number: (N) => pt.create({ ...N, coerce: !0 }),
    boolean: (N) => Qe.create({
      ...N,
      coerce: !0
    }),
    bigint: (N) => st.create({ ...N, coerce: !0 }),
    date: (N) => ht.create({ ...N, coerce: !0 })
  }, t.NEVER = p.INVALID;
})(rc);
(function(t) {
  var e = le && le.__createBinding || (Object.create ? function(a, u, x, y) {
    y === void 0 && (y = x), Object.defineProperty(a, y, { enumerable: !0, get: function() {
      return u[x];
    } });
  } : function(a, u, x, y) {
    y === void 0 && (y = x), a[y] = u[x];
  }), r = le && le.__exportStar || function(a, u) {
    for (var x in a) x !== "default" && !Object.prototype.hasOwnProperty.call(u, x) && e(u, a, x);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), r(ni, t), r($l, t), r(tc, t), r(va, t), r(rc, t), r(ai, t);
})(Il);
(function(t) {
  var e = le && le.__createBinding || (Object.create ? function(y, p, h, m) {
    m === void 0 && (m = h), Object.defineProperty(y, m, { enumerable: !0, get: function() {
      return p[h];
    } });
  } : function(y, p, h, m) {
    m === void 0 && (m = h), y[m] = p[h];
  }), r = le && le.__setModuleDefault || (Object.create ? function(y, p) {
    Object.defineProperty(y, "default", { enumerable: !0, value: p });
  } : function(y, p) {
    y.default = p;
  }), a = le && le.__importStar || function(y) {
    if (y && y.__esModule) return y;
    var p = {};
    if (y != null) for (var m in y) m !== "default" && Object.prototype.hasOwnProperty.call(y, m) && e(p, y, m);
    return r(p, y), p;
  }, u = le && le.__exportStar || function(y, p) {
    for (var m in y) m !== "default" && !Object.prototype.hasOwnProperty.call(p, m) && e(p, y, m);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.z = void 0;
  const x = a(Il);
  t.z = x, u(Il, t), t.default = x;
})(wn);
var _r = {}, bi = {}, tr = {}, Ji = {}, Gi = {};
Object.defineProperty(Gi, "__esModule", { value: !0 });
Gi.isObject = Gi.assure = Gi.is = void 0;
const d0 = (t, e) => e.safeParse(t).success;
Gi.is = d0;
const p0 = (t, e) => t.parse(e);
Gi.assure = p0;
const h0 = (t) => typeof t == "object" && t !== null;
Gi.isObject = h0;
var On = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.parseIntWithFallback = t.dedupeStrs = t.range = t.chunkArray = t.errHasMsg = t.isErrnoException = t.asyncFilter = t.s32decode = t.s32encode = t.streamToBuffer = t.flattenUint8Arrays = t.bailableWait = t.wait = t.jitter = t.noUndefinedVals = void 0;
  const e = ($) => (Object.keys($).forEach((z) => {
    $[z] === void 0 && delete $[z];
  }), $);
  t.noUndefinedVals = e;
  const r = ($) => Math.round((Math.random() - 0.5) * $ * 2);
  t.jitter = r;
  const a = ($) => new Promise((z) => setTimeout(z, $));
  t.wait = a;
  const u = ($) => {
    let z;
    const J = new Promise((ie) => {
      const ye = setTimeout(ie, V);
      z = () => {
        clearTimeout(ye), ie();
      };
    });
    return { bail: z, wait: () => Y };
  };
  t.bailableWait = u;
  const x = (V) => {
    const z = V.reduce((ye, ve) => ye + ve.length, 0), J = new Uint8Array(z);
    let ie = 0;
    return V.forEach((ye) => {
      J.set(ye, ie), ie += ye.length;
    }), J;
  };
  t.flattenUint8Arrays = x;
  const y = async ($) => {
    const z = [];
    for await (const Y of $)
      z.push(Y);
    return (0, t.flattenUint8Arrays)(z);
  };
  t.streamToBuffer = y;
  const p = "234567abcdefghijklmnopqrstuvwxyz", h = ($) => {
    let z = "";
    for (; $; ) {
      const Y = $ % 32;
      $ = Math.floor($ / 32), z = p.charAt(Y) + z;
    }
    return z;
  };
  t.s32encode = h;
  const m = ($) => {
    let z = 0;
    for (const Y of $)
      z = z * 32 + p.indexOf(Y);
    return z;
  };
  t.s32decode = h;
  const d = async (V, z) => {
    const J = await Promise.all(V.map((ie) => z(ie)));
    return V.filter((ie, ye) => J[ye]);
  };
  t.asyncFilter = d;
  const T = ($) => !!$ && $.code;
  t.isErrnoException = T;
  const S = (V, z) => !!V && typeof V == "object" && V.message === z;
  t.errHasMsg = S;
  const B = (V, z) => V.reduce((J, ie, ye) => {
    const ve = Math.floor(ye / z);
    return J[ve] || (J[ve] = []), J[ve].push(ie), J;
  }, []);
  t.chunkArray = B;
  const I = ($) => {
    const z = [];
    for (let Y = 0; Y < $; Y++)
      z.push(Y);
    return z;
  };
  t.range = I;
  const O = ($) => [...new Set($)];
  t.dedupeStrs = O;
  const j = ($, z) => {
    const Y = parseInt($ || "", 10);
    return isNaN(Y) ? z : Y;
  };
  t.parseIntWithFallback = j;
})(On);
var Kn = {};
Object.defineProperty(Kn, "__esModule", { value: !0 });
Kn.mapDefined = Kn.keyBy = void 0;
const m0 = (t, e) => t.reduce((r, a) => (r[a[e]] = a, r), {});
Kn.keyBy = m0;
const y0 = (t, e) => {
  const r = [];
  for (const a of t) {
    const u = e(a);
    u !== void 0 && r.push(u);
  }
  return r;
};
Kn.mapDefined = y0;
var nc = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.handleAllSettledErrors = t.AsyncBufferFullError = t.AsyncBuffer = t.allComplete = t.createDeferrables = t.createDeferrable = t.readFromGenerator = void 0;
  const e = On, r = async (d, T, S = Promise.resolve(), B = Number.MAX_SAFE_INTEGER) => {
    const I = [];
    let O, j = !1;
    const $ = async () => {
      if (await T(I.at(-1)))
        return !0;
      const J = (0, e.bailableWait)(20);
      return await J.wait(), O = J.bail, F ? !1 : await V();
    }, z = new Promise((J) => {
      S.then(() => {
        V().then(() => J());
      });
    });
    try {
      for (; I.length < B; ) {
        const Y = await Promise.race([d.next(), z]);
        if (!Y)
          break;
        const ie = Y;
        if (ie.done)
          break;
        I.push(ie.value);
      }
    } finally {
      j = !0, O && O();
    }
    return I;
  };
  t.readFromGenerator = r;
  const a = () => {
    let d;
    const T = new Promise((S) => {
      d = () => S();
    });
    return { resolve: d, complete: T };
  };
  t.createDeferrable = a;
  const u = (d) => {
    const T = [];
    for (let S = 0; S < d; S++)
      T.push((0, t.createDeferrable)());
    return T;
  };
  t.createDeferrables = u;
  const x = async (d) => {
    await Promise.all(d.map((T) => T.complete));
  };
  t.allComplete = x;
  class y {
    constructor(T) {
      Object.defineProperty(this, "maxSize", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: T
      }), Object.defineProperty(this, "buffer", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: []
      }), Object.defineProperty(this, "promise", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "resolve", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "closed", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: !1
      }), Object.defineProperty(this, "toThrow", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), this.promise = Promise.resolve(), this.resolve = () => null, this.resetPromise();
    }
    get curr() {
      return this.buffer;
    }
    get size() {
      return this.buffer.length;
    }
    get isClosed() {
      return this.closed;
    }
    resetPromise() {
      this.promise = new Promise((T) => this.resolve = T);
    }
    push(T) {
      this.buffer.push(T), this.resolve();
    }
    pushMany(T) {
      T.forEach((S) => this.buffer.push(S)), this.resolve();
    }
    async *events() {
      for (; ; ) {
        if (this.closed && this.buffer.length === 0) {
          if (this.toThrow)
            throw this.toThrow;
          return;
        }
        if (await this.promise, this.toThrow)
          throw this.toThrow;
        if (this.maxSize && this.size > this.maxSize)
          throw new p(this.maxSize);
        const [T, ...S] = this.buffer;
        T ? (this.buffer = S, yield T) : this.resetPromise();
      }
    }
    throw(T) {
      this.toThrow = T, this.closed = !0, this.resolve();
    }
    close() {
      this.closed = !0, this.resolve();
    }
  }
  t.AsyncBuffer = y;
  class p extends Error {
    constructor(T) {
      super(`ReachedMaxBufferSize: ${T}`);
    }
  }
  t.AsyncBufferFullError = p;
  const m = (d) => {
    const T = d.filter(h).map((S) => S.reason);
    if (T.length !== 0)
      throw T.length === 1 ? T[0] : new AggregateError(T, "Multiple errors: " + T.map((S) => S?.message).join(`
`));
  };
  t.handleAllSettledErrors = m;
  const h = (d) => d.status === "rejected";
})(nc);
var Ra = {};
Object.defineProperty(Ra, "__esModule", { value: !0 });
Ra.TID = void 0;
const Ro = On, wu = 13;
let Rl = 0, Su = 0, Ao = null;
function Lu(t) {
  return t.replaceAll("-", "");
}
class vi {
  constructor(e) {
    Object.defineProperty(this, "str", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
    const r = Lu(e);
    if (r.length !== wu)
      throw new Error(`Poorly formatted TID: ${r.length} length`);
    this.str = r;
  }
  static next(e) {
    const r = Math.max(Date.now(), Rl);
    r === Rl && Su++, Rl = r;
    const a = r * 1e3 + Su;
    Ao === null && (Ao = Math.floor(Math.random() * 32));
    const u = vi.fromTime(a, Ao);
    return !e || u.newerThan(e) ? u : vi.fromTime(e.timestamp() + 1, Ao);
  }
  static nextStr(e) {
    return vi.next(e ? new vi(e) : void 0).toString();
  }
  static fromTime(e, r) {
    const a = `${(0, Ro.s32encode)(e)}${(0, Ro.s32encode)(r).padStart(2, "2")}`;
    return new vi(a);
  }
  static fromStr(e) {
    return new vi(e);
  }
  static oldestFirst(e, r) {
    return e.compareTo(r);
  }
  static newestFirst(e, r) {
    return r.compareTo(e);
  }
  static is(e) {
    return Lu(e).length === wu;
  }
  timestamp() {
    return (0, Ro.s32decode)(this.str.slice(0, 11));
  }
  clockid() {
    return (0, Ro.s32decode)(this.str.slice(11, 13));
  }
  formatted() {
    const e = this.toString();
    return `${e.slice(0, 4)}-${e.slice(4, 7)}-${e.slice(7, 11)}-${e.slice(11, 13)}`;
  }
  toString() {
    return this.str;
  }
  // newer > older
  compareTo(e) {
    return this.str > e.str ? 1 : this.str < e.str ? -1 : 0;
  }
  equals(e) {
    return this.str === e.str;
  }
  newerThan(e) {
    return this.compareTo(e) > 0;
  }
  olderThan(e) {
    return this.compareTo(e) < 0;
  }
}
Ra.TID = vi;
Ra.default = vi;
var ac = {}, b0 = sc, Cu = 128, x0 = 127, E0 = ~x0, g0 = Math.pow(2, 31);
function sc(t, e, r) {
  e = e || [], r = r || 0;
  for (var a = r; t >= g0; )
    e[r++] = t & 255 | Cu, t /= 128;
  for (; t & E0; )
    e[r++] = t & 255 | Cu, t >>>= 7;
  return e[r] = t | 0, sc.bytes = r - a + 1, e;
}
var v0 = Ul, R0 = 128, Du = 127;
function Ul(t, a) {
  var r = 0, a = a || 0, u = 0, x = a, y, p = t.length;
  do {
    if (x >= p)
      throw Ul.bytes = 0, new RangeError("Could not decode varint");
    y = t[x++], r += u < 28 ? (y & Du) << u : (y & Du) * Math.pow(2, u), u += 7;
  } while (y >= R0);
  return Ul.bytes = x - a, r;
}
var A0 = Math.pow(2, 7), _0 = Math.pow(2, 14), T0 = Math.pow(2, 21), w0 = Math.pow(2, 28), S0 = Math.pow(2, 35), L0 = Math.pow(2, 42), C0 = Math.pow(2, 49), D0 = Math.pow(2, 56), k0 = Math.pow(2, 63), P0 = function(t) {
  return t < A0 ? 1 : t < _0 ? 2 : t < T0 ? 3 : t < w0 ? 4 : t < S0 ? 5 : t < L0 ? 6 : t < C0 ? 7 : t < D0 ? 8 : t < k0 ? 9 : 10;
}, B0 = {
  encode: b0,
  decode: v0,
  encodingLength: P0
}, Io = B0;
const Ol = (t, e = 0) => [
  Io.decode(t, e),
  Io.decode.bytes
], Uo = (t, e, r = 0) => (Io.encode(t, e, r), e), Oo = (t) => Io.encodingLength(t), I0 = (t, e) => {
  if (t === e)
    return !0;
  if (t.byteLength !== e.byteLength)
    return !1;
  for (let r = 0; r < t.byteLength; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}, Gl = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
    return t;
  if (t instanceof ArrayBuffer)
    return new Uint8Array(t);
  if (ArrayBuffer.isView(t))
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, U0 = (t) => new TextEncoder().encode(t), O0 = (t) => new TextDecoder().decode(t), K0 = (t, e) => {
  const r = e.byteLength, a = Oo(t), u = a + Oo(r), x = new Uint8Array(u + r);
  return Uo(t, x, 0), Uo(r, x, a), x.set(e, u), new ql(t, r, e, x);
}, N0 = (t) => {
  const e = Gl(t), [r, a] = Ol(e), [u, x] = Ol(e.subarray(a)), y = e.subarray(a + x);
  if (y.byteLength !== u)
    throw new Error("Incorrect length");
  return new ql(r, u, y, e);
}, V0 = (t, e) => t === e ? !0 : t.code === e.code && t.size === e.size && I0(t.bytes, e.bytes);
class ql {
  constructor(e, r, a, u) {
    this.code = e, this.size = r, this.digest = a, this.bytes = u;
  }
}
function M0(t, e) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), a = 0; a < r.length; a++)
    r[a] = 255;
  for (var u = 0; u < t.length; u++) {
    var x = t.charAt(u), y = x.charCodeAt(0);
    if (r[y] !== 255)
      throw new TypeError(x + " is ambiguous");
    r[y] = u;
  }
  var p = t.length, h = t.charAt(0), m = Math.log(p) / Math.log(256), d = Math.log(256) / Math.log(p);
  function T(I) {
    if (I instanceof Uint8Array || (ArrayBuffer.isView(I) ? I = new Uint8Array(I.buffer, I.byteOffset, I.byteLength) : Array.isArray(I) && (I = Uint8Array.from(I))), !(I instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (I.length === 0)
      return "";
    for (var O = 0, F = 0, V = 0, z = I.length; V !== z && I[V] === 0; )
      V++, O++;
    for (var J = (z - V) * d + 1 >>> 0, ie = new Uint8Array(J); V !== z; ) {
      for (var ye = I[V], ve = 0, Ae = J - 1; (ye !== 0 || ve < F) && Ae !== -1; Ae--, ve++)
        ye += 256 * ie[Ae] >>> 0, ie[Ae] = ye % p >>> 0, ye = ye / p >>> 0;
      if (ye !== 0)
        throw new Error("Non-zero carry");
      F = ve, V++;
    }
    for (var Ee = J - F; Ee !== J && ie[Ee] === 0; )
      Ee++;
    for (var Ce = m.repeat(O); Ee < J; ++Ee)
      Ce += t.charAt(ie[Ee]);
    return Ce;
  }
  function S(I) {
    if (typeof I != "string")
      throw new TypeError("Expected String");
    if (I.length === 0)
      return new Uint8Array();
    var O = 0;
    if (I[O] !== " ") {
      for (var j = 0, $ = 0; I[O] === h; )
        j++, O++;
      for (var z = (I.length - O) * m + 1 >>> 0, Y = new Uint8Array(z); I[O]; ) {
        var ie = r[I.charCodeAt(O)];
        if (ie === 255)
          return;
        for (var ye = 0, ve = z - 1; (ie !== 0 || ye < V) && ve !== -1; ve--, ye++)
          ie += p * J[ve] >>> 0, J[ve] = ie % 256 >>> 0, ie = ie / 256 >>> 0;
        if (ie !== 0)
          throw new Error("Non-zero carry");
        V = ye, O++;
      }
      if (I[O] !== " ") {
        for (var Ae = z - V; Ae !== z && J[Ae] === 0; )
          Ae++;
        for (var Ee = new Uint8Array(F + (z - Ae)), Ce = F; Ae !== z; )
          Ee[Ce++] = J[Ae++];
        return Ee;
      }
    }
  }
  function B(I) {
    var O = S(I);
    if (O)
      return O;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: T,
    decodeUnsafe: S,
    decode: B
  };
}
var j0 = M0, F0 = j0;
class $0 {
  constructor(e, r, a) {
    this.name = e, this.prefix = r, this.baseEncode = a;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class G0 {
  constructor(e, r, a) {
    if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = r.codePointAt(0), this.baseDecode = a;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return oc(this, e);
  }
}
class q0 {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return oc(this, e);
  }
  decode(e) {
    const r = e[0], a = this.decoders[r];
    if (a)
      return a.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const oc = (t, e) => new q0({
  ...t.decoders || { [t.prefix]: t },
  ...e.decoders || { [e.prefix]: e }
});
class X0 {
  constructor(e, r, a, u) {
    this.name = e, this.prefix = r, this.baseEncode = a, this.baseDecode = u, this.encoder = new $0(e, r, a), this.decoder = new G0(e, r, u);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const zo = ({ name: t, prefix: e, encode: r, decode: a }) => new X0(t, e, r, a), Aa = ({ prefix: t, name: e, alphabet: r }) => {
  const { encode: a, decode: u } = F0(r, e);
  return zo({
    prefix: t,
    name: e,
    encode: a,
    decode: (x) => Gl(u(x))
  });
}, z0 = (t, e, r, a) => {
  const u = {};
  for (let d = 0; d < e.length; ++d)
    u[e[d]] = d;
  let x = t.length;
  for (; t[x - 1] === "="; )
    --x;
  const y = new Uint8Array(x * r / 8 | 0);
  let p = 0, h = 0, m = 0;
  for (let d = 0; d < x; ++d) {
    const T = u[t[d]];
    if (T === void 0)
      throw new SyntaxError(`Non-${a} character`);
    h = h << r | T, p += r, p >= 8 && (p -= 8, y[m++] = 255 & h >> p);
  }
  if (p >= r || 255 & h << 8 - p)
    throw new SyntaxError("Unexpected end of data");
  return y;
}, H0 = (t, e, r) => {
  const a = e[e.length - 1] === "=", u = (1 << r) - 1;
  let x = "", y = 0, p = 0;
  for (let h = 0; h < t.length; ++h)
    for (p = p << 8 | t[h], y += 8; y > r; )
      y -= r, x += e[u & p >> y];
  if (y && (x += e[u & p << r - y]), a)
    for (; x.length * r & 7; )
      x += "=";
  return x;
}, rr = ({ name: t, prefix: e, bitsPerChar: r, alphabet: a }) => zo({
  prefix: e,
  name: t,
  encode(u) {
    return H0(u, a, r);
  },
  decode(u) {
    return z0(u, a, r, t);
  }
}), Ri = Aa({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), Z0 = Aa({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), W0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: Ri,
  base58flickr: Z0
}, Symbol.toStringTag, { value: "Module" })), ha = rr({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), Y0 = rr({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), J0 = rr({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), Q0 = rr({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), em = rr({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), tm = rr({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), rm = rr({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), im = rr({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), nm = rr({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), am = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: ha,
  base32hex: em,
  base32hexpad: rm,
  base32hexpadupper: im,
  base32hexupper: tm,
  base32pad: J0,
  base32padupper: Q0,
  base32upper: Y0,
  base32z: nm
}, Symbol.toStringTag, { value: "Module" }));
class ar {
  constructor(e, r, a, u) {
    this.code = r, this.version = e, this.multihash = a, this.bytes = u, this.byteOffset = u.byteOffset, this.byteLength = u.byteLength, this.asCID = this, this._baseCache = /* @__PURE__ */ new Map(), Object.defineProperties(this, {
      byteOffset: To,
      byteLength: To,
      code: _o,
      version: _o,
      multihash: _o,
      bytes: _o,
      _baseCache: To,
      asCID: To
    });
  }
  toV0() {
    switch (this.version) {
      case 0:
        return this;
      default: {
        const { code: e, multihash: r } = this;
        if (e !== la)
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        if (r.code !== um)
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        return ar.createV0(r);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: e, digest: r } = this.multihash, a = K0(e, r);
        return ar.createV1(this.code, a);
      }
      case 1:
        return this;
      default:
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
    }
  }
  equals(e) {
    return e && this.code === e.code && this.version === e.version && V0(this.multihash, e.multihash);
  }
  toString(e) {
    const { bytes: r, version: a, _baseCache: u } = this;
    switch (a) {
      case 0:
        return om(r, u, e || Ri.encoder);
      default:
        return lm(r, u, e || ha.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(e) {
    return cm(/^0\.0/, dm), !!(e && (e[Pu] || e.asCID === e));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(e) {
    if (e instanceof ar)
      return e;
    if (e != null && e.asCID === e) {
      const { version: r, code: a, multihash: u, bytes: x } = e;
      return new ar(r, a, u, x || ku(r, a, u.bytes));
    } else if (e != null && e[Pu] === !0) {
      const { version: r, multihash: a, code: u } = e, x = N0(a);
      return ar.create(r, u, x);
    } else
      return null;
  }
  static create(e, r, a) {
    if (typeof r != "number")
      throw new Error("String codecs are no longer supported");
    switch (e) {
      case 0: {
        if (r !== la)
          throw new Error(`Version 0 CID must use dag-pb (code: ${la}) block encoding`);
        return new ar(e, r, a, a.bytes);
      }
      case 1: {
        const u = ku(e, r, a.bytes);
        return new ar(e, r, a, u);
      }
      default:
        throw new Error("Invalid version");
    }
  }
  static createV0(e) {
    return ar.create(0, la, e);
  }
  static createV1(e, r) {
    return ar.create(1, e, r);
  }
  static decode(e) {
    const [r, a] = ar.decodeFirst(e);
    if (a.length)
      throw new Error("Incorrect length");
    return r;
  }
  static decodeFirst(e) {
    const r = ar.inspectBytes(e), a = r.size - r.multihashSize, u = Gl(e.subarray(a, a + r.multihashSize));
    if (u.byteLength !== r.multihashSize)
      throw new Error("Incorrect length");
    const x = u.subarray(r.multihashSize - r.digestSize), y = new ql(r.multihashCode, r.digestSize, x, u);
    return [
      r.version === 0 ? ar.createV0(y) : ar.createV1(r.codec, y),
      e.subarray(r.size)
    ];
  }
  static inspectBytes(e) {
    let r = 0;
    const a = () => {
      const [T, S] = Ol(e.subarray(r));
      return r += S, T;
    };
    let u = a(), x = la;
    if (u === 18 ? (u = 0, r = 0) : u === 1 && (x = a()), u !== 0 && u !== 1)
      throw new RangeError(`Invalid CID version ${u}`);
    const y = r, p = a(), h = a(), m = r + h, d = m - y;
    return {
      version: u,
      codec: x,
      multihashCode: p,
      digestSize: h,
      multihashSize: d,
      size: m
    };
  }
  static parse(e, r) {
    const [a, u] = sm(e, r), x = ar.decode(u);
    return x._baseCache.set(a, e), x;
  }
}
const sm = (t, e) => {
  switch (t[0]) {
    case "Q": {
      const r = e || Ri;
      return [
        Ri.prefix,
        r.decode(`${Ri.prefix}${t}`)
      ];
    }
    case Ri.prefix: {
      const r = e || Ri;
      return [
        Ri.prefix,
        r.decode(t)
      ];
    }
    case ha.prefix: {
      const r = e || ha;
      return [
        ha.prefix,
        r.decode(t)
      ];
    }
    default: {
      if (e == null)
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      return [
        t[0],
        e.decode(t)
      ];
    }
  }
}, om = (t, e, r) => {
  const { prefix: a } = r;
  if (a !== Ri.prefix)
    throw Error(`Cannot string encode V0 in ${r.name} encoding`);
  const u = e.get(a);
  if (u == null) {
    const x = r.encode(t).slice(1);
    return e.set(a, x), x;
  } else
    return u;
}, lm = (t, e, r) => {
  const { prefix: a } = r, u = e.get(a);
  if (u == null) {
    const x = r.encode(t);
    return e.set(a, x), x;
  } else
    return u;
}, la = 112, um = 18, ku = (t, e, r) => {
  const a = Oo(t), u = a + Oo(e), x = new Uint8Array(u + r.byteLength);
  return Uo(t, x, 0), Uo(e, x, a), x.set(r, u), x;
}, Pu = Symbol.for("@ipld/js-cid/CID"), _o = {
  writable: !1,
  configurable: !1,
  enumerable: !0
}, To = {
  writable: !1,
  enumerable: !1,
  configurable: !1
}, fm = "0.0.0-dev", cm = (t, e) => {
  if (t.test(fm))
    console.warn(e);
  else
    throw new Error(e);
}, dm = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`, pm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CID: ar
}, Symbol.toStringTag, { value: "Module" })), ta = /* @__PURE__ */ Gf(pm);
function hm(t, e) {
  for (let r = 0; r < t.byteLength; r++) {
    if (t[r] < e[r])
      return -1;
    if (t[r] > e[r])
      return 1;
  }
  return t.byteLength > e.byteLength ? 1 : t.byteLength < e.byteLength ? -1 : 0;
}
function mm(t, e) {
  e || (e = t.reduce((u, x) => u + x.length, 0));
  const r = new Uint8Array(e);
  let a = 0;
  for (const u of t)
    r.set(u, a), a += u.length;
  return r;
}
function ym(t, e) {
  if (t === e)
    return !0;
  if (t.byteLength !== e.byteLength)
    return !1;
  for (let r = 0; r < t.byteLength; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
const bm = zo({
  prefix: "\0",
  name: "identity",
  encode: (t) => O0(t),
  decode: (t) => U0(t)
}), xm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: bm
}, Symbol.toStringTag, { value: "Module" })), Em = rr({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), gm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: Em
}, Symbol.toStringTag, { value: "Module" })), vm = rr({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), Rm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: vm
}, Symbol.toStringTag, { value: "Module" })), Am = Aa({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), _m = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: Am
}, Symbol.toStringTag, { value: "Module" })), Tm = rr({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), wm = rr({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), Sm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: Tm,
  base16upper: wm
}, Symbol.toStringTag, { value: "Module" })), Lm = Aa({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), Cm = Aa({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), Dm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: Lm,
  base36upper: Cm
}, Symbol.toStringTag, { value: "Module" })), km = rr({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), Pm = rr({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), Bm = rr({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), Im = rr({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), Um = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: km,
  base64pad: Pm,
  base64url: Bm,
  base64urlpad: Im
}, Symbol.toStringTag, { value: "Module" })), lc = Array.from(""), Om = lc.reduce((t, e, r) => (t[r] = e, t), []), Km = lc.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);
function Nm(t) {
  return t.reduce((e, r) => (e += Om[r], e), "");
}
function Vm(t) {
  const e = [];
  for (const r of t) {
    const a = Km[r.codePointAt(0)];
    if (a === void 0)
      throw new Error(`Non-base256emoji character: ${r}`);
    e.push(a);
  }
  return new Uint8Array(e);
}
const Mm = zo({
  prefix: "",
  name: "base256emoji",
  encode: Nm,
  decode: Vm
}), jm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: Mm
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const Bu = {
  ...xm,
  ...gm,
  ...Rm,
  ..._m,
  ...Sm,
  ...am,
  ...Dm,
  ...W0,
  ...Um,
  ...jm
};
function uc(t, e, r, a) {
  return {
    name: t,
    prefix: e,
    encoder: {
      name: t,
      prefix: e,
      encode: r
    },
    decoder: { decode: a }
  };
}
const Iu = uc("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), Al = uc("ascii", "a", (t) => {
  let e = "a";
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = new Uint8Array(t.length);
  for (let r = 0; r < t.length; r++)
    e[r] = t.charCodeAt(r);
  return e;
}), fc = {
  utf8: Iu,
  "utf-8": Iu,
  hex: Bu.base16,
  latin1: Al,
  ascii: Al,
  binary: Al,
  ...Bu
};
function Fm(t, e = "utf8") {
  const r = fc[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return r.decoder.decode(`${r.prefix}${t}`);
}
function $m(t, e = "utf8") {
  const r = fc[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return r.encoder.encode(t).substring(1);
}
function Gm(t, e) {
  if (t.length !== e.length)
    throw new Error("Inputs should have the same length");
  const r = new Uint8Array(t.length);
  for (let a = 0; a < t.length; a++)
    r[a] = t[a] ^ e[a];
  return r;
}
const qm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  compare: hm,
  concat: mm,
  equals: ym,
  fromString: Fm,
  toString: $m,
  xor: Gm
}, Symbol.toStringTag, { value: "Module" })), cc = /* @__PURE__ */ Gf(qm);
(function(t) {
  var e = le && le.__createBinding || (Object.create ? function(h, d, T, S) {
    S === void 0 && (S = T);
    var B = Object.getOwnPropertyDescriptor(d, T);
    (!B || ("get" in B ? !d.__esModule : B.writable || B.configurable)) && (B = { enumerable: !0, get: function() {
      return d[T];
    } }), Object.defineProperty(h, S, B);
  } : function(h, d, T, S) {
    S === void 0 && (S = T), h[S] = d[T];
  }), r = le && le.__setModuleDefault || (Object.create ? function(h, d) {
    Object.defineProperty(h, "default", { enumerable: !0, value: d });
  } : function(h, d) {
    h.default = d;
  }), a = le && le.__importStar || function(h) {
    if (h && h.__esModule) return h;
    var d = {};
    if (h != null) for (var T in h) T !== "default" && Object.prototype.hasOwnProperty.call(h, T) && e(d, h, T);
    return r(d, h), d;
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ipldEquals = t.ipldToJson = t.jsonToIpld = void 0;
  const u = ta, x = a(cc), y = (h) => {
    if (Array.isArray(h))
      return h.map((d) => (0, t.jsonToIpld)(d));
    if (h && typeof h == "object") {
      if (typeof h.$link == "string" && Object.keys(h).length === 1)
        return u.CID.parse(h.$link);
      if (typeof h.$bytes == "string" && Object.keys(h).length === 1)
        return x.fromString(h.$bytes, "base64");
      const d = {};
      for (const T of Object.keys(m))
        d[T] = (0, t.jsonToIpld)(m[T]);
      return d;
    }
    return m;
  };
  t.jsonToIpld = y;
  const p = (m) => {
    if (Array.isArray(m))
      return m.map((d) => (0, t.ipldToJson)(d));
    if (m && typeof m == "object") {
      if (m instanceof Uint8Array)
        return {
          $bytes: x.toString(m, "base64")
        };
      if (u.CID.asCID(m))
        return {
          $link: m.toString()
        };
      const d = {};
      for (const T of Object.keys(m))
        d[T] = (0, t.ipldToJson)(m[T]);
      return d;
    }
    return m;
  };
  t.ipldToJson = p;
  const h = (m, d) => {
    if (Array.isArray(m) && Array.isArray(d)) {
      if (m.length !== d.length)
        return !1;
      for (let T = 0; T < m.length; T++)
        if (!(0, t.ipldEquals)(m[T], d[T]))
          return !1;
      return !0;
    }
    if (m && d && typeof m == "object" && typeof d == "object") {
      if (m instanceof Uint8Array && d instanceof Uint8Array)
        return x.equals(m, d);
      if (u.CID.asCID(m) && u.CID.asCID(d))
        return u.CID.asCID(m)?.equals(u.CID.asCID(d));
      if (Object.keys(m).length !== Object.keys(d).length)
        return !1;
      for (const T of Object.keys(m))
        if (!(0, t.ipldEquals)(m[T], d[T]))
          return !1;
      return !0;
    }
    return m === d;
  };
  t.ipldEquals = m;
})(ac);
var Nn = {};
Object.defineProperty(Nn, "__esModule", { value: !0 });
Nn.backoffMs = Nn.retry = void 0;
const Xm = On;
async function zm(t, e = {}) {
  const { maxRetries: r = 3, retryable: a = () => !0, getWaitMs: u = dc } = e;
  let x = 0, y;
  for (; !y; )
    try {
      return await t();
    } catch (p) {
      const m = u(x);
      x < r && m !== null && a(p) ? (x += 1, m !== 0 && await (0, Xm.wait)(m)) : y = p;
    }
  throw y;
}
Nn.retry = zm;
function dc(t, e = 100, r = 1e3) {
  const a = Math.pow(2, t) * e, u = Math.min(a, r);
  return Hm(u);
}
Nn.backoffMs = dc;
function Hm(t) {
  const e = t * 0.15;
  return t + Zm(-e, e);
}
function Zm(t, e) {
  return Math.random() * (e - t) + t;
}
var pc = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.def = t.schema = void 0;
  const e = ta, r = wn, a = r.z.any().refine((u) => e.CID.asCID(u) !== null, {
    message: "Not a CID"
  }).transform((u) => e.CID.asCID(u));
  t.schema = {
    cid: a,
    bytes: r.z.instanceof(Uint8Array),
    string: r.z.string(),
    array: r.z.array(r.z.unknown()),
    map: r.z.record(r.z.string(), r.z.unknown()),
    unknown: r.z.unknown()
  }, t.def = {
    cid: {
      name: "cid",
      schema: t.schema.cid
    },
    bytes: {
      name: "bytes",
      schema: t.schema.bytes
    },
    string: {
      name: "string",
      schema: t.schema.string
    },
    map: {
      name: "map",
      schema: t.schema.map
    },
    unknown: {
      name: "unknown",
      schema: t.schema.unknown
    }
  };
})(pc);
var hc = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.addHoursToDate = t.lessThanAgoMs = t.DAY = t.HOUR = t.MINUTE = t.SECOND = void 0, t.SECOND = 1e3, t.MINUTE = t.SECOND * 60, t.HOUR = t.MINUTE * 60, t.DAY = t.HOUR * 24;
  const e = (a, u) => Date.now() < a.getTime() + u;
  t.lessThanAgoMs = e;
  const r = (a, u) => {
    const x = u ? new Date(u) : /* @__PURE__ */ new Date();
    return x.setHours(x.getHours() + a), x;
  };
  t.addHoursToDate = r;
})(hc);
var Er = {}, Xl = {}, zl = {}, Hl = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.EXTENDED_PICTOGRAPHIC = t.CLUSTER_BREAK = void 0, function(e) {
    e[e.CR = 0] = "CR", e[e.LF = 1] = "LF", e[e.CONTROL = 2] = "CONTROL", e[e.EXTEND = 3] = "EXTEND", e[e.REGIONAL_INDICATOR = 4] = "REGIONAL_INDICATOR", e[e.SPACINGMARK = 5] = "SPACINGMARK", e[e.L = 6] = "L", e[e.V = 7] = "V", e[e.T = 8] = "T", e[e.LV = 9] = "LV", e[e.LVT = 10] = "LVT", e[e.OTHER = 11] = "OTHER", e[e.PREPEND = 12] = "PREPEND", e[e.E_BASE = 13] = "E_BASE", e[e.E_MODIFIER = 14] = "E_MODIFIER", e[e.ZWJ = 15] = "ZWJ", e[e.GLUE_AFTER_ZWJ = 16] = "GLUE_AFTER_ZWJ", e[e.E_BASE_GAZ = 17] = "E_BASE_GAZ";
  }(t.CLUSTER_BREAK || (t.CLUSTER_BREAK = {})), t.EXTENDED_PICTOGRAPHIC = 101;
})(Hl);
var Zl = {};
Object.defineProperty(Zl, "__esModule", { value: !0 });
const Ge = Hl, xi = 0, _l = 1, Wm = 2, Ym = 3, Jm = 4;
class Qm {
  /**
   * Check if the the character at the position {pos} of the string is surrogate
   * @param str {string}
   * @param pos {number}
   * @returns {boolean}
   */
  static isSurrogate(e, r) {
    return 55296 <= e.charCodeAt(r) && e.charCodeAt(r) <= 56319 && 56320 <= e.charCodeAt(r + 1) && e.charCodeAt(r + 1) <= 57343;
  }
  /**
   * The String.prototype.codePointAt polyfill
   * Private function, gets a Unicode code point from a JavaScript UTF-16 string
   * handling surrogate pairs appropriately
   * @param str {string}
   * @param idx {number}
   * @returns {number}
   */
  static codePointAt(e, r) {
    r === void 0 && (r = 0);
    const a = e.charCodeAt(r);
    if (55296 <= a && a <= 56319 && r < e.length - 1) {
      const u = a, x = e.charCodeAt(r + 1);
      return 56320 <= x && x <= 57343 ? (u - 55296) * 1024 + (x - 56320) + 65536 : u;
    }
    if (56320 <= a && a <= 57343 && r >= 1) {
      const u = e.charCodeAt(r - 1), x = a;
      return 55296 <= u && u <= 56319 ? (u - 55296) * 1024 + (x - 56320) + 65536 : x;
    }
    return a;
  }
  //
  /**
   * Private function, returns whether a break is allowed between the two given grapheme breaking classes
   * Implemented the UAX #29 3.1.1 Grapheme Cluster Boundary Rules on extended grapheme clusters
   * @param start {number}
   * @param mid {Array<number>}
   * @param end {number}
   * @param startEmoji {number}
   * @param midEmoji {Array<number>}
   * @param endEmoji {number}
   * @returns {number}
   */
  static shouldBreak(e, r, a, u, x, y) {
    const p = [e].concat(r).concat([a]), m = [u].concat(x).concat([y]), h = p[p.length - 2], d = a, T = y, S = p.lastIndexOf(Ge.CLUSTER_BREAK.REGIONAL_INDICATOR);
    if (S > 0 && p.slice(1, S).every(function(I) {
      return I === Ge.CLUSTER_BREAK.REGIONAL_INDICATOR;
    }) && [Ge.CLUSTER_BREAK.PREPEND, Ge.CLUSTER_BREAK.REGIONAL_INDICATOR].indexOf(m) === -1)
      return p.filter(function(I) {
        return I === Ge.CLUSTER_BREAK.REGIONAL_INDICATOR;
      }).length % 2 === 1 ? Ym : Jm;
    if (h === Ge.CLUSTER_BREAK.CR && d === Ge.CLUSTER_BREAK.LF)
      return xi;
    if (m === Ge.CLUSTER_BREAK.CONTROL || m === Ge.CLUSTER_BREAK.CR || m === Ge.CLUSTER_BREAK.LF)
      return _l;
    if (d === Ge.CLUSTER_BREAK.CONTROL || d === Ge.CLUSTER_BREAK.CR || d === Ge.CLUSTER_BREAK.LF)
      return _l;
    if (m === Ge.CLUSTER_BREAK.L && (d === Ge.CLUSTER_BREAK.L || d === Ge.CLUSTER_BREAK.V || d === Ge.CLUSTER_BREAK.LV || d === Ge.CLUSTER_BREAK.LVT))
      return xi;
    if ((m === Ge.CLUSTER_BREAK.LV || m === Ge.CLUSTER_BREAK.V) && (d === Ge.CLUSTER_BREAK.V || d === Ge.CLUSTER_BREAK.T))
      return xi;
    if ((m === Ge.CLUSTER_BREAK.LVT || m === Ge.CLUSTER_BREAK.T) && d === Ge.CLUSTER_BREAK.T)
      return xi;
    if (d === Ge.CLUSTER_BREAK.EXTEND || d === Ge.CLUSTER_BREAK.ZWJ)
      return xi;
    if (d === Ge.CLUSTER_BREAK.SPACINGMARK)
      return xi;
    if (m === Ge.CLUSTER_BREAK.PREPEND)
      return xi;
    const B = h.slice(0, -1).lastIndexOf(Ge.EXTENDED_PICTOGRAPHIC);
    return B !== -1 && h[B] === Ge.EXTENDED_PICTOGRAPHIC && p.slice(B + 1, -2).every(function(I) {
      return I === Ge.CLUSTER_BREAK.EXTEND;
    }) && h === Ge.CLUSTER_BREAK.ZWJ && T === Ge.EXTENDED_PICTOGRAPHIC ? xi : r.indexOf(Ge.CLUSTER_BREAK.REGIONAL_INDICATOR) !== -1 ? Wm : h === Ge.CLUSTER_BREAK.REGIONAL_INDICATOR && d === Ge.CLUSTER_BREAK.REGIONAL_INDICATOR ? xi : _l;
  }
}
Zl.default = Qm;
var Wl = {};
Object.defineProperty(Wl, "__esModule", { value: !0 });
class ey {
  constructor(e, r) {
    this._index = 0, this._str = e, this._nextBreak = r;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    let e;
    if ((e = this._nextBreak(this._str, this._index)) < this._str.length) {
      const r = this._str.slice(this._index, e);
      return this._index = e, { value: r, done: !1 };
    }
    if (this._index < this._str.length) {
      const r = this._str.slice(this._index);
      return this._index = this._str.length, { value: r, done: !1 };
    }
    return { value: void 0, done: !0 };
  }
}
Wl.default = ey;
var mc = le && le.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(zl, "__esModule", { value: !0 });
const i = Hl, wo = mc(Zl), ty = mc(Wl);
class Ei {
  /**
   * Returns the next grapheme break in the string after the given index
   * @param string {string}
   * @param index {number}
   * @returns {number}
   */
  static nextBreak(e, r) {
    if (r === void 0 && (r = 0), r < 0)
      return 0;
    if (r >= e.length - 1)
      return e.length;
    const a = wo.default.codePointAt(e, r), u = Ei.getGraphemeBreakProperty(a), x = Ei.getEmojiProperty(a), y = [], p = [];
    for (let h = r + 1; h < e.length; h++) {
      if (wo.default.isSurrogate(e, h - 1))
        continue;
      const m = wo.default.codePointAt(e, h), d = Ei.getGraphemeBreakProperty(m), T = Ei.getEmojiProperty(m);
      if (wo.default.shouldBreak(u, y, d, x, p, T))
        return h;
      y.push(d), p.push(T);
    }
    return e.length;
  }
  /**
   * Breaks the given string into an array of grapheme clusters
   * @param str {string}
   * @returns {string[]}
   */
  splitGraphemes(e) {
    const r = [];
    let a = 0, u;
    for (; (u = Ei.nextBreak(e, a)) < e.length; )
      r.push(e.slice(a, u)), a = u;
    return a < e.length && r.push(e.slice(a)), r;
  }
  /**
   * Returns an iterator of grapheme clusters in the given string
   * @param str {string}
   * @returns {GraphemerIterator}
   */
  iterateGraphemes(e) {
    return new ty.default(e, Ei.nextBreak);
  }
  /**
   * Returns the number of grapheme clusters in the given string
   * @param str {string}
   * @returns {number}
   */
  countGraphemes(e) {
    let r = 0, a = 0, u;
    for (; (u = Ei.nextBreak(e, a)) < e.length; )
      a = u, r++;
    return a < e.length && r++, r;
  }
  /**
   * Given a Unicode code point, determines this symbol's grapheme break property
   * @param code {number} Unicode code point
   * @returns {number}
   */
  static getGraphemeBreakProperty(e) {
    if (e < 48905) {
      if (e < 44116) {
        if (e < 4141) {
          if (e < 2818) {
            if (e < 2363)
              if (e < 1759) {
                if (e < 1471) {
                  if (e < 127) {
                    if (e < 11) {
                      if (e < 10) {
                        if (0 <= e && e <= 9)
                          return i.CLUSTER_BREAK.CONTROL;
                      } else if (e === 10)
                        return i.CLUSTER_BREAK.LF;
                    } else if (e < 13) {
                      if (11 <= e && e <= 12)
                        return i.CLUSTER_BREAK.CONTROL;
                    } else if (e < 14) {
                      if (e === 13)
                        return i.CLUSTER_BREAK.CR;
                    } else if (14 <= e && e <= 31)
                      return i.CLUSTER_BREAK.CONTROL;
                  } else if (e < 768) {
                    if (e < 173) {
                      if (127 <= e && e <= 159)
                        return i.CLUSTER_BREAK.CONTROL;
                    } else if (e === 173)
                      return i.CLUSTER_BREAK.CONTROL;
                  } else if (e < 1155) {
                    if (768 <= e && e <= 879)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1425) {
                    if (1155 <= e && e <= 1161)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (1425 <= e && e <= 1469)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 1552) {
                  if (e < 1476) {
                    if (e < 1473) {
                      if (e === 1471)
                        return i.CLUSTER_BREAK.EXTEND;
                    } else if (1473 <= e && e <= 1474)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1479) {
                    if (1476 <= e && e <= 1477)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1536) {
                    if (e === 1479)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (1536 <= e && e <= 1541)
                    return i.CLUSTER_BREAK.PREPEND;
                } else if (e < 1648) {
                  if (e < 1564) {
                    if (1552 <= e && e <= 1562)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1611) {
                    if (e === 1564)
                      return i.CLUSTER_BREAK.CONTROL;
                  } else if (1611 <= e && e <= 1631)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 1750) {
                  if (e === 1648)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 1757) {
                  if (1750 <= e && e <= 1756)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 1757)
                  return i.CLUSTER_BREAK.PREPEND;
              } else if (e < 2075) {
                if (e < 1840)
                  if (e < 1770) {
                    if (e < 1767) {
                      if (1759 <= e && e <= 1764)
                        return i.CLUSTER_BREAK.EXTEND;
                    } else if (1767 <= e && e <= 1768)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 1807) {
                    if (1770 <= e && e <= 1773)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else {
                    if (e === 1807)
                      return i.CLUSTER_BREAK.PREPEND;
                    if (e === 1809)
                      return i.CLUSTER_BREAK.EXTEND;
                  }
                else if (e < 2027) {
                  if (e < 1958) {
                    if (1840 <= e && e <= 1866)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (1958 <= e && e <= 1968)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2045) {
                  if (2027 <= e && e <= 2035)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2070) {
                  if (e === 2045)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (2070 <= e && e <= 2073)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2200) {
                if (e < 2089) {
                  if (e < 2085) {
                    if (2075 <= e && e <= 2083)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (2085 <= e && e <= 2087)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2137) {
                  if (2089 <= e && e <= 2093)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2192) {
                  if (2137 <= e && e <= 2139)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (2192 <= e && e <= 2193)
                  return i.CLUSTER_BREAK.PREPEND;
              } else if (e < 2275) {
                if (e < 2250) {
                  if (2200 <= e && e <= 2207)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2274) {
                  if (2250 <= e && e <= 2273)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 2274)
                  return i.CLUSTER_BREAK.PREPEND;
              } else if (e < 2307) {
                if (2275 <= e && e <= 2306)
                  return i.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 2307)
                  return i.CLUSTER_BREAK.SPACINGMARK;
                if (e === 2362)
                  return i.CLUSTER_BREAK.EXTEND;
              }
            else if (e < 2561) {
              if (e < 2434) {
                if (e < 2381) {
                  if (e < 2366) {
                    if (e === 2363)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                    if (e === 2364)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2369) {
                    if (2366 <= e && e <= 2368)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 2377) {
                    if (2369 <= e && e <= 2376)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (2377 <= e && e <= 2380)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2385) {
                  if (e < 2382) {
                    if (e === 2381)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (2382 <= e && e <= 2383)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2402) {
                  if (2385 <= e && e <= 2391)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2433) {
                  if (2402 <= e && e <= 2403)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 2433)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2503) {
                if (e < 2494) {
                  if (e < 2492) {
                    if (2434 <= e && e <= 2435)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e === 2492)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2495) {
                  if (e === 2494)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2497) {
                  if (2495 <= e && e <= 2496)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (2497 <= e && e <= 2500)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2519) {
                if (e < 2507) {
                  if (2503 <= e && e <= 2504)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2509) {
                  if (2507 <= e && e <= 2508)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e === 2509)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2530) {
                if (e === 2519)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2558) {
                if (2530 <= e && e <= 2531)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e === 2558)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 2691) {
              if (e < 2631) {
                if (e < 2620) {
                  if (e < 2563) {
                    if (2561 <= e && e <= 2562)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e === 2563)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2622) {
                  if (e === 2620)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2625) {
                  if (2622 <= e && e <= 2624)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (2625 <= e && e <= 2626)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2672) {
                if (e < 2635) {
                  if (2631 <= e && e <= 2632)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2641) {
                  if (2635 <= e && e <= 2637)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 2641)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2677) {
                if (2672 <= e && e <= 2673)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2689) {
                if (e === 2677)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (2689 <= e && e <= 2690)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 2761) {
              if (e < 2750) {
                if (e === 2691)
                  return i.CLUSTER_BREAK.SPACINGMARK;
                if (e === 2748)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 2753) {
                if (2750 <= e && e <= 2752)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 2759) {
                if (2753 <= e && e <= 2757)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (2759 <= e && e <= 2760)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 2786) {
              if (e < 2763) {
                if (e === 2761)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 2765) {
                if (2763 <= e && e <= 2764)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e === 2765)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 2810) {
              if (2786 <= e && e <= 2787)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 2817) {
              if (2810 <= e && e <= 2815)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e === 2817)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 3315) {
            if (e < 3076) {
              if (e < 2946) {
                if (e < 2887) {
                  if (e < 2878) {
                    if (e < 2876) {
                      if (2818 <= e && e <= 2819)
                        return i.CLUSTER_BREAK.SPACINGMARK;
                    } else if (e === 2876)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2880) {
                    if (2878 <= e && e <= 2879)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 2881) {
                    if (e === 2880)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                  } else if (2881 <= e && e <= 2884)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2893) {
                  if (e < 2891) {
                    if (2887 <= e && e <= 2888)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                  } else if (2891 <= e && e <= 2892)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 2901) {
                  if (e === 2893)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 2914) {
                  if (2901 <= e && e <= 2903)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (2914 <= e && e <= 2915)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3014) {
                if (e < 3007) {
                  if (e === 2946 || e === 3006)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 3008) {
                  if (e === 3007)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 3009) {
                  if (e === 3008)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (3009 <= e && e <= 3010)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3031) {
                if (e < 3018) {
                  if (3014 <= e && e <= 3016)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 3021) {
                  if (3018 <= e && e <= 3020)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e === 3021)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3072) {
                if (e === 3031)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3073) {
                if (e === 3072)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (3073 <= e && e <= 3075)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3262) {
              if (e < 3146) {
                if (e < 3134) {
                  if (e === 3076 || e === 3132)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 3137) {
                  if (3134 <= e && e <= 3136)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 3142) {
                  if (3137 <= e && e <= 3140)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (3142 <= e && e <= 3144)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3201) {
                if (e < 3157) {
                  if (3146 <= e && e <= 3149)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 3170) {
                  if (3157 <= e && e <= 3158)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (3170 <= e && e <= 3171)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3202) {
                if (e === 3201)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3260) {
                if (3202 <= e && e <= 3203)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e === 3260)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 3270) {
              if (e < 3264) {
                if (e === 3262)
                  return i.CLUSTER_BREAK.SPACINGMARK;
                if (e === 3263)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3266) {
                if (3264 <= e && e <= 3265)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3267) {
                if (e === 3266)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (3267 <= e && e <= 3268)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3276) {
              if (e < 3271) {
                if (e === 3270)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3274) {
                if (3271 <= e && e <= 3272)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (3274 <= e && e <= 3275)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3285) {
              if (3276 <= e && e <= 3277)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 3298) {
              if (3285 <= e && e <= 3286)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (3298 <= e && e <= 3299)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 3551) {
            if (e < 3406) {
              if (e < 3391) {
                if (e < 3330) {
                  if (e < 3328) {
                    if (e === 3315)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                  } else if (3328 <= e && e <= 3329)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 3387) {
                  if (3330 <= e && e <= 3331)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 3390) {
                  if (3387 <= e && e <= 3388)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 3390)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3398) {
                if (e < 3393) {
                  if (3391 <= e && e <= 3392)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (3393 <= e && e <= 3396)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3402) {
                if (3398 <= e && e <= 3400)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3405) {
                if (3402 <= e && e <= 3404)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e === 3405)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 3530) {
              if (e < 3426) {
                if (e === 3406)
                  return i.CLUSTER_BREAK.PREPEND;
                if (e === 3415)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3457) {
                if (3426 <= e && e <= 3427)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3458) {
                if (e === 3457)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (3458 <= e && e <= 3459)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3538) {
              if (e < 3535) {
                if (e === 3530)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3536) {
                if (e === 3535)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (3536 <= e && e <= 3537)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3542) {
              if (3538 <= e && e <= 3540)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 3544) {
              if (e === 3542)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (3544 <= e && e <= 3550)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 3893) {
            if (e < 3655) {
              if (e < 3633) {
                if (e < 3570) {
                  if (e === 3551)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (3570 <= e && e <= 3571)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 3635) {
                if (e === 3633)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 3636) {
                if (e === 3635)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (3636 <= e && e <= 3642)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 3764)
              if (e < 3761) {
                if (3655 <= e && e <= 3662)
                  return i.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 3761)
                  return i.CLUSTER_BREAK.EXTEND;
                if (e === 3763)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              }
            else if (e < 3784) {
              if (3764 <= e && e <= 3772)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 3864) {
              if (3784 <= e && e <= 3790)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (3864 <= e && e <= 3865)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 3967) {
            if (e < 3897) {
              if (e === 3893 || e === 3895)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 3902) {
              if (e === 3897)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 3953) {
              if (3902 <= e && e <= 3903)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (3953 <= e && e <= 3966)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 3981) {
            if (e < 3968) {
              if (e === 3967)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 3974) {
              if (3968 <= e && e <= 3972)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (3974 <= e && e <= 3975)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 3993) {
            if (3981 <= e && e <= 3991)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 4038) {
            if (3993 <= e && e <= 4028)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e === 4038)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 7204) {
          if (e < 6448) {
            if (e < 5938) {
              if (e < 4226) {
                if (e < 4157) {
                  if (e < 4146) {
                    if (e < 4145) {
                      if (4141 <= e && e <= 4144)
                        return i.CLUSTER_BREAK.EXTEND;
                    } else if (e === 4145)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e < 4153) {
                    if (4146 <= e && e <= 4151)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e < 4155) {
                    if (4153 <= e && e <= 4154)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (4155 <= e && e <= 4156)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 4184) {
                  if (e < 4182) {
                    if (4157 <= e && e <= 4158)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (4182 <= e && e <= 4183)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 4190) {
                  if (4184 <= e && e <= 4185)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 4209) {
                  if (4190 <= e && e <= 4192)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (4209 <= e && e <= 4212)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 4352) {
                if (e < 4229) {
                  if (e === 4226)
                    return i.CLUSTER_BREAK.EXTEND;
                  if (e === 4228)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 4237) {
                  if (4229 <= e && e <= 4230)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 4237 || e === 4253)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 4957) {
                if (e < 4448) {
                  if (4352 <= e && e <= 4447)
                    return i.CLUSTER_BREAK.L;
                } else if (e < 4520) {
                  if (4448 <= e && e <= 4519)
                    return i.CLUSTER_BREAK.V;
                } else if (4520 <= e && e <= 4607)
                  return i.CLUSTER_BREAK.T;
              } else if (e < 5906) {
                if (4957 <= e && e <= 4959)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 5909) {
                if (5906 <= e && e <= 5908)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e === 5909)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 6089) {
              if (e < 6070) {
                if (e < 5970) {
                  if (e < 5940) {
                    if (5938 <= e && e <= 5939)
                      return i.CLUSTER_BREAK.EXTEND;
                  } else if (e === 5940)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 6002) {
                  if (5970 <= e && e <= 5971)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 6068) {
                  if (6002 <= e && e <= 6003)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (6068 <= e && e <= 6069)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6078) {
                if (e < 6071) {
                  if (e === 6070)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (6071 <= e && e <= 6077)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6086) {
                if (6078 <= e && e <= 6085)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 6087) {
                if (e === 6086)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (6087 <= e && e <= 6088)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 6277)
              if (e < 6155) {
                if (e < 6109) {
                  if (6089 <= e && e <= 6099)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 6109)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6158) {
                if (6155 <= e && e <= 6157)
                  return i.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 6158)
                  return i.CLUSTER_BREAK.CONTROL;
                if (e === 6159)
                  return i.CLUSTER_BREAK.EXTEND;
              }
            else if (e < 6435) {
              if (e < 6313) {
                if (6277 <= e && e <= 6278)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6432) {
                if (e === 6313)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (6432 <= e && e <= 6434)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 6439) {
              if (6435 <= e && e <= 6438)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 6441) {
              if (6439 <= e && e <= 6440)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (6441 <= e && e <= 6443)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 6971) {
            if (e < 6744)
              if (e < 6681) {
                if (e < 6451) {
                  if (e < 6450) {
                    if (6448 <= e && e <= 6449)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                  } else if (e === 6450)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 6457) {
                  if (6451 <= e && e <= 6456)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 6679) {
                  if (6457 <= e && e <= 6459)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (6679 <= e && e <= 6680)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6741) {
                if (e < 6683) {
                  if (6681 <= e && e <= 6682)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e === 6683)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6742) {
                if (e === 6741)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else {
                if (e === 6742)
                  return i.CLUSTER_BREAK.EXTEND;
                if (e === 6743)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              }
            else if (e < 6771) {
              if (e < 6754) {
                if (e < 6752) {
                  if (6744 <= e && e <= 6750)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 6752)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6757) {
                if (e === 6754)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6765) {
                if (6757 <= e && e <= 6764)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (6765 <= e && e <= 6770)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 6912) {
              if (e < 6783) {
                if (6771 <= e && e <= 6780)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6832) {
                if (e === 6783)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (6832 <= e && e <= 6862)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 6916) {
              if (6912 <= e && e <= 6915)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 6964) {
              if (e === 6916)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (6964 <= e && e <= 6970)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 7080) {
            if (e < 7019) {
              if (e < 6973) {
                if (e === 6971)
                  return i.CLUSTER_BREAK.SPACINGMARK;
                if (e === 6972)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 6978) {
                if (6973 <= e && e <= 6977)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 6979) {
                if (e === 6978)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (6979 <= e && e <= 6980)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 7073) {
              if (e < 7040) {
                if (7019 <= e && e <= 7027)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 7042) {
                if (7040 <= e && e <= 7041)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e === 7042)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 7074) {
              if (e === 7073)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 7078) {
              if (7074 <= e && e <= 7077)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (7078 <= e && e <= 7079)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 7144)
            if (e < 7083) {
              if (e < 7082) {
                if (7080 <= e && e <= 7081)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e === 7082)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 7142) {
              if (7083 <= e && e <= 7085)
                return i.CLUSTER_BREAK.EXTEND;
            } else {
              if (e === 7142)
                return i.CLUSTER_BREAK.EXTEND;
              if (e === 7143)
                return i.CLUSTER_BREAK.SPACINGMARK;
            }
          else if (e < 7150) {
            if (e < 7146) {
              if (7144 <= e && e <= 7145)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 7149) {
              if (7146 <= e && e <= 7148)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 7149)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 7151) {
            if (e === 7150)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 7154) {
            if (7151 <= e && e <= 7153)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (7154 <= e && e <= 7155)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 43346) {
          if (e < 11647) {
            if (e < 7415) {
              if (e < 7380) {
                if (e < 7220) {
                  if (e < 7212) {
                    if (7204 <= e && e <= 7211)
                      return i.CLUSTER_BREAK.SPACINGMARK;
                  } else if (7212 <= e && e <= 7219)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e < 7222) {
                  if (7220 <= e && e <= 7221)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (e < 7376) {
                  if (7222 <= e && e <= 7223)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (7376 <= e && e <= 7378)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 7394) {
                if (e < 7393) {
                  if (7380 <= e && e <= 7392)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 7393)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 7405) {
                if (7394 <= e && e <= 7400)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e === 7405 || e === 7412)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 8205)
              if (e < 7616) {
                if (e < 7416) {
                  if (e === 7415)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (7416 <= e && e <= 7417)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 8203) {
                if (7616 <= e && e <= 7679)
                  return i.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 8203)
                  return i.CLUSTER_BREAK.CONTROL;
                if (e === 8204)
                  return i.CLUSTER_BREAK.EXTEND;
              }
            else if (e < 8288) {
              if (e < 8206) {
                if (e === 8205)
                  return i.CLUSTER_BREAK.ZWJ;
              } else if (e < 8232) {
                if (8206 <= e && e <= 8207)
                  return i.CLUSTER_BREAK.CONTROL;
              } else if (8232 <= e && e <= 8238)
                return i.CLUSTER_BREAK.CONTROL;
            } else if (e < 8400) {
              if (8288 <= e && e <= 8303)
                return i.CLUSTER_BREAK.CONTROL;
            } else if (e < 11503) {
              if (8400 <= e && e <= 8432)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (11503 <= e && e <= 11505)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 43043) {
            if (e < 42612) {
              if (e < 12330) {
                if (e < 11744) {
                  if (e === 11647)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (11744 <= e && e <= 11775)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 12441) {
                if (12330 <= e && e <= 12335)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 42607) {
                if (12441 <= e && e <= 12442)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (42607 <= e && e <= 42610)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 43010) {
              if (e < 42654) {
                if (42612 <= e && e <= 42621)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 42736) {
                if (42654 <= e && e <= 42655)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (42736 <= e && e <= 42737)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 43014) {
              if (e === 43010)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e === 43014 || e === 43019)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 43188) {
            if (e < 43047) {
              if (e < 43045) {
                if (43043 <= e && e <= 43044)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (43045 <= e && e <= 43046)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 43052) {
              if (e === 43047)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43136) {
              if (e === 43052)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (43136 <= e && e <= 43137)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 43263) {
            if (e < 43204) {
              if (43188 <= e && e <= 43203)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43232) {
              if (43204 <= e && e <= 43205)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (43232 <= e && e <= 43249)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 43302) {
            if (e === 43263)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 43335) {
            if (43302 <= e && e <= 43309)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (43335 <= e && e <= 43345)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 43698) {
          if (e < 43493) {
            if (e < 43444)
              if (e < 43392) {
                if (e < 43360) {
                  if (43346 <= e && e <= 43347)
                    return i.CLUSTER_BREAK.SPACINGMARK;
                } else if (43360 <= e && e <= 43388)
                  return i.CLUSTER_BREAK.L;
              } else if (e < 43395) {
                if (43392 <= e && e <= 43394)
                  return i.CLUSTER_BREAK.EXTEND;
              } else {
                if (e === 43395)
                  return i.CLUSTER_BREAK.SPACINGMARK;
                if (e === 43443)
                  return i.CLUSTER_BREAK.EXTEND;
              }
            else if (e < 43450) {
              if (e < 43446) {
                if (43444 <= e && e <= 43445)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (43446 <= e && e <= 43449)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 43452) {
              if (43450 <= e && e <= 43451)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43454) {
              if (43452 <= e && e <= 43453)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (43454 <= e && e <= 43456)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 43573) {
            if (e < 43567) {
              if (e < 43561) {
                if (e === 43493)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (43561 <= e && e <= 43566)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 43569) {
              if (43567 <= e && e <= 43568)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 43571) {
              if (43569 <= e && e <= 43570)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (43571 <= e && e <= 43572)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 43597) {
            if (e < 43587) {
              if (43573 <= e && e <= 43574)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e === 43587 || e === 43596)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 43644) {
            if (e === 43597)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e === 43644 || e === 43696)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 44006) {
          if (e < 43756)
            if (e < 43710) {
              if (e < 43703) {
                if (43698 <= e && e <= 43700)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (43703 <= e && e <= 43704)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 43713) {
              if (43710 <= e && e <= 43711)
                return i.CLUSTER_BREAK.EXTEND;
            } else {
              if (e === 43713)
                return i.CLUSTER_BREAK.EXTEND;
              if (e === 43755)
                return i.CLUSTER_BREAK.SPACINGMARK;
            }
          else if (e < 43766) {
            if (e < 43758) {
              if (43756 <= e && e <= 43757)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 43765) {
              if (43758 <= e && e <= 43759)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 43765)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 44003) {
            if (e === 43766)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 44005) {
            if (44003 <= e && e <= 44004)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e === 44005)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 44032)
          if (e < 44009) {
            if (e < 44008) {
              if (44006 <= e && e <= 44007)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 44008)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 44012) {
            if (44009 <= e && e <= 44010)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else {
            if (e === 44012)
              return i.CLUSTER_BREAK.SPACINGMARK;
            if (e === 44013)
              return i.CLUSTER_BREAK.EXTEND;
          }
        else if (e < 44061) {
          if (e < 44033) {
            if (e === 44032)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 44060) {
            if (44033 <= e && e <= 44059)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 44060)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 44088) {
          if (44061 <= e && e <= 44087)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 44089) {
          if (e === 44088)
            return i.CLUSTER_BREAK.LV;
        } else if (44089 <= e && e <= 44115)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 46497) {
        if (e < 45293) {
          if (e < 44704) {
            if (e < 44397) {
              if (e < 44256) {
                if (e < 44173) {
                  if (e < 44144) {
                    if (e < 44117) {
                      if (e === 44116)
                        return i.CLUSTER_BREAK.LV;
                    } else if (44117 <= e && e <= 44143)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e < 44145) {
                    if (e === 44144)
                      return i.CLUSTER_BREAK.LV;
                  } else if (e < 44172) {
                    if (44145 <= e && e <= 44171)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e === 44172)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 44201) {
                  if (e < 44200) {
                    if (44173 <= e && e <= 44199)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e === 44200)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 44228) {
                  if (44201 <= e && e <= 44227)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 44229) {
                  if (e === 44228)
                    return i.CLUSTER_BREAK.LV;
                } else if (44229 <= e && e <= 44255)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 44313) {
                if (e < 44284) {
                  if (e < 44257) {
                    if (e === 44256)
                      return i.CLUSTER_BREAK.LV;
                  } else if (44257 <= e && e <= 44283)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 44285) {
                  if (e === 44284)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 44312) {
                  if (44285 <= e && e <= 44311)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 44312)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 44368) {
                if (e < 44340) {
                  if (44313 <= e && e <= 44339)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 44341) {
                  if (e === 44340)
                    return i.CLUSTER_BREAK.LV;
                } else if (44341 <= e && e <= 44367)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 44369) {
                if (e === 44368)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 44396) {
                if (44369 <= e && e <= 44395)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 44396)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 44537) {
              if (e < 44480) {
                if (e < 44425) {
                  if (e < 44424) {
                    if (44397 <= e && e <= 44423)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e === 44424)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 44452) {
                  if (44425 <= e && e <= 44451)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 44453) {
                  if (e === 44452)
                    return i.CLUSTER_BREAK.LV;
                } else if (44453 <= e && e <= 44479)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 44508) {
                if (e < 44481) {
                  if (e === 44480)
                    return i.CLUSTER_BREAK.LV;
                } else if (44481 <= e && e <= 44507)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 44509) {
                if (e === 44508)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 44536) {
                if (44509 <= e && e <= 44535)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 44536)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 44620) {
              if (e < 44565) {
                if (e < 44564) {
                  if (44537 <= e && e <= 44563)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 44564)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 44592) {
                if (44565 <= e && e <= 44591)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 44593) {
                if (e === 44592)
                  return i.CLUSTER_BREAK.LV;
              } else if (44593 <= e && e <= 44619)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 44649) {
              if (e < 44621) {
                if (e === 44620)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 44648) {
                if (44621 <= e && e <= 44647)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 44648)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 44676) {
              if (44649 <= e && e <= 44675)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 44677) {
              if (e === 44676)
                return i.CLUSTER_BREAK.LV;
            } else if (44677 <= e && e <= 44703)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 44985) {
            if (e < 44844) {
              if (e < 44761) {
                if (e < 44732) {
                  if (e < 44705) {
                    if (e === 44704)
                      return i.CLUSTER_BREAK.LV;
                  } else if (44705 <= e && e <= 44731)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 44733) {
                  if (e === 44732)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 44760) {
                  if (44733 <= e && e <= 44759)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 44760)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 44789) {
                if (e < 44788) {
                  if (44761 <= e && e <= 44787)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 44788)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 44816) {
                if (44789 <= e && e <= 44815)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 44817) {
                if (e === 44816)
                  return i.CLUSTER_BREAK.LV;
              } else if (44817 <= e && e <= 44843)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 44901) {
              if (e < 44872) {
                if (e < 44845) {
                  if (e === 44844)
                    return i.CLUSTER_BREAK.LV;
                } else if (44845 <= e && e <= 44871)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 44873) {
                if (e === 44872)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 44900) {
                if (44873 <= e && e <= 44899)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 44900)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 44956) {
              if (e < 44928) {
                if (44901 <= e && e <= 44927)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 44929) {
                if (e === 44928)
                  return i.CLUSTER_BREAK.LV;
              } else if (44929 <= e && e <= 44955)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 44957) {
              if (e === 44956)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 44984) {
              if (44957 <= e && e <= 44983)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 44984)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 45152) {
            if (e < 45068) {
              if (e < 45013) {
                if (e < 45012) {
                  if (44985 <= e && e <= 45011)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 45012)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 45040) {
                if (45013 <= e && e <= 45039)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 45041) {
                if (e === 45040)
                  return i.CLUSTER_BREAK.LV;
              } else if (45041 <= e && e <= 45067)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 45097) {
              if (e < 45069) {
                if (e === 45068)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 45096) {
                if (45069 <= e && e <= 45095)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 45096)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45124) {
              if (45097 <= e && e <= 45123)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 45125) {
              if (e === 45124)
                return i.CLUSTER_BREAK.LV;
            } else if (45125 <= e && e <= 45151)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 45209) {
            if (e < 45180) {
              if (e < 45153) {
                if (e === 45152)
                  return i.CLUSTER_BREAK.LV;
              } else if (45153 <= e && e <= 45179)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 45181) {
              if (e === 45180)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45208) {
              if (45181 <= e && e <= 45207)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 45208)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 45264) {
            if (e < 45236) {
              if (45209 <= e && e <= 45235)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 45237) {
              if (e === 45236)
                return i.CLUSTER_BREAK.LV;
            } else if (45237 <= e && e <= 45263)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 45265) {
            if (e === 45264)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 45292) {
            if (45265 <= e && e <= 45291)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 45292)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 45908) {
          if (e < 45600) {
            if (e < 45433) {
              if (e < 45376) {
                if (e < 45321) {
                  if (e < 45320) {
                    if (45293 <= e && e <= 45319)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e === 45320)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 45348) {
                  if (45321 <= e && e <= 45347)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 45349) {
                  if (e === 45348)
                    return i.CLUSTER_BREAK.LV;
                } else if (45349 <= e && e <= 45375)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 45404) {
                if (e < 45377) {
                  if (e === 45376)
                    return i.CLUSTER_BREAK.LV;
                } else if (45377 <= e && e <= 45403)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 45405) {
                if (e === 45404)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 45432) {
                if (45405 <= e && e <= 45431)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 45432)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45516) {
              if (e < 45461) {
                if (e < 45460) {
                  if (45433 <= e && e <= 45459)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 45460)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 45488) {
                if (45461 <= e && e <= 45487)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 45489) {
                if (e === 45488)
                  return i.CLUSTER_BREAK.LV;
              } else if (45489 <= e && e <= 45515)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 45545) {
              if (e < 45517) {
                if (e === 45516)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 45544) {
                if (45517 <= e && e <= 45543)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 45544)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45572) {
              if (45545 <= e && e <= 45571)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 45573) {
              if (e === 45572)
                return i.CLUSTER_BREAK.LV;
            } else if (45573 <= e && e <= 45599)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 45741) {
            if (e < 45657) {
              if (e < 45628) {
                if (e < 45601) {
                  if (e === 45600)
                    return i.CLUSTER_BREAK.LV;
                } else if (45601 <= e && e <= 45627)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 45629) {
                if (e === 45628)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 45656) {
                if (45629 <= e && e <= 45655)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 45656)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45712) {
              if (e < 45684) {
                if (45657 <= e && e <= 45683)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 45685) {
                if (e === 45684)
                  return i.CLUSTER_BREAK.LV;
              } else if (45685 <= e && e <= 45711)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 45713) {
              if (e === 45712)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45740) {
              if (45713 <= e && e <= 45739)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 45740)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 45824) {
            if (e < 45769) {
              if (e < 45768) {
                if (45741 <= e && e <= 45767)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 45768)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45796) {
              if (45769 <= e && e <= 45795)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 45797) {
              if (e === 45796)
                return i.CLUSTER_BREAK.LV;
            } else if (45797 <= e && e <= 45823)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 45853) {
            if (e < 45825) {
              if (e === 45824)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45852) {
              if (45825 <= e && e <= 45851)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 45852)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 45880) {
            if (45853 <= e && e <= 45879)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 45881) {
            if (e === 45880)
              return i.CLUSTER_BREAK.LV;
          } else if (45881 <= e && e <= 45907)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 46189) {
          if (e < 46048) {
            if (e < 45965) {
              if (e < 45936) {
                if (e < 45909) {
                  if (e === 45908)
                    return i.CLUSTER_BREAK.LV;
                } else if (45909 <= e && e <= 45935)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 45937) {
                if (e === 45936)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 45964) {
                if (45937 <= e && e <= 45963)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 45964)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 45993) {
              if (e < 45992) {
                if (45965 <= e && e <= 45991)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 45992)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 46020) {
              if (45993 <= e && e <= 46019)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 46021) {
              if (e === 46020)
                return i.CLUSTER_BREAK.LV;
            } else if (46021 <= e && e <= 46047)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 46105) {
            if (e < 46076) {
              if (e < 46049) {
                if (e === 46048)
                  return i.CLUSTER_BREAK.LV;
              } else if (46049 <= e && e <= 46075)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 46077) {
              if (e === 46076)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 46104) {
              if (46077 <= e && e <= 46103)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 46104)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 46160) {
            if (e < 46132) {
              if (46105 <= e && e <= 46131)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 46133) {
              if (e === 46132)
                return i.CLUSTER_BREAK.LV;
            } else if (46133 <= e && e <= 46159)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 46161) {
            if (e === 46160)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 46188) {
            if (46161 <= e && e <= 46187)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 46188)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 46356) {
          if (e < 46272) {
            if (e < 46217) {
              if (e < 46216) {
                if (46189 <= e && e <= 46215)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 46216)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 46244) {
              if (46217 <= e && e <= 46243)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 46245) {
              if (e === 46244)
                return i.CLUSTER_BREAK.LV;
            } else if (46245 <= e && e <= 46271)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 46301) {
            if (e < 46273) {
              if (e === 46272)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 46300) {
              if (46273 <= e && e <= 46299)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 46300)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 46328) {
            if (46301 <= e && e <= 46327)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 46329) {
            if (e === 46328)
              return i.CLUSTER_BREAK.LV;
          } else if (46329 <= e && e <= 46355)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 46413) {
          if (e < 46384) {
            if (e < 46357) {
              if (e === 46356)
                return i.CLUSTER_BREAK.LV;
            } else if (46357 <= e && e <= 46383)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 46385) {
            if (e === 46384)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 46412) {
            if (46385 <= e && e <= 46411)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 46412)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 46468) {
          if (e < 46440) {
            if (46413 <= e && e <= 46439)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 46441) {
            if (e === 46440)
              return i.CLUSTER_BREAK.LV;
          } else if (46441 <= e && e <= 46467)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 46469) {
          if (e === 46468)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 46496) {
          if (46469 <= e && e <= 46495)
            return i.CLUSTER_BREAK.LVT;
        } else if (e === 46496)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 47701) {
        if (e < 47112) {
          if (e < 46804) {
            if (e < 46637) {
              if (e < 46580) {
                if (e < 46525) {
                  if (e < 46524) {
                    if (46497 <= e && e <= 46523)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e === 46524)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 46552) {
                  if (46525 <= e && e <= 46551)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 46553) {
                  if (e === 46552)
                    return i.CLUSTER_BREAK.LV;
                } else if (46553 <= e && e <= 46579)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 46608) {
                if (e < 46581) {
                  if (e === 46580)
                    return i.CLUSTER_BREAK.LV;
                } else if (46581 <= e && e <= 46607)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 46609) {
                if (e === 46608)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 46636) {
                if (46609 <= e && e <= 46635)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 46636)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 46720) {
              if (e < 46665) {
                if (e < 46664) {
                  if (46637 <= e && e <= 46663)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 46664)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 46692) {
                if (46665 <= e && e <= 46691)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 46693) {
                if (e === 46692)
                  return i.CLUSTER_BREAK.LV;
              } else if (46693 <= e && e <= 46719)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 46749) {
              if (e < 46721) {
                if (e === 46720)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 46748) {
                if (46721 <= e && e <= 46747)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 46748)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 46776) {
              if (46749 <= e && e <= 46775)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 46777) {
              if (e === 46776)
                return i.CLUSTER_BREAK.LV;
            } else if (46777 <= e && e <= 46803)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 46945) {
            if (e < 46861) {
              if (e < 46832) {
                if (e < 46805) {
                  if (e === 46804)
                    return i.CLUSTER_BREAK.LV;
                } else if (46805 <= e && e <= 46831)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 46833) {
                if (e === 46832)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 46860) {
                if (46833 <= e && e <= 46859)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 46860)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 46916) {
              if (e < 46888) {
                if (46861 <= e && e <= 46887)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 46889) {
                if (e === 46888)
                  return i.CLUSTER_BREAK.LV;
              } else if (46889 <= e && e <= 46915)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 46917) {
              if (e === 46916)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 46944) {
              if (46917 <= e && e <= 46943)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 46944)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 47028) {
            if (e < 46973) {
              if (e < 46972) {
                if (46945 <= e && e <= 46971)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 46972)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47e3) {
              if (46973 <= e && e <= 46999)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 47001) {
              if (e === 47e3)
                return i.CLUSTER_BREAK.LV;
            } else if (47001 <= e && e <= 47027)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47057) {
            if (e < 47029) {
              if (e === 47028)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47056) {
              if (47029 <= e && e <= 47055)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 47056)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 47084) {
            if (47057 <= e && e <= 47083)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47085) {
            if (e === 47084)
              return i.CLUSTER_BREAK.LV;
          } else if (47085 <= e && e <= 47111)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 47393) {
          if (e < 47252) {
            if (e < 47169) {
              if (e < 47140) {
                if (e < 47113) {
                  if (e === 47112)
                    return i.CLUSTER_BREAK.LV;
                } else if (47113 <= e && e <= 47139)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 47141) {
                if (e === 47140)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 47168) {
                if (47141 <= e && e <= 47167)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 47168)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47197) {
              if (e < 47196) {
                if (47169 <= e && e <= 47195)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 47196)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47224) {
              if (47197 <= e && e <= 47223)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 47225) {
              if (e === 47224)
                return i.CLUSTER_BREAK.LV;
            } else if (47225 <= e && e <= 47251)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47309) {
            if (e < 47280) {
              if (e < 47253) {
                if (e === 47252)
                  return i.CLUSTER_BREAK.LV;
              } else if (47253 <= e && e <= 47279)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 47281) {
              if (e === 47280)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47308) {
              if (47281 <= e && e <= 47307)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 47308)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 47364) {
            if (e < 47336) {
              if (47309 <= e && e <= 47335)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 47337) {
              if (e === 47336)
                return i.CLUSTER_BREAK.LV;
            } else if (47337 <= e && e <= 47363)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47365) {
            if (e === 47364)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 47392) {
            if (47365 <= e && e <= 47391)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 47392)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 47560) {
          if (e < 47476) {
            if (e < 47421) {
              if (e < 47420) {
                if (47393 <= e && e <= 47419)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 47420)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47448) {
              if (47421 <= e && e <= 47447)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 47449) {
              if (e === 47448)
                return i.CLUSTER_BREAK.LV;
            } else if (47449 <= e && e <= 47475)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47505) {
            if (e < 47477) {
              if (e === 47476)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47504) {
              if (47477 <= e && e <= 47503)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 47504)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 47532) {
            if (47505 <= e && e <= 47531)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47533) {
            if (e === 47532)
              return i.CLUSTER_BREAK.LV;
          } else if (47533 <= e && e <= 47559)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 47617) {
          if (e < 47588) {
            if (e < 47561) {
              if (e === 47560)
                return i.CLUSTER_BREAK.LV;
            } else if (47561 <= e && e <= 47587)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47589) {
            if (e === 47588)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 47616) {
            if (47589 <= e && e <= 47615)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 47616)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 47672) {
          if (e < 47644) {
            if (47617 <= e && e <= 47643)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47645) {
            if (e === 47644)
              return i.CLUSTER_BREAK.LV;
          } else if (47645 <= e && e <= 47671)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 47673) {
          if (e === 47672)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 47700) {
          if (47673 <= e && e <= 47699)
            return i.CLUSTER_BREAK.LVT;
        } else if (e === 47700)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 48316) {
        if (e < 48008) {
          if (e < 47841) {
            if (e < 47784) {
              if (e < 47729) {
                if (e < 47728) {
                  if (47701 <= e && e <= 47727)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 47728)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 47756) {
                if (47729 <= e && e <= 47755)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 47757) {
                if (e === 47756)
                  return i.CLUSTER_BREAK.LV;
              } else if (47757 <= e && e <= 47783)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 47812) {
              if (e < 47785) {
                if (e === 47784)
                  return i.CLUSTER_BREAK.LV;
              } else if (47785 <= e && e <= 47811)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 47813) {
              if (e === 47812)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47840) {
              if (47813 <= e && e <= 47839)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 47840)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 47924) {
            if (e < 47869) {
              if (e < 47868) {
                if (47841 <= e && e <= 47867)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 47868)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47896) {
              if (47869 <= e && e <= 47895)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 47897) {
              if (e === 47896)
                return i.CLUSTER_BREAK.LV;
            } else if (47897 <= e && e <= 47923)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47953) {
            if (e < 47925) {
              if (e === 47924)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 47952) {
              if (47925 <= e && e <= 47951)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 47952)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 47980) {
            if (47953 <= e && e <= 47979)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 47981) {
            if (e === 47980)
              return i.CLUSTER_BREAK.LV;
          } else if (47981 <= e && e <= 48007)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48149) {
          if (e < 48065) {
            if (e < 48036) {
              if (e < 48009) {
                if (e === 48008)
                  return i.CLUSTER_BREAK.LV;
              } else if (48009 <= e && e <= 48035)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 48037) {
              if (e === 48036)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 48064) {
              if (48037 <= e && e <= 48063)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 48064)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48120) {
            if (e < 48092) {
              if (48065 <= e && e <= 48091)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 48093) {
              if (e === 48092)
                return i.CLUSTER_BREAK.LV;
            } else if (48093 <= e && e <= 48119)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 48121) {
            if (e === 48120)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48148) {
            if (48121 <= e && e <= 48147)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 48148)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 48232) {
          if (e < 48177) {
            if (e < 48176) {
              if (48149 <= e && e <= 48175)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 48176)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48204) {
            if (48177 <= e && e <= 48203)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 48205) {
            if (e === 48204)
              return i.CLUSTER_BREAK.LV;
          } else if (48205 <= e && e <= 48231)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48261) {
          if (e < 48233) {
            if (e === 48232)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48260) {
            if (48233 <= e && e <= 48259)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 48260)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 48288) {
          if (48261 <= e && e <= 48287)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48289) {
          if (e === 48288)
            return i.CLUSTER_BREAK.LV;
        } else if (48289 <= e && e <= 48315)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 48597) {
        if (e < 48456) {
          if (e < 48373) {
            if (e < 48344) {
              if (e < 48317) {
                if (e === 48316)
                  return i.CLUSTER_BREAK.LV;
              } else if (48317 <= e && e <= 48343)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 48345) {
              if (e === 48344)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 48372) {
              if (48345 <= e && e <= 48371)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 48372)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48401) {
            if (e < 48400) {
              if (48373 <= e && e <= 48399)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 48400)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48428) {
            if (48401 <= e && e <= 48427)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 48429) {
            if (e === 48428)
              return i.CLUSTER_BREAK.LV;
          } else if (48429 <= e && e <= 48455)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48513) {
          if (e < 48484) {
            if (e < 48457) {
              if (e === 48456)
                return i.CLUSTER_BREAK.LV;
            } else if (48457 <= e && e <= 48483)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 48485) {
            if (e === 48484)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48512) {
            if (48485 <= e && e <= 48511)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 48512)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 48568) {
          if (e < 48540) {
            if (48513 <= e && e <= 48539)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 48541) {
            if (e === 48540)
              return i.CLUSTER_BREAK.LV;
          } else if (48541 <= e && e <= 48567)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48569) {
          if (e === 48568)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 48596) {
          if (48569 <= e && e <= 48595)
            return i.CLUSTER_BREAK.LVT;
        } else if (e === 48596)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 48764) {
        if (e < 48680) {
          if (e < 48625) {
            if (e < 48624) {
              if (48597 <= e && e <= 48623)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 48624)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48652) {
            if (48625 <= e && e <= 48651)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 48653) {
            if (e === 48652)
              return i.CLUSTER_BREAK.LV;
          } else if (48653 <= e && e <= 48679)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48709) {
          if (e < 48681) {
            if (e === 48680)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 48708) {
            if (48681 <= e && e <= 48707)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 48708)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 48736) {
          if (48709 <= e && e <= 48735)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48737) {
          if (e === 48736)
            return i.CLUSTER_BREAK.LV;
        } else if (48737 <= e && e <= 48763)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 48821) {
        if (e < 48792) {
          if (e < 48765) {
            if (e === 48764)
              return i.CLUSTER_BREAK.LV;
          } else if (48765 <= e && e <= 48791)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48793) {
          if (e === 48792)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 48820) {
          if (48793 <= e && e <= 48819)
            return i.CLUSTER_BREAK.LVT;
        } else if (e === 48820)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 48876) {
        if (e < 48848) {
          if (48821 <= e && e <= 48847)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 48849) {
          if (e === 48848)
            return i.CLUSTER_BREAK.LV;
        } else if (48849 <= e && e <= 48875)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 48877) {
        if (e === 48876)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 48904) {
        if (48877 <= e && e <= 48903)
          return i.CLUSTER_BREAK.LVT;
      } else if (e === 48904)
        return i.CLUSTER_BREAK.LV;
    } else if (e < 53720) {
      if (e < 51312) {
        if (e < 50108) {
          if (e < 49493) {
            if (e < 49212) {
              if (e < 49045) {
                if (e < 48988) {
                  if (e < 48933) {
                    if (e < 48932) {
                      if (48905 <= e && e <= 48931)
                        return i.CLUSTER_BREAK.LVT;
                    } else if (e === 48932)
                      return i.CLUSTER_BREAK.LV;
                  } else if (e < 48960) {
                    if (48933 <= e && e <= 48959)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e < 48961) {
                    if (e === 48960)
                      return i.CLUSTER_BREAK.LV;
                  } else if (48961 <= e && e <= 48987)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 49016) {
                  if (e < 48989) {
                    if (e === 48988)
                      return i.CLUSTER_BREAK.LV;
                  } else if (48989 <= e && e <= 49015)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 49017) {
                  if (e === 49016)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 49044) {
                  if (49017 <= e && e <= 49043)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 49044)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49128) {
                if (e < 49073) {
                  if (e < 49072) {
                    if (49045 <= e && e <= 49071)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e === 49072)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 49100) {
                  if (49073 <= e && e <= 49099)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 49101) {
                  if (e === 49100)
                    return i.CLUSTER_BREAK.LV;
                } else if (49101 <= e && e <= 49127)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49157) {
                if (e < 49129) {
                  if (e === 49128)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 49156) {
                  if (49129 <= e && e <= 49155)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 49156)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49184) {
                if (49157 <= e && e <= 49183)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49185) {
                if (e === 49184)
                  return i.CLUSTER_BREAK.LV;
              } else if (49185 <= e && e <= 49211)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 49352) {
              if (e < 49269) {
                if (e < 49240) {
                  if (e < 49213) {
                    if (e === 49212)
                      return i.CLUSTER_BREAK.LV;
                  } else if (49213 <= e && e <= 49239)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 49241) {
                  if (e === 49240)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 49268) {
                  if (49241 <= e && e <= 49267)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 49268)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49297) {
                if (e < 49296) {
                  if (49269 <= e && e <= 49295)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 49296)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49324) {
                if (49297 <= e && e <= 49323)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49325) {
                if (e === 49324)
                  return i.CLUSTER_BREAK.LV;
              } else if (49325 <= e && e <= 49351)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 49409) {
              if (e < 49380) {
                if (e < 49353) {
                  if (e === 49352)
                    return i.CLUSTER_BREAK.LV;
                } else if (49353 <= e && e <= 49379)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49381) {
                if (e === 49380)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49408) {
                if (49381 <= e && e <= 49407)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 49408)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 49464) {
              if (e < 49436) {
                if (49409 <= e && e <= 49435)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49437) {
                if (e === 49436)
                  return i.CLUSTER_BREAK.LV;
              } else if (49437 <= e && e <= 49463)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 49465) {
              if (e === 49464)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 49492) {
              if (49465 <= e && e <= 49491)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 49492)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 49800) {
            if (e < 49633) {
              if (e < 49576) {
                if (e < 49521) {
                  if (e < 49520) {
                    if (49493 <= e && e <= 49519)
                      return i.CLUSTER_BREAK.LVT;
                  } else if (e === 49520)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 49548) {
                  if (49521 <= e && e <= 49547)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 49549) {
                  if (e === 49548)
                    return i.CLUSTER_BREAK.LV;
                } else if (49549 <= e && e <= 49575)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49604) {
                if (e < 49577) {
                  if (e === 49576)
                    return i.CLUSTER_BREAK.LV;
                } else if (49577 <= e && e <= 49603)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49605) {
                if (e === 49604)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49632) {
                if (49605 <= e && e <= 49631)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 49632)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 49716) {
              if (e < 49661) {
                if (e < 49660) {
                  if (49633 <= e && e <= 49659)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 49660)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49688) {
                if (49661 <= e && e <= 49687)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49689) {
                if (e === 49688)
                  return i.CLUSTER_BREAK.LV;
              } else if (49689 <= e && e <= 49715)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 49745) {
              if (e < 49717) {
                if (e === 49716)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49744) {
                if (49717 <= e && e <= 49743)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 49744)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 49772) {
              if (49745 <= e && e <= 49771)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 49773) {
              if (e === 49772)
                return i.CLUSTER_BREAK.LV;
            } else if (49773 <= e && e <= 49799)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 49941) {
            if (e < 49857) {
              if (e < 49828) {
                if (e < 49801) {
                  if (e === 49800)
                    return i.CLUSTER_BREAK.LV;
                } else if (49801 <= e && e <= 49827)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49829) {
                if (e === 49828)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 49856) {
                if (49829 <= e && e <= 49855)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 49856)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 49912) {
              if (e < 49884) {
                if (49857 <= e && e <= 49883)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 49885) {
                if (e === 49884)
                  return i.CLUSTER_BREAK.LV;
              } else if (49885 <= e && e <= 49911)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 49913) {
              if (e === 49912)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 49940) {
              if (49913 <= e && e <= 49939)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 49940)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 50024) {
            if (e < 49969) {
              if (e < 49968) {
                if (49941 <= e && e <= 49967)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 49968)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 49996) {
              if (49969 <= e && e <= 49995)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 49997) {
              if (e === 49996)
                return i.CLUSTER_BREAK.LV;
            } else if (49997 <= e && e <= 50023)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 50053) {
            if (e < 50025) {
              if (e === 50024)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 50052) {
              if (50025 <= e && e <= 50051)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 50052)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 50080) {
            if (50053 <= e && e <= 50079)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 50081) {
            if (e === 50080)
              return i.CLUSTER_BREAK.LV;
          } else if (50081 <= e && e <= 50107)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 50697) {
          if (e < 50389) {
            if (e < 50248) {
              if (e < 50165) {
                if (e < 50136) {
                  if (e < 50109) {
                    if (e === 50108)
                      return i.CLUSTER_BREAK.LV;
                  } else if (50109 <= e && e <= 50135)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 50137) {
                  if (e === 50136)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 50164) {
                  if (50137 <= e && e <= 50163)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 50164)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 50193) {
                if (e < 50192) {
                  if (50165 <= e && e <= 50191)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 50192)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 50220) {
                if (50193 <= e && e <= 50219)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 50221) {
                if (e === 50220)
                  return i.CLUSTER_BREAK.LV;
              } else if (50221 <= e && e <= 50247)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50305) {
              if (e < 50276) {
                if (e < 50249) {
                  if (e === 50248)
                    return i.CLUSTER_BREAK.LV;
                } else if (50249 <= e && e <= 50275)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 50277) {
                if (e === 50276)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 50304) {
                if (50277 <= e && e <= 50303)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 50304)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 50360) {
              if (e < 50332) {
                if (50305 <= e && e <= 50331)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 50333) {
                if (e === 50332)
                  return i.CLUSTER_BREAK.LV;
              } else if (50333 <= e && e <= 50359)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50361) {
              if (e === 50360)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 50388) {
              if (50361 <= e && e <= 50387)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 50388)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 50556) {
            if (e < 50472) {
              if (e < 50417) {
                if (e < 50416) {
                  if (50389 <= e && e <= 50415)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 50416)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 50444) {
                if (50417 <= e && e <= 50443)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 50445) {
                if (e === 50444)
                  return i.CLUSTER_BREAK.LV;
              } else if (50445 <= e && e <= 50471)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50501) {
              if (e < 50473) {
                if (e === 50472)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 50500) {
                if (50473 <= e && e <= 50499)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 50500)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 50528) {
              if (50501 <= e && e <= 50527)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50529) {
              if (e === 50528)
                return i.CLUSTER_BREAK.LV;
            } else if (50529 <= e && e <= 50555)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 50613) {
            if (e < 50584) {
              if (e < 50557) {
                if (e === 50556)
                  return i.CLUSTER_BREAK.LV;
              } else if (50557 <= e && e <= 50583)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50585) {
              if (e === 50584)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 50612) {
              if (50585 <= e && e <= 50611)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 50612)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 50668) {
            if (e < 50640) {
              if (50613 <= e && e <= 50639)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50641) {
              if (e === 50640)
                return i.CLUSTER_BREAK.LV;
            } else if (50641 <= e && e <= 50667)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 50669) {
            if (e === 50668)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 50696) {
            if (50669 <= e && e <= 50695)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 50696)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 51004) {
          if (e < 50837) {
            if (e < 50780) {
              if (e < 50725) {
                if (e < 50724) {
                  if (50697 <= e && e <= 50723)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 50724)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 50752) {
                if (50725 <= e && e <= 50751)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 50753) {
                if (e === 50752)
                  return i.CLUSTER_BREAK.LV;
              } else if (50753 <= e && e <= 50779)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50808) {
              if (e < 50781) {
                if (e === 50780)
                  return i.CLUSTER_BREAK.LV;
              } else if (50781 <= e && e <= 50807)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50809) {
              if (e === 50808)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 50836) {
              if (50809 <= e && e <= 50835)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 50836)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 50920) {
            if (e < 50865) {
              if (e < 50864) {
                if (50837 <= e && e <= 50863)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 50864)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 50892) {
              if (50865 <= e && e <= 50891)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 50893) {
              if (e === 50892)
                return i.CLUSTER_BREAK.LV;
            } else if (50893 <= e && e <= 50919)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 50949) {
            if (e < 50921) {
              if (e === 50920)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 50948) {
              if (50921 <= e && e <= 50947)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 50948)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 50976) {
            if (50949 <= e && e <= 50975)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 50977) {
            if (e === 50976)
              return i.CLUSTER_BREAK.LV;
          } else if (50977 <= e && e <= 51003)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 51145) {
          if (e < 51061) {
            if (e < 51032) {
              if (e < 51005) {
                if (e === 51004)
                  return i.CLUSTER_BREAK.LV;
              } else if (51005 <= e && e <= 51031)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 51033) {
              if (e === 51032)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 51060) {
              if (51033 <= e && e <= 51059)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 51060)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 51116) {
            if (e < 51088) {
              if (51061 <= e && e <= 51087)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 51089) {
              if (e === 51088)
                return i.CLUSTER_BREAK.LV;
            } else if (51089 <= e && e <= 51115)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 51117) {
            if (e === 51116)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 51144) {
            if (51117 <= e && e <= 51143)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 51144)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 51228) {
          if (e < 51173) {
            if (e < 51172) {
              if (51145 <= e && e <= 51171)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 51172)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 51200) {
            if (51173 <= e && e <= 51199)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 51201) {
            if (e === 51200)
              return i.CLUSTER_BREAK.LV;
          } else if (51201 <= e && e <= 51227)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 51257) {
          if (e < 51229) {
            if (e === 51228)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 51256) {
            if (51229 <= e && e <= 51255)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 51256)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 51284) {
          if (51257 <= e && e <= 51283)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 51285) {
          if (e === 51284)
            return i.CLUSTER_BREAK.LV;
        } else if (51285 <= e && e <= 51311)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 52516) {
        if (e < 51901) {
          if (e < 51593) {
            if (e < 51452) {
              if (e < 51369) {
                if (e < 51340) {
                  if (e < 51313) {
                    if (e === 51312)
                      return i.CLUSTER_BREAK.LV;
                  } else if (51313 <= e && e <= 51339)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 51341) {
                  if (e === 51340)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 51368) {
                  if (51341 <= e && e <= 51367)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 51368)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 51397) {
                if (e < 51396) {
                  if (51369 <= e && e <= 51395)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 51396)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 51424) {
                if (51397 <= e && e <= 51423)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 51425) {
                if (e === 51424)
                  return i.CLUSTER_BREAK.LV;
              } else if (51425 <= e && e <= 51451)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 51509) {
              if (e < 51480) {
                if (e < 51453) {
                  if (e === 51452)
                    return i.CLUSTER_BREAK.LV;
                } else if (51453 <= e && e <= 51479)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 51481) {
                if (e === 51480)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 51508) {
                if (51481 <= e && e <= 51507)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 51508)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 51564) {
              if (e < 51536) {
                if (51509 <= e && e <= 51535)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 51537) {
                if (e === 51536)
                  return i.CLUSTER_BREAK.LV;
              } else if (51537 <= e && e <= 51563)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 51565) {
              if (e === 51564)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 51592) {
              if (51565 <= e && e <= 51591)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 51592)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 51760) {
            if (e < 51676) {
              if (e < 51621) {
                if (e < 51620) {
                  if (51593 <= e && e <= 51619)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 51620)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 51648) {
                if (51621 <= e && e <= 51647)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 51649) {
                if (e === 51648)
                  return i.CLUSTER_BREAK.LV;
              } else if (51649 <= e && e <= 51675)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 51705) {
              if (e < 51677) {
                if (e === 51676)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 51704) {
                if (51677 <= e && e <= 51703)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 51704)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 51732) {
              if (51705 <= e && e <= 51731)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 51733) {
              if (e === 51732)
                return i.CLUSTER_BREAK.LV;
            } else if (51733 <= e && e <= 51759)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 51817) {
            if (e < 51788) {
              if (e < 51761) {
                if (e === 51760)
                  return i.CLUSTER_BREAK.LV;
              } else if (51761 <= e && e <= 51787)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 51789) {
              if (e === 51788)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 51816) {
              if (51789 <= e && e <= 51815)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 51816)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 51872) {
            if (e < 51844) {
              if (51817 <= e && e <= 51843)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 51845) {
              if (e === 51844)
                return i.CLUSTER_BREAK.LV;
            } else if (51845 <= e && e <= 51871)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 51873) {
            if (e === 51872)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 51900) {
            if (51873 <= e && e <= 51899)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 51900)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 52208) {
          if (e < 52041) {
            if (e < 51984) {
              if (e < 51929) {
                if (e < 51928) {
                  if (51901 <= e && e <= 51927)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 51928)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 51956) {
                if (51929 <= e && e <= 51955)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 51957) {
                if (e === 51956)
                  return i.CLUSTER_BREAK.LV;
              } else if (51957 <= e && e <= 51983)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52012) {
              if (e < 51985) {
                if (e === 51984)
                  return i.CLUSTER_BREAK.LV;
              } else if (51985 <= e && e <= 52011)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52013) {
              if (e === 52012)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52040) {
              if (52013 <= e && e <= 52039)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 52040)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52124) {
            if (e < 52069) {
              if (e < 52068) {
                if (52041 <= e && e <= 52067)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 52068)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52096) {
              if (52069 <= e && e <= 52095)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52097) {
              if (e === 52096)
                return i.CLUSTER_BREAK.LV;
            } else if (52097 <= e && e <= 52123)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52153) {
            if (e < 52125) {
              if (e === 52124)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52152) {
              if (52125 <= e && e <= 52151)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 52152)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52180) {
            if (52153 <= e && e <= 52179)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52181) {
            if (e === 52180)
              return i.CLUSTER_BREAK.LV;
          } else if (52181 <= e && e <= 52207)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 52349) {
          if (e < 52265) {
            if (e < 52236) {
              if (e < 52209) {
                if (e === 52208)
                  return i.CLUSTER_BREAK.LV;
              } else if (52209 <= e && e <= 52235)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52237) {
              if (e === 52236)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52264) {
              if (52237 <= e && e <= 52263)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 52264)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52320) {
            if (e < 52292) {
              if (52265 <= e && e <= 52291)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52293) {
              if (e === 52292)
                return i.CLUSTER_BREAK.LV;
            } else if (52293 <= e && e <= 52319)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52321) {
            if (e === 52320)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52348) {
            if (52321 <= e && e <= 52347)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 52348)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 52432) {
          if (e < 52377) {
            if (e < 52376) {
              if (52349 <= e && e <= 52375)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 52376)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52404) {
            if (52377 <= e && e <= 52403)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52405) {
            if (e === 52404)
              return i.CLUSTER_BREAK.LV;
          } else if (52405 <= e && e <= 52431)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 52461) {
          if (e < 52433) {
            if (e === 52432)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52460) {
            if (52433 <= e && e <= 52459)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 52460)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 52488) {
          if (52461 <= e && e <= 52487)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 52489) {
          if (e === 52488)
            return i.CLUSTER_BREAK.LV;
        } else if (52489 <= e && e <= 52515)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 53105) {
        if (e < 52797) {
          if (e < 52656) {
            if (e < 52573) {
              if (e < 52544) {
                if (e < 52517) {
                  if (e === 52516)
                    return i.CLUSTER_BREAK.LV;
                } else if (52517 <= e && e <= 52543)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 52545) {
                if (e === 52544)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 52572) {
                if (52545 <= e && e <= 52571)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 52572)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52601) {
              if (e < 52600) {
                if (52573 <= e && e <= 52599)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 52600)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52628) {
              if (52601 <= e && e <= 52627)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52629) {
              if (e === 52628)
                return i.CLUSTER_BREAK.LV;
            } else if (52629 <= e && e <= 52655)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52713) {
            if (e < 52684) {
              if (e < 52657) {
                if (e === 52656)
                  return i.CLUSTER_BREAK.LV;
              } else if (52657 <= e && e <= 52683)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52685) {
              if (e === 52684)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52712) {
              if (52685 <= e && e <= 52711)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 52712)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52768) {
            if (e < 52740) {
              if (52713 <= e && e <= 52739)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52741) {
              if (e === 52740)
                return i.CLUSTER_BREAK.LV;
            } else if (52741 <= e && e <= 52767)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52769) {
            if (e === 52768)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52796) {
            if (52769 <= e && e <= 52795)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 52796)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 52964) {
          if (e < 52880) {
            if (e < 52825) {
              if (e < 52824) {
                if (52797 <= e && e <= 52823)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 52824)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52852) {
              if (52825 <= e && e <= 52851)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 52853) {
              if (e === 52852)
                return i.CLUSTER_BREAK.LV;
            } else if (52853 <= e && e <= 52879)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52909) {
            if (e < 52881) {
              if (e === 52880)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 52908) {
              if (52881 <= e && e <= 52907)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 52908)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 52936) {
            if (52909 <= e && e <= 52935)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52937) {
            if (e === 52936)
              return i.CLUSTER_BREAK.LV;
          } else if (52937 <= e && e <= 52963)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 53021) {
          if (e < 52992) {
            if (e < 52965) {
              if (e === 52964)
                return i.CLUSTER_BREAK.LV;
            } else if (52965 <= e && e <= 52991)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 52993) {
            if (e === 52992)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 53020) {
            if (52993 <= e && e <= 53019)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 53020)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 53076) {
          if (e < 53048) {
            if (53021 <= e && e <= 53047)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 53049) {
            if (e === 53048)
              return i.CLUSTER_BREAK.LV;
          } else if (53049 <= e && e <= 53075)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 53077) {
          if (e === 53076)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 53104) {
          if (53077 <= e && e <= 53103)
            return i.CLUSTER_BREAK.LVT;
        } else if (e === 53104)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 53412) {
        if (e < 53245) {
          if (e < 53188) {
            if (e < 53133) {
              if (e < 53132) {
                if (53105 <= e && e <= 53131)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 53132)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 53160) {
              if (53133 <= e && e <= 53159)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 53161) {
              if (e === 53160)
                return i.CLUSTER_BREAK.LV;
            } else if (53161 <= e && e <= 53187)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 53216) {
            if (e < 53189) {
              if (e === 53188)
                return i.CLUSTER_BREAK.LV;
            } else if (53189 <= e && e <= 53215)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 53217) {
            if (e === 53216)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 53244) {
            if (53217 <= e && e <= 53243)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 53244)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 53328) {
          if (e < 53273) {
            if (e < 53272) {
              if (53245 <= e && e <= 53271)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 53272)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 53300) {
            if (53273 <= e && e <= 53299)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 53301) {
            if (e === 53300)
              return i.CLUSTER_BREAK.LV;
          } else if (53301 <= e && e <= 53327)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 53357) {
          if (e < 53329) {
            if (e === 53328)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 53356) {
            if (53329 <= e && e <= 53355)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 53356)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 53384) {
          if (53357 <= e && e <= 53383)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 53385) {
          if (e === 53384)
            return i.CLUSTER_BREAK.LV;
        } else if (53385 <= e && e <= 53411)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 53553) {
        if (e < 53469) {
          if (e < 53440) {
            if (e < 53413) {
              if (e === 53412)
                return i.CLUSTER_BREAK.LV;
            } else if (53413 <= e && e <= 53439)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 53441) {
            if (e === 53440)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 53468) {
            if (53441 <= e && e <= 53467)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 53468)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 53524) {
          if (e < 53496) {
            if (53469 <= e && e <= 53495)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 53497) {
            if (e === 53496)
              return i.CLUSTER_BREAK.LV;
          } else if (53497 <= e && e <= 53523)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 53525) {
          if (e === 53524)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 53552) {
          if (53525 <= e && e <= 53551)
            return i.CLUSTER_BREAK.LVT;
        } else if (e === 53552)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 53636) {
        if (e < 53581) {
          if (e < 53580) {
            if (53553 <= e && e <= 53579)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 53580)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 53608) {
          if (53581 <= e && e <= 53607)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 53609) {
          if (e === 53608)
            return i.CLUSTER_BREAK.LV;
        } else if (53609 <= e && e <= 53635)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 53665) {
        if (e < 53637) {
          if (e === 53636)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 53664) {
          if (53637 <= e && e <= 53663)
            return i.CLUSTER_BREAK.LVT;
        } else if (e === 53664)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 53692) {
        if (53665 <= e && e <= 53691)
          return i.CLUSTER_BREAK.LVT;
      } else if (e < 53693) {
        if (e === 53692)
          return i.CLUSTER_BREAK.LV;
      } else if (53693 <= e && e <= 53719)
        return i.CLUSTER_BREAK.LVT;
    } else if (e < 70459) {
      if (e < 54897) {
        if (e < 54308) {
          if (e < 54001) {
            if (e < 53860) {
              if (e < 53777) {
                if (e < 53748) {
                  if (e < 53721) {
                    if (e === 53720)
                      return i.CLUSTER_BREAK.LV;
                  } else if (53721 <= e && e <= 53747)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e < 53749) {
                  if (e === 53748)
                    return i.CLUSTER_BREAK.LV;
                } else if (e < 53776) {
                  if (53749 <= e && e <= 53775)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 53776)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 53805) {
                if (e < 53804) {
                  if (53777 <= e && e <= 53803)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 53804)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 53832) {
                if (53805 <= e && e <= 53831)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 53833) {
                if (e === 53832)
                  return i.CLUSTER_BREAK.LV;
              } else if (53833 <= e && e <= 53859)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 53917) {
              if (e < 53888) {
                if (e < 53861) {
                  if (e === 53860)
                    return i.CLUSTER_BREAK.LV;
                } else if (53861 <= e && e <= 53887)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 53889) {
                if (e === 53888)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 53916) {
                if (53889 <= e && e <= 53915)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 53916)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 53972) {
              if (e < 53944) {
                if (53917 <= e && e <= 53943)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 53945) {
                if (e === 53944)
                  return i.CLUSTER_BREAK.LV;
              } else if (53945 <= e && e <= 53971)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 53973) {
              if (e === 53972)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54e3) {
              if (53973 <= e && e <= 53999)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 54e3)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 54141) {
            if (e < 54084) {
              if (e < 54029) {
                if (e < 54028) {
                  if (54001 <= e && e <= 54027)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 54028)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 54056) {
                if (54029 <= e && e <= 54055)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 54057) {
                if (e === 54056)
                  return i.CLUSTER_BREAK.LV;
              } else if (54057 <= e && e <= 54083)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 54112) {
              if (e < 54085) {
                if (e === 54084)
                  return i.CLUSTER_BREAK.LV;
              } else if (54085 <= e && e <= 54111)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 54113) {
              if (e === 54112)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54140) {
              if (54113 <= e && e <= 54139)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 54140)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 54224) {
            if (e < 54169) {
              if (e < 54168) {
                if (54141 <= e && e <= 54167)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 54168)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54196) {
              if (54169 <= e && e <= 54195)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 54197) {
              if (e === 54196)
                return i.CLUSTER_BREAK.LV;
            } else if (54197 <= e && e <= 54223)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 54253) {
            if (e < 54225) {
              if (e === 54224)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54252) {
              if (54225 <= e && e <= 54251)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 54252)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 54280) {
            if (54253 <= e && e <= 54279)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 54281) {
            if (e === 54280)
              return i.CLUSTER_BREAK.LV;
          } else if (54281 <= e && e <= 54307)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 54589) {
          if (e < 54448) {
            if (e < 54365) {
              if (e < 54336) {
                if (e < 54309) {
                  if (e === 54308)
                    return i.CLUSTER_BREAK.LV;
                } else if (54309 <= e && e <= 54335)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 54337) {
                if (e === 54336)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 54364) {
                if (54337 <= e && e <= 54363)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 54364)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54393) {
              if (e < 54392) {
                if (54365 <= e && e <= 54391)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 54392)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54420) {
              if (54393 <= e && e <= 54419)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 54421) {
              if (e === 54420)
                return i.CLUSTER_BREAK.LV;
            } else if (54421 <= e && e <= 54447)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 54505) {
            if (e < 54476) {
              if (e < 54449) {
                if (e === 54448)
                  return i.CLUSTER_BREAK.LV;
              } else if (54449 <= e && e <= 54475)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 54477) {
              if (e === 54476)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54504) {
              if (54477 <= e && e <= 54503)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 54504)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 54560) {
            if (e < 54532) {
              if (54505 <= e && e <= 54531)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 54533) {
              if (e === 54532)
                return i.CLUSTER_BREAK.LV;
            } else if (54533 <= e && e <= 54559)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 54561) {
            if (e === 54560)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 54588) {
            if (54561 <= e && e <= 54587)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 54588)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 54756) {
          if (e < 54672) {
            if (e < 54617) {
              if (e < 54616) {
                if (54589 <= e && e <= 54615)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 54616)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54644) {
              if (54617 <= e && e <= 54643)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 54645) {
              if (e === 54644)
                return i.CLUSTER_BREAK.LV;
            } else if (54645 <= e && e <= 54671)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 54701) {
            if (e < 54673) {
              if (e === 54672)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 54700) {
              if (54673 <= e && e <= 54699)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 54700)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 54728) {
            if (54701 <= e && e <= 54727)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 54729) {
            if (e === 54728)
              return i.CLUSTER_BREAK.LV;
          } else if (54729 <= e && e <= 54755)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 54813) {
          if (e < 54784) {
            if (e < 54757) {
              if (e === 54756)
                return i.CLUSTER_BREAK.LV;
            } else if (54757 <= e && e <= 54783)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 54785) {
            if (e === 54784)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 54812) {
            if (54785 <= e && e <= 54811)
              return i.CLUSTER_BREAK.LVT;
          } else if (e === 54812)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 54868) {
          if (e < 54840) {
            if (54813 <= e && e <= 54839)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 54841) {
            if (e === 54840)
              return i.CLUSTER_BREAK.LV;
          } else if (54841 <= e && e <= 54867)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 54869) {
          if (e === 54868)
            return i.CLUSTER_BREAK.LV;
        } else if (e < 54896) {
          if (54869 <= e && e <= 54895)
            return i.CLUSTER_BREAK.LVT;
        } else if (e === 54896)
          return i.CLUSTER_BREAK.LV;
      } else if (e < 69632) {
        if (e < 55216) {
          if (e < 55037) {
            if (e < 54980) {
              if (e < 54925) {
                if (e < 54924) {
                  if (54897 <= e && e <= 54923)
                    return i.CLUSTER_BREAK.LVT;
                } else if (e === 54924)
                  return i.CLUSTER_BREAK.LV;
              } else if (e < 54952) {
                if (54925 <= e && e <= 54951)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e < 54953) {
                if (e === 54952)
                  return i.CLUSTER_BREAK.LV;
              } else if (54953 <= e && e <= 54979)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 55008) {
              if (e < 54981) {
                if (e === 54980)
                  return i.CLUSTER_BREAK.LV;
              } else if (54981 <= e && e <= 55007)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 55009) {
              if (e === 55008)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 55036) {
              if (55009 <= e && e <= 55035)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 55036)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 55120) {
            if (e < 55065) {
              if (e < 55064) {
                if (55037 <= e && e <= 55063)
                  return i.CLUSTER_BREAK.LVT;
              } else if (e === 55064)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 55092) {
              if (55065 <= e && e <= 55091)
                return i.CLUSTER_BREAK.LVT;
            } else if (e < 55093) {
              if (e === 55092)
                return i.CLUSTER_BREAK.LV;
            } else if (55093 <= e && e <= 55119)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 55149) {
            if (e < 55121) {
              if (e === 55120)
                return i.CLUSTER_BREAK.LV;
            } else if (e < 55148) {
              if (55121 <= e && e <= 55147)
                return i.CLUSTER_BREAK.LVT;
            } else if (e === 55148)
              return i.CLUSTER_BREAK.LV;
          } else if (e < 55176) {
            if (55149 <= e && e <= 55175)
              return i.CLUSTER_BREAK.LVT;
          } else if (e < 55177) {
            if (e === 55176)
              return i.CLUSTER_BREAK.LV;
          } else if (55177 <= e && e <= 55203)
            return i.CLUSTER_BREAK.LVT;
        } else if (e < 68097) {
          if (e < 65279) {
            if (e < 64286) {
              if (e < 55243) {
                if (55216 <= e && e <= 55238)
                  return i.CLUSTER_BREAK.V;
              } else if (55243 <= e && e <= 55291)
                return i.CLUSTER_BREAK.T;
            } else if (e < 65024) {
              if (e === 64286)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 65056) {
              if (65024 <= e && e <= 65039)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (65056 <= e && e <= 65071)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 66045) {
            if (e < 65438) {
              if (e === 65279)
                return i.CLUSTER_BREAK.CONTROL;
            } else if (e < 65520) {
              if (65438 <= e && e <= 65439)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (65520 <= e && e <= 65531)
              return i.CLUSTER_BREAK.CONTROL;
          } else if (e < 66272) {
            if (e === 66045)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 66422) {
            if (e === 66272)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (66422 <= e && e <= 66426)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 68325) {
          if (e < 68108) {
            if (e < 68101) {
              if (68097 <= e && e <= 68099)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (68101 <= e && e <= 68102)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 68152) {
            if (68108 <= e && e <= 68111)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 68159) {
            if (68152 <= e && e <= 68154)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e === 68159)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 69373) {
          if (e < 68900) {
            if (68325 <= e && e <= 68326)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 69291) {
            if (68900 <= e && e <= 68903)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (69291 <= e && e <= 69292)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 69446) {
          if (69373 <= e && e <= 69375)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 69506) {
          if (69446 <= e && e <= 69456)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (69506 <= e && e <= 69509)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 70016) {
        if (e < 69815) {
          if (e < 69747) {
            if (e < 69634) {
              if (e === 69632)
                return i.CLUSTER_BREAK.SPACINGMARK;
              if (e === 69633)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 69688) {
              if (e === 69634)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 69744) {
              if (69688 <= e && e <= 69702)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e === 69744)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 69762) {
            if (e < 69759) {
              if (69747 <= e && e <= 69748)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (69759 <= e && e <= 69761)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 69808) {
            if (e === 69762)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 69811) {
            if (69808 <= e && e <= 69810)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (69811 <= e && e <= 69814)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 69888)
          if (e < 69821) {
            if (e < 69817) {
              if (69815 <= e && e <= 69816)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (69817 <= e && e <= 69818)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 69826) {
            if (e === 69821)
              return i.CLUSTER_BREAK.PREPEND;
          } else {
            if (e === 69826)
              return i.CLUSTER_BREAK.EXTEND;
            if (e === 69837)
              return i.CLUSTER_BREAK.PREPEND;
          }
        else if (e < 69933) {
          if (e < 69927) {
            if (69888 <= e && e <= 69890)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 69932) {
            if (69927 <= e && e <= 69931)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e === 69932)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 69957) {
          if (69933 <= e && e <= 69940)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 70003) {
          if (69957 <= e && e <= 69958)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e === 70003)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 70194) {
        if (e < 70082) {
          if (e < 70067) {
            if (e < 70018) {
              if (70016 <= e && e <= 70017)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e === 70018)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 70070) {
            if (70067 <= e && e <= 70069)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 70079) {
            if (70070 <= e && e <= 70078)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (70079 <= e && e <= 70080)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 70095) {
          if (e < 70089) {
            if (70082 <= e && e <= 70083)
              return i.CLUSTER_BREAK.PREPEND;
          } else if (e < 70094) {
            if (70089 <= e && e <= 70092)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e === 70094)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 70188) {
          if (e === 70095)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 70191) {
          if (70188 <= e && e <= 70190)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (70191 <= e && e <= 70193)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 70209) {
        if (e < 70197) {
          if (e < 70196) {
            if (70194 <= e && e <= 70195)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e === 70196)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 70198) {
          if (e === 70197)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 70206) {
          if (70198 <= e && e <= 70199)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e === 70206)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 70371) {
        if (e < 70367) {
          if (e === 70209)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 70368) {
          if (e === 70367)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (70368 <= e && e <= 70370)
          return i.CLUSTER_BREAK.SPACINGMARK;
      } else if (e < 70400) {
        if (70371 <= e && e <= 70378)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 70402) {
        if (70400 <= e && e <= 70401)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (70402 <= e && e <= 70403)
        return i.CLUSTER_BREAK.SPACINGMARK;
    } else if (e < 72343) {
      if (e < 71339) {
        if (e < 70841) {
          if (e < 70512) {
            if (e < 70471) {
              if (e < 70463) {
                if (e < 70462) {
                  if (70459 <= e && e <= 70460)
                    return i.CLUSTER_BREAK.EXTEND;
                } else if (e === 70462)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (e < 70464) {
                if (e === 70463)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (e < 70465) {
                if (e === 70464)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (70465 <= e && e <= 70468)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 70487) {
              if (e < 70475) {
                if (70471 <= e && e <= 70472)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (70475 <= e && e <= 70477)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 70498) {
              if (e === 70487)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 70502) {
              if (70498 <= e && e <= 70499)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (70502 <= e && e <= 70508)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 70725) {
            if (e < 70712) {
              if (e < 70709) {
                if (70512 <= e && e <= 70516)
                  return i.CLUSTER_BREAK.EXTEND;
              } else if (70709 <= e && e <= 70711)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 70720) {
              if (70712 <= e && e <= 70719)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 70722) {
              if (70720 <= e && e <= 70721)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (70722 <= e && e <= 70724)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 70832) {
            if (e < 70726) {
              if (e === 70725)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e === 70726 || e === 70750)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 70833) {
            if (e === 70832)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 70835) {
            if (70833 <= e && e <= 70834)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (70835 <= e && e <= 70840)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 71096) {
          if (e < 70847)
            if (e < 70843) {
              if (e === 70841)
                return i.CLUSTER_BREAK.SPACINGMARK;
              if (e === 70842)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 70845) {
              if (70843 <= e && e <= 70844)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else {
              if (e === 70845)
                return i.CLUSTER_BREAK.EXTEND;
              if (e === 70846)
                return i.CLUSTER_BREAK.SPACINGMARK;
            }
          else if (e < 71087) {
            if (e < 70849) {
              if (70847 <= e && e <= 70848)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 70850) {
              if (e === 70849)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (70850 <= e && e <= 70851)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 71088) {
            if (e === 71087)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 71090) {
            if (71088 <= e && e <= 71089)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (71090 <= e && e <= 71093)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 71216) {
          if (e < 71102) {
            if (e < 71100) {
              if (71096 <= e && e <= 71099)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (71100 <= e && e <= 71101)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 71103) {
            if (e === 71102)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 71132) {
            if (71103 <= e && e <= 71104)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (71132 <= e && e <= 71133)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 71229) {
          if (e < 71219) {
            if (71216 <= e && e <= 71218)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 71227) {
            if (71219 <= e && e <= 71226)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (71227 <= e && e <= 71228)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 71230) {
          if (e === 71229)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 71231) {
          if (e === 71230)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (71231 <= e && e <= 71232)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 71999)
        if (e < 71463) {
          if (e < 71350) {
            if (e < 71341) {
              if (e === 71339)
                return i.CLUSTER_BREAK.EXTEND;
              if (e === 71340)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 71342) {
              if (e === 71341)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 71344) {
              if (71342 <= e && e <= 71343)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (71344 <= e && e <= 71349)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 71453) {
            if (e === 71350)
              return i.CLUSTER_BREAK.SPACINGMARK;
            if (e === 71351)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 71458) {
            if (71453 <= e && e <= 71455)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 71462) {
            if (71458 <= e && e <= 71461)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e === 71462)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 71984) {
          if (e < 71727) {
            if (e < 71724) {
              if (71463 <= e && e <= 71467)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (71724 <= e && e <= 71726)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 71736) {
            if (71727 <= e && e <= 71735)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 71737) {
            if (e === 71736)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (71737 <= e && e <= 71738)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 71995) {
          if (e < 71985) {
            if (e === 71984)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 71991) {
            if (71985 <= e && e <= 71989)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (71991 <= e && e <= 71992)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 71997) {
          if (71995 <= e && e <= 71996)
            return i.CLUSTER_BREAK.EXTEND;
        } else {
          if (e === 71997)
            return i.CLUSTER_BREAK.SPACINGMARK;
          if (e === 71998)
            return i.CLUSTER_BREAK.EXTEND;
        }
      else if (e < 72193)
        if (e < 72145)
          if (e < 72001) {
            if (e === 71999)
              return i.CLUSTER_BREAK.PREPEND;
            if (e === 72e3)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 72002) {
            if (e === 72001)
              return i.CLUSTER_BREAK.PREPEND;
          } else {
            if (e === 72002)
              return i.CLUSTER_BREAK.SPACINGMARK;
            if (e === 72003)
              return i.CLUSTER_BREAK.EXTEND;
          }
        else if (e < 72156) {
          if (e < 72148) {
            if (72145 <= e && e <= 72147)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 72154) {
            if (72148 <= e && e <= 72151)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (72154 <= e && e <= 72155)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 72160) {
          if (72156 <= e && e <= 72159)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else {
          if (e === 72160)
            return i.CLUSTER_BREAK.EXTEND;
          if (e === 72164)
            return i.CLUSTER_BREAK.SPACINGMARK;
        }
      else if (e < 72263) {
        if (e < 72249) {
          if (e < 72243) {
            if (72193 <= e && e <= 72202)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (72243 <= e && e <= 72248)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 72250) {
          if (e === 72249)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 72251) {
          if (e === 72250)
            return i.CLUSTER_BREAK.PREPEND;
        } else if (72251 <= e && e <= 72254)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 72281) {
        if (e < 72273) {
          if (e === 72263)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 72279) {
          if (72273 <= e && e <= 72278)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (72279 <= e && e <= 72280)
          return i.CLUSTER_BREAK.SPACINGMARK;
      } else if (e < 72324) {
        if (72281 <= e && e <= 72283)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 72330) {
        if (72324 <= e && e <= 72329)
          return i.CLUSTER_BREAK.PREPEND;
      } else if (72330 <= e && e <= 72342)
        return i.CLUSTER_BREAK.EXTEND;
    } else if (e < 94033) {
      if (e < 73104) {
        if (e < 72881) {
          if (e < 72766) {
            if (e < 72751) {
              if (e < 72344) {
                if (e === 72343)
                  return i.CLUSTER_BREAK.SPACINGMARK;
              } else if (72344 <= e && e <= 72345)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (e < 72752) {
              if (e === 72751)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (e < 72760) {
              if (72752 <= e && e <= 72758)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (72760 <= e && e <= 72765)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 72850) {
            if (e === 72766)
              return i.CLUSTER_BREAK.SPACINGMARK;
            if (e === 72767)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 72873) {
            if (72850 <= e && e <= 72871)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 72874) {
            if (e === 72873)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (72874 <= e && e <= 72880)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 73018) {
          if (e < 72884) {
            if (e < 72882) {
              if (e === 72881)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (72882 <= e && e <= 72883)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 72885) {
            if (e === 72884)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 73009) {
            if (72885 <= e && e <= 72886)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (73009 <= e && e <= 73014)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 73030) {
          if (e < 73020) {
            if (e === 73018)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 73023) {
            if (73020 <= e && e <= 73021)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (73023 <= e && e <= 73029)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 73031) {
          if (e === 73030)
            return i.CLUSTER_BREAK.PREPEND;
        } else if (e < 73098) {
          if (e === 73031)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (73098 <= e && e <= 73102)
          return i.CLUSTER_BREAK.SPACINGMARK;
      } else if (e < 73526) {
        if (e < 73459)
          if (e < 73109) {
            if (e < 73107) {
              if (73104 <= e && e <= 73105)
                return i.CLUSTER_BREAK.EXTEND;
            } else if (73107 <= e && e <= 73108)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (e < 73110) {
            if (e === 73109)
              return i.CLUSTER_BREAK.EXTEND;
          } else {
            if (e === 73110)
              return i.CLUSTER_BREAK.SPACINGMARK;
            if (e === 73111)
              return i.CLUSTER_BREAK.EXTEND;
          }
        else if (e < 73474) {
          if (e < 73461) {
            if (73459 <= e && e <= 73460)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 73472) {
            if (73461 <= e && e <= 73462)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (73472 <= e && e <= 73473)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 73475) {
          if (e === 73474)
            return i.CLUSTER_BREAK.PREPEND;
        } else if (e < 73524) {
          if (e === 73475)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (73524 <= e && e <= 73525)
          return i.CLUSTER_BREAK.SPACINGMARK;
      } else if (e < 78896)
        if (e < 73536) {
          if (e < 73534) {
            if (73526 <= e && e <= 73530)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (73534 <= e && e <= 73535)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 73537) {
          if (e === 73536)
            return i.CLUSTER_BREAK.EXTEND;
        } else {
          if (e === 73537)
            return i.CLUSTER_BREAK.SPACINGMARK;
          if (e === 73538)
            return i.CLUSTER_BREAK.EXTEND;
        }
      else if (e < 92912) {
        if (e < 78912) {
          if (78896 <= e && e <= 78911)
            return i.CLUSTER_BREAK.CONTROL;
        } else if (e < 78919) {
          if (e === 78912)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (78919 <= e && e <= 78933)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 92976) {
        if (92912 <= e && e <= 92916)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 94031) {
        if (92976 <= e && e <= 92982)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e === 94031)
        return i.CLUSTER_BREAK.EXTEND;
    } else if (e < 121476) {
      if (e < 119143)
        if (e < 113824) {
          if (e < 94180) {
            if (e < 94095) {
              if (94033 <= e && e <= 94087)
                return i.CLUSTER_BREAK.SPACINGMARK;
            } else if (94095 <= e && e <= 94098)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 94192) {
            if (e === 94180)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e < 113821) {
            if (94192 <= e && e <= 94193)
              return i.CLUSTER_BREAK.SPACINGMARK;
          } else if (113821 <= e && e <= 113822)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 118576) {
          if (e < 118528) {
            if (113824 <= e && e <= 113827)
              return i.CLUSTER_BREAK.CONTROL;
          } else if (118528 <= e && e <= 118573)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 119141) {
          if (118576 <= e && e <= 118598)
            return i.CLUSTER_BREAK.EXTEND;
        } else {
          if (e === 119141)
            return i.CLUSTER_BREAK.EXTEND;
          if (e === 119142)
            return i.CLUSTER_BREAK.SPACINGMARK;
        }
      else if (e < 119173) {
        if (e < 119150) {
          if (e < 119149) {
            if (119143 <= e && e <= 119145)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (e === 119149)
            return i.CLUSTER_BREAK.SPACINGMARK;
        } else if (e < 119155) {
          if (119150 <= e && e <= 119154)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 119163) {
          if (119155 <= e && e <= 119162)
            return i.CLUSTER_BREAK.CONTROL;
        } else if (119163 <= e && e <= 119170)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 121344) {
        if (e < 119210) {
          if (119173 <= e && e <= 119179)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 119362) {
          if (119210 <= e && e <= 119213)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (119362 <= e && e <= 119364)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 121403) {
        if (121344 <= e && e <= 121398)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 121461) {
        if (121403 <= e && e <= 121452)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e === 121461)
        return i.CLUSTER_BREAK.EXTEND;
    } else if (e < 123628) {
      if (e < 122907) {
        if (e < 121505) {
          if (e < 121499) {
            if (e === 121476)
              return i.CLUSTER_BREAK.EXTEND;
          } else if (121499 <= e && e <= 121503)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 122880) {
          if (121505 <= e && e <= 121519)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 122888) {
          if (122880 <= e && e <= 122886)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (122888 <= e && e <= 122904)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 123023) {
        if (e < 122915) {
          if (122907 <= e && e <= 122913)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (e < 122918) {
          if (122915 <= e && e <= 122916)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (122918 <= e && e <= 122922)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 123184) {
        if (e === 123023)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 123566) {
        if (123184 <= e && e <= 123190)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e === 123566)
        return i.CLUSTER_BREAK.EXTEND;
    } else if (e < 127995) {
      if (e < 125136) {
        if (e < 124140) {
          if (123628 <= e && e <= 123631)
            return i.CLUSTER_BREAK.EXTEND;
        } else if (124140 <= e && e <= 124143)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 125252) {
        if (125136 <= e && e <= 125142)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 127462) {
        if (125252 <= e && e <= 125258)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (127462 <= e && e <= 127487)
        return i.CLUSTER_BREAK.REGIONAL_INDICATOR;
    } else if (e < 917632) {
      if (e < 917504) {
        if (127995 <= e && e <= 127999)
          return i.CLUSTER_BREAK.EXTEND;
      } else if (e < 917536) {
        if (917504 <= e && e <= 917535)
          return i.CLUSTER_BREAK.CONTROL;
      } else if (917536 <= e && e <= 917631)
        return i.CLUSTER_BREAK.EXTEND;
    } else if (e < 917760) {
      if (917632 <= e && e <= 917759)
        return i.CLUSTER_BREAK.CONTROL;
    } else if (e < 918e3) {
      if (917760 <= e && e <= 917999)
        return i.CLUSTER_BREAK.EXTEND;
    } else if (918e3 <= e && e <= 921599)
      return i.CLUSTER_BREAK.CONTROL;
    return i.CLUSTER_BREAK.OTHER;
  }
  /**
   * Given a Unicode code point, returns if symbol is an extended pictographic or some other break
   * @param code {number} Unicode code point
   * @returns {number}
   */
  static getEmojiProperty(e) {
    if (e < 10160) {
      if (e < 9728) {
        if (e < 9e3) {
          if (e < 8482) {
            if (e < 8252) {
              if (e === 169 || e === 174)
                return i.EXTENDED_PICTOGRAPHIC;
            } else if (e === 8252 || e === 8265)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e < 8596) {
            if (e === 8482 || e === 8505)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e < 8617) {
            if (8596 <= e && e <= 8601)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e < 8986) {
            if (8617 <= e && e <= 8618)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (8986 <= e && e <= 8987)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 9410) {
          if (e < 9167) {
            if (e === 9e3 || e === 9096)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9193) {
            if (e === 9167)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9208) {
            if (9193 <= e && e <= 9203)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (9208 <= e && e <= 9210)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 9654) {
          if (e < 9642) {
            if (e === 9410)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (9642 <= e && e <= 9643)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 9664) {
          if (e === 9654)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 9723) {
          if (e === 9664)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (9723 <= e && e <= 9726)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 10035) {
        if (e < 10004) {
          if (e < 9748) {
            if (e < 9735) {
              if (9728 <= e && e <= 9733)
                return i.EXTENDED_PICTOGRAPHIC;
            } else if (9735 <= e && e <= 9746)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9872) {
            if (9748 <= e && e <= 9861)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e < 9992) {
            if (9872 <= e && e <= 9989)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (9992 <= e && e <= 10002)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 10013) {
          if (e === 10004 || e === 10006)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 10017) {
          if (e === 10013)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e === 10017 || e === 10024)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 10067) {
        if (e < 10055) {
          if (e < 10052) {
            if (10035 <= e && e <= 10036)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e === 10052)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 10060) {
          if (e === 10055)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e === 10060 || e === 10062)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 10083) {
        if (e < 10071) {
          if (10067 <= e && e <= 10069)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e === 10071)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 10133) {
        if (10083 <= e && e <= 10087)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 10145) {
        if (10133 <= e && e <= 10135)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e === 10145)
        return i.EXTENDED_PICTOGRAPHIC;
    } else if (e < 127489) {
      if (e < 12951) {
        if (e < 11035) {
          if (e < 10548) {
            if (e === 10160 || e === 10175)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e < 11013) {
            if (10548 <= e && e <= 10549)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (11013 <= e && e <= 11015)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 11093) {
          if (e < 11088) {
            if (11035 <= e && e <= 11036)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e === 11088)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 12336) {
          if (e === 11093)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e === 12336 || e === 12349)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 127340) {
        if (e < 126976) {
          if (e === 12951 || e === 12953)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127245) {
          if (126976 <= e && e <= 127231)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127279) {
          if (127245 <= e && e <= 127247)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e === 127279)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 127374) {
        if (e < 127358) {
          if (127340 <= e && e <= 127345)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (127358 <= e && e <= 127359)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 127377) {
        if (e === 127374)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 127405) {
        if (127377 <= e && e <= 127386)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (127405 <= e && e <= 127461)
        return i.EXTENDED_PICTOGRAPHIC;
    } else if (e < 128981) {
      if (e < 127561) {
        if (e < 127535) {
          if (e < 127514) {
            if (127489 <= e && e <= 127503)
              return i.EXTENDED_PICTOGRAPHIC;
          } else if (e === 127514)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127538) {
          if (e === 127535)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (e < 127548) {
          if (127538 <= e && e <= 127546)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (127548 <= e && e <= 127551)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 128326) {
        if (e < 128e3) {
          if (127561 <= e && e <= 127994)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (128e3 <= e && e <= 128317)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 128640) {
        if (128326 <= e && e <= 128591)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 128884) {
        if (128640 <= e && e <= 128767)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (128884 <= e && e <= 128895)
        return i.EXTENDED_PICTOGRAPHIC;
    } else if (e < 129198) {
      if (e < 129096) {
        if (e < 129036) {
          if (128981 <= e && e <= 129023)
            return i.EXTENDED_PICTOGRAPHIC;
        } else if (129036 <= e && e <= 129039)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 129114) {
        if (129096 <= e && e <= 129103)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (e < 129160) {
        if (129114 <= e && e <= 129119)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (129160 <= e && e <= 129167)
        return i.EXTENDED_PICTOGRAPHIC;
    } else if (e < 129340) {
      if (e < 129292) {
        if (129198 <= e && e <= 129279)
          return i.EXTENDED_PICTOGRAPHIC;
      } else if (129292 <= e && e <= 129338)
        return i.EXTENDED_PICTOGRAPHIC;
    } else if (e < 129351) {
      if (129340 <= e && e <= 129349)
        return i.EXTENDED_PICTOGRAPHIC;
    } else if (e < 130048) {
      if (129351 <= e && e <= 129791)
        return i.EXTENDED_PICTOGRAPHIC;
    } else if (130048 <= e && e <= 131069)
      return i.EXTENDED_PICTOGRAPHIC;
    return i.CLUSTER_BREAK.OTHER;
  }
}
zl.default = Ei;
var ry = le && le.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(Xl, "__esModule", { value: !0 });
const iy = ry(zl);
Xl.default = iy.default;
var ny = le && le.__createBinding || (Object.create ? function(t, e, r, a) {
  a === void 0 && (a = r);
  var u = Object.getOwnPropertyDescriptor(e, r);
  (!u || ("get" in u ? !e.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, a, u);
} : function(t, e, r, a) {
  a === void 0 && (a = r), t[a] = e[r];
}), ay = le && le.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), sy = le && le.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && ny(e, t, r);
  return ay(e, t), e;
}, oy = le && le.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(Er, "__esModule", { value: !0 });
Er.validateLanguage = Er.parseLanguage = Er.b64UrlToUtf8 = Er.utf8ToB64Url = Er.graphemeLen = Er.utf8Len = void 0;
const ly = oy(Xl), Ko = sy(cc), uy = (t) => new TextEncoder().encode(t).byteLength;
Er.utf8Len = uy;
const fy = (t) => new ly.default().countGraphemes(t);
Er.graphemeLen = fy;
const cy = (t) => Ko.toString(Ko.fromString(t, "utf8"), "base64url");
Er.utf8ToB64Url = cy;
const dy = (t) => Ko.toString(Ko.fromString(t, "base64url"), "utf8");
Er.b64UrlToUtf8 = dy;
const py = (t) => {
  const e = t.match(yc);
  if (!e?.groups)
    return null;
  const r = e.groups;
  return {
    grandfathered: r.grandfathered,
    language: r.language,
    extlang: r.extlang,
    script: r.script,
    region: r.region,
    variant: r.variant,
    extension: r.extension,
    privateUse: r.privateUseA || r.privateUseB
  };
};
Er.parseLanguage = py;
const hy = (t) => yc.test(t);
Er.validateLanguage = hy;
const yc = /^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-(?<extension>[0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8})+))*(-(?<privateUseA>x(-[A-Za-z0-9]{1,8})+))?)|(?<privateUseB>x(-[A-Za-z0-9]{1,8})+))$/;
var bc = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.didDocument = t.getServiceEndpoint = t.getNotifEndpoint = t.getFeedGenEndpoint = t.getPdsEndpoint = t.getSigningDidKey = t.getVerificationMaterial = t.getSigningKey = t.getHandle = t.getDid = t.isValidDidDoc = void 0;
  const e = wn, r = (O) => t.didDocument.safeParse(O).success;
  t.isValidDidDoc = r;
  const a = (O) => {
    const j = O.id;
    if (typeof j != "string")
      throw new Error("No `id` on document");
    return j;
  };
  t.getDid = a;
  const u = (O) => {
    const j = O.alsoKnownAs;
    if (!j)
      return;
    const $ = j.find((z) => z.startsWith("at://"));
    if ($)
      return $.slice(5);
  };
  t.getHandle = u;
  const x = (O) => (0, t.getVerificationMaterial)(O, "atproto");
  t.getSigningKey = x;
  const y = (O, j) => {
    const $ = (0, t.getDid)(O);
    let z = O.verificationMethod;
    if (!z || typeof z != "object")
      return;
    Array.isArray(z) || (z = [z]);
    const Y = z.find((ie) => ie.id === `#${j}` || ie.id === `${$}#${j}`);
    if (Y?.publicKeyMultibase)
      return {
        type: Y.type,
        publicKeyMultibase: Y.publicKeyMultibase
      };
  };
  t.getVerificationMaterial = y;
  const p = (O) => {
    const j = (0, t.getSigningKey)(O);
    if (j)
      return `did:key:${j.publicKeyMultibase}`;
  };
  t.getSigningDidKey = p;
  const h = (O) => (0, t.getServiceEndpoint)(O, {
    id: "#atproto_pds",
    type: "AtprotoPersonalDataServer"
  });
  t.getPdsEndpoint = h;
  const m = (O) => (0, t.getServiceEndpoint)(O, {
    id: "#bsky_fg",
    type: "BskyFeedGenerator"
  });
  t.getFeedGenEndpoint = m;
  const d = (O) => (0, t.getServiceEndpoint)(O, {
    id: "#bsky_notif",
    type: "BskyNotificationService"
  });
  t.getNotifEndpoint = d;
  const T = (O, j) => {
    const $ = (0, t.getDid)(O);
    let z = O.service;
    if (!z || typeof z != "object")
      return;
    Array.isArray(z) || (z = [z]);
    const J = z.find((ie) => ie.id === F.id || ie.id === `${V}${F.id}`);
    if (J && !(F.type && J.type !== F.type) && typeof J.serviceEndpoint == "string")
      return S(J.serviceEndpoint);
  };
  t.getServiceEndpoint = T;
  const S = (O) => {
    let F;
    try {
      j = new URL(O);
    } catch {
      return;
    }
    if (["http:", "https:"].includes(j.protocol))
      return j.hostname ? O : void 0;
  }, B = e.z.object({
    id: e.z.string(),
    type: e.z.string(),
    controller: e.z.string(),
    publicKeyMultibase: e.z.string().optional()
  }), I = e.z.object({
    id: e.z.string(),
    type: e.z.string(),
    serviceEndpoint: e.z.union([e.z.string(), e.z.record(e.z.unknown())])
  });
  t.didDocument = e.z.object({
    id: e.z.string(),
    alsoKnownAs: e.z.array(e.z.string()).optional(),
    verificationMethod: e.z.array(B).optional(),
    service: e.z.array(I).optional()
  });
})(bc);
(function(t) {
  var e = le && le.__createBinding || (Object.create ? function(x, y, p, h) {
    h === void 0 && (h = p);
    var m = Object.getOwnPropertyDescriptor(y, p);
    (!m || ("get" in m ? !y.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
      return y[p];
    } }), Object.defineProperty(x, h, m);
  } : function(x, y, p, h) {
    h === void 0 && (h = p), x[h] = y[p];
  }), r = le && le.__setModuleDefault || (Object.create ? function(x, y) {
    Object.defineProperty(x, "default", { enumerable: !0, value: y });
  } : function(x, y) {
    x.default = y;
  }), a = le && le.__importStar || function(x) {
    if (x && x.__esModule) return x;
    var y = {};
    if (x != null) for (var p in x) p !== "default" && Object.prototype.hasOwnProperty.call(x, p) && e(y, x, p);
    return r(y, x), y;
  }, u = le && le.__exportStar || function(x, y) {
    for (var p in x) p !== "default" && !Object.prototype.hasOwnProperty.call(y, p) && e(y, x, p);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.util = t.check = void 0, t.check = a(Gi), t.util = a(On), u(Kn, t), u(nc, t), u(On, t), u(Ra, t), u(ac, t), u(Nn, t), u(pc, t), u(hc, t), u(Er, t), u(bc, t);
})(Ji);
var kt = {}, xc = {};
(function(t) {
  (() => {
    var e = { d: (d, T) => {
      for (var S in T) e.o(T, S) && !e.o(d, S) && Object.defineProperty(d, S, { enumerable: !0, get: T[S] });
    }, o: (d, T) => Object.prototype.hasOwnProperty.call(d, T), r: (d) => {
      typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(d, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(d, "__esModule", { value: !0 });
    } }, r = {};
    function a(d, T) {
      return T === void 0 && (T = "-"), new RegExp("^(?!0{4}" + T + "0{2}" + T + "0{2})((?=[0-9]{4}" + T + "(((0[^2])|1[0-2])|02(?=" + T + "(([0-1][0-9])|2[0-8])))" + T + "[0-9]{2})|(?=((([13579][26])|([2468][048])|(0[48]))0{2})|([0-9]{2}((((0|[2468])[48])|[2468][048])|([13579][26])))" + T + "02" + T + "29))([0-9]{4})" + T + "(?!((0[469])|11)" + T + "31)((0[1,3-9]|1[0-2])|(02(?!" + T + "3)))" + T + "(0[1-9]|[1-2][0-9]|3[0-1])$").test(d);
    }
    function u(d) {
      var T = /\D/.exec(d);
      return T ? T[0] : "";
    }
    function x(d, T, S) {
      T === void 0 && (T = ":"), S === void 0 && (S = !1);
      var B = new RegExp("^([0-1]|2(?=([0-3])|4" + T + "00))[0-9]" + T + "[0-5][0-9](" + T + "([0-5]|6(?=0))[0-9])?(.[0-9]{1,9})?$");
      if (!S || !/[Z+\-]/.test(d)) return B.test(d);
      if (/Z$/.test(d)) return B.test(d.replace("Z", ""));
      var I = d.includes("+"), O = d.split(/[+-]/), F = O[0], V = O[1];
      return B.test(F) && function(z, J, ie) {
        return ie === void 0 && (ie = ":"), new RegExp(J ? "^(0(?!(2" + ie + "4)|0" + ie + "3)|1(?=([0-1]|2(?=" + ie + "[04])|[34](?=" + ie + "0))))([03469](?=" + ie + "[03])|[17](?=" + ie + "0)|2(?=" + ie + "[04])|5(?=" + ie + "[034])|8(?=" + ie + "[04]))" + ie + "([03](?=0)|4(?=5))[05]$" : "^(0(?=[^0])|1(?=[0-2]))([39](?=" + ie + "[03])|[0-24-8](?=" + ie + "00))" + ie + "[03]0$").test(z);
      }(V, I, u(V));
    }
    function y(d) {
      var T = d.split("T"), S = T[0], B = T[1], I = a(S, u(S));
      if (!B) return !1;
      var O, F = (O = B.match(/([^Z+\-\d])(?=\d+\1)/), Array.isArray(O) ? O[0] : "");
      return I && x(B, F, !0);
    }
    function p(d, T) {
      return T === void 0 && (T = "-"), new RegExp("^[0-9]{4}" + T + "(0(?=[^0])|1(?=[0-2]))[0-9]$").test(d);
    }
    e.r(r), e.d(r, { isValidDate: () => a, isValidISODateString: () => y, isValidTime: () => x, isValidYearMonth: () => p });
    var m = t;
    for (var h in r) m[h] = r[h];
    r.__esModule && Object.defineProperty(m, "__esModule", { value: !0 });
  })();
})(xc);
var Uu;
function my() {
  if (Uu) return kt;
  Uu = 1, Object.defineProperty(kt, "__esModule", { value: !0 }), kt.language = kt.cid = kt.nsid = kt.atIdentifier = kt.handle = kt.did = kt.atUri = kt.uri = kt.datetime = void 0;
  const t = xc, e = ta, r = Qi(), a = ea, u = Ji;
  function x(I, O) {
    try {
      if (!(0, t.isValidISODateString)(O))
        throw new Error();
    } catch {
      return {
        success: !1,
        error: new r.ValidationError(`${I} must be an valid atproto datetime (both RFC-3339 and ISO-8601)`)
      };
    }
    return { success: !0, value: O };
  }
  kt.datetime = x;
  function y(I, O) {
    return O.match(/^\w+:(?:\/\/)?[^\s/][^\s]*$/) !== null ? { success: !0, value: O } : {
      success: !1,
      error: new r.ValidationError(`${I} must be a uri`)
    };
  }
  kt.uri = y;
  function p(I, O) {
    try {
      (0, a.ensureValidAtUri)(O);
    } catch {
      return {
        success: !1,
        error: new r.ValidationError(`${I} must be a valid at-uri`)
      };
    }
    return { success: !0, value: O };
  }
  kt.atUri = p;
  function h(I, O) {
    try {
      (0, a.ensureValidDid)(O);
    } catch {
      return {
        success: !1,
        error: new r.ValidationError(`${I} must be a valid did`)
      };
    }
    return { success: !0, value: O };
  }
  kt.did = h;
  function m(I, O) {
    try {
      (0, a.ensureValidHandle)(O);
    } catch {
      return {
        success: !1,
        error: new r.ValidationError(`${I} must be a valid handle`)
      };
    }
    return { success: !0, value: O };
  }
  kt.handle = m;
  function d(I, O) {
    return !h(I, O).success && !m(I, O).success ? {
      success: !1,
      error: new r.ValidationError(`${I} must be a valid did or a handle`)
    } : { success: !0, value: O };
  }
  kt.atIdentifier = d;
  function T(I, O) {
    try {
      (0, a.ensureValidNsid)(O);
    } catch {
      return {
        success: !1,
        error: new r.ValidationError(`${I} must be a valid nsid`)
      };
    }
    return { success: !0, value: O };
  }
  kt.nsid = T;
  function S(I, O) {
    try {
      e.CID.parse(O);
    } catch {
      return {
        success: !1,
        error: new r.ValidationError(`${I} must be a cid string`)
      };
    }
    return { success: !0, value: O };
  }
  kt.cid = S;
  function B(I, O) {
    return (0, u.validateLanguage)(O) ? { success: !0, value: O } : {
      success: !1,
      error: new r.ValidationError(`${I} must be a well-formed BCP 47 language tag`)
    };
  }
  return kt.language = B, kt;
}
var Ou;
function Ec() {
  if (Ou) return tr;
  Ou = 1;
  var t = le && le.__createBinding || (Object.create ? function(I, O, j, $) {
    $ === void 0 && ($ = j);
    var z = Object.getOwnPropertyDescriptor(O, j);
    (!z || ("get" in z ? !O.__esModule : z.writable || z.configurable)) && (z = { enumerable: !0, get: function() {
      return O[j];
    } }), Object.defineProperty(I, $, z);
  } : function(I, O, j, $) {
    $ === void 0 && ($ = j), I[$] = O[j];
  }), e = le && le.__setModuleDefault || (Object.create ? function(I, O) {
    Object.defineProperty(I, "default", { enumerable: !0, value: O });
  } : function(I, O) {
    I.default = O;
  }), r = le && le.__importStar || function(I) {
    if (I && I.__esModule) return I;
    var O = {};
    if (I != null) for (var F in I) F !== "default" && Object.prototype.hasOwnProperty.call(I, F) && t(O, I, F);
    return e(O, I), O;
  };
  Object.defineProperty(tr, "__esModule", { value: !0 }), tr.unknown = tr.cidLink = tr.bytes = tr.string = tr.integer = tr.boolean = tr.validate = void 0;
  const a = Ji, u = ta, x = r(my()), y = Qi();
  function p(I, O, F, V) {
    switch (F.type) {
      case "boolean":
        return h(I, O, j, $);
      case "integer":
        return m(I, O, j, $);
      case "string":
        return d(I, O, j, $);
      case "bytes":
        return T(I, O, j, $);
      case "cid-link":
        return S(I, O, F, V);
      case "unknown":
        return B(I, O, j, $);
      default:
        return {
          success: !1,
          error: new y.ValidationError(`Unexpected lexicon type: ${j.type}`)
        };
    }
  }
  tr.validate = p;
  function h(I, O, j, $) {
    j = j;
    const z = typeof $;
    return z === "undefined" ? typeof j.default == "boolean" ? { success: !0, value: j.default } : {
      success: !1,
      error: new y.ValidationError(`${O} must be a boolean`)
    } : z !== "boolean" ? {
      success: !1,
      error: new y.ValidationError(`${O} must be a boolean`)
    } : typeof j.const == "boolean" && $ !== j.const ? {
      success: !1,
      error: new y.ValidationError(`${O} must be ${j.const}`)
    } : { success: !0, value: $ };
  }
  tr.boolean = h;
  function m(I, O, j, $) {
    return j = j, typeof $ === "undefined" ? typeof j.default == "number" ? { success: !0, value: j.default } : {
      success: !1,
      error: new y.ValidationError(`${O} must be an integer`)
    } : Number.isInteger($) ? typeof j.const == "number" && $ !== j.const ? {
      success: !1,
      error: new y.ValidationError(`${O} must be ${j.const}`)
    } : Array.isArray(j.enum) && !j.enum.includes($) ? {
      success: !1,
      error: new y.ValidationError(`${O} must be one of (${j.enum.join("|")})`)
    } : typeof j.maximum == "number" && $ > j.maximum ? {
      success: !1,
      error: new y.ValidationError(`${O} can not be greater than ${j.maximum}`)
    } : typeof j.minimum == "number" && $ < j.minimum ? {
      success: !1,
      error: new y.ValidationError(`${O} can not be less than ${j.minimum}`)
    } : { success: !0, value: $ } : {
      success: !1,
      error: new y.ValidationError(`${O} must be an integer`)
    };
  }
  tr.integer = m;
  function d(I, O, j, $) {
    if (j = j, typeof $ > "u")
      return typeof j.default == "string" ? { success: !0, value: j.default } : {
        success: !1,
        error: new y.ValidationError(`${O} must be a string`)
      };
    if (typeof $ != "string")
      return {
        success: !1,
        error: new y.ValidationError(`${O} must be a string`)
      };
    if (typeof j.const == "string" && $ !== j.const)
      return {
        success: !1,
        error: new y.ValidationError(`${O} must be ${j.const}`)
      };
    if (Array.isArray(j.enum) && !j.enum.includes($))
      return {
        success: !1,
        error: new y.ValidationError(`${O} must be one of (${j.enum.join("|")})`)
      };
    if (typeof j.maxLength == "number" && (0, a.utf8Len)($) > j.maxLength)
      return {
        success: !1,
        error: new y.ValidationError(`${O} must not be longer than ${j.maxLength} characters`)
      };
    if (typeof j.minLength == "number" && (0, a.utf8Len)($) < j.minLength)
      return {
        success: !1,
        error: new y.ValidationError(`${O} must not be shorter than ${j.minLength} characters`)
      };
    if (typeof j.maxGraphemes == "number" && (0, a.graphemeLen)($) > j.maxGraphemes)
      return {
        success: !1,
        error: new y.ValidationError(`${O} must not be longer than ${j.maxGraphemes} graphemes`)
      };
    if (typeof j.minGraphemes == "number" && (0, a.graphemeLen)($) < j.minGraphemes)
      return {
        success: !1,
        error: new y.ValidationError(`${O} must not be shorter than ${j.minGraphemes} graphemes`)
      };
    if (typeof j.format == "string")
      switch (j.format) {
        case "datetime":
          return x.datetime(O, $);
        case "uri":
          return x.uri(O, $);
        case "at-uri":
          return x.atUri(O, $);
        case "did":
          return x.did(O, $);
        case "handle":
          return x.handle(O, $);
        case "at-identifier":
          return x.atIdentifier(O, $);
        case "nsid":
          return x.nsid(O, $);
        case "cid":
          return x.cid(O, $);
        case "language":
          return x.language(O, $);
      }
    return { success: !0, value: $ };
  }
  tr.string = d;
  function T(I, O, j, $) {
    return j = j, !$ || !($ instanceof Uint8Array) ? {
      success: !1,
      error: new y.ValidationError(`${O} must be a byte array`)
    } : typeof j.maxLength == "number" && $.byteLength > j.maxLength ? {
      success: !1,
      error: new y.ValidationError(`${O} must not be larger than ${j.maxLength} bytes`)
    } : typeof j.minLength == "number" && $.byteLength < j.minLength ? {
      success: !1,
      error: new y.ValidationError(`${O} must not be smaller than ${j.minLength} bytes`)
    } : { success: !0, value: $ };
  }
  tr.bytes = T;
  function S(I, O, F, V) {
    return u.CID.asCID(V) === null ? {
      success: !1,
      error: new y.ValidationError(`${O} must be a CID`)
    } : { success: !0, value: $ };
  }
  tr.cidLink = S;
  function B(I, O, F, V) {
    return !V || typeof V != "object" ? {
      success: !1,
      error: new y.ValidationError(`${O} must be an object`)
    } : { success: !0, value: $ };
  }
  return tr.unknown = B, tr;
}
var ua = {}, Ho = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.BlobRef = t.jsonBlobRef = t.untypedJsonBlobRef = t.typedJsonBlobRef = void 0;
  const e = Ji, r = ta, a = wn;
  t.typedJsonBlobRef = a.z.object({
    $type: a.z.literal("blob"),
    ref: e.schema.cid,
    mimeType: a.z.string(),
    size: a.z.number()
  }).strict(), t.untypedJsonBlobRef = a.z.object({
    cid: a.z.string(),
    mimeType: a.z.string()
  }).strict(), t.jsonBlobRef = a.z.union([t.typedJsonBlobRef, t.untypedJsonBlobRef]);
  class u {
    constructor(y, p, h, m) {
      Object.defineProperty(this, "ref", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: y
      }), Object.defineProperty(this, "mimeType", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: p
      }), Object.defineProperty(this, "size", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: h
      }), Object.defineProperty(this, "original", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), this.original = m ?? {
        $type: "blob",
        ref: y,
        mimeType: p,
        size: h
      };
    }
    static asBlobRef(y) {
      return e.check.is(y, t.jsonBlobRef) ? u.fromJsonRef(y) : null;
    }
    static fromJsonRef(y) {
      return e.check.is(y, t.typedJsonBlobRef) ? new u(y.ref, y.mimeType, y.size) : new u(r.CID.parse(y.cid), y.mimeType, -1, y);
    }
    ipld() {
      return {
        $type: "blob",
        ref: this.ref,
        mimeType: this.mimeType,
        size: this.size
      };
    }
    toJSON() {
      return (0, e.ipldToJson)(this.ipld());
    }
  }
  t.BlobRef = u;
})(Ho);
var Ku;
function yy() {
  if (Ku) return ua;
  Ku = 1, Object.defineProperty(ua, "__esModule", { value: !0 }), ua.blob = void 0;
  const t = Ho, e = Qi();
  function r(a, u, x, y) {
    return !y || !(y instanceof t.BlobRef) ? {
      success: !1,
      error: new e.ValidationError(`${u} should be a blob ref`)
    } : { success: !0, value: y };
  }
  return ua.blob = r, ua;
}
var Nu;
function Zo() {
  if (Nu) return bi;
  Nu = 1;
  var t = le && le.__createBinding || (Object.create ? function(d, T, S, B) {
    B === void 0 && (B = S);
    var I = Object.getOwnPropertyDescriptor(T, S);
    (!I || ("get" in I ? !T.__esModule : I.writable || I.configurable)) && (I = { enumerable: !0, get: function() {
      return T[S];
    } }), Object.defineProperty(d, B, I);
  } : function(d, T, S, B) {
    B === void 0 && (B = S), d[B] = T[S];
  }), e = le && le.__setModuleDefault || (Object.create ? function(d, T) {
    Object.defineProperty(d, "default", { enumerable: !0, value: T });
  } : function(d, T) {
    d.default = T;
  }), r = le && le.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var T = {};
    if (d != null) for (var S in d) S !== "default" && Object.prototype.hasOwnProperty.call(d, S) && t(T, d, S);
    return e(T, d), T;
  };
  Object.defineProperty(bi, "__esModule", { value: !0 }), bi.object = bi.array = bi.validate = void 0;
  const a = Qi(), u = Wo(), x = r(Ec()), y = r(yy());
  function p(d, T, S, B) {
    switch (S.type) {
      case "boolean":
        return x.boolean(d, T, S, B);
      case "integer":
        return x.integer(d, T, S, B);
      case "string":
        return x.string(d, T, S, B);
      case "bytes":
        return x.bytes(d, T, S, B);
      case "cid-link":
        return x.cidLink(d, T, S, B);
      case "unknown":
        return x.unknown(d, T, S, B);
      case "object":
        return h(d, T, S, B);
      case "array":
        return m(d, T, S, B);
      case "blob":
        return y.blob(d, T, S, B);
      default:
        return {
          success: !1,
          error: new a.ValidationError(`Unexpected lexicon type: ${S.type}`)
        };
    }
  }
  bi.validate = p;
  function m(d, T, S, B) {
    if (!Array.isArray(B))
      return {
        success: !1,
        error: new a.ValidationError(`${T} must be an array`)
      };
    if (typeof S.maxLength == "number" && B.length > S.maxLength)
      return {
        success: !1,
        error: new a.ValidationError(`${T} must not have more than ${S.maxLength} elements`)
      };
    if (typeof S.minLength == "number" && B.length < S.minLength)
      return {
        success: !1,
        error: new a.ValidationError(`${T} must not have fewer than ${S.minLength} elements`)
      };
    const I = S.items;
    for (let O = 0; O < B.length; O++) {
      const j = B[O], $ = `${T}/${O}`, z = (0, u.validateOneOf)(d, $, I, j);
      if (!z.success)
        return z;
    }
    return { success: !0, value: B };
  }
  bi.array = m;
  function h(d, T, S, B) {
    if (S = S, !B || typeof B != "object")
      return {
        success: !1,
        error: new a.ValidationError(`${T} must be an object`)
      };
    const I = new Set(S.required), O = new Set(S.nullable);
    let F = B;
    if (typeof S.properties == "object")
      for (const V in S.properties) {
        if (B[V] === null && O.has(V))
          continue;
        const z = S.properties[V], J = `${T}/${V}`, ie = (0, u.validateOneOf)(d, J, z, B[V]), ye = ie.success ? ie.value : B[V], ve = typeof ye > "u";
        if (ve && I.has(V))
          return {
            success: !1,
            error: new a.ValidationError(`${T} must have the property "${$}"`)
          };
        if (!ve && !ie.success)
          return ie;
        ye !== B[V] && (F === B && (F = { ...B }), F[V] = ye);
      }
    return { success: !0, value: j };
  }
  return bi.object = m, bi;
}
var Vu;
function Wo() {
  if (Vu) return _r;
  Vu = 1;
  var t = le && le.__createBinding || (Object.create ? function(S, B, I, O) {
    O === void 0 && (O = I);
    var j = Object.getOwnPropertyDescriptor(B, I);
    (!j || ("get" in j ? !B.__esModule : j.writable || j.configurable)) && (j = { enumerable: !0, get: function() {
      return B[I];
    } }), Object.defineProperty(S, O, F);
  } : function(S, B, I, O) {
    O === void 0 && (O = I), S[O] = B[I];
  }), e = le && le.__setModuleDefault || (Object.create ? function(S, B) {
    Object.defineProperty(S, "default", { enumerable: !0, value: B });
  } : function(S, B) {
    S.default = B;
  }), r = le && le.__importStar || function(S) {
    if (S && S.__esModule) return S;
    var B = {};
    if (S != null) for (var I in S) I !== "default" && Object.prototype.hasOwnProperty.call(S, I) && t(B, S, I);
    return e(B, S), B;
  };
  Object.defineProperty(_r, "__esModule", { value: !0 }), _r.requiredPropertiesRefinement = _r.toConcreteTypes = _r.assertValidOneOf = _r.validateOneOf = _r.toLexUri = void 0;
  const a = r(Zo()), u = Qi(), x = wn;
  function y(S, B) {
    if (S.split("#").length > 2)
      throw new Error("Uri can only have one hash segment");
    if (S.startsWith("lex:"))
      return S;
    if (S.startsWith("#")) {
      if (!B)
        throw new Error(`Unable to resolve uri without anchor: ${S}`);
      return `${B}${S}`;
    }
    return `lex:${S}`;
  }
  _r.toLexUri = y;
  function p(S, B, I, O, F = !1) {
    let V, z;
    if (I.type === "union") {
      if (!(0, u.isDiscriminatedObject)(O))
        return {
          success: !1,
          error: new u.ValidationError(`${B} must be an object which includes the "$type" property`)
        };
      if (T(I.refs, O.$type))
        z = h(S, {
          type: "ref",
          ref: O.$type
        });
      else
        return I.closed ? {
          success: !1,
          error: new u.ValidationError(`${B} $type must be one of ${I.refs.join(", ")}`)
        } : { success: !0, value: O };
    } else
      z = h(S, I);
    for (const J of z) {
      const ie = F ? a.object(S, B, J, O) : a.validate(S, B, J, O);
      if (ie.success)
        return ie;
      $ ?? ($ = ie.error);
    }
    return z.length > 1 ? {
      success: !1,
      error: new u.ValidationError(`${B} did not match any of the expected definitions`)
    } : { success: !1, error: $ };
  }
  _r.validateOneOf = p;
  function m(S, B, I, O, F = !1) {
    const V = p(S, B, I, O, F);
    if (!V.success)
      throw V.error;
    return V.value;
  }
  _r.assertValidOneOf = m;
  function h(S, B) {
    return B.type === "ref" ? [S.getDefOrThrow(B.ref)] : B.type === "union" ? B.refs.map((I) => S.getDefOrThrow(I)).flat() : [B];
  }
  _r.toConcreteTypes = h;
  function d(S, B) {
    if (S.required !== void 0) {
      if (!Array.isArray(S.required)) {
        B.addIssue({
          code: x.z.ZodIssueCode.invalid_type,
          received: typeof S.required,
          expected: "array"
        });
        return;
      }
      if (S.properties === void 0) {
        S.required.length > 0 && B.addIssue({
          code: x.z.ZodIssueCode.custom,
          message: "Required fields defined but no properties defined"
        });
        return;
      }
      for (const I of S.required)
        S.properties[I] === void 0 && B.addIssue({
          code: x.z.ZodIssueCode.custom,
          message: `Required field "${I}" not defined`
        });
    }
  }
  _r.requiredPropertiesRefinement = d;
  const T = (S, B) => {
    const I = y(B);
    return S.includes(I) ? !0 : I.endsWith("#main") ? S.includes(I.replace("#main", "")) : S.includes(I + "#main");
  };
  return _r;
}
var Mu;
function Qi() {
  return Mu || (Mu = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.LexiconDefNotFoundError = t.InvalidLexiconError = t.ValidationError = t.parseLexiconDoc = t.isDiscriminatedObject = t.discriminatedObject = t.hasProp = t.isObj = t.isValidLexiconDoc = t.lexiconDoc = t.lexUserType = t.lexRecord = t.lexXrpcSubscription = t.lexXrpcProcedure = t.lexXrpcQuery = t.lexXrpcError = t.lexXrpcSubscriptionMessage = t.lexXrpcBody = t.lexXrpcParameters = t.lexObject = t.lexToken = t.lexPrimitiveArray = t.lexArray = t.lexBlob = t.lexRefVariant = t.lexRefUnion = t.lexRef = t.lexIpldType = t.lexCidLink = t.lexBytes = t.lexPrimitive = t.lexUnknown = t.lexString = t.lexStringFormat = t.lexInteger = t.lexBoolean = void 0;
    const e = wn, r = ea, a = Wo();
    t.lexBoolean = e.z.object({
      type: e.z.literal("boolean"),
      description: e.z.string().optional(),
      default: e.z.boolean().optional(),
      const: e.z.boolean().optional()
    }).strict(), t.lexInteger = e.z.object({
      type: e.z.literal("integer"),
      description: e.z.string().optional(),
      default: e.z.number().int().optional(),
      minimum: e.z.number().int().optional(),
      maximum: e.z.number().int().optional(),
      enum: e.z.number().int().array().optional(),
      const: e.z.number().int().optional()
    }).strict(), t.lexStringFormat = e.z.enum([
      "datetime",
      "uri",
      "at-uri",
      "did",
      "handle",
      "at-identifier",
      "nsid",
      "cid",
      "language"
    ]), t.lexString = e.z.object({
      type: e.z.literal("string"),
      format: t.lexStringFormat.optional(),
      description: e.z.string().optional(),
      default: e.z.string().optional(),
      minLength: e.z.number().int().optional(),
      maxLength: e.z.number().int().optional(),
      minGraphemes: e.z.number().int().optional(),
      maxGraphemes: e.z.number().int().optional(),
      enum: e.z.string().array().optional(),
      const: e.z.string().optional(),
      knownValues: e.z.string().array().optional()
    }).strict(), t.lexUnknown = e.z.object({
      type: e.z.literal("unknown"),
      description: e.z.string().optional()
    }).strict(), t.lexPrimitive = e.z.discriminatedUnion("type", [
      t.lexBoolean,
      t.lexInteger,
      t.lexString,
      t.lexUnknown
    ]), t.lexBytes = e.z.object({
      type: e.z.literal("bytes"),
      description: e.z.string().optional(),
      maxLength: e.z.number().optional(),
      minLength: e.z.number().optional()
    }).strict(), t.lexCidLink = e.z.object({
      type: e.z.literal("cid-link"),
      description: e.z.string().optional()
    }).strict(), t.lexIpldType = e.z.discriminatedUnion("type", [t.lexBytes, t.lexCidLink]), t.lexRef = e.z.object({
      type: e.z.literal("ref"),
      description: e.z.string().optional(),
      ref: e.z.string()
    }).strict(), t.lexRefUnion = e.z.object({
      type: e.z.literal("union"),
      description: e.z.string().optional(),
      refs: e.z.string().array(),
      closed: e.z.boolean().optional()
    }).strict(), t.lexRefVariant = e.z.discriminatedUnion("type", [t.lexRef, t.lexRefUnion]), t.lexBlob = e.z.object({
      type: e.z.literal("blob"),
      description: e.z.string().optional(),
      accept: e.z.string().array().optional(),
      maxSize: e.z.number().optional()
    }).strict(), t.lexArray = e.z.object({
      type: e.z.literal("array"),
      description: e.z.string().optional(),
      items: e.z.union([t.lexPrimitive, t.lexIpldType, t.lexBlob, t.lexRefVariant]),
      minLength: e.z.number().int().optional(),
      maxLength: e.z.number().int().optional()
    }).strict(), t.lexPrimitiveArray = t.lexArray.merge(e.z.object({
      items: t.lexPrimitive
    }).strict()), t.lexToken = e.z.object({
      type: e.z.literal("token"),
      description: e.z.string().optional()
    }).strict(), t.lexObject = e.z.object({
      type: e.z.literal("object"),
      description: e.z.string().optional(),
      required: e.z.string().array().optional(),
      nullable: e.z.string().array().optional(),
      properties: e.z.record(e.z.union([t.lexRefVariant, t.lexIpldType, t.lexArray, t.lexBlob, t.lexPrimitive]))
    }).strict().superRefine(a.requiredPropertiesRefinement), t.lexXrpcParameters = e.z.object({
      type: e.z.literal("params"),
      description: e.z.string().optional(),
      required: e.z.string().array().optional(),
      properties: e.z.record(e.z.union([t.lexPrimitive, t.lexPrimitiveArray]))
    }).strict().superRefine(a.requiredPropertiesRefinement), t.lexXrpcBody = e.z.object({
      description: e.z.string().optional(),
      encoding: e.z.string(),
      schema: e.z.union([t.lexRefVariant, t.lexObject]).optional()
    }).strict(), t.lexXrpcSubscriptionMessage = e.z.object({
      description: e.z.string().optional(),
      schema: e.z.union([t.lexRefVariant, t.lexObject]).optional()
    }).strict(), t.lexXrpcError = e.z.object({
      name: e.z.string(),
      description: e.z.string().optional()
    }).strict(), t.lexXrpcQuery = e.z.object({
      type: e.z.literal("query"),
      description: e.z.string().optional(),
      parameters: t.lexXrpcParameters.optional(),
      output: t.lexXrpcBody.optional(),
      errors: t.lexXrpcError.array().optional()
    }).strict(), t.lexXrpcProcedure = e.z.object({
      type: e.z.literal("procedure"),
      description: e.z.string().optional(),
      parameters: t.lexXrpcParameters.optional(),
      input: t.lexXrpcBody.optional(),
      output: t.lexXrpcBody.optional(),
      errors: t.lexXrpcError.array().optional()
    }).strict(), t.lexXrpcSubscription = e.z.object({
      type: e.z.literal("subscription"),
      description: e.z.string().optional(),
      parameters: t.lexXrpcParameters.optional(),
      message: t.lexXrpcSubscriptionMessage.optional(),
      errors: t.lexXrpcError.array().optional()
    }).strict(), t.lexRecord = e.z.object({
      type: e.z.literal("record"),
      description: e.z.string().optional(),
      key: e.z.string().optional(),
      record: t.lexObject
    }).strict(), t.lexUserType = e.z.custom((S) => {
      if (!(!S || typeof S != "object") && S.type !== void 0)
        switch (S.type) {
          case "record":
            return t.lexRecord.parse(S);
          case "query":
            return t.lexXrpcQuery.parse(S);
          case "procedure":
            return t.lexXrpcProcedure.parse(S);
          case "subscription":
            return t.lexXrpcSubscription.parse(S);
          case "blob":
            return t.lexBlob.parse(S);
          case "array":
            return t.lexArray.parse(S);
          case "token":
            return t.lexToken.parse(S);
          case "object":
            return t.lexObject.parse(S);
          case "boolean":
            return t.lexBoolean.parse(S);
          case "integer":
            return t.lexInteger.parse(S);
          case "string":
            return t.lexString.parse(S);
          case "bytes":
            return t.lexBytes.parse(S);
          case "cid-link":
            return t.lexCidLink.parse(S);
          case "unknown":
            return t.lexUnknown.parse(S);
        }
    }, (S) => !S || typeof S != "object" ? {
      message: "Must be an object",
      fatal: !0
    } : S.type === void 0 ? {
      message: "Must have a type",
      fatal: !0
    } : {
      message: `Invalid type: ${S.type} must be one of: record, query, procedure, subscription, blob, array, token, object, boolean, integer, string, bytes, cid-link, unknown`,
      fatal: !0
    }), t.lexiconDoc = e.z.object({
      lexicon: e.z.literal(1),
      id: e.z.string().refine((S) => r.NSID.isValid(S), {
        message: "Must be a valid NSID"
      }),
      revision: e.z.number().optional(),
      description: e.z.string().optional(),
      defs: e.z.record(t.lexUserType)
    }).strict().superRefine((S, B) => {
      for (const I in S.defs) {
        const O = S.defs[I];
        I !== "main" && (O.type === "record" || O.type === "procedure" || O.type === "query" || O.type === "subscription") && B.addIssue({
          code: e.z.ZodIssueCode.custom,
          message: "Records, procedures, queries, and subscriptions must be the main definition."
        });
      }
    });
    function u(S) {
      return t.lexiconDoc.safeParse(S).success;
    }
    t.isValidLexiconDoc = u;
    function x(S) {
      return S !== null && typeof S == "object";
    }
    t.isObj = x;
    function y(S, B) {
      return B in S;
    }
    t.hasProp = y, t.discriminatedObject = e.z.object({ $type: e.z.string() });
    function p(S) {
      return t.discriminatedObject.safeParse(S).success;
    }
    t.isDiscriminatedObject = p;
    function m(S) {
      return t.lexiconDoc.parse(S), S;
    }
    t.parseLexiconDoc = h;
    class m extends Error {
    }
    t.ValidationError = m;
    class d extends Error {
    }
    t.InvalidLexiconError = d;
    class T extends Error {
    }
    t.LexiconDefNotFoundError = T;
  }(vl)), vl;
}
var Yo = {}, Or = {}, Jo = {}, by = le && le.__createBinding || (Object.create ? function(t, e, r, a) {
  a === void 0 && (a = r);
  var u = Object.getOwnPropertyDescriptor(e, r);
  (!u || ("get" in u ? !e.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, a, u);
} : function(t, e, r, a) {
  a === void 0 && (a = r), t[a] = e[r];
}), xy = le && le.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), Ey = le && le.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && by(e, t, r);
  return xy(e, t), e;
};
Object.defineProperty(Jo, "__esModule", { value: !0 });
Jo.params = void 0;
const gy = Qi(), vy = Ey(Ec()), Ry = Zo();
function Ay(t, e, r, a) {
  const u = a && typeof a == "object" ? a : {}, x = new Set(r.required ?? []);
  let y = u;
  if (typeof r.properties == "object")
    for (const p in r.properties) {
      const m = r.properties[p], h = m.type === "array" ? (0, Ry.array)(t, p, m, u[p]) : vy.validate(t, p, m, u[p]), d = h.success ? h.value : u[p], T = typeof d > "u";
      if (T && x.has(p))
        return {
          success: !1,
          error: new gy.ValidationError(`${e} must have the property "${p}"`)
        };
      if (!T && !m.success)
        return m;
      d !== u[p] && (y === u && (y = { ...u }), y[p] = d);
    }
  return { success: !0, value: y };
}
Jo.params = Ay;
var _y = le && le.__createBinding || (Object.create ? function(t, e, r, a) {
  a === void 0 && (a = r);
  var u = Object.getOwnPropertyDescriptor(e, r);
  (!u || ("get" in u ? !e.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, a, u);
} : function(t, e, r, a) {
  a === void 0 && (a = r), t[a] = e[r];
}), Ty = le && le.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), gc = le && le.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && _y(e, t, r);
  return Ty(e, t), e;
};
Object.defineProperty(Or, "__esModule", { value: !0 });
Or.assertValidXrpcMessage = Or.assertValidXrpcOutput = Or.assertValidXrpcInput = Or.assertValidXrpcParams = Or.assertValidRecord = void 0;
const Yl = Wo(), wy = gc(Zo()), Sy = gc(Jo);
function Ly(t, e, r) {
  const a = wy.object(t, "Record", e.record, r);
  if (!a.success)
    throw a.error;
  return a.value;
}
Or.assertValidRecord = Ly;
function Cy(t, e, r) {
  if (e.parameters) {
    const a = Sy.params(t, "Params", e.parameters, r);
    if (!a.success)
      throw a.error;
    return a.value;
  }
}
Or.assertValidXrpcParams = Cy;
function Dy(t, e, r) {
  if (e.input?.schema)
    return (0, Yl.assertValidOneOf)(t, "Input", e.input.schema, r, !0);
}
Or.assertValidXrpcInput = Dy;
function ky(t, e, r) {
  if (e.output?.schema)
    return (0, Yl.assertValidOneOf)(t, "Output", e.output.schema, r, !0);
}
Or.assertValidXrpcOutput = ky;
function Py(t, e, r) {
  if (e.message?.schema)
    return (0, Yl.assertValidOneOf)(t, "Message", e.message.schema, r, !0);
}
Or.assertValidXrpcMessage = Py;
var By = le && le.__createBinding || (Object.create ? function(t, e, r, a) {
  a === void 0 && (a = r);
  var u = Object.getOwnPropertyDescriptor(e, r);
  (!u || ("get" in u ? !e.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, a, u);
} : function(t, e, r, a) {
  a === void 0 && (a = r), t[a] = e[r];
}), Iy = le && le.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), Uy = le && le.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && By(e, t, r);
  return Iy(e, t), e;
};
Object.defineProperty(Yo, "__esModule", { value: !0 });
Yo.Lexicons = void 0;
const Zr = Qi(), fa = Or, sr = Wo(), ju = Uy(Zo());
class Oy {
  constructor(e) {
    if (Object.defineProperty(this, "docs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), Object.defineProperty(this, "defs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Map()
    }), e?.length)
      for (const r of e)
        this.add(r);
  }
  /**
   * Add a lexicon doc.
   */
  add(e) {
    const r = (0, sr.toLexUri)(e.id);
    if (this.docs.has(r))
      throw new Error(`${r} has already been registered`);
    Kl(e, r), this.docs.set(r, e);
    for (const [a, u] of Fu(e))
      this.defs.set(a, u);
  }
  /**
   * Remove a lexicon doc.
   */
  remove(e) {
    e = (0, sr.toLexUri)(e);
    const r = this.docs.get(e);
    if (!r)
      throw new Error(`Unable to remove "${e}": does not exist`);
    for (const [a, u] of Fu(r))
      this.defs.delete(a);
    this.docs.delete(e);
  }
  /**
   * Get a lexicon doc.
   */
  get(e) {
    return e = (0, sr.toLexUri)(e), this.docs.get(e);
  }
  /**
   * Get a definition.
   */
  getDef(e) {
    return e = (0, sr.toLexUri)(e), this.defs.get(e);
  }
  getDefOrThrow(e, r) {
    const a = this.getDef(e);
    if (!a)
      throw new Wr.LexiconDefNotFoundError(`Lexicon not found: ${e}`);
    if (r && !r.includes(a.type))
      throw new Wr.InvalidLexiconError(`Not a ${r.join(" or ")} lexicon: ${e}`);
    return a;
  }
  /**
   * Validate a record or object.
   */
  validate(e, r) {
    e = (0, sr.toLexUri)(e);
    const a = this.getDefOrThrow(e, ["record", "object"]);
    if (!(0, Wr.isObj)(r))
      throw new Wr.ValidationError("Value must be an object");
    if (a.type === "record")
      return ju.object(this, "Record", a.record, r);
    if (a.type === "object")
      return ju.object(this, "Object", a, r);
    throw new Wr.InvalidLexiconError("Definition must be a record or object");
  }
  /**
   * Validate a record and throw on any error.
   */
  assertValidRecord(e, r) {
    e = (0, sr.toLexUri)(e);
    const a = this.getDefOrThrow(e, ["record"]);
    if (!(0, Wr.isObj)(r))
      throw new Wr.ValidationError("Record must be an object");
    if (!(0, Wr.hasProp)(r, "$type") || typeof r.$type != "string")
      throw new Wr.ValidationError("Record/$type must be a string");
    const u = r.$type || "";
    if ((0, sr.toLexUri)(u) !== e)
      throw new Wr.ValidationError(`Invalid $type: must be ${e}, got ${u}`);
    return (0, fa.assertValidRecord)(this, a, r);
  }
  /**
   * Validate xrpc query params and throw on any error.
   */
  assertValidXrpcParams(e, r) {
    e = (0, sr.toLexUri)(e);
    const a = this.getDefOrThrow(e, [
      "query",
      "procedure",
      "subscription"
    ]);
    return (0, fa.assertValidXrpcParams)(this, a, r);
  }
  /**
   * Validate xrpc input body and throw on any error.
   */
  assertValidXrpcInput(e, r) {
    e = (0, sr.toLexUri)(e);
    const a = this.getDefOrThrow(e, ["procedure"]);
    return (0, fa.assertValidXrpcInput)(this, a, r);
  }
  /**
   * Validate xrpc output body and throw on any error.
   */
  assertValidXrpcOutput(e, r) {
    e = (0, sr.toLexUri)(e);
    const a = this.getDefOrThrow(e, ["query", "procedure"]);
    return (0, fa.assertValidXrpcOutput)(this, a, r);
  }
  /**
   * Validate xrpc subscription message and throw on any error.
   */
  assertValidXrpcMessage(e, r) {
    e = (0, sr.toLexUri)(e);
    const a = this.getDefOrThrow(e, ["subscription"]);
    return (0, fa.assertValidXrpcMessage)(this, a, r);
  }
  /**
   * Resolve a lex uri given a ref
   */
  resolveLexUri(e, r) {
    return e = (0, sr.toLexUri)(e), (0, sr.toLexUri)(r, e);
  }
}
Yo.Lexicons = Oy;
function* Fu(t) {
  for (const e in t.defs)
    yield [`lex:${t.id}#${e}`, t.defs[e]], e === "main" && (yield [`lex:${t.id}`, t.defs[e]]);
}
function Kl(t, e) {
  for (const r in t)
    t.type === "ref" ? t.ref = (0, sr.toLexUri)(t.ref, e) : t.type === "union" ? t.refs = t.refs.map((a) => (0, sr.toLexUri)(a, e)) : Array.isArray(t[r]) ? t[r] = t[r].map((a) => typeof a == "string" ? a.startsWith("#") ? (0, sr.toLexUri)(a, e) : a : a && typeof a == "object" ? Kl(a, e) : a) : t[r] && typeof t[r] == "object" && (t[r] = Kl(t[r], e));
  return t;
}
var vc = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.jsonStringToLex = t.jsonToLex = t.stringifyLex = t.lexToJson = t.ipldToLex = t.lexToIpld = void 0;
  const e = Ji, r = ta, a = Ho, u = (d) => {
    if (Array.isArray(d))
      return d.map((T) => (0, t.lexToIpld)(T));
    if (d && typeof d == "object") {
      if (d instanceof a.BlobRef)
        return d.original;
      if (r.CID.asCID(d) || d instanceof Uint8Array)
        return d;
      const T = {};
      for (const S of Object.keys(d))
        T[S] = (0, t.lexToIpld)(d[S]);
      return T;
    }
    return d;
  };
  t.lexToIpld = u;
  const x = (d) => {
    if (Array.isArray(d))
      return d.map((T) => (0, t.ipldToLex)(T));
    if (d && typeof d == "object") {
      if ((d.$type === "blob" || typeof d.cid == "string" && typeof d.mimeType == "string") && e.check.is(d, a.jsonBlobRef))
        return a.BlobRef.fromJsonRef(d);
      if (r.CID.asCID(d) || d instanceof Uint8Array)
        return d;
      const T = {};
      for (const S of Object.keys(d))
        T[S] = (0, t.ipldToLex)(d[S]);
      return T;
    }
    return d;
  };
  t.ipldToLex = x;
  const y = (d) => (0, e.ipldToJson)((0, t.lexToIpld)(d));
  t.lexToJson = y;
  const p = (d) => JSON.stringify((0, t.lexToJson)(d));
  t.stringifyLex = p;
  const m = (d) => (0, t.ipldToLex)((0, e.jsonToIpld)(d));
  t.jsonToLex = m;
  const h = (d) => (0, t.jsonToLex)(JSON.parse(d));
  t.jsonStringToLex = h;
})(vc);
(function(t) {
  var e = le && le.__createBinding || (Object.create ? function(a, u, x, y) {
    y === void 0 && (y = x);
    var p = Object.getOwnPropertyDescriptor(u, x);
    (!p || ("get" in p ? !u.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return u[x];
    } }), Object.defineProperty(a, y, p);
  } : function(a, u, x, y) {
    y === void 0 && (y = x), a[y] = u[x];
  }), r = le && le.__exportStar || function(a, u) {
    for (var x in a) x !== "default" && !Object.prototype.hasOwnProperty.call(u, x) && e(u, a, x);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), r(Qi(), t), r(Yo, t), r(Ho, t), r(vc, t);
})(ga);
var Rc = {};
Object.defineProperty(Rc, "__esModule", { value: !0 });
var _a = {};
Object.defineProperty(_a, "__esModule", { value: !0 });
_a.BSKY_LABELER_DID = void 0;
_a.BSKY_LABELER_DID = "did:plc:ar7c4by46qjdydhdevvrndac";
var Ta = {};
Object.defineProperty(Ta, "__esModule", { value: !0 });
Ta.sanitizeMutedWordValue = void 0;
function Ky(t) {
  return t.trim().replace(/^#(?!\ufe0f)/, "").replace(/[\r\n\u00AD\u2060\u200D\u200C\u200B]+/, "");
}
Ta.sanitizeMutedWordValue = Ky;
var v = {}, te = {}, Qo = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.XRPCInvalidResponseError = t.XRPCError = t.XRPCResponse = t.ResponseTypeStrings = t.ResponseTypeNames = t.ResponseType = t.errorResponseBody = void 0;
  const e = wn;
  t.errorResponseBody = e.z.object({
    error: e.z.string().optional(),
    message: e.z.string().optional()
  });
  var r;
  (function(y) {
    y[y.Unknown = 1] = "Unknown", y[y.InvalidResponse = 2] = "InvalidResponse", y[y.Success = 200] = "Success", y[y.InvalidRequest = 400] = "InvalidRequest", y[y.AuthRequired = 401] = "AuthRequired", y[y.Forbidden = 403] = "Forbidden", y[y.XRPCNotSupported = 404] = "XRPCNotSupported", y[y.PayloadTooLarge = 413] = "PayloadTooLarge", y[y.RateLimitExceeded = 429] = "RateLimitExceeded", y[y.InternalServerError = 500] = "InternalServerError", y[y.MethodNotImplemented = 501] = "MethodNotImplemented", y[y.UpstreamFailure = 502] = "UpstreamFailure", y[y.NotEnoughResources = 503] = "NotEnoughResources", y[y.UpstreamTimeout = 504] = "UpstreamTimeout";
  })(r || (t.ResponseType = r = {})), t.ResponseTypeNames = {
    [r.InvalidResponse]: "InvalidResponse",
    [r.Success]: "Success",
    [r.InvalidRequest]: "InvalidRequest",
    [r.AuthRequired]: "AuthenticationRequired",
    [r.Forbidden]: "Forbidden",
    [r.XRPCNotSupported]: "XRPCNotSupported",
    [r.PayloadTooLarge]: "PayloadTooLarge",
    [r.RateLimitExceeded]: "RateLimitExceeded",
    [r.InternalServerError]: "InternalServerError",
    [r.MethodNotImplemented]: "MethodNotImplemented",
    [r.UpstreamFailure]: "UpstreamFailure",
    [r.NotEnoughResources]: "NotEnoughResources",
    [r.UpstreamTimeout]: "UpstreamTimeout"
  }, t.ResponseTypeStrings = {
    [r.InvalidResponse]: "Invalid Response",
    [r.Success]: "Success",
    [r.InvalidRequest]: "Invalid Request",
    [r.AuthRequired]: "Authentication Required",
    [r.Forbidden]: "Forbidden",
    [r.XRPCNotSupported]: "XRPC Not Supported",
    [r.PayloadTooLarge]: "Payload Too Large",
    [r.RateLimitExceeded]: "Rate Limit Exceeded",
    [r.InternalServerError]: "Internal Server Error",
    [r.MethodNotImplemented]: "Method Not Implemented",
    [r.UpstreamFailure]: "Upstream Failure",
    [r.NotEnoughResources]: "Not Enough Resources",
    [r.UpstreamTimeout]: "Upstream Timeout"
  };
  class a {
    constructor(p, h) {
      Object.defineProperty(this, "data", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: p
      }), Object.defineProperty(this, "headers", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: h
      }), Object.defineProperty(this, "success", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: !0
      });
    }
  }
  t.XRPCResponse = a;
  class u extends Error {
    constructor(p, h, m, d) {
      super(m || h || t.ResponseTypeStrings[p]), Object.defineProperty(this, "status", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: p
      }), Object.defineProperty(this, "error", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: h
      }), Object.defineProperty(this, "success", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: !1
      }), Object.defineProperty(this, "headers", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), this.error || (this.error = t.ResponseTypeNames[p]), this.headers = d;
    }
  }
  t.XRPCError = u;
  class x extends u {
    constructor(p, h, m) {
      super(r.InvalidResponse, t.ResponseTypeStrings[r.InvalidResponse], "The server gave an invalid response and may be out of date."), Object.defineProperty(this, "lexiconNsid", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: p
      }), Object.defineProperty(this, "validationError", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: h
      }), Object.defineProperty(this, "responseBody", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: m
      });
    }
  }
  t.XRPCInvalidResponseError = x;
})(Qo);
var Ti = {}, qt = {};
Object.defineProperty(qt, "__esModule", { value: !0 });
qt.httpResponseBodyParse = qt.httpResponseCodeToEnum = qt.encodeMethodCallBody = qt.constructMethodCallHeaders = qt.normalizeHeaders = qt.encodeQueryParam = qt.constructMethodCallUri = qt.getMethodSchemaHTTPMethod = void 0;
const Ac = ga, Jr = Qo;
function Ny(t) {
  return t.type === "procedure" ? "post" : "get";
}
qt.getMethodSchemaHTTPMethod = Ny;
function Vy(t, e, r, a) {
  const u = new URL(r);
  if (u.pathname = `/xrpc/${t}`, a)
    for (const [x, y] of Object.entries(a)) {
      const p = e.parameters?.properties?.[x];
      if (!p)
        throw new Error(`Invalid query parameter: ${x}`);
      y !== void 0 && (p.type === "array" ? [].concat(y).forEach((m) => {
        u.searchParams.append(x, Nl(p.items.type, m));
      }) : u.searchParams.set(x, Nl(p.type, y)));
    }
  return u.toString();
}
qt.constructMethodCallUri = Vy;
function Nl(t, e) {
  if (t === "string" || t === "unknown")
    return String(e);
  if (t === "float")
    return String(Number(e));
  if (t === "integer")
    return String(Number(e) | 0);
  if (t === "boolean")
    return e ? "true" : "false";
  if (t === "datetime")
    return e instanceof Date ? e.toISOString() : String(e);
  throw new Error(`Unsupported query param type: ${t}`);
}
qt.encodeQueryParam = Nl;
function My(t) {
  const e = {};
  for (const [r, a] of Object.entries(t))
    e[r.toLowerCase()] = a;
  return e;
}
qt.normalizeHeaders = My;
function jy(t, e, r) {
  const a = r?.headers || {};
  return t.type === "procedure" && (r?.encoding && (a["Content-Type"] = r.encoding), e && typeof e == "object" && (a["Content-Type"] || (a["Content-Type"] = "application/json"))), a;
}
qt.constructMethodCallHeaders = jy;
function Fy(t, e) {
  if (!(!t["content-type"] || typeof e > "u"))
    return e instanceof ArrayBuffer ? e : t["content-type"].startsWith("text/") ? new TextEncoder().encode(e.toString()) : t["content-type"].startsWith("application/json") ? new TextEncoder().encode((0, Ac.stringifyLex)(e)) : e;
}
qt.encodeMethodCallBody = Fy;
function $y(t) {
  let e;
  return t in Jr.ResponseType ? e = t : t >= 100 && t < 200 ? e = Jr.ResponseType.XRPCNotSupported : t >= 200 && t < 300 ? e = Jr.ResponseType.Success : t >= 300 && t < 400 ? e = Jr.ResponseType.XRPCNotSupported : t >= 400 && t < 500 ? e = Jr.ResponseType.InvalidRequest : e = Jr.ResponseType.InternalServerError, e;
}
qt.httpResponseCodeToEnum = $y;
function Gy(t, e) {
  if (t) {
    if (t.includes("application/json") && e?.byteLength)
      try {
        const r = new TextDecoder().decode(e);
        return (0, Ac.jsonStringToLex)(r);
      } catch (r) {
        throw new Jr.XRPCError(Jr.ResponseType.InvalidResponse, `Failed to parse response body: ${String(r)}`);
      }
    if (t.startsWith("text/") && e?.byteLength)
      try {
        return new TextDecoder().decode(e);
      } catch (r) {
        throw new Jr.XRPCError(Jr.ResponseType.InvalidResponse, `Failed to parse response body: ${String(r)}`);
      }
  }
  return e instanceof ArrayBuffer ? new Uint8Array(e) : e;
}
qt.httpResponseBodyParse = Gy;
Object.defineProperty(Ti, "__esModule", { value: !0 });
Ti.defaultFetchHandler = Ti.ServiceClient = Ti.Client = void 0;
const _c = ga, on = qt, Fi = Qo;
class qy {
  constructor() {
    Object.defineProperty(this, "fetch", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: wc
    }), Object.defineProperty(this, "lex", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new _c.Lexicons()
    });
  }
  // method calls
  //
  async call(e, r, a, u, x) {
    return this.service(e).call(r, a, u, x);
  }
  service(e) {
    return new Tc(this, e);
  }
  // schemas
  // =
  addLexicon(e) {
    this.lex.add(e);
  }
  addLexicons(e) {
    for (const r of e)
      this.addLexicon(r);
  }
  removeLexicon(e) {
    this.lex.remove(e);
  }
}
Ti.Client = qy;
class Tc {
  constructor(e, r) {
    Object.defineProperty(this, "baseClient", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "uri", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), this.baseClient = e, this.uri = typeof r == "string" ? new URL(r) : r;
  }
  setHeader(e, r) {
    this.headers[e] = r;
  }
  unsetHeader(e) {
    delete this.headers[e];
  }
  async call(e, r, a, u) {
    const x = this.baseClient.lex.getDefOrThrow(e);
    if (!x || x.type !== "query" && x.type !== "procedure")
      throw new Error(`Invalid lexicon: ${e}. Must be a query or procedure.`);
    const y = (0, on.getMethodSchemaHTTPMethod)(x), p = (0, on.constructMethodCallUri)(e, x, this.uri, r), h = (0, on.constructMethodCallHeaders)(x, a, {
      headers: {
        ...this.headers,
        ...u?.headers
      },
      encoding: u?.encoding
    }), m = await this.baseClient.fetch(p, y, h, a), d = (0, on.httpResponseCodeToEnum)(m.status);
    if (d === Fi.ResponseType.Success) {
      try {
        this.baseClient.lex.assertValidXrpcOutput(e, m.body);
      } catch (T) {
        throw T instanceof _c.ValidationError ? new Fi.XRPCInvalidResponseError(e, T, h.body) : T;
      }
      return new Fi.XRPCResponse(m.body, m.headers);
    } else
      throw h.body && Xy(h.body) ? new Fi.XRPCError(d, h.body.error, h.body.message, h.headers) : new Fi.XRPCError(d);
  }
}
Ti.ServiceClient = Tc;
async function wc(t, e, r, a) {
  try {
    const u = (0, on.normalizeHeaders)(r), x = {
      method: e,
      headers: u,
      body: (0, on.encodeMethodCallBody)(u, a),
      duplex: "half"
    }, y = await fetch(t, x), p = await y.arrayBuffer();
    return {
      status: y.status,
      headers: Object.fromEntries(y.headers.entries()),
      body: (0, on.httpResponseBodyParse)(y.headers.get("content-type"), p)
    };
  } catch (u) {
    throw new Fi.XRPCError(Fi.ResponseType.Unknown, String(u));
  }
}
Ti.defaultFetchHandler = wc;
function Xy(t) {
  return Fi.errorResponseBody.safeParse(t).success;
}
(function(t) {
  var e = le && le.__createBinding || (Object.create ? function(x, y, p, h) {
    h === void 0 && (h = p);
    var m = Object.getOwnPropertyDescriptor(y, p);
    (!m || ("get" in m ? !y.__esModule : m.writable || m.configurable)) && (m = { enumerable: !0, get: function() {
      return y[p];
    } }), Object.defineProperty(x, h, m);
  } : function(x, y, p, h) {
    h === void 0 && (h = p), x[h] = y[p];
  }), r = le && le.__exportStar || function(x, y) {
    for (var p in x) p !== "default" && !Object.prototype.hasOwnProperty.call(y, p) && e(y, x, p);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), r(Qo, t), r(Ti, t);
  const a = Ti, u = new a.Client();
  t.default = u;
})(te);
var Ve = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ids = t.lexicons = t.schemas = t.schemaDict = void 0;
  const e = ga;
  t.schemaDict = {
    ComAtprotoAdminDefs: {
      lexicon: 1,
      id: "com.atproto.admin.defs",
      defs: {
        statusAttr: {
          type: "object",
          required: ["applied"],
          properties: {
            applied: {
              type: "boolean"
            },
            ref: {
              type: "string"
            }
          }
        },
        accountView: {
          type: "object",
          required: ["did", "handle", "indexedAt"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            email: {
              type: "string"
            },
            relatedRecords: {
              type: "array",
              items: {
                type: "unknown"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            invitedBy: {
              type: "ref",
              ref: "lex:com.atproto.server.defs#inviteCode"
            },
            invites: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.server.defs#inviteCode"
              }
            },
            invitesDisabled: {
              type: "boolean"
            },
            emailConfirmedAt: {
              type: "string",
              format: "datetime"
            },
            inviteNote: {
              type: "string"
            }
          }
        },
        repoRef: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        },
        repoBlobRef: {
          type: "object",
          required: ["did", "cid"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            recordUri: {
              type: "string",
              format: "at-uri"
            }
          }
        }
      }
    },
    ComAtprotoAdminDeleteAccount: {
      lexicon: 1,
      id: "com.atproto.admin.deleteAccount",
      defs: {
        main: {
          type: "procedure",
          description: "Delete a user account as an administrator.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminDisableAccountInvites: {
      lexicon: 1,
      id: "com.atproto.admin.disableAccountInvites",
      defs: {
        main: {
          type: "procedure",
          description: "Disable an account from receiving new invite codes, but does not invalidate existing codes.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["account"],
              properties: {
                account: {
                  type: "string",
                  format: "did"
                },
                note: {
                  type: "string",
                  description: "Optional reason for disabled invites."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminDisableInviteCodes: {
      lexicon: 1,
      id: "com.atproto.admin.disableInviteCodes",
      defs: {
        main: {
          type: "procedure",
          description: "Disable some set of codes and/or all codes associated with a set of users.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                codes: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                accounts: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminEnableAccountInvites: {
      lexicon: 1,
      id: "com.atproto.admin.enableAccountInvites",
      defs: {
        main: {
          type: "procedure",
          description: "Re-enable an account's ability to receive invite codes.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["account"],
              properties: {
                account: {
                  type: "string",
                  format: "did"
                },
                note: {
                  type: "string",
                  description: "Optional reason for enabled invites."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminGetAccountInfo: {
      lexicon: 1,
      id: "com.atproto.admin.getAccountInfo",
      defs: {
        main: {
          type: "query",
          description: "Get details about an account.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:com.atproto.admin.defs#accountView"
            }
          }
        }
      }
    },
    ComAtprotoAdminGetAccountInfos: {
      lexicon: 1,
      id: "com.atproto.admin.getAccountInfos",
      defs: {
        main: {
          type: "query",
          description: "Get details about some accounts.",
          parameters: {
            type: "params",
            required: ["dids"],
            properties: {
              dids: {
                type: "array",
                items: {
                  type: "string",
                  format: "did"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["infos"],
              properties: {
                infos: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#accountView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminGetInviteCodes: {
      lexicon: 1,
      id: "com.atproto.admin.getInviteCodes",
      defs: {
        main: {
          type: "query",
          description: "Get an admin view of invite codes.",
          parameters: {
            type: "params",
            properties: {
              sort: {
                type: "string",
                knownValues: ["recent", "usage"],
                default: "recent"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 500,
                default: 100
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["codes"],
              properties: {
                cursor: {
                  type: "string"
                },
                codes: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.defs#inviteCode"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminGetSubjectStatus: {
      lexicon: 1,
      id: "com.atproto.admin.getSubjectStatus",
      defs: {
        main: {
          type: "query",
          description: "Get the service-specific admin status of a subject (account, record, or blob).",
          parameters: {
            type: "params",
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              uri: {
                type: "string",
                format: "at-uri"
              },
              blob: {
                type: "string",
                format: "cid"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject"],
              properties: {
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef",
                    "lex:com.atproto.admin.defs#repoBlobRef"
                  ]
                },
                takedown: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#statusAttr"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminSendEmail: {
      lexicon: 1,
      id: "com.atproto.admin.sendEmail",
      defs: {
        main: {
          type: "procedure",
          description: "Send email to a user's account email address.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["recipientDid", "content", "senderDid"],
              properties: {
                recipientDid: {
                  type: "string",
                  format: "did"
                },
                content: {
                  type: "string"
                },
                subject: {
                  type: "string"
                },
                senderDid: {
                  type: "string",
                  format: "did"
                },
                comment: {
                  type: "string",
                  description: "Additional comment by the sender that won't be used in the email itself but helpful to provide more context for moderators/reviewers"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["sent"],
              properties: {
                sent: {
                  type: "boolean"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminUpdateAccountEmail: {
      lexicon: 1,
      id: "com.atproto.admin.updateAccountEmail",
      defs: {
        main: {
          type: "procedure",
          description: "Administrative action to update an account's email.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["account", "email"],
              properties: {
                account: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo."
                },
                email: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminUpdateAccountHandle: {
      lexicon: 1,
      id: "com.atproto.admin.updateAccountHandle",
      defs: {
        main: {
          type: "procedure",
          description: "Administrative action to update an account's handle.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "handle"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminUpdateAccountPassword: {
      lexicon: 1,
      id: "com.atproto.admin.updateAccountPassword",
      defs: {
        main: {
          type: "procedure",
          description: "Update the password for a user account as an administrator.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "password"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                password: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoAdminUpdateSubjectStatus: {
      lexicon: 1,
      id: "com.atproto.admin.updateSubjectStatus",
      defs: {
        main: {
          type: "procedure",
          description: "Update the service-specific admin status of a subject (account, record, or blob).",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject"],
              properties: {
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef",
                    "lex:com.atproto.admin.defs#repoBlobRef"
                  ]
                },
                takedown: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#statusAttr"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject"],
              properties: {
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef",
                    "lex:com.atproto.admin.defs#repoBlobRef"
                  ]
                },
                takedown: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#statusAttr"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoIdentityGetRecommendedDidCredentials: {
      lexicon: 1,
      id: "com.atproto.identity.getRecommendedDidCredentials",
      defs: {
        main: {
          type: "query",
          description: "Describe the credentials that should be included in the DID doc of an account that is migrating to this service.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                rotationKeys: {
                  description: "Recommended rotation keys for PLC dids. Should be undefined (or ignored) for did:webs.",
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                alsoKnownAs: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                verificationMethods: {
                  type: "unknown"
                },
                services: {
                  type: "unknown"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoIdentityRequestPlcOperationSignature: {
      lexicon: 1,
      id: "com.atproto.identity.requestPlcOperationSignature",
      defs: {
        main: {
          type: "procedure",
          description: "Request an email with a code to in order to request a signed PLC operation. Requires Auth."
        }
      }
    },
    ComAtprotoIdentityResolveHandle: {
      lexicon: 1,
      id: "com.atproto.identity.resolveHandle",
      defs: {
        main: {
          type: "query",
          description: "Resolves a handle (domain name) to a DID.",
          parameters: {
            type: "params",
            required: ["handle"],
            properties: {
              handle: {
                type: "string",
                format: "handle",
                description: "The handle to resolve."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoIdentitySignPlcOperation: {
      lexicon: 1,
      id: "com.atproto.identity.signPlcOperation",
      defs: {
        main: {
          type: "procedure",
          description: "Signs a PLC operation to update some value(s) in the requesting DID's document.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                token: {
                  description: "A token received through com.atproto.identity.requestPlcOperationSignature",
                  type: "string"
                },
                rotationKeys: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                alsoKnownAs: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                verificationMethods: {
                  type: "unknown"
                },
                services: {
                  type: "unknown"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["operation"],
              properties: {
                operation: {
                  type: "unknown",
                  description: "A signed DID PLC operation."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoIdentitySubmitPlcOperation: {
      lexicon: 1,
      id: "com.atproto.identity.submitPlcOperation",
      defs: {
        main: {
          type: "procedure",
          description: "Validates a PLC operation to ensure that it doesn't violate a service's constraints or get the identity into a bad state, then submits it to the PLC registry",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["operation"],
              properties: {
                operation: {
                  type: "unknown"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoIdentityUpdateHandle: {
      lexicon: 1,
      id: "com.atproto.identity.updateHandle",
      defs: {
        main: {
          type: "procedure",
          description: "Updates the current account's handle. Verifies handle validity, and updates did:plc document if necessary. Implemented by PDS, and requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["handle"],
              properties: {
                handle: {
                  type: "string",
                  format: "handle",
                  description: "The new handle."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoLabelDefs: {
      lexicon: 1,
      id: "com.atproto.label.defs",
      defs: {
        label: {
          type: "object",
          description: "Metadata tag on an atproto resource (eg, repo or record).",
          required: ["src", "uri", "val", "cts"],
          properties: {
            ver: {
              type: "integer",
              description: "The AT Protocol version of the label object."
            },
            src: {
              type: "string",
              format: "did",
              description: "DID of the actor who created this label."
            },
            uri: {
              type: "string",
              format: "uri",
              description: "AT URI of the record, repository (account), or other resource that this label applies to."
            },
            cid: {
              type: "string",
              format: "cid",
              description: "Optionally, CID specifying the specific version of 'uri' resource this label applies to."
            },
            val: {
              type: "string",
              maxLength: 128,
              description: "The short string name of the value or type of this label."
            },
            neg: {
              type: "boolean",
              description: "If true, this is a negation label, overwriting a previous label."
            },
            cts: {
              type: "string",
              format: "datetime",
              description: "Timestamp when this label was created."
            },
            exp: {
              type: "string",
              format: "datetime",
              description: "Timestamp at which this label expires (no longer applies)."
            },
            sig: {
              type: "bytes",
              description: "Signature of dag-cbor encoded label."
            }
          }
        },
        selfLabels: {
          type: "object",
          description: "Metadata tags on an atproto record, published by the author within the record.",
          required: ["values"],
          properties: {
            values: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#selfLabel"
              },
              maxLength: 10
            }
          }
        },
        selfLabel: {
          type: "object",
          description: "Metadata tag on an atproto record, published by the author within the record. Note that schemas should use #selfLabels, not #selfLabel.",
          required: ["val"],
          properties: {
            val: {
              type: "string",
              maxLength: 128,
              description: "The short string name of the value or type of this label."
            }
          }
        },
        labelValueDefinition: {
          type: "object",
          description: "Declares a label value and its expected interpertations and behaviors.",
          required: ["identifier", "severity", "blurs", "locales"],
          properties: {
            identifier: {
              type: "string",
              description: "The value of the label being defined. Must only include lowercase ascii and the '-' character ([a-z-]+).",
              maxLength: 100,
              maxGraphemes: 100
            },
            severity: {
              type: "string",
              description: "How should a client visually convey this label? 'inform' means neutral and informational; 'alert' means negative and warning; 'none' means show nothing.",
              knownValues: ["inform", "alert", "none"]
            },
            blurs: {
              type: "string",
              description: "What should this label hide in the UI, if applied? 'content' hides all of the target; 'media' hides the images/video/audio; 'none' hides nothing.",
              knownValues: ["content", "media", "none"]
            },
            defaultSetting: {
              type: "string",
              description: "The default setting for this label.",
              knownValues: ["ignore", "warn", "hide"],
              default: "warn"
            },
            adultOnly: {
              type: "boolean",
              description: "Does the user need to have adult content enabled in order to configure this label?"
            },
            locales: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#labelValueDefinitionStrings"
              }
            }
          }
        },
        labelValueDefinitionStrings: {
          type: "object",
          description: "Strings which describe the label in the UI, localized into a specific language.",
          required: ["lang", "name", "description"],
          properties: {
            lang: {
              type: "string",
              description: "The code of the language these strings are written in.",
              format: "language"
            },
            name: {
              type: "string",
              description: "A short human-readable name for the label.",
              maxGraphemes: 64,
              maxLength: 640
            },
            description: {
              type: "string",
              description: "A longer description of what the label means and why it might be applied.",
              maxGraphemes: 1e4,
              maxLength: 1e5
            }
          }
        },
        labelValue: {
          type: "string",
          knownValues: [
            "!hide",
            "!no-promote",
            "!warn",
            "!no-unauthenticated",
            "dmca-violation",
            "doxxing",
            "porn",
            "sexual",
            "nudity",
            "nsfl",
            "gore"
          ]
        }
      }
    },
    ComAtprotoLabelQueryLabels: {
      lexicon: 1,
      id: "com.atproto.label.queryLabels",
      defs: {
        main: {
          type: "query",
          description: "Find labels relevant to the provided AT-URI patterns. Public endpoint for moderation services, though may return different or additional results with auth.",
          parameters: {
            type: "params",
            required: ["uriPatterns"],
            properties: {
              uriPatterns: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "List of AT URI patterns to match (boolean 'OR'). Each may be a prefix (ending with '*'; will match inclusive of the string leading to '*'), or a full URI."
              },
              sources: {
                type: "array",
                items: {
                  type: "string",
                  format: "did"
                },
                description: "Optional list of label sources (DIDs) to filter on."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 250,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["labels"],
              properties: {
                cursor: {
                  type: "string"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoLabelSubscribeLabels: {
      lexicon: 1,
      id: "com.atproto.label.subscribeLabels",
      defs: {
        main: {
          type: "subscription",
          description: "Subscribe to stream of labels (and negations). Public endpoint implemented by mod services. Uses same sequencing scheme as repo event stream.",
          parameters: {
            type: "params",
            properties: {
              cursor: {
                type: "integer",
                description: "The last known event seq number to backfill from."
              }
            }
          },
          message: {
            schema: {
              type: "union",
              refs: [
                "lex:com.atproto.label.subscribeLabels#labels",
                "lex:com.atproto.label.subscribeLabels#info"
              ]
            }
          },
          errors: [
            {
              name: "FutureCursor"
            }
          ]
        },
        labels: {
          type: "object",
          required: ["seq", "labels"],
          properties: {
            seq: {
              type: "integer"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        info: {
          type: "object",
          required: ["name"],
          properties: {
            name: {
              type: "string",
              knownValues: ["OutdatedCursor"]
            },
            message: {
              type: "string"
            }
          }
        }
      }
    },
    ComAtprotoModerationCreateReport: {
      lexicon: 1,
      id: "com.atproto.moderation.createReport",
      defs: {
        main: {
          type: "procedure",
          description: "Submit a moderation report regarding an atproto account or record. Implemented by moderation services (with PDS proxying), and requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["reasonType", "subject"],
              properties: {
                reasonType: {
                  type: "ref",
                  description: "Indicates the broad category of violation the report is for.",
                  ref: "lex:com.atproto.moderation.defs#reasonType"
                },
                reason: {
                  type: "string",
                  maxGraphemes: 2e3,
                  maxLength: 2e4,
                  description: "Additional context about the content and violation."
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: [
                "id",
                "reasonType",
                "subject",
                "reportedBy",
                "createdAt"
              ],
              properties: {
                id: {
                  type: "integer"
                },
                reasonType: {
                  type: "ref",
                  ref: "lex:com.atproto.moderation.defs#reasonType"
                },
                reason: {
                  type: "string",
                  maxGraphemes: 2e3,
                  maxLength: 2e4
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                },
                reportedBy: {
                  type: "string",
                  format: "did"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoModerationDefs: {
      lexicon: 1,
      id: "com.atproto.moderation.defs",
      defs: {
        reasonType: {
          type: "string",
          knownValues: [
            "com.atproto.moderation.defs#reasonSpam",
            "com.atproto.moderation.defs#reasonViolation",
            "com.atproto.moderation.defs#reasonMisleading",
            "com.atproto.moderation.defs#reasonSexual",
            "com.atproto.moderation.defs#reasonRude",
            "com.atproto.moderation.defs#reasonOther",
            "com.atproto.moderation.defs#reasonAppeal"
          ]
        },
        reasonSpam: {
          type: "token",
          description: "Spam: frequent unwanted promotion, replies, mentions"
        },
        reasonViolation: {
          type: "token",
          description: "Direct violation of server rules, laws, terms of service"
        },
        reasonMisleading: {
          type: "token",
          description: "Misleading identity, affiliation, or content"
        },
        reasonSexual: {
          type: "token",
          description: "Unwanted or mislabeled sexual content"
        },
        reasonRude: {
          type: "token",
          description: "Rude, harassing, explicit, or otherwise unwelcoming behavior"
        },
        reasonOther: {
          type: "token",
          description: "Other: reports not falling under another report category"
        },
        reasonAppeal: {
          type: "token",
          description: "Appeal: appeal a previously taken moderation action"
        }
      }
    },
    ComAtprotoRepoApplyWrites: {
      lexicon: 1,
      id: "com.atproto.repo.applyWrites",
      defs: {
        main: {
          type: "procedure",
          description: "Apply a batch transaction of repository creates, updates, and deletes. Requires auth, implemented by PDS.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repo", "writes"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo (aka, current account)."
                },
                validate: {
                  type: "boolean",
                  default: !0,
                  description: "Can be set to 'false' to skip Lexicon schema validation of record data, for all operations."
                },
                writes: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:com.atproto.repo.applyWrites#create",
                      "lex:com.atproto.repo.applyWrites#update",
                      "lex:com.atproto.repo.applyWrites#delete"
                    ],
                    closed: !0
                  }
                },
                swapCommit: {
                  type: "string",
                  description: "If provided, the entire operation will fail if the current repo commit CID does not match this value. Used to prevent conflicting repo mutations.",
                  format: "cid"
                }
              }
            }
          },
          errors: [
            {
              name: "InvalidSwap",
              description: "Indicates that the 'swapCommit' parameter did not match current commit."
            }
          ]
        },
        create: {
          type: "object",
          description: "Operation which creates a new record.",
          required: ["collection", "value"],
          properties: {
            collection: {
              type: "string",
              format: "nsid"
            },
            rkey: {
              type: "string",
              maxLength: 15
            },
            value: {
              type: "unknown"
            }
          }
        },
        update: {
          type: "object",
          description: "Operation which updates an existing record.",
          required: ["collection", "rkey", "value"],
          properties: {
            collection: {
              type: "string",
              format: "nsid"
            },
            rkey: {
              type: "string"
            },
            value: {
              type: "unknown"
            }
          }
        },
        delete: {
          type: "object",
          description: "Operation which deletes an existing record.",
          required: ["collection", "rkey"],
          properties: {
            collection: {
              type: "string",
              format: "nsid"
            },
            rkey: {
              type: "string"
            }
          }
        }
      }
    },
    ComAtprotoRepoCreateRecord: {
      lexicon: 1,
      id: "com.atproto.repo.createRecord",
      defs: {
        main: {
          type: "procedure",
          description: "Create a single new repository record. Requires auth, implemented by PDS.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repo", "collection", "record"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo (aka, current account)."
                },
                collection: {
                  type: "string",
                  format: "nsid",
                  description: "The NSID of the record collection."
                },
                rkey: {
                  type: "string",
                  description: "The Record Key.",
                  maxLength: 15
                },
                validate: {
                  type: "boolean",
                  default: !0,
                  description: "Can be set to 'false' to skip Lexicon schema validation of record data."
                },
                record: {
                  type: "unknown",
                  description: "The record itself. Must contain a $type field."
                },
                swapCommit: {
                  type: "string",
                  format: "cid",
                  description: "Compare and swap with the previous commit by CID."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["uri", "cid"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                }
              }
            }
          },
          errors: [
            {
              name: "InvalidSwap",
              description: "Indicates that 'swapCommit' didn't match current repo commit."
            }
          ]
        }
      }
    },
    ComAtprotoRepoDeleteRecord: {
      lexicon: 1,
      id: "com.atproto.repo.deleteRecord",
      defs: {
        main: {
          type: "procedure",
          description: "Delete a repository record, or ensure it doesn't exist. Requires auth, implemented by PDS.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repo", "collection", "rkey"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo (aka, current account)."
                },
                collection: {
                  type: "string",
                  format: "nsid",
                  description: "The NSID of the record collection."
                },
                rkey: {
                  type: "string",
                  description: "The Record Key."
                },
                swapRecord: {
                  type: "string",
                  format: "cid",
                  description: "Compare and swap with the previous record by CID."
                },
                swapCommit: {
                  type: "string",
                  format: "cid",
                  description: "Compare and swap with the previous commit by CID."
                }
              }
            }
          },
          errors: [
            {
              name: "InvalidSwap"
            }
          ]
        }
      }
    },
    ComAtprotoRepoDescribeRepo: {
      lexicon: 1,
      id: "com.atproto.repo.describeRepo",
      defs: {
        main: {
          type: "query",
          description: "Get information about an account and repository, including the list of collections. Does not require auth.",
          parameters: {
            type: "params",
            required: ["repo"],
            properties: {
              repo: {
                type: "string",
                format: "at-identifier",
                description: "The handle or DID of the repo."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: [
                "handle",
                "did",
                "didDoc",
                "collections",
                "handleIsCorrect"
              ],
              properties: {
                handle: {
                  type: "string",
                  format: "handle"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                didDoc: {
                  type: "unknown",
                  description: "The complete DID document for this account."
                },
                collections: {
                  type: "array",
                  description: "List of all the collections (NSIDs) for which this repo contains at least one record.",
                  items: {
                    type: "string",
                    format: "nsid"
                  }
                },
                handleIsCorrect: {
                  type: "boolean",
                  description: "Indicates if handle is currently valid (resolves bi-directionally)"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoRepoGetRecord: {
      lexicon: 1,
      id: "com.atproto.repo.getRecord",
      defs: {
        main: {
          type: "query",
          description: "Get a single record from a repository. Does not require auth.",
          parameters: {
            type: "params",
            required: ["repo", "collection", "rkey"],
            properties: {
              repo: {
                type: "string",
                format: "at-identifier",
                description: "The handle or DID of the repo."
              },
              collection: {
                type: "string",
                format: "nsid",
                description: "The NSID of the record collection."
              },
              rkey: {
                type: "string",
                description: "The Record Key."
              },
              cid: {
                type: "string",
                format: "cid",
                description: "The CID of the version of the record. If not specified, then return the most recent version."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["uri", "value"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                value: {
                  type: "unknown"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoRepoImportRepo: {
      lexicon: 1,
      id: "com.atproto.repo.importRepo",
      defs: {
        main: {
          type: "procedure",
          description: "Import a repo in the form of a CAR file. Requires Content-Length HTTP header to be set.",
          input: {
            encoding: "application/vnd.ipld.car"
          }
        }
      }
    },
    ComAtprotoRepoListMissingBlobs: {
      lexicon: 1,
      id: "com.atproto.repo.listMissingBlobs",
      defs: {
        main: {
          type: "query",
          description: "Returns a list of missing blobs for the requesting account. Intended to be used in the account migration flow.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 1e3,
                default: 500
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["blobs"],
              properties: {
                cursor: {
                  type: "string"
                },
                blobs: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.listMissingBlobs#recordBlob"
                  }
                }
              }
            }
          }
        },
        recordBlob: {
          type: "object",
          required: ["cid", "recordUri"],
          properties: {
            cid: {
              type: "string",
              format: "cid"
            },
            recordUri: {
              type: "string",
              format: "at-uri"
            }
          }
        }
      }
    },
    ComAtprotoRepoListRecords: {
      lexicon: 1,
      id: "com.atproto.repo.listRecords",
      defs: {
        main: {
          type: "query",
          description: "List a range of records in a repository, matching a specific collection. Does not require auth.",
          parameters: {
            type: "params",
            required: ["repo", "collection"],
            properties: {
              repo: {
                type: "string",
                format: "at-identifier",
                description: "The handle or DID of the repo."
              },
              collection: {
                type: "string",
                format: "nsid",
                description: "The NSID of the record type."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50,
                description: "The number of records to return."
              },
              cursor: {
                type: "string"
              },
              rkeyStart: {
                type: "string",
                description: "DEPRECATED: The lowest sort-ordered rkey to start from (exclusive)"
              },
              rkeyEnd: {
                type: "string",
                description: "DEPRECATED: The highest sort-ordered rkey to stop at (exclusive)"
              },
              reverse: {
                type: "boolean",
                description: "Flag to reverse the order of the returned records."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["records"],
              properties: {
                cursor: {
                  type: "string"
                },
                records: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.listRecords#record"
                  }
                }
              }
            }
          }
        },
        record: {
          type: "object",
          required: ["uri", "cid", "value"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            value: {
              type: "unknown"
            }
          }
        }
      }
    },
    ComAtprotoRepoPutRecord: {
      lexicon: 1,
      id: "com.atproto.repo.putRecord",
      defs: {
        main: {
          type: "procedure",
          description: "Write a repository record, creating or updating it as needed. Requires auth, implemented by PDS.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repo", "collection", "rkey", "record"],
              nullable: ["swapRecord"],
              properties: {
                repo: {
                  type: "string",
                  format: "at-identifier",
                  description: "The handle or DID of the repo (aka, current account)."
                },
                collection: {
                  type: "string",
                  format: "nsid",
                  description: "The NSID of the record collection."
                },
                rkey: {
                  type: "string",
                  description: "The Record Key.",
                  maxLength: 15
                },
                validate: {
                  type: "boolean",
                  default: !0,
                  description: "Can be set to 'false' to skip Lexicon schema validation of record data."
                },
                record: {
                  type: "unknown",
                  description: "The record to write."
                },
                swapRecord: {
                  type: "string",
                  format: "cid",
                  description: "Compare and swap with the previous record by CID. WARNING: nullable and optional field; may cause problems with golang implementation"
                },
                swapCommit: {
                  type: "string",
                  format: "cid",
                  description: "Compare and swap with the previous commit by CID."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["uri", "cid"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                }
              }
            }
          },
          errors: [
            {
              name: "InvalidSwap"
            }
          ]
        }
      }
    },
    ComAtprotoRepoStrongRef: {
      lexicon: 1,
      id: "com.atproto.repo.strongRef",
      description: "A URI with a content-hash fingerprint.",
      defs: {
        main: {
          type: "object",
          required: ["uri", "cid"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            }
          }
        }
      }
    },
    ComAtprotoRepoUploadBlob: {
      lexicon: 1,
      id: "com.atproto.repo.uploadBlob",
      defs: {
        main: {
          type: "procedure",
          description: "Upload a new blob, to be referenced from a repository record. The blob will be deleted if it is not referenced within a time window (eg, minutes). Blob restrictions (mimetype, size, etc) are enforced when the reference is created. Requires auth, implemented by PDS.",
          input: {
            encoding: "*/*"
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["blob"],
              properties: {
                blob: {
                  type: "blob"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerActivateAccount: {
      lexicon: 1,
      id: "com.atproto.server.activateAccount",
      defs: {
        main: {
          type: "procedure",
          description: "Activates a currently deactivated account. Used to finalize account migration after the account's repo is imported and identity is setup."
        }
      }
    },
    ComAtprotoServerCheckAccountStatus: {
      lexicon: 1,
      id: "com.atproto.server.checkAccountStatus",
      defs: {
        main: {
          type: "query",
          description: "Returns the status of an account, especially as pertaining to import or recovery. Can be called many times over the course of an account migration. Requires auth and can only be called pertaining to oneself.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: [
                "activated",
                "validDid",
                "repoCommit",
                "repoRev",
                "repoBlocks",
                "indexedRecords",
                "privateStateValues",
                "expectedBlobs",
                "importedBlobs"
              ],
              properties: {
                activated: {
                  type: "boolean"
                },
                validDid: {
                  type: "boolean"
                },
                repoCommit: {
                  type: "string",
                  format: "cid"
                },
                repoRev: {
                  type: "string"
                },
                repoBlocks: {
                  type: "integer"
                },
                indexedRecords: {
                  type: "integer"
                },
                privateStateValues: {
                  type: "integer"
                },
                expectedBlobs: {
                  type: "integer"
                },
                importedBlobs: {
                  type: "integer"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerConfirmEmail: {
      lexicon: 1,
      id: "com.atproto.server.confirmEmail",
      defs: {
        main: {
          type: "procedure",
          description: "Confirm an email using a token from com.atproto.server.requestEmailConfirmation.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["email", "token"],
              properties: {
                email: {
                  type: "string"
                },
                token: {
                  type: "string"
                }
              }
            }
          },
          errors: [
            {
              name: "AccountNotFound"
            },
            {
              name: "ExpiredToken"
            },
            {
              name: "InvalidToken"
            },
            {
              name: "InvalidEmail"
            }
          ]
        }
      }
    },
    ComAtprotoServerCreateAccount: {
      lexicon: 1,
      id: "com.atproto.server.createAccount",
      defs: {
        main: {
          type: "procedure",
          description: "Create an account. Implemented by PDS.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["handle"],
              properties: {
                email: {
                  type: "string"
                },
                handle: {
                  type: "string",
                  format: "handle",
                  description: "Requested handle for the account."
                },
                did: {
                  type: "string",
                  format: "did",
                  description: "Pre-existing atproto DID, being imported to a new account."
                },
                inviteCode: {
                  type: "string"
                },
                verificationCode: {
                  type: "string"
                },
                verificationPhone: {
                  type: "string"
                },
                password: {
                  type: "string",
                  description: "Initial account password. May need to meet instance-specific password strength requirements."
                },
                recoveryKey: {
                  type: "string",
                  description: "DID PLC rotation key (aka, recovery key) to be included in PLC creation operation."
                },
                plcOp: {
                  type: "unknown",
                  description: "A signed DID PLC operation to be submitted as part of importing an existing account to this instance. NOTE: this optional field may be updated when full account migration is implemented."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              description: "Account login session returned on successful account creation.",
              required: ["accessJwt", "refreshJwt", "handle", "did"],
              properties: {
                accessJwt: {
                  type: "string"
                },
                refreshJwt: {
                  type: "string"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID of the new account."
                },
                didDoc: {
                  type: "unknown",
                  description: "Complete DID document."
                }
              }
            }
          },
          errors: [
            {
              name: "InvalidHandle"
            },
            {
              name: "InvalidPassword"
            },
            {
              name: "InvalidInviteCode"
            },
            {
              name: "HandleNotAvailable"
            },
            {
              name: "UnsupportedDomain"
            },
            {
              name: "UnresolvableDid"
            },
            {
              name: "IncompatibleDidDoc"
            }
          ]
        }
      }
    },
    ComAtprotoServerCreateAppPassword: {
      lexicon: 1,
      id: "com.atproto.server.createAppPassword",
      defs: {
        main: {
          type: "procedure",
          description: "Create an App Password.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["name"],
              properties: {
                name: {
                  type: "string",
                  description: "A short name for the App Password, to help distinguish them."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:com.atproto.server.createAppPassword#appPassword"
            }
          },
          errors: [
            {
              name: "AccountTakedown"
            }
          ]
        },
        appPassword: {
          type: "object",
          required: ["name", "password", "createdAt"],
          properties: {
            name: {
              type: "string"
            },
            password: {
              type: "string"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            }
          }
        }
      }
    },
    ComAtprotoServerCreateInviteCode: {
      lexicon: 1,
      id: "com.atproto.server.createInviteCode",
      defs: {
        main: {
          type: "procedure",
          description: "Create an invite code.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["useCount"],
              properties: {
                useCount: {
                  type: "integer"
                },
                forAccount: {
                  type: "string",
                  format: "did"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["code"],
              properties: {
                code: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerCreateInviteCodes: {
      lexicon: 1,
      id: "com.atproto.server.createInviteCodes",
      defs: {
        main: {
          type: "procedure",
          description: "Create invite codes.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["codeCount", "useCount"],
              properties: {
                codeCount: {
                  type: "integer",
                  default: 1
                },
                useCount: {
                  type: "integer"
                },
                forAccounts: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "did"
                  }
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["codes"],
              properties: {
                codes: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.createInviteCodes#accountCodes"
                  }
                }
              }
            }
          }
        },
        accountCodes: {
          type: "object",
          required: ["account", "codes"],
          properties: {
            account: {
              type: "string"
            },
            codes: {
              type: "array",
              items: {
                type: "string"
              }
            }
          }
        }
      }
    },
    ComAtprotoServerCreateSession: {
      lexicon: 1,
      id: "com.atproto.server.createSession",
      defs: {
        main: {
          type: "procedure",
          description: "Create an authentication session.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["identifier", "password"],
              properties: {
                identifier: {
                  type: "string",
                  description: "Handle or other identifier supported by the server for the authenticating user."
                },
                password: {
                  type: "string"
                },
                authFactorToken: {
                  type: "string"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["accessJwt", "refreshJwt", "handle", "did"],
              properties: {
                accessJwt: {
                  type: "string"
                },
                refreshJwt: {
                  type: "string"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                didDoc: {
                  type: "unknown"
                },
                email: {
                  type: "string"
                },
                emailConfirmed: {
                  type: "boolean"
                },
                emailAuthFactor: {
                  type: "boolean"
                }
              }
            }
          },
          errors: [
            {
              name: "AccountTakedown"
            },
            {
              name: "AuthFactorTokenRequired"
            }
          ]
        }
      }
    },
    ComAtprotoServerDeactivateAccount: {
      lexicon: 1,
      id: "com.atproto.server.deactivateAccount",
      defs: {
        main: {
          type: "procedure",
          description: "Deactivates a currently active account. Stops serving of repo, and future writes to repo until reactivated. Used to finalize account migration with the old host after the account has been activated on the new host.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                deleteAfter: {
                  type: "string",
                  format: "datetime",
                  description: "A recommendation to server as to how long they should hold onto the deactivated account before deleting."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerDefs: {
      lexicon: 1,
      id: "com.atproto.server.defs",
      defs: {
        inviteCode: {
          type: "object",
          required: [
            "code",
            "available",
            "disabled",
            "forAccount",
            "createdBy",
            "createdAt",
            "uses"
          ],
          properties: {
            code: {
              type: "string"
            },
            available: {
              type: "integer"
            },
            disabled: {
              type: "boolean"
            },
            forAccount: {
              type: "string"
            },
            createdBy: {
              type: "string"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            uses: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.server.defs#inviteCodeUse"
              }
            }
          }
        },
        inviteCodeUse: {
          type: "object",
          required: ["usedBy", "usedAt"],
          properties: {
            usedBy: {
              type: "string",
              format: "did"
            },
            usedAt: {
              type: "string",
              format: "datetime"
            }
          }
        }
      }
    },
    ComAtprotoServerDeleteAccount: {
      lexicon: 1,
      id: "com.atproto.server.deleteAccount",
      defs: {
        main: {
          type: "procedure",
          description: "Delete an actor's account with a token and password. Can only be called after requesting a deletion token. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "password", "token"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                password: {
                  type: "string"
                },
                token: {
                  type: "string"
                }
              }
            }
          },
          errors: [
            {
              name: "ExpiredToken"
            },
            {
              name: "InvalidToken"
            }
          ]
        }
      }
    },
    ComAtprotoServerDeleteSession: {
      lexicon: 1,
      id: "com.atproto.server.deleteSession",
      defs: {
        main: {
          type: "procedure",
          description: "Delete the current session. Requires auth."
        }
      }
    },
    ComAtprotoServerDescribeServer: {
      lexicon: 1,
      id: "com.atproto.server.describeServer",
      defs: {
        main: {
          type: "query",
          description: "Describes the server's account creation requirements and capabilities. Implemented by PDS.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "availableUserDomains"],
              properties: {
                inviteCodeRequired: {
                  type: "boolean",
                  description: "If true, an invite code must be supplied to create an account on this instance."
                },
                phoneVerificationRequired: {
                  type: "boolean",
                  description: "If true, a phone verification token must be supplied to create an account on this instance."
                },
                availableUserDomains: {
                  type: "array",
                  description: "List of domain suffixes that can be used in account handles.",
                  items: {
                    type: "string"
                  }
                },
                links: {
                  type: "ref",
                  description: "URLs of service policy documents.",
                  ref: "lex:com.atproto.server.describeServer#links"
                },
                contact: {
                  type: "ref",
                  description: "Contact information",
                  ref: "lex:com.atproto.server.describeServer#contact"
                },
                did: {
                  type: "string",
                  format: "did"
                }
              }
            }
          }
        },
        links: {
          type: "object",
          properties: {
            privacyPolicy: {
              type: "string",
              format: "uri"
            },
            termsOfService: {
              type: "string",
              format: "uri"
            }
          }
        },
        contact: {
          type: "object",
          properties: {
            email: {
              type: "string"
            }
          }
        }
      }
    },
    ComAtprotoServerGetAccountInviteCodes: {
      lexicon: 1,
      id: "com.atproto.server.getAccountInviteCodes",
      defs: {
        main: {
          type: "query",
          description: "Get all invite codes for the current account. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              includeUsed: {
                type: "boolean",
                default: !0
              },
              createAvailable: {
                type: "boolean",
                default: !0,
                description: "Controls whether any new 'earned' but not 'created' invites should be created."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["codes"],
              properties: {
                codes: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.defs#inviteCode"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "DuplicateCreate"
            }
          ]
        }
      }
    },
    ComAtprotoServerGetServiceAuth: {
      lexicon: 1,
      id: "com.atproto.server.getServiceAuth",
      defs: {
        main: {
          type: "query",
          description: "Get a signed token on behalf of the requesting DID for the requested service.",
          parameters: {
            type: "params",
            required: ["aud"],
            properties: {
              aud: {
                type: "string",
                format: "did",
                description: "The DID of the service that the token will be used to authenticate with"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["token"],
              properties: {
                token: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerGetSession: {
      lexicon: 1,
      id: "com.atproto.server.getSession",
      defs: {
        main: {
          type: "query",
          description: "Get information about the current auth session. Requires auth.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["handle", "did"],
              properties: {
                handle: {
                  type: "string",
                  format: "handle"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                email: {
                  type: "string"
                },
                emailConfirmed: {
                  type: "boolean"
                },
                emailAuthFactor: {
                  type: "boolean"
                },
                didDoc: {
                  type: "unknown"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerListAppPasswords: {
      lexicon: 1,
      id: "com.atproto.server.listAppPasswords",
      defs: {
        main: {
          type: "query",
          description: "List all App Passwords.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["passwords"],
              properties: {
                passwords: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.listAppPasswords#appPassword"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "AccountTakedown"
            }
          ]
        },
        appPassword: {
          type: "object",
          required: ["name", "createdAt"],
          properties: {
            name: {
              type: "string"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            }
          }
        }
      }
    },
    ComAtprotoServerRefreshSession: {
      lexicon: 1,
      id: "com.atproto.server.refreshSession",
      defs: {
        main: {
          type: "procedure",
          description: "Refresh an authentication session. Requires auth using the 'refreshJwt' (not the 'accessJwt').",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["accessJwt", "refreshJwt", "handle", "did"],
              properties: {
                accessJwt: {
                  type: "string"
                },
                refreshJwt: {
                  type: "string"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                didDoc: {
                  type: "unknown"
                }
              }
            }
          },
          errors: [
            {
              name: "AccountTakedown"
            }
          ]
        }
      }
    },
    ComAtprotoServerRequestAccountDelete: {
      lexicon: 1,
      id: "com.atproto.server.requestAccountDelete",
      defs: {
        main: {
          type: "procedure",
          description: "Initiate a user account deletion via email."
        }
      }
    },
    ComAtprotoServerRequestEmailConfirmation: {
      lexicon: 1,
      id: "com.atproto.server.requestEmailConfirmation",
      defs: {
        main: {
          type: "procedure",
          description: "Request an email with a code to confirm ownership of email."
        }
      }
    },
    ComAtprotoServerRequestEmailUpdate: {
      lexicon: 1,
      id: "com.atproto.server.requestEmailUpdate",
      defs: {
        main: {
          type: "procedure",
          description: "Request a token in order to update email.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["tokenRequired"],
              properties: {
                tokenRequired: {
                  type: "boolean"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerRequestPasswordReset: {
      lexicon: 1,
      id: "com.atproto.server.requestPasswordReset",
      defs: {
        main: {
          type: "procedure",
          description: "Initiate a user account password reset via email.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["email"],
              properties: {
                email: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerReserveSigningKey: {
      lexicon: 1,
      id: "com.atproto.server.reserveSigningKey",
      defs: {
        main: {
          type: "procedure",
          description: "Reserve a repo signing key, for use with account creation. Necessary so that a DID PLC update operation can be constructed during an account migraiton. Public and does not require auth; implemented by PDS. NOTE: this endpoint may change when full account migration is implemented.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {
                did: {
                  type: "string",
                  format: "did",
                  description: "The DID to reserve a key for."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["signingKey"],
              properties: {
                signingKey: {
                  type: "string",
                  description: "The public key for the reserved signing key, in did:key serialization."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerResetPassword: {
      lexicon: 1,
      id: "com.atproto.server.resetPassword",
      defs: {
        main: {
          type: "procedure",
          description: "Reset a user account password using a token.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["token", "password"],
              properties: {
                token: {
                  type: "string"
                },
                password: {
                  type: "string"
                }
              }
            }
          },
          errors: [
            {
              name: "ExpiredToken"
            },
            {
              name: "InvalidToken"
            }
          ]
        }
      }
    },
    ComAtprotoServerRevokeAppPassword: {
      lexicon: 1,
      id: "com.atproto.server.revokeAppPassword",
      defs: {
        main: {
          type: "procedure",
          description: "Revoke an App Password by name.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["name"],
              properties: {
                name: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoServerUpdateEmail: {
      lexicon: 1,
      id: "com.atproto.server.updateEmail",
      defs: {
        main: {
          type: "procedure",
          description: "Update an account's email.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["email"],
              properties: {
                email: {
                  type: "string"
                },
                emailAuthFactor: {
                  type: "boolean"
                },
                token: {
                  type: "string",
                  description: "Requires a token from com.atproto.sever.requestEmailUpdate if the account's email has been confirmed."
                }
              }
            }
          },
          errors: [
            {
              name: "ExpiredToken"
            },
            {
              name: "InvalidToken"
            },
            {
              name: "TokenRequired"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetBlob: {
      lexicon: 1,
      id: "com.atproto.sync.getBlob",
      defs: {
        main: {
          type: "query",
          description: "Get a blob associated with a given account. Returns the full blob as originally uploaded. Does not require auth; implemented by PDS.",
          parameters: {
            type: "params",
            required: ["did", "cid"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the account."
              },
              cid: {
                type: "string",
                format: "cid",
                description: "The CID of the blob to fetch"
              }
            }
          },
          output: {
            encoding: "*/*"
          }
        }
      }
    },
    ComAtprotoSyncGetBlocks: {
      lexicon: 1,
      id: "com.atproto.sync.getBlocks",
      defs: {
        main: {
          type: "query",
          description: "Get data blocks from a given repo, by CID. For example, intermediate MST nodes, or records. Does not require auth; implemented by PDS.",
          parameters: {
            type: "params",
            required: ["did", "cids"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              },
              cids: {
                type: "array",
                items: {
                  type: "string",
                  format: "cid"
                }
              }
            }
          },
          output: {
            encoding: "application/vnd.ipld.car"
          }
        }
      }
    },
    ComAtprotoSyncGetCheckout: {
      lexicon: 1,
      id: "com.atproto.sync.getCheckout",
      defs: {
        main: {
          type: "query",
          description: "DEPRECATED - please use com.atproto.sync.getRepo instead",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              }
            }
          },
          output: {
            encoding: "application/vnd.ipld.car"
          }
        }
      }
    },
    ComAtprotoSyncGetHead: {
      lexicon: 1,
      id: "com.atproto.sync.getHead",
      defs: {
        main: {
          type: "query",
          description: "DEPRECATED - please use com.atproto.sync.getLatestCommit instead",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["root"],
              properties: {
                root: {
                  type: "string",
                  format: "cid"
                }
              }
            }
          },
          errors: [
            {
              name: "HeadNotFound"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetLatestCommit: {
      lexicon: 1,
      id: "com.atproto.sync.getLatestCommit",
      defs: {
        main: {
          type: "query",
          description: "Get the current commit CID & revision of the specified repo. Does not require auth.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["cid", "rev"],
              properties: {
                cid: {
                  type: "string",
                  format: "cid"
                },
                rev: {
                  type: "string"
                }
              }
            }
          },
          errors: [
            {
              name: "RepoNotFound"
            }
          ]
        }
      }
    },
    ComAtprotoSyncGetRecord: {
      lexicon: 1,
      id: "com.atproto.sync.getRecord",
      defs: {
        main: {
          type: "query",
          description: "Get data blocks needed to prove the existence or non-existence of record in the current version of repo. Does not require auth.",
          parameters: {
            type: "params",
            required: ["did", "collection", "rkey"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              },
              collection: {
                type: "string",
                format: "nsid"
              },
              rkey: {
                type: "string",
                description: "Record Key"
              },
              commit: {
                type: "string",
                format: "cid",
                description: "DEPRECATED: referenced a repo commit by CID, and retrieved record as of that commit"
              }
            }
          },
          output: {
            encoding: "application/vnd.ipld.car"
          }
        }
      }
    },
    ComAtprotoSyncGetRepo: {
      lexicon: 1,
      id: "com.atproto.sync.getRepo",
      defs: {
        main: {
          type: "query",
          description: "Download a repository export as CAR file. Optionally only a 'diff' since a previous revision. Does not require auth; implemented by PDS.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              },
              since: {
                type: "string",
                description: "The revision ('rev') of the repo to create a diff from."
              }
            }
          },
          output: {
            encoding: "application/vnd.ipld.car"
          }
        }
      }
    },
    ComAtprotoSyncListBlobs: {
      lexicon: 1,
      id: "com.atproto.sync.listBlobs",
      defs: {
        main: {
          type: "query",
          description: "List blob CIDso for an account, since some repo revision. Does not require auth; implemented by PDS.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did",
                description: "The DID of the repo."
              },
              since: {
                type: "string",
                description: "Optional revision of the repo to list blobs since."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 1e3,
                default: 500
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["cids"],
              properties: {
                cursor: {
                  type: "string"
                },
                cids: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "cid"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoSyncListRepos: {
      lexicon: 1,
      id: "com.atproto.sync.listRepos",
      defs: {
        main: {
          type: "query",
          description: "Enumerates all the DID, rev, and commit CID for all repos hosted by this service. Does not require auth; implemented by PDS and Relay.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 1e3,
                default: 500
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repos"],
              properties: {
                cursor: {
                  type: "string"
                },
                repos: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.sync.listRepos#repo"
                  }
                }
              }
            }
          }
        },
        repo: {
          type: "object",
          required: ["did", "head", "rev"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            head: {
              type: "string",
              format: "cid",
              description: "Current repo commit CID"
            },
            rev: {
              type: "string"
            }
          }
        }
      }
    },
    ComAtprotoSyncNotifyOfUpdate: {
      lexicon: 1,
      id: "com.atproto.sync.notifyOfUpdate",
      defs: {
        main: {
          type: "procedure",
          description: "Notify a crawling service of a recent update, and that crawling should resume. Intended use is after a gap between repo stream events caused the crawling service to disconnect. Does not require auth; implemented by Relay.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["hostname"],
              properties: {
                hostname: {
                  type: "string",
                  description: "Hostname of the current service (usually a PDS) that is notifying of update."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoSyncRequestCrawl: {
      lexicon: 1,
      id: "com.atproto.sync.requestCrawl",
      defs: {
        main: {
          type: "procedure",
          description: "Request a service to persistently crawl hosted repos. Expected use is new PDS instances declaring their existence to Relays. Does not require auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["hostname"],
              properties: {
                hostname: {
                  type: "string",
                  description: "Hostname of the current service (eg, PDS) that is requesting to be crawled."
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoSyncSubscribeRepos: {
      lexicon: 1,
      id: "com.atproto.sync.subscribeRepos",
      defs: {
        main: {
          type: "subscription",
          description: "Repository event stream, aka Firehose endpoint. Outputs repo commits with diff data, and identity update events, for all repositories on the current server. See the atproto specifications for details around stream sequencing, repo versioning, CAR diff format, and more. Public and does not require auth; implemented by PDS and Relay.",
          parameters: {
            type: "params",
            properties: {
              cursor: {
                type: "integer",
                description: "The last known event seq number to backfill from."
              }
            }
          },
          message: {
            schema: {
              type: "union",
              refs: [
                "lex:com.atproto.sync.subscribeRepos#commit",
                "lex:com.atproto.sync.subscribeRepos#identity",
                "lex:com.atproto.sync.subscribeRepos#handle",
                "lex:com.atproto.sync.subscribeRepos#migrate",
                "lex:com.atproto.sync.subscribeRepos#tombstone",
                "lex:com.atproto.sync.subscribeRepos#info"
              ]
            }
          },
          errors: [
            {
              name: "FutureCursor"
            },
            {
              name: "ConsumerTooSlow",
              description: "If the consumer of the stream can not keep up with events, and a backlog gets too large, the server will drop the connection."
            }
          ]
        },
        commit: {
          type: "object",
          description: "Represents an update of repository state. Note that empty commits are allowed, which include no repo data changes, but an update to rev and signature.",
          required: [
            "seq",
            "rebase",
            "tooBig",
            "repo",
            "commit",
            "rev",
            "since",
            "blocks",
            "ops",
            "blobs",
            "time"
          ],
          nullable: ["prev", "since"],
          properties: {
            seq: {
              type: "integer",
              description: "The stream sequence number of this message."
            },
            rebase: {
              type: "boolean",
              description: "DEPRECATED -- unused"
            },
            tooBig: {
              type: "boolean",
              description: "Indicates that this commit contained too many ops, or data size was too large. Consumers will need to make a separate request to get missing data."
            },
            repo: {
              type: "string",
              format: "did",
              description: "The repo this event comes from."
            },
            commit: {
              type: "cid-link",
              description: "Repo commit object CID."
            },
            prev: {
              type: "cid-link",
              description: "DEPRECATED -- unused. WARNING -- nullable and optional; stick with optional to ensure golang interoperability."
            },
            rev: {
              type: "string",
              description: "The rev of the emitted commit. Note that this information is also in the commit object included in blocks, unless this is a tooBig event."
            },
            since: {
              type: "string",
              description: "The rev of the last emitted commit from this repo (if any)."
            },
            blocks: {
              type: "bytes",
              description: "CAR file containing relevant blocks, as a diff since the previous repo state.",
              maxLength: 1e6
            },
            ops: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.sync.subscribeRepos#repoOp",
                description: "List of repo mutation operations in this commit (eg, records created, updated, or deleted)."
              },
              maxLength: 200
            },
            blobs: {
              type: "array",
              items: {
                type: "cid-link",
                description: "List of new blobs (by CID) referenced by records in this commit."
              }
            },
            time: {
              type: "string",
              format: "datetime",
              description: "Timestamp of when this message was originally broadcast."
            }
          }
        },
        identity: {
          type: "object",
          description: "Represents a change to an account's identity. Could be an updated handle, signing key, or pds hosting endpoint. Serves as a prod to all downstream services to refresh their identity cache.",
          required: ["seq", "did", "time"],
          properties: {
            seq: {
              type: "integer"
            },
            did: {
              type: "string",
              format: "did"
            },
            time: {
              type: "string",
              format: "datetime"
            }
          }
        },
        handle: {
          type: "object",
          description: "Represents an update of the account's handle, or transition to/from invalid state. NOTE: Will be deprecated in favor of #identity.",
          required: ["seq", "did", "handle", "time"],
          properties: {
            seq: {
              type: "integer"
            },
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            time: {
              type: "string",
              format: "datetime"
            }
          }
        },
        migrate: {
          type: "object",
          description: "Represents an account moving from one PDS instance to another. NOTE: not implemented; account migration uses #identity instead",
          required: ["seq", "did", "migrateTo", "time"],
          nullable: ["migrateTo"],
          properties: {
            seq: {
              type: "integer"
            },
            did: {
              type: "string",
              format: "did"
            },
            migrateTo: {
              type: "string"
            },
            time: {
              type: "string",
              format: "datetime"
            }
          }
        },
        tombstone: {
          type: "object",
          description: "Indicates that an account has been deleted. NOTE: may be deprecated in favor of #identity or a future #account event",
          required: ["seq", "did", "time"],
          properties: {
            seq: {
              type: "integer"
            },
            did: {
              type: "string",
              format: "did"
            },
            time: {
              type: "string",
              format: "datetime"
            }
          }
        },
        info: {
          type: "object",
          required: ["name"],
          properties: {
            name: {
              type: "string",
              knownValues: ["OutdatedCursor"]
            },
            message: {
              type: "string"
            }
          }
        },
        repoOp: {
          type: "object",
          description: "A repo operation, ie a mutation of a single record.",
          required: ["action", "path", "cid"],
          nullable: ["cid"],
          properties: {
            action: {
              type: "string",
              knownValues: ["create", "update", "delete"]
            },
            path: {
              type: "string"
            },
            cid: {
              type: "cid-link",
              description: "For creates and updates, the new record CID. For deletions, null."
            }
          }
        }
      }
    },
    ComAtprotoTempCheckSignupQueue: {
      lexicon: 1,
      id: "com.atproto.temp.checkSignupQueue",
      defs: {
        main: {
          type: "query",
          description: "Check accounts location in signup queue.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["activated"],
              properties: {
                activated: {
                  type: "boolean"
                },
                placeInQueue: {
                  type: "integer"
                },
                estimatedTimeMs: {
                  type: "integer"
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoTempFetchLabels: {
      lexicon: 1,
      id: "com.atproto.temp.fetchLabels",
      defs: {
        main: {
          type: "query",
          description: "DEPRECATED: use queryLabels or subscribeLabels instead -- Fetch all labels from a labeler created after a certain date.",
          parameters: {
            type: "params",
            properties: {
              since: {
                type: "integer"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 250,
                default: 50
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["labels"],
              properties: {
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            }
          }
        }
      }
    },
    ComAtprotoTempRequestPhoneVerification: {
      lexicon: 1,
      id: "com.atproto.temp.requestPhoneVerification",
      defs: {
        main: {
          type: "procedure",
          description: "Request a verification code to be sent to the supplied phone number",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["phoneNumber"],
              properties: {
                phoneNumber: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorDefs: {
      lexicon: 1,
      id: "app.bsky.actor.defs",
      defs: {
        profileViewBasic: {
          type: "object",
          required: ["did", "handle"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            displayName: {
              type: "string",
              maxGraphemes: 64,
              maxLength: 640
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            associated: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileAssociated"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#viewerState"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        profileView: {
          type: "object",
          required: ["did", "handle"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            displayName: {
              type: "string",
              maxGraphemes: 64,
              maxLength: 640
            },
            description: {
              type: "string",
              maxGraphemes: 256,
              maxLength: 2560
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            associated: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileAssociated"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#viewerState"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        profileViewDetailed: {
          type: "object",
          required: ["did", "handle"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            displayName: {
              type: "string",
              maxGraphemes: 64,
              maxLength: 640
            },
            description: {
              type: "string",
              maxGraphemes: 256,
              maxLength: 2560
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            banner: {
              type: "string",
              format: "uri"
            },
            followersCount: {
              type: "integer"
            },
            followsCount: {
              type: "integer"
            },
            postsCount: {
              type: "integer"
            },
            associated: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileAssociated"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#viewerState"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        profileAssociated: {
          type: "object",
          properties: {
            lists: {
              type: "integer"
            },
            feedgens: {
              type: "integer"
            },
            labeler: {
              type: "boolean"
            }
          }
        },
        viewerState: {
          type: "object",
          description: "Metadata about the requesting account's relationship with the subject account. Only has meaningful content for authed requests.",
          properties: {
            muted: {
              type: "boolean"
            },
            mutedByList: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listViewBasic"
            },
            blockedBy: {
              type: "boolean"
            },
            blocking: {
              type: "string",
              format: "at-uri"
            },
            blockingByList: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listViewBasic"
            },
            following: {
              type: "string",
              format: "at-uri"
            },
            followedBy: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        preferences: {
          type: "array",
          items: {
            type: "union",
            refs: [
              "lex:app.bsky.actor.defs#adultContentPref",
              "lex:app.bsky.actor.defs#contentLabelPref",
              "lex:app.bsky.actor.defs#savedFeedsPref",
              "lex:app.bsky.actor.defs#personalDetailsPref",
              "lex:app.bsky.actor.defs#feedViewPref",
              "lex:app.bsky.actor.defs#threadViewPref",
              "lex:app.bsky.actor.defs#interestsPref",
              "lex:app.bsky.actor.defs#mutedWordsPref",
              "lex:app.bsky.actor.defs#hiddenPostsPref"
            ]
          }
        },
        adultContentPref: {
          type: "object",
          required: ["enabled"],
          properties: {
            enabled: {
              type: "boolean",
              default: !1
            }
          }
        },
        contentLabelPref: {
          type: "object",
          required: ["label", "visibility"],
          properties: {
            labelerDid: {
              type: "string",
              description: "Which labeler does this preference apply to? If undefined, applies globally.",
              format: "did"
            },
            label: {
              type: "string"
            },
            visibility: {
              type: "string",
              knownValues: ["ignore", "show", "warn", "hide"]
            }
          }
        },
        savedFeedsPref: {
          type: "object",
          required: ["pinned", "saved"],
          properties: {
            pinned: {
              type: "array",
              items: {
                type: "string",
                format: "at-uri"
              }
            },
            saved: {
              type: "array",
              items: {
                type: "string",
                format: "at-uri"
              }
            },
            timelineIndex: {
              type: "integer"
            }
          }
        },
        personalDetailsPref: {
          type: "object",
          properties: {
            birthDate: {
              type: "string",
              format: "datetime",
              description: "The birth date of account owner."
            }
          }
        },
        feedViewPref: {
          type: "object",
          required: ["feed"],
          properties: {
            feed: {
              type: "string",
              description: "The URI of the feed, or an identifier which describes the feed."
            },
            hideReplies: {
              type: "boolean",
              description: "Hide replies in the feed."
            },
            hideRepliesByUnfollowed: {
              type: "boolean",
              description: "Hide replies in the feed if they are not by followed users.",
              default: !0
            },
            hideRepliesByLikeCount: {
              type: "integer",
              description: "Hide replies in the feed if they do not have this number of likes."
            },
            hideReposts: {
              type: "boolean",
              description: "Hide reposts in the feed."
            },
            hideQuotePosts: {
              type: "boolean",
              description: "Hide quote posts in the feed."
            }
          }
        },
        threadViewPref: {
          type: "object",
          properties: {
            sort: {
              type: "string",
              description: "Sorting mode for threads.",
              knownValues: ["oldest", "newest", "most-likes", "random"]
            },
            prioritizeFollowedUsers: {
              type: "boolean",
              description: "Show followed users at the top of all replies."
            }
          }
        },
        interestsPref: {
          type: "object",
          required: ["tags"],
          properties: {
            tags: {
              type: "array",
              maxLength: 100,
              items: {
                type: "string",
                maxLength: 640,
                maxGraphemes: 64
              },
              description: "A list of tags which describe the account owner's interests gathered during onboarding."
            }
          }
        },
        mutedWordTarget: {
          type: "string",
          knownValues: ["content", "tag"],
          maxLength: 640,
          maxGraphemes: 64
        },
        mutedWord: {
          type: "object",
          description: "A word that the account owner has muted.",
          required: ["value", "targets"],
          properties: {
            value: {
              type: "string",
              description: "The muted word itself.",
              maxLength: 1e4,
              maxGraphemes: 1e3
            },
            targets: {
              type: "array",
              description: "The intended targets of the muted word.",
              items: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#mutedWordTarget"
              }
            }
          }
        },
        mutedWordsPref: {
          type: "object",
          required: ["items"],
          properties: {
            items: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#mutedWord"
              },
              description: "A list of words the account owner has muted."
            }
          }
        },
        hiddenPostsPref: {
          type: "object",
          required: ["items"],
          properties: {
            items: {
              type: "array",
              items: {
                type: "string",
                format: "at-uri"
              },
              description: "A list of URIs of posts the account owner has hidden."
            }
          }
        },
        labelersPref: {
          type: "object",
          required: ["labelers"],
          properties: {
            labelers: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.actor.defs#labelerPrefItem"
              }
            }
          }
        },
        labelerPrefItem: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        }
      }
    },
    AppBskyActorGetPreferences: {
      lexicon: 1,
      id: "app.bsky.actor.getPreferences",
      defs: {
        main: {
          type: "query",
          description: "Get private preferences attached to the current account. Expected use is synchronization between multiple devices, and import/export during account migration. Requires auth.",
          parameters: {
            type: "params",
            properties: {}
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["preferences"],
              properties: {
                preferences: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#preferences"
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorGetProfile: {
      lexicon: 1,
      id: "app.bsky.actor.getProfile",
      defs: {
        main: {
          type: "query",
          description: "Get detailed profile view of an actor. Does not require auth, but contains relevant metadata with auth.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier",
                description: "Handle or DID of account to fetch profile of."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewDetailed"
            }
          }
        }
      }
    },
    AppBskyActorGetProfiles: {
      lexicon: 1,
      id: "app.bsky.actor.getProfiles",
      defs: {
        main: {
          type: "query",
          description: "Get detailed profile views of multiple actors.",
          parameters: {
            type: "params",
            required: ["actors"],
            properties: {
              actors: {
                type: "array",
                items: {
                  type: "string",
                  format: "at-identifier"
                },
                maxLength: 25
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["profiles"],
              properties: {
                profiles: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileViewDetailed"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorGetSuggestions: {
      lexicon: 1,
      id: "app.bsky.actor.getSuggestions",
      defs: {
        main: {
          type: "query",
          description: "Get a list of suggested actors. Expected use is discovery of accounts to follow during new account onboarding.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actors"],
              properties: {
                cursor: {
                  type: "string"
                },
                actors: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorProfile: {
      lexicon: 1,
      id: "app.bsky.actor.profile",
      defs: {
        main: {
          type: "record",
          description: "A declaration of a Bluesky account profile.",
          key: "literal:self",
          record: {
            type: "object",
            properties: {
              displayName: {
                type: "string",
                maxGraphemes: 64,
                maxLength: 640
              },
              description: {
                type: "string",
                description: "Free-form profile description text.",
                maxGraphemes: 256,
                maxLength: 2560
              },
              avatar: {
                type: "blob",
                description: "Small image to be displayed next to posts from account. AKA, 'profile picture'",
                accept: ["image/png", "image/jpeg"],
                maxSize: 1e6
              },
              banner: {
                type: "blob",
                description: "Larger horizontal image to display behind profile view.",
                accept: ["image/png", "image/jpeg"],
                maxSize: 1e6
              },
              labels: {
                type: "union",
                description: "Self-label values, specific to the Bluesky application, on the overall account.",
                refs: ["lex:com.atproto.label.defs#selfLabels"]
              }
            }
          }
        }
      }
    },
    AppBskyActorPutPreferences: {
      lexicon: 1,
      id: "app.bsky.actor.putPreferences",
      defs: {
        main: {
          type: "procedure",
          description: "Set the private preferences attached to the account.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["preferences"],
              properties: {
                preferences: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#preferences"
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorSearchActors: {
      lexicon: 1,
      id: "app.bsky.actor.searchActors",
      defs: {
        main: {
          type: "query",
          description: "Find actors (profiles) matching search criteria. Does not require auth.",
          parameters: {
            type: "params",
            properties: {
              term: {
                type: "string",
                description: "DEPRECATED: use 'q' instead."
              },
              q: {
                type: "string",
                description: "Search query string. Syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 25
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actors"],
              properties: {
                cursor: {
                  type: "string"
                },
                actors: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyActorSearchActorsTypeahead: {
      lexicon: 1,
      id: "app.bsky.actor.searchActorsTypeahead",
      defs: {
        main: {
          type: "query",
          description: "Find actor suggestions for a prefix search term. Expected use is for auto-completion during text field entry. Does not require auth.",
          parameters: {
            type: "params",
            properties: {
              term: {
                type: "string",
                description: "DEPRECATED: use 'q' instead."
              },
              q: {
                type: "string",
                description: "Search query prefix; not a full query string."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 10
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actors"],
              properties: {
                actors: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileViewBasic"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyEmbedExternal: {
      lexicon: 1,
      id: "app.bsky.embed.external",
      defs: {
        main: {
          type: "object",
          description: "A representation of some externally linked content (eg, a URL and 'card'), embedded in a Bluesky record (eg, a post).",
          required: ["external"],
          properties: {
            external: {
              type: "ref",
              ref: "lex:app.bsky.embed.external#external"
            }
          }
        },
        external: {
          type: "object",
          required: ["uri", "title", "description"],
          properties: {
            uri: {
              type: "string",
              format: "uri"
            },
            title: {
              type: "string"
            },
            description: {
              type: "string"
            },
            thumb: {
              type: "blob",
              accept: ["image/*"],
              maxSize: 1e6
            }
          }
        },
        view: {
          type: "object",
          required: ["external"],
          properties: {
            external: {
              type: "ref",
              ref: "lex:app.bsky.embed.external#viewExternal"
            }
          }
        },
        viewExternal: {
          type: "object",
          required: ["uri", "title", "description"],
          properties: {
            uri: {
              type: "string",
              format: "uri"
            },
            title: {
              type: "string"
            },
            description: {
              type: "string"
            },
            thumb: {
              type: "string",
              format: "uri"
            }
          }
        }
      }
    },
    AppBskyEmbedImages: {
      lexicon: 1,
      id: "app.bsky.embed.images",
      description: "A set of images embedded in a Bluesky record (eg, a post).",
      defs: {
        main: {
          type: "object",
          required: ["images"],
          properties: {
            images: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.embed.images#image"
              },
              maxLength: 4
            }
          }
        },
        image: {
          type: "object",
          required: ["image", "alt"],
          properties: {
            image: {
              type: "blob",
              accept: ["image/*"],
              maxSize: 1e6
            },
            alt: {
              type: "string",
              description: "Alt text description of the image, for accessibility."
            },
            aspectRatio: {
              type: "ref",
              ref: "lex:app.bsky.embed.images#aspectRatio"
            }
          }
        },
        aspectRatio: {
          type: "object",
          description: "width:height represents an aspect ratio. It may be approximate, and may not correspond to absolute dimensions in any given unit.",
          required: ["width", "height"],
          properties: {
            width: {
              type: "integer",
              minimum: 1
            },
            height: {
              type: "integer",
              minimum: 1
            }
          }
        },
        view: {
          type: "object",
          required: ["images"],
          properties: {
            images: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.embed.images#viewImage"
              },
              maxLength: 4
            }
          }
        },
        viewImage: {
          type: "object",
          required: ["thumb", "fullsize", "alt"],
          properties: {
            thumb: {
              type: "string",
              format: "uri",
              description: "Fully-qualified URL where a thumbnail of the image can be fetched. For example, CDN location provided by the App View."
            },
            fullsize: {
              type: "string",
              format: "uri",
              description: "Fully-qualified URL where a large version of the image can be fetched. May or may not be the exact original blob. For example, CDN location provided by the App View."
            },
            alt: {
              type: "string",
              description: "Alt text description of the image, for accessibility."
            },
            aspectRatio: {
              type: "ref",
              ref: "lex:app.bsky.embed.images#aspectRatio"
            }
          }
        }
      }
    },
    AppBskyEmbedRecord: {
      lexicon: 1,
      id: "app.bsky.embed.record",
      description: "A representation of a record embedded in a Bluesky record (eg, a post). For example, a quote-post, or sharing a feed generator record.",
      defs: {
        main: {
          type: "object",
          required: ["record"],
          properties: {
            record: {
              type: "ref",
              ref: "lex:com.atproto.repo.strongRef"
            }
          }
        },
        view: {
          type: "object",
          required: ["record"],
          properties: {
            record: {
              type: "union",
              refs: [
                "lex:app.bsky.embed.record#viewRecord",
                "lex:app.bsky.embed.record#viewNotFound",
                "lex:app.bsky.embed.record#viewBlocked",
                "lex:app.bsky.feed.defs#generatorView",
                "lex:app.bsky.graph.defs#listView",
                "lex:app.bsky.labeler.defs#labelerView"
              ]
            }
          }
        },
        viewRecord: {
          type: "object",
          required: ["uri", "cid", "author", "value", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            author: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic"
            },
            value: {
              type: "unknown",
              description: "The record data itself."
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            replyCount: {
              type: "integer"
            },
            repostCount: {
              type: "integer"
            },
            likeCount: {
              type: "integer"
            },
            embeds: {
              type: "array",
              items: {
                type: "union",
                refs: [
                  "lex:app.bsky.embed.images#view",
                  "lex:app.bsky.embed.external#view",
                  "lex:app.bsky.embed.record#view",
                  "lex:app.bsky.embed.recordWithMedia#view"
                ]
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        viewNotFound: {
          type: "object",
          required: ["uri", "notFound"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            notFound: {
              type: "boolean",
              const: !0
            }
          }
        },
        viewBlocked: {
          type: "object",
          required: ["uri", "blocked", "author"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            blocked: {
              type: "boolean",
              const: !0
            },
            author: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#blockedAuthor"
            }
          }
        }
      }
    },
    AppBskyEmbedRecordWithMedia: {
      lexicon: 1,
      id: "app.bsky.embed.recordWithMedia",
      description: "A representation of a record embedded in a Bluesky record (eg, a post), alongside other compatible embeds. For example, a quote post and image, or a quote post and external URL card.",
      defs: {
        main: {
          type: "object",
          required: ["record", "media"],
          properties: {
            record: {
              type: "ref",
              ref: "lex:app.bsky.embed.record"
            },
            media: {
              type: "union",
              refs: ["lex:app.bsky.embed.images", "lex:app.bsky.embed.external"]
            }
          }
        },
        view: {
          type: "object",
          required: ["record", "media"],
          properties: {
            record: {
              type: "ref",
              ref: "lex:app.bsky.embed.record#view"
            },
            media: {
              type: "union",
              refs: [
                "lex:app.bsky.embed.images#view",
                "lex:app.bsky.embed.external#view"
              ]
            }
          }
        }
      }
    },
    AppBskyFeedDefs: {
      lexicon: 1,
      id: "app.bsky.feed.defs",
      defs: {
        postView: {
          type: "object",
          required: ["uri", "cid", "author", "record", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            author: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic"
            },
            record: {
              type: "unknown"
            },
            embed: {
              type: "union",
              refs: [
                "lex:app.bsky.embed.images#view",
                "lex:app.bsky.embed.external#view",
                "lex:app.bsky.embed.record#view",
                "lex:app.bsky.embed.recordWithMedia#view"
              ]
            },
            replyCount: {
              type: "integer"
            },
            repostCount: {
              type: "integer"
            },
            likeCount: {
              type: "integer"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#viewerState"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            threadgate: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#threadgateView"
            }
          }
        },
        viewerState: {
          type: "object",
          description: "Metadata about the requesting account's relationship with the subject content. Only has meaningful content for authed requests.",
          properties: {
            repost: {
              type: "string",
              format: "at-uri"
            },
            like: {
              type: "string",
              format: "at-uri"
            },
            replyDisabled: {
              type: "boolean"
            }
          }
        },
        feedViewPost: {
          type: "object",
          required: ["post"],
          properties: {
            post: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#postView"
            },
            reply: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#replyRef"
            },
            reason: {
              type: "union",
              refs: ["lex:app.bsky.feed.defs#reasonRepost"]
            },
            feedContext: {
              type: "string",
              description: "Context provided by feed generator that may be passed back alongside interactions.",
              maxLength: 2e3
            }
          }
        },
        replyRef: {
          type: "object",
          required: ["root", "parent"],
          properties: {
            root: {
              type: "union",
              refs: [
                "lex:app.bsky.feed.defs#postView",
                "lex:app.bsky.feed.defs#notFoundPost",
                "lex:app.bsky.feed.defs#blockedPost"
              ]
            },
            parent: {
              type: "union",
              refs: [
                "lex:app.bsky.feed.defs#postView",
                "lex:app.bsky.feed.defs#notFoundPost",
                "lex:app.bsky.feed.defs#blockedPost"
              ]
            }
          }
        },
        reasonRepost: {
          type: "object",
          required: ["by", "indexedAt"],
          properties: {
            by: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileViewBasic"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        threadViewPost: {
          type: "object",
          required: ["post"],
          properties: {
            post: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#postView"
            },
            parent: {
              type: "union",
              refs: [
                "lex:app.bsky.feed.defs#threadViewPost",
                "lex:app.bsky.feed.defs#notFoundPost",
                "lex:app.bsky.feed.defs#blockedPost"
              ]
            },
            replies: {
              type: "array",
              items: {
                type: "union",
                refs: [
                  "lex:app.bsky.feed.defs#threadViewPost",
                  "lex:app.bsky.feed.defs#notFoundPost",
                  "lex:app.bsky.feed.defs#blockedPost"
                ]
              }
            }
          }
        },
        notFoundPost: {
          type: "object",
          required: ["uri", "notFound"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            notFound: {
              type: "boolean",
              const: !0
            }
          }
        },
        blockedPost: {
          type: "object",
          required: ["uri", "blocked", "author"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            blocked: {
              type: "boolean",
              const: !0
            },
            author: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#blockedAuthor"
            }
          }
        },
        blockedAuthor: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#viewerState"
            }
          }
        },
        generatorView: {
          type: "object",
          required: ["uri", "cid", "did", "creator", "displayName", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            did: {
              type: "string",
              format: "did"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            },
            displayName: {
              type: "string"
            },
            description: {
              type: "string",
              maxGraphemes: 300,
              maxLength: 3e3
            },
            descriptionFacets: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.richtext.facet"
              }
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            likeCount: {
              type: "integer",
              minimum: 0
            },
            acceptsInteractions: {
              type: "boolean"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.feed.defs#generatorViewerState"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        generatorViewerState: {
          type: "object",
          properties: {
            like: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        skeletonFeedPost: {
          type: "object",
          required: ["post"],
          properties: {
            post: {
              type: "string",
              format: "at-uri"
            },
            reason: {
              type: "union",
              refs: ["lex:app.bsky.feed.defs#skeletonReasonRepost"]
            },
            feedContext: {
              type: "string",
              description: "Context that will be passed through to client and may be passed to feed generator back alongside interactions.",
              maxLength: 2e3
            }
          }
        },
        skeletonReasonRepost: {
          type: "object",
          required: ["repost"],
          properties: {
            repost: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        threadgateView: {
          type: "object",
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            record: {
              type: "unknown"
            },
            lists: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.graph.defs#listViewBasic"
              }
            }
          }
        },
        interaction: {
          type: "object",
          properties: {
            item: {
              type: "string",
              format: "at-uri"
            },
            event: {
              type: "string",
              knownValues: [
                "app.bsky.feed.defs#requestLess",
                "app.bsky.feed.defs#requestMore",
                "app.bsky.feed.defs#clickthroughItem",
                "app.bsky.feed.defs#clickthroughAuthor",
                "app.bsky.feed.defs#clickthroughReposter",
                "app.bsky.feed.defs#clickthroughEmbed",
                "app.bsky.feed.defs#interactionSeen",
                "app.bsky.feed.defs#interactionLike",
                "app.bsky.feed.defs#interactionRepost",
                "app.bsky.feed.defs#interactionReply",
                "app.bsky.feed.defs#interactionQuote",
                "app.bsky.feed.defs#interactionShare"
              ]
            },
            feedContext: {
              type: "string",
              description: "Context on a feed item that was orginally supplied by the feed generator on getFeedSkeleton.",
              maxLength: 2e3
            }
          }
        },
        requestLess: {
          type: "token",
          description: "Request that less content like the given feed item be shown in the feed"
        },
        requestMore: {
          type: "token",
          description: "Request that more content like the given feed item be shown in the feed"
        },
        clickthroughItem: {
          type: "token",
          description: "User clicked through to the feed item"
        },
        clickthroughAuthor: {
          type: "token",
          description: "User clicked through to the author of the feed item"
        },
        clickthroughReposter: {
          type: "token",
          description: "User clicked through to the reposter of the feed item"
        },
        clickthroughEmbed: {
          type: "token",
          description: "User clicked through to the embedded content of the feed item"
        },
        interactionSeen: {
          type: "token",
          description: "Feed item was seen by user"
        },
        interactionLike: {
          type: "token",
          description: "User liked the feed item"
        },
        interactionRepost: {
          type: "token",
          description: "User reposted the feed item"
        },
        interactionReply: {
          type: "token",
          description: "User replied to the feed item"
        },
        interactionQuote: {
          type: "token",
          description: "User quoted the feed item"
        },
        interactionShare: {
          type: "token",
          description: "User shared the feed item"
        }
      }
    },
    AppBskyFeedDescribeFeedGenerator: {
      lexicon: 1,
      id: "app.bsky.feed.describeFeedGenerator",
      defs: {
        main: {
          type: "query",
          description: "Get information about a feed generator, including policies and offered feed URIs. Does not require auth; implemented by Feed Generator services (not App View).",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["did", "feeds"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                feeds: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.describeFeedGenerator#feed"
                  }
                },
                links: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.describeFeedGenerator#links"
                }
              }
            }
          }
        },
        feed: {
          type: "object",
          required: ["uri"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        links: {
          type: "object",
          properties: {
            privacyPolicy: {
              type: "string"
            },
            termsOfService: {
              type: "string"
            }
          }
        }
      }
    },
    AppBskyFeedGenerator: {
      lexicon: 1,
      id: "app.bsky.feed.generator",
      defs: {
        main: {
          type: "record",
          description: "Record declaring of the existence of a feed generator, and containing metadata about it. The record can exist in any repository.",
          key: "any",
          record: {
            type: "object",
            required: ["did", "displayName", "createdAt"],
            properties: {
              did: {
                type: "string",
                format: "did"
              },
              displayName: {
                type: "string",
                maxGraphemes: 24,
                maxLength: 240
              },
              description: {
                type: "string",
                maxGraphemes: 300,
                maxLength: 3e3
              },
              descriptionFacets: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet"
                }
              },
              avatar: {
                type: "blob",
                accept: ["image/png", "image/jpeg"],
                maxSize: 1e6
              },
              acceptsInteractions: {
                type: "boolean",
                description: "Declaration that a feed accepts feedback interactions from a client through app.bsky.feed.sendInteractions"
              },
              labels: {
                type: "union",
                description: "Self-label values",
                refs: ["lex:com.atproto.label.defs#selfLabels"]
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetActorFeeds: {
      lexicon: 1,
      id: "app.bsky.feed.getActorFeeds",
      defs: {
        main: {
          type: "query",
          description: "Get a list of feeds (feed generator records) created by the actor (in the actor's repo).",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feeds"],
              properties: {
                cursor: {
                  type: "string"
                },
                feeds: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#generatorView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetActorLikes: {
      lexicon: 1,
      id: "app.bsky.feed.getActorLikes",
      defs: {
        main: {
          type: "query",
          description: "Get a list of posts liked by an actor. Does not require auth.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#feedViewPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "BlockedActor"
            },
            {
              name: "BlockedByActor"
            }
          ]
        }
      }
    },
    AppBskyFeedGetAuthorFeed: {
      lexicon: 1,
      id: "app.bsky.feed.getAuthorFeed",
      defs: {
        main: {
          type: "query",
          description: "Get a view of an actor's 'author feed' (post and reposts by the author). Does not require auth.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              },
              filter: {
                type: "string",
                description: "Combinations of post/repost types to include in response.",
                knownValues: [
                  "posts_with_replies",
                  "posts_no_replies",
                  "posts_with_media",
                  "posts_and_author_threads"
                ],
                default: "posts_with_replies"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#feedViewPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "BlockedActor"
            },
            {
              name: "BlockedByActor"
            }
          ]
        }
      }
    },
    AppBskyFeedGetFeed: {
      lexicon: 1,
      id: "app.bsky.feed.getFeed",
      defs: {
        main: {
          type: "query",
          description: "Get a hydrated feed from an actor's selected feed generator. Implemented by App View.",
          parameters: {
            type: "params",
            required: ["feed"],
            properties: {
              feed: {
                type: "string",
                format: "at-uri"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#feedViewPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "UnknownFeed"
            }
          ]
        }
      }
    },
    AppBskyFeedGetFeedGenerator: {
      lexicon: 1,
      id: "app.bsky.feed.getFeedGenerator",
      defs: {
        main: {
          type: "query",
          description: "Get information about a feed generator. Implemented by AppView.",
          parameters: {
            type: "params",
            required: ["feed"],
            properties: {
              feed: {
                type: "string",
                format: "at-uri",
                description: "AT-URI of the feed generator record."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["view", "isOnline", "isValid"],
              properties: {
                view: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#generatorView"
                },
                isOnline: {
                  type: "boolean",
                  description: "Indicates whether the feed generator service has been online recently, or else seems to be inactive."
                },
                isValid: {
                  type: "boolean",
                  description: "Indicates whether the feed generator service is compatible with the record declaration."
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetFeedGenerators: {
      lexicon: 1,
      id: "app.bsky.feed.getFeedGenerators",
      defs: {
        main: {
          type: "query",
          description: "Get information about a list of feed generators.",
          parameters: {
            type: "params",
            required: ["feeds"],
            properties: {
              feeds: {
                type: "array",
                items: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feeds"],
              properties: {
                feeds: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#generatorView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetFeedSkeleton: {
      lexicon: 1,
      id: "app.bsky.feed.getFeedSkeleton",
      defs: {
        main: {
          type: "query",
          description: "Get a skeleton of a feed provided by a feed generator. Auth is optional, depending on provider requirements, and provides the DID of the requester. Implemented by Feed Generator Service.",
          parameters: {
            type: "params",
            required: ["feed"],
            properties: {
              feed: {
                type: "string",
                format: "at-uri",
                description: "Reference to feed generator record describing the specific feed being requested."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#skeletonFeedPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "UnknownFeed"
            }
          ]
        }
      }
    },
    AppBskyFeedGetLikes: {
      lexicon: 1,
      id: "app.bsky.feed.getLikes",
      defs: {
        main: {
          type: "query",
          description: "Get like records which reference a subject (by AT-URI and CID).",
          parameters: {
            type: "params",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri",
                description: "AT-URI of the subject (eg, a post record)."
              },
              cid: {
                type: "string",
                format: "cid",
                description: "CID of the subject record (aka, specific version of record), to filter likes."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["uri", "likes"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                cursor: {
                  type: "string"
                },
                likes: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.getLikes#like"
                  }
                }
              }
            }
          }
        },
        like: {
          type: "object",
          required: ["indexedAt", "createdAt", "actor"],
          properties: {
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            actor: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            }
          }
        }
      }
    },
    AppBskyFeedGetListFeed: {
      lexicon: 1,
      id: "app.bsky.feed.getListFeed",
      defs: {
        main: {
          type: "query",
          description: "Get a feed of recent posts from a list (posts and reposts from any actors on the list). Does not require auth.",
          parameters: {
            type: "params",
            required: ["list"],
            properties: {
              list: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to the list record."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#feedViewPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "UnknownList"
            }
          ]
        }
      }
    },
    AppBskyFeedGetPostThread: {
      lexicon: 1,
      id: "app.bsky.feed.getPostThread",
      defs: {
        main: {
          type: "query",
          description: "Get posts in a thread. Does not require auth, but additional metadata and filtering will be applied for authed requests.",
          parameters: {
            type: "params",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to post record."
              },
              depth: {
                type: "integer",
                description: "How many levels of reply depth should be included in response.",
                default: 6,
                minimum: 0,
                maximum: 1e3
              },
              parentHeight: {
                type: "integer",
                description: "How many levels of parent (and grandparent, etc) post to include.",
                default: 80,
                minimum: 0,
                maximum: 1e3
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["thread"],
              properties: {
                thread: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#threadViewPost",
                    "lex:app.bsky.feed.defs#notFoundPost",
                    "lex:app.bsky.feed.defs#blockedPost"
                  ]
                }
              }
            }
          },
          errors: [
            {
              name: "NotFound"
            }
          ]
        }
      }
    },
    AppBskyFeedGetPosts: {
      lexicon: 1,
      id: "app.bsky.feed.getPosts",
      defs: {
        main: {
          type: "query",
          description: "Gets post views for a specified list of posts (by AT-URI). This is sometimes referred to as 'hydrating' a 'feed skeleton'.",
          parameters: {
            type: "params",
            required: ["uris"],
            properties: {
              uris: {
                type: "array",
                description: "List of post AT-URIs to return hydrated views for.",
                items: {
                  type: "string",
                  format: "at-uri"
                },
                maxLength: 25
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["posts"],
              properties: {
                posts: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#postView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetRepostedBy: {
      lexicon: 1,
      id: "app.bsky.feed.getRepostedBy",
      defs: {
        main: {
          type: "query",
          description: "Get a list of reposts for a given post.",
          parameters: {
            type: "params",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) of post record"
              },
              cid: {
                type: "string",
                format: "cid",
                description: "If supplied, filters to reposts of specific version (by CID) of the post record."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["uri", "repostedBy"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                cursor: {
                  type: "string"
                },
                repostedBy: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetSuggestedFeeds: {
      lexicon: 1,
      id: "app.bsky.feed.getSuggestedFeeds",
      defs: {
        main: {
          type: "query",
          description: "Get a list of suggested feeds (feed generators) for the requesting account.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feeds"],
              properties: {
                cursor: {
                  type: "string"
                },
                feeds: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#generatorView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedGetTimeline: {
      lexicon: 1,
      id: "app.bsky.feed.getTimeline",
      defs: {
        main: {
          type: "query",
          description: "Get a view of the requesting account's home timeline. This is expected to be some form of reverse-chronological feed.",
          parameters: {
            type: "params",
            properties: {
              algorithm: {
                type: "string",
                description: "Variant 'algorithm' for timeline. Implementation-specific. NOTE: most feed flexibility has been moved to feed generator mechanism."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feed"],
              properties: {
                cursor: {
                  type: "string"
                },
                feed: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#feedViewPost"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyFeedLike: {
      lexicon: 1,
      id: "app.bsky.feed.like",
      defs: {
        main: {
          type: "record",
          description: "Record declaring a 'like' of a piece of subject content.",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "createdAt"],
            properties: {
              subject: {
                type: "ref",
                ref: "lex:com.atproto.repo.strongRef"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyFeedPost: {
      lexicon: 1,
      id: "app.bsky.feed.post",
      defs: {
        main: {
          type: "record",
          description: "Record containing a Bluesky post.",
          key: "tid",
          record: {
            type: "object",
            required: ["text", "createdAt"],
            properties: {
              text: {
                type: "string",
                maxLength: 3e3,
                maxGraphemes: 300,
                description: "The primary post content. May be an empty string, if there are embeds."
              },
              entities: {
                type: "array",
                description: "DEPRECATED: replaced by app.bsky.richtext.facet.",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.post#entity"
                }
              },
              facets: {
                type: "array",
                description: "Annotations of text (mentions, URLs, hashtags, etc)",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet"
                }
              },
              reply: {
                type: "ref",
                ref: "lex:app.bsky.feed.post#replyRef"
              },
              embed: {
                type: "union",
                refs: [
                  "lex:app.bsky.embed.images",
                  "lex:app.bsky.embed.external",
                  "lex:app.bsky.embed.record",
                  "lex:app.bsky.embed.recordWithMedia"
                ]
              },
              langs: {
                type: "array",
                description: "Indicates human language of post primary text content.",
                maxLength: 3,
                items: {
                  type: "string",
                  format: "language"
                }
              },
              labels: {
                type: "union",
                description: "Self-label values for this post. Effectively content warnings.",
                refs: ["lex:com.atproto.label.defs#selfLabels"]
              },
              tags: {
                type: "array",
                description: "Additional hashtags, in addition to any included in post text and facets.",
                maxLength: 8,
                items: {
                  type: "string",
                  maxLength: 640,
                  maxGraphemes: 64
                }
              },
              createdAt: {
                type: "string",
                format: "datetime",
                description: "Client-declared timestamp when this post was originally created."
              }
            }
          }
        },
        replyRef: {
          type: "object",
          required: ["root", "parent"],
          properties: {
            root: {
              type: "ref",
              ref: "lex:com.atproto.repo.strongRef"
            },
            parent: {
              type: "ref",
              ref: "lex:com.atproto.repo.strongRef"
            }
          }
        },
        entity: {
          type: "object",
          description: "Deprecated: use facets instead.",
          required: ["index", "type", "value"],
          properties: {
            index: {
              type: "ref",
              ref: "lex:app.bsky.feed.post#textSlice"
            },
            type: {
              type: "string",
              description: "Expected values are 'mention' and 'link'."
            },
            value: {
              type: "string"
            }
          }
        },
        textSlice: {
          type: "object",
          description: "Deprecated. Use app.bsky.richtext instead -- A text segment. Start is inclusive, end is exclusive. Indices are for utf16-encoded strings.",
          required: ["start", "end"],
          properties: {
            start: {
              type: "integer",
              minimum: 0
            },
            end: {
              type: "integer",
              minimum: 0
            }
          }
        }
      }
    },
    AppBskyFeedRepost: {
      lexicon: 1,
      id: "app.bsky.feed.repost",
      defs: {
        main: {
          description: "Record representing a 'repost' of an existing Bluesky post.",
          type: "record",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "createdAt"],
            properties: {
              subject: {
                type: "ref",
                ref: "lex:com.atproto.repo.strongRef"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyFeedSearchPosts: {
      lexicon: 1,
      id: "app.bsky.feed.searchPosts",
      defs: {
        main: {
          type: "query",
          description: "Find posts matching search criteria, returning views of those posts.",
          parameters: {
            type: "params",
            required: ["q"],
            properties: {
              q: {
                type: "string",
                description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
              },
              sort: {
                type: "string",
                knownValues: ["top", "latest"],
                default: "latest",
                description: "Specifies the ranking order of results."
              },
              since: {
                type: "string",
                description: "Filter results for posts after the indicated datetime (inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYYY-MM-DD)."
              },
              until: {
                type: "string",
                description: "Filter results for posts before the indicated datetime (not inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYY-MM-DD)."
              },
              mentions: {
                type: "string",
                format: "at-identifier",
                description: "Filter to posts which mention the given account. Handles are resolved to DID before query-time. Only matches rich-text facet mentions."
              },
              author: {
                type: "string",
                format: "at-identifier",
                description: "Filter to posts by the given account. Handles are resolved to DID before query-time."
              },
              lang: {
                type: "string",
                format: "language",
                description: "Filter to posts in the given language. Expected to be based on post language field, though server may override language detection."
              },
              domain: {
                type: "string",
                description: "Filter to posts with URLs (facet links or embeds) linking to the given domain (hostname). Server may apply hostname normalization."
              },
              url: {
                type: "string",
                format: "uri",
                description: "Filter to posts with links (facet links or embeds) pointing to this URL. Server may apply URL normalization or fuzzy matching."
              },
              tag: {
                type: "array",
                items: {
                  type: "string",
                  maxLength: 640,
                  maxGraphemes: 64
                },
                description: "Filter to posts with the given tag (hashtag), based on rich-text facet or tag field. Do not include the hash (#) prefix. Multiple tags can be specified, with 'AND' matching."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 25
              },
              cursor: {
                type: "string",
                description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["posts"],
              properties: {
                cursor: {
                  type: "string"
                },
                hitsTotal: {
                  type: "integer",
                  description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                },
                posts: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#postView"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "BadQueryString"
            }
          ]
        }
      }
    },
    AppBskyFeedSendInteractions: {
      lexicon: 1,
      id: "app.bsky.feed.sendInteractions",
      defs: {
        main: {
          type: "procedure",
          description: "Send information about interactions with feed items back to the feed generator that served them.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["interactions"],
              properties: {
                interactions: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#interaction"
                  }
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              properties: {}
            }
          }
        }
      }
    },
    AppBskyFeedThreadgate: {
      lexicon: 1,
      id: "app.bsky.feed.threadgate",
      defs: {
        main: {
          type: "record",
          key: "tid",
          description: "Record defining interaction gating rules for a thread (aka, reply controls). The record key (rkey) of the threadgate record must match the record key of the thread's root post, and that record must be in the same repository..",
          record: {
            type: "object",
            required: ["post", "createdAt"],
            properties: {
              post: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to the post record."
              },
              allow: {
                type: "array",
                maxLength: 5,
                items: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.threadgate#mentionRule",
                    "lex:app.bsky.feed.threadgate#followingRule",
                    "lex:app.bsky.feed.threadgate#listRule"
                  ]
                }
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        },
        mentionRule: {
          type: "object",
          description: "Allow replies from actors mentioned in your post.",
          properties: {}
        },
        followingRule: {
          type: "object",
          description: "Allow replies from actors you follow.",
          properties: {}
        },
        listRule: {
          type: "object",
          description: "Allow replies from actors on a list.",
          required: ["list"],
          properties: {
            list: {
              type: "string",
              format: "at-uri"
            }
          }
        }
      }
    },
    AppBskyGraphBlock: {
      lexicon: 1,
      id: "app.bsky.graph.block",
      defs: {
        main: {
          type: "record",
          description: "Record declaring a 'block' relationship against another account. NOTE: blocks are public in Bluesky; see blog posts for details.",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "createdAt"],
            properties: {
              subject: {
                type: "string",
                format: "did",
                description: "DID of the account to be blocked."
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyGraphDefs: {
      lexicon: 1,
      id: "app.bsky.graph.defs",
      defs: {
        listViewBasic: {
          type: "object",
          required: ["uri", "cid", "name", "purpose"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            name: {
              type: "string",
              maxLength: 64,
              minLength: 1
            },
            purpose: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listPurpose"
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listViewerState"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        listView: {
          type: "object",
          required: ["uri", "cid", "creator", "name", "purpose", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            },
            name: {
              type: "string",
              maxLength: 64,
              minLength: 1
            },
            purpose: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listPurpose"
            },
            description: {
              type: "string",
              maxGraphemes: 300,
              maxLength: 3e3
            },
            descriptionFacets: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:app.bsky.richtext.facet"
              }
            },
            avatar: {
              type: "string",
              format: "uri"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.graph.defs#listViewerState"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        listItemView: {
          type: "object",
          required: ["uri", "subject"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            subject: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            }
          }
        },
        listPurpose: {
          type: "string",
          knownValues: [
            "app.bsky.graph.defs#modlist",
            "app.bsky.graph.defs#curatelist"
          ]
        },
        modlist: {
          type: "token",
          description: "A list of actors to apply an aggregate moderation action (mute/block) on."
        },
        curatelist: {
          type: "token",
          description: "A list of actors used for curation purposes such as list feeds or interaction gating."
        },
        listViewerState: {
          type: "object",
          properties: {
            muted: {
              type: "boolean"
            },
            blocked: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        notFoundActor: {
          type: "object",
          description: "indicates that a handle or DID could not be resolved",
          required: ["actor", "notFound"],
          properties: {
            actor: {
              type: "string",
              format: "at-identifier"
            },
            notFound: {
              type: "boolean",
              const: !0
            }
          }
        },
        relationship: {
          type: "object",
          description: "lists the bi-directional graph relationships between one actor (not indicated in the object), and the target actors (the DID included in the object)",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            following: {
              type: "string",
              format: "at-uri",
              description: "if the actor follows this DID, this is the AT-URI of the follow record"
            },
            followedBy: {
              type: "string",
              format: "at-uri",
              description: "if the actor is followed by this DID, contains the AT-URI of the follow record"
            }
          }
        }
      }
    },
    AppBskyGraphFollow: {
      lexicon: 1,
      id: "app.bsky.graph.follow",
      defs: {
        main: {
          type: "record",
          description: "Record declaring a social 'follow' relationship of another account. Duplicate follows will be ignored by the AppView.",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "createdAt"],
            properties: {
              subject: {
                type: "string",
                format: "did"
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetBlocks: {
      lexicon: 1,
      id: "app.bsky.graph.getBlocks",
      defs: {
        main: {
          type: "query",
          description: "Enumerates which accounts the requesting account is currently blocking. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["blocks"],
              properties: {
                cursor: {
                  type: "string"
                },
                blocks: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetFollowers: {
      lexicon: 1,
      id: "app.bsky.graph.getFollowers",
      defs: {
        main: {
          type: "query",
          description: "Enumerates accounts which follow a specified account (actor).",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject", "followers"],
              properties: {
                subject: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                cursor: {
                  type: "string"
                },
                followers: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetFollows: {
      lexicon: 1,
      id: "app.bsky.graph.getFollows",
      defs: {
        main: {
          type: "query",
          description: "Enumerates accounts which a specified account (actor) follows.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject", "follows"],
              properties: {
                subject: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                cursor: {
                  type: "string"
                },
                follows: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetList: {
      lexicon: 1,
      id: "app.bsky.graph.getList",
      defs: {
        main: {
          type: "query",
          description: "Gets a 'view' (with additional context) of a specified list.",
          parameters: {
            type: "params",
            required: ["list"],
            properties: {
              list: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) of the list record to hydrate."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["list", "items"],
              properties: {
                cursor: {
                  type: "string"
                },
                list: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listView"
                },
                items: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listItemView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetListBlocks: {
      lexicon: 1,
      id: "app.bsky.graph.getListBlocks",
      defs: {
        main: {
          type: "query",
          description: "Get mod lists that the requesting account (actor) is blocking. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["lists"],
              properties: {
                cursor: {
                  type: "string"
                },
                lists: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetListMutes: {
      lexicon: 1,
      id: "app.bsky.graph.getListMutes",
      defs: {
        main: {
          type: "query",
          description: "Enumerates mod lists that the requesting account (actor) currently has muted. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["lists"],
              properties: {
                cursor: {
                  type: "string"
                },
                lists: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetLists: {
      lexicon: 1,
      id: "app.bsky.graph.getLists",
      defs: {
        main: {
          type: "query",
          description: "Enumerates the lists created by a specified account (actor).",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier",
                description: "The account (actor) to enumerate lists from."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["lists"],
              properties: {
                cursor: {
                  type: "string"
                },
                lists: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetMutes: {
      lexicon: 1,
      id: "app.bsky.graph.getMutes",
      defs: {
        main: {
          type: "query",
          description: "Enumerates accounts that the requesting account (actor) currently has muted. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["mutes"],
              properties: {
                cursor: {
                  type: "string"
                },
                mutes: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphGetRelationships: {
      lexicon: 1,
      id: "app.bsky.graph.getRelationships",
      defs: {
        main: {
          type: "query",
          description: "Enumerates public relationships between one account, and a list of other accounts. Does not require auth.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier",
                description: "Primary account requesting relationships for."
              },
              others: {
                type: "array",
                description: "List of 'other' accounts to be related back to the primary.",
                maxLength: 30,
                items: {
                  type: "string",
                  format: "at-identifier"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["relationships"],
              properties: {
                actor: {
                  type: "string",
                  format: "did"
                },
                relationships: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.graph.defs#relationship",
                      "lex:app.bsky.graph.defs#notFoundActor"
                    ]
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "ActorNotFound",
              description: "the primary actor at-identifier could not be resolved"
            }
          ]
        }
      }
    },
    AppBskyGraphGetSuggestedFollowsByActor: {
      lexicon: 1,
      id: "app.bsky.graph.getSuggestedFollowsByActor",
      defs: {
        main: {
          type: "query",
          description: "Enumerates follows similar to a given account (actor). Expected use is to recommend additional accounts immediately after following one account.",
          parameters: {
            type: "params",
            required: ["actor"],
            properties: {
              actor: {
                type: "string",
                format: "at-identifier"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["suggestions"],
              properties: {
                suggestions: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphList: {
      lexicon: 1,
      id: "app.bsky.graph.list",
      defs: {
        main: {
          type: "record",
          description: "Record representing a list of accounts (actors). Scope includes both moderation-oriented lists and curration-oriented lists.",
          key: "tid",
          record: {
            type: "object",
            required: ["name", "purpose", "createdAt"],
            properties: {
              purpose: {
                type: "ref",
                description: "Defines the purpose of the list (aka, moderation-oriented or curration-oriented)",
                ref: "lex:app.bsky.graph.defs#listPurpose"
              },
              name: {
                type: "string",
                maxLength: 64,
                minLength: 1,
                description: "Display name for list; can not be empty."
              },
              description: {
                type: "string",
                maxGraphemes: 300,
                maxLength: 3e3
              },
              descriptionFacets: {
                type: "array",
                items: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet"
                }
              },
              avatar: {
                type: "blob",
                accept: ["image/png", "image/jpeg"],
                maxSize: 1e6
              },
              labels: {
                type: "union",
                refs: ["lex:com.atproto.label.defs#selfLabels"]
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyGraphListblock: {
      lexicon: 1,
      id: "app.bsky.graph.listblock",
      defs: {
        main: {
          type: "record",
          description: "Record representing a block relationship against an entire an entire list of accounts (actors).",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "createdAt"],
            properties: {
              subject: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to the mod list record."
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyGraphListitem: {
      lexicon: 1,
      id: "app.bsky.graph.listitem",
      defs: {
        main: {
          type: "record",
          description: "Record representing an account's inclusion on a specific list. The AppView will ignore duplicate listitem records.",
          key: "tid",
          record: {
            type: "object",
            required: ["subject", "list", "createdAt"],
            properties: {
              subject: {
                type: "string",
                format: "did",
                description: "The account which is included on the list."
              },
              list: {
                type: "string",
                format: "at-uri",
                description: "Reference (AT-URI) to the list record (app.bsky.graph.list)."
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyGraphMuteActor: {
      lexicon: 1,
      id: "app.bsky.graph.muteActor",
      defs: {
        main: {
          type: "procedure",
          description: "Creates a mute relationship for the specified account. Mutes are private in Bluesky. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphMuteActorList: {
      lexicon: 1,
      id: "app.bsky.graph.muteActorList",
      defs: {
        main: {
          type: "procedure",
          description: "Creates a mute relationship for the specified list of accounts. Mutes are private in Bluesky. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["list"],
              properties: {
                list: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphUnmuteActor: {
      lexicon: 1,
      id: "app.bsky.graph.unmuteActor",
      defs: {
        main: {
          type: "procedure",
          description: "Unmutes the specified account. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actor"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                }
              }
            }
          }
        }
      }
    },
    AppBskyGraphUnmuteActorList: {
      lexicon: 1,
      id: "app.bsky.graph.unmuteActorList",
      defs: {
        main: {
          type: "procedure",
          description: "Unmutes the specified list of accounts. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["list"],
              properties: {
                list: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        }
      }
    },
    AppBskyLabelerDefs: {
      lexicon: 1,
      id: "app.bsky.labeler.defs",
      defs: {
        labelerView: {
          type: "object",
          required: ["uri", "cid", "creator", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            },
            likeCount: {
              type: "integer",
              minimum: 0
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.labeler.defs#labelerViewerState"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        labelerViewDetailed: {
          type: "object",
          required: ["uri", "cid", "creator", "policies", "indexedAt"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            creator: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            },
            policies: {
              type: "ref",
              ref: "lex:app.bsky.labeler.defs#labelerPolicies"
            },
            likeCount: {
              type: "integer",
              minimum: 0
            },
            viewer: {
              type: "ref",
              ref: "lex:app.bsky.labeler.defs#labelerViewerState"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        },
        labelerViewerState: {
          type: "object",
          properties: {
            like: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        labelerPolicies: {
          type: "object",
          required: ["labelValues"],
          properties: {
            labelValues: {
              type: "array",
              description: "The label values which this labeler publishes. May include global or custom labels.",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#labelValue"
              }
            },
            labelValueDefinitions: {
              type: "array",
              description: "Label values created by this labeler and scoped exclusively to it. Labels defined here will override global label definitions for this labeler.",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#labelValueDefinition"
              }
            }
          }
        }
      }
    },
    AppBskyLabelerGetServices: {
      lexicon: 1,
      id: "app.bsky.labeler.getServices",
      defs: {
        main: {
          type: "query",
          description: "Get information about a list of labeler services.",
          parameters: {
            type: "params",
            required: ["dids"],
            properties: {
              dids: {
                type: "array",
                items: {
                  type: "string",
                  format: "did"
                }
              },
              detailed: {
                type: "boolean",
                default: !1
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["views"],
              properties: {
                views: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.labeler.defs#labelerView",
                      "lex:app.bsky.labeler.defs#labelerViewDetailed"
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyLabelerService: {
      lexicon: 1,
      id: "app.bsky.labeler.service",
      defs: {
        main: {
          type: "record",
          description: "A declaration of the existence of labeler service.",
          key: "literal:self",
          record: {
            type: "object",
            required: ["policies", "createdAt"],
            properties: {
              policies: {
                type: "ref",
                ref: "lex:app.bsky.labeler.defs#labelerPolicies"
              },
              labels: {
                type: "union",
                refs: ["lex:com.atproto.label.defs#selfLabels"]
              },
              createdAt: {
                type: "string",
                format: "datetime"
              }
            }
          }
        }
      }
    },
    AppBskyNotificationGetUnreadCount: {
      lexicon: 1,
      id: "app.bsky.notification.getUnreadCount",
      defs: {
        main: {
          type: "query",
          description: "Count the number of unread notifications for the requesting account. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              seenAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["count"],
              properties: {
                count: {
                  type: "integer"
                }
              }
            }
          }
        }
      }
    },
    AppBskyNotificationListNotifications: {
      lexicon: 1,
      id: "app.bsky.notification.listNotifications",
      defs: {
        main: {
          type: "query",
          description: "Enumerate notifications for the requesting account. Requires auth.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              },
              seenAt: {
                type: "string",
                format: "datetime"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["notifications"],
              properties: {
                cursor: {
                  type: "string"
                },
                notifications: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.notification.listNotifications#notification"
                  }
                },
                seenAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        },
        notification: {
          type: "object",
          required: [
            "uri",
            "cid",
            "author",
            "reason",
            "record",
            "isRead",
            "indexedAt"
          ],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            author: {
              type: "ref",
              ref: "lex:app.bsky.actor.defs#profileView"
            },
            reason: {
              type: "string",
              description: "Expected values are 'like', 'repost', 'follow', 'mention', 'reply', and 'quote'.",
              knownValues: [
                "like",
                "repost",
                "follow",
                "mention",
                "reply",
                "quote"
              ]
            },
            reasonSubject: {
              type: "string",
              format: "at-uri"
            },
            record: {
              type: "unknown"
            },
            isRead: {
              type: "boolean"
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            }
          }
        }
      }
    },
    AppBskyNotificationRegisterPush: {
      lexicon: 1,
      id: "app.bsky.notification.registerPush",
      defs: {
        main: {
          type: "procedure",
          description: "Register to receive push notifications, via a specified service, for the requesting account. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["serviceDid", "token", "platform", "appId"],
              properties: {
                serviceDid: {
                  type: "string",
                  format: "did"
                },
                token: {
                  type: "string"
                },
                platform: {
                  type: "string",
                  knownValues: ["ios", "android", "web"]
                },
                appId: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    AppBskyNotificationUpdateSeen: {
      lexicon: 1,
      id: "app.bsky.notification.updateSeen",
      defs: {
        main: {
          type: "procedure",
          description: "Notify server that the requesting account has seen notifications. Requires auth.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["seenAt"],
              properties: {
                seenAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        }
      }
    },
    AppBskyRichtextFacet: {
      lexicon: 1,
      id: "app.bsky.richtext.facet",
      defs: {
        main: {
          type: "object",
          description: "Annotation of a sub-string within rich text.",
          required: ["index", "features"],
          properties: {
            index: {
              type: "ref",
              ref: "lex:app.bsky.richtext.facet#byteSlice"
            },
            features: {
              type: "array",
              items: {
                type: "union",
                refs: [
                  "lex:app.bsky.richtext.facet#mention",
                  "lex:app.bsky.richtext.facet#link",
                  "lex:app.bsky.richtext.facet#tag"
                ]
              }
            }
          }
        },
        mention: {
          type: "object",
          description: "Facet feature for mention of another account. The text is usually a handle, including a '@' prefix, but the facet reference is a DID.",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        },
        link: {
          type: "object",
          description: "Facet feature for a URL. The text URL may have been simplified or truncated, but the facet reference should be a complete URL.",
          required: ["uri"],
          properties: {
            uri: {
              type: "string",
              format: "uri"
            }
          }
        },
        tag: {
          type: "object",
          description: "Facet feature for a hashtag. The text usually includes a '#' prefix, but the facet reference should not (except in the case of 'double hash tags').",
          required: ["tag"],
          properties: {
            tag: {
              type: "string",
              maxLength: 640,
              maxGraphemes: 64
            }
          }
        },
        byteSlice: {
          type: "object",
          description: "Specifies the sub-string range a facet feature applies to. Start index is inclusive, end index is exclusive. Indices are zero-indexed, counting bytes of the UTF-8 encoded text. NOTE: some languages, like Javascript, use UTF-16 or Unicode codepoints for string slice indexing; in these languages, convert to byte arrays before working with facets.",
          required: ["byteStart", "byteEnd"],
          properties: {
            byteStart: {
              type: "integer",
              minimum: 0
            },
            byteEnd: {
              type: "integer",
              minimum: 0
            }
          }
        }
      }
    },
    AppBskyUnspeccedDefs: {
      lexicon: 1,
      id: "app.bsky.unspecced.defs",
      defs: {
        skeletonSearchPost: {
          type: "object",
          required: ["uri"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        skeletonSearchActor: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        }
      }
    },
    AppBskyUnspeccedGetPopularFeedGenerators: {
      lexicon: 1,
      id: "app.bsky.unspecced.getPopularFeedGenerators",
      defs: {
        main: {
          type: "query",
          description: "An unspecced view of globally popular feed generators.",
          parameters: {
            type: "params",
            properties: {
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              },
              query: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["feeds"],
              properties: {
                cursor: {
                  type: "string"
                },
                feeds: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#generatorView"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyUnspeccedGetSuggestionsSkeleton: {
      lexicon: 1,
      id: "app.bsky.unspecced.getSuggestionsSkeleton",
      defs: {
        main: {
          type: "query",
          description: "Get a skeleton of suggested actors. Intended to be called and then hydrated through app.bsky.actor.getSuggestions",
          parameters: {
            type: "params",
            properties: {
              viewer: {
                type: "string",
                format: "did",
                description: "DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actors"],
              properties: {
                cursor: {
                  type: "string"
                },
                actors: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.unspecced.defs#skeletonSearchActor"
                  }
                }
              }
            }
          }
        }
      }
    },
    AppBskyUnspeccedGetTaggedSuggestions: {
      lexicon: 1,
      id: "app.bsky.unspecced.getTaggedSuggestions",
      defs: {
        main: {
          type: "query",
          description: "Get a list of suggestions (feeds and users) tagged with categories",
          parameters: {
            type: "params",
            properties: {}
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["suggestions"],
              properties: {
                suggestions: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.unspecced.getTaggedSuggestions#suggestion"
                  }
                }
              }
            }
          }
        },
        suggestion: {
          type: "object",
          required: ["tag", "subjectType", "subject"],
          properties: {
            tag: {
              type: "string"
            },
            subjectType: {
              type: "string",
              knownValues: ["actor", "feed"]
            },
            subject: {
              type: "string",
              format: "uri"
            }
          }
        }
      }
    },
    AppBskyUnspeccedSearchActorsSkeleton: {
      lexicon: 1,
      id: "app.bsky.unspecced.searchActorsSkeleton",
      defs: {
        main: {
          type: "query",
          description: "Backend Actors (profile) search, returns only skeleton.",
          parameters: {
            type: "params",
            required: ["q"],
            properties: {
              q: {
                type: "string",
                description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. For typeahead search, only simple term match is supported, not full syntax."
              },
              viewer: {
                type: "string",
                format: "did",
                description: "DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking."
              },
              typeahead: {
                type: "boolean",
                description: "If true, acts as fast/simple 'typeahead' query."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 25
              },
              cursor: {
                type: "string",
                description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["actors"],
              properties: {
                cursor: {
                  type: "string"
                },
                hitsTotal: {
                  type: "integer",
                  description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                },
                actors: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.unspecced.defs#skeletonSearchActor"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "BadQueryString"
            }
          ]
        }
      }
    },
    AppBskyUnspeccedSearchPostsSkeleton: {
      lexicon: 1,
      id: "app.bsky.unspecced.searchPostsSkeleton",
      defs: {
        main: {
          type: "query",
          description: "Backend Posts search, returns only skeleton",
          parameters: {
            type: "params",
            required: ["q"],
            properties: {
              q: {
                type: "string",
                description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
              },
              sort: {
                type: "string",
                knownValues: ["top", "latest"],
                default: "latest",
                description: "Specifies the ranking order of results."
              },
              since: {
                type: "string",
                description: "Filter results for posts after the indicated datetime (inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYYY-MM-DD)."
              },
              until: {
                type: "string",
                description: "Filter results for posts before the indicated datetime (not inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYY-MM-DD)."
              },
              mentions: {
                type: "string",
                format: "at-identifier",
                description: "Filter to posts which mention the given account. Handles are resolved to DID before query-time. Only matches rich-text facet mentions."
              },
              author: {
                type: "string",
                format: "at-identifier",
                description: "Filter to posts by the given account. Handles are resolved to DID before query-time."
              },
              lang: {
                type: "string",
                format: "language",
                description: "Filter to posts in the given language. Expected to be based on post language field, though server may override language detection."
              },
              domain: {
                type: "string",
                description: "Filter to posts with URLs (facet links or embeds) linking to the given domain (hostname). Server may apply hostname normalization."
              },
              url: {
                type: "string",
                format: "uri",
                description: "Filter to posts with links (facet links or embeds) pointing to this URL. Server may apply URL normalization or fuzzy matching."
              },
              tag: {
                type: "array",
                items: {
                  type: "string",
                  maxLength: 640,
                  maxGraphemes: 64
                },
                description: "Filter to posts with the given tag (hashtag), based on rich-text facet or tag field. Do not include the hash (#) prefix. Multiple tags can be specified, with 'AND' matching."
              },
              viewer: {
                type: "string",
                format: "did",
                description: "DID of the account making the request (not included for public/unauthenticated queries). Used for 'from:me' queries."
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 25
              },
              cursor: {
                type: "string",
                description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["posts"],
              properties: {
                cursor: {
                  type: "string"
                },
                hitsTotal: {
                  type: "integer",
                  description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                },
                posts: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.unspecced.defs#skeletonSearchPost"
                  }
                }
              }
            }
          },
          errors: [
            {
              name: "BadQueryString"
            }
          ]
        }
      }
    },
    ToolsOzoneCommunicationCreateTemplate: {
      lexicon: 1,
      id: "tools.ozone.communication.createTemplate",
      defs: {
        main: {
          type: "procedure",
          description: "Administrative action to create a new, re-usable communication (email for now) template.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subject", "contentMarkdown", "name"],
              properties: {
                name: {
                  type: "string",
                  description: "Name of the template."
                },
                contentMarkdown: {
                  type: "string",
                  description: "Content of the template, markdown supported, can contain variable placeholders."
                },
                subject: {
                  type: "string",
                  description: "Subject of the message, used in emails."
                },
                createdBy: {
                  type: "string",
                  format: "did",
                  description: "DID of the user who is creating the template."
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.communication.defs#templateView"
            }
          }
        }
      }
    },
    ToolsOzoneCommunicationDefs: {
      lexicon: 1,
      id: "tools.ozone.communication.defs",
      defs: {
        templateView: {
          type: "object",
          required: [
            "id",
            "name",
            "contentMarkdown",
            "disabled",
            "lastUpdatedBy",
            "createdAt",
            "updatedAt"
          ],
          properties: {
            id: {
              type: "string"
            },
            name: {
              type: "string",
              description: "Name of the template."
            },
            subject: {
              type: "string",
              description: "Content of the template, can contain markdown and variable placeholders."
            },
            contentMarkdown: {
              type: "string",
              description: "Subject of the message, used in emails."
            },
            disabled: {
              type: "boolean"
            },
            lastUpdatedBy: {
              type: "string",
              format: "did",
              description: "DID of the user who last updated the template."
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            updatedAt: {
              type: "string",
              format: "datetime"
            }
          }
        }
      }
    },
    ToolsOzoneCommunicationDeleteTemplate: {
      lexicon: 1,
      id: "tools.ozone.communication.deleteTemplate",
      defs: {
        main: {
          type: "procedure",
          description: "Delete a communication template.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["id"],
              properties: {
                id: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneCommunicationListTemplates: {
      lexicon: 1,
      id: "tools.ozone.communication.listTemplates",
      defs: {
        main: {
          type: "query",
          description: "Get list of all communication templates.",
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["communicationTemplates"],
              properties: {
                communicationTemplates: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.communication.defs#templateView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneCommunicationUpdateTemplate: {
      lexicon: 1,
      id: "tools.ozone.communication.updateTemplate",
      defs: {
        main: {
          type: "procedure",
          description: "Administrative action to update an existing communication template. Allows passing partial fields to patch specific fields only.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["id"],
              properties: {
                id: {
                  type: "string",
                  description: "ID of the template to be updated."
                },
                name: {
                  type: "string",
                  description: "Name of the template."
                },
                contentMarkdown: {
                  type: "string",
                  description: "Content of the template, markdown supported, can contain variable placeholders."
                },
                subject: {
                  type: "string",
                  description: "Subject of the message, used in emails."
                },
                updatedBy: {
                  type: "string",
                  format: "did",
                  description: "DID of the user who is updating the template."
                },
                disabled: {
                  type: "boolean"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.communication.defs#templateView"
            }
          }
        }
      }
    },
    ToolsOzoneModerationDefs: {
      lexicon: 1,
      id: "tools.ozone.moderation.defs",
      defs: {
        modEventView: {
          type: "object",
          required: [
            "id",
            "event",
            "subject",
            "subjectBlobCids",
            "createdBy",
            "createdAt"
          ],
          properties: {
            id: {
              type: "integer"
            },
            event: {
              type: "union",
              refs: [
                "lex:tools.ozone.moderation.defs#modEventTakedown",
                "lex:tools.ozone.moderation.defs#modEventReverseTakedown",
                "lex:tools.ozone.moderation.defs#modEventComment",
                "lex:tools.ozone.moderation.defs#modEventReport",
                "lex:tools.ozone.moderation.defs#modEventLabel",
                "lex:tools.ozone.moderation.defs#modEventAcknowledge",
                "lex:tools.ozone.moderation.defs#modEventEscalate",
                "lex:tools.ozone.moderation.defs#modEventMute",
                "lex:tools.ozone.moderation.defs#modEventEmail",
                "lex:tools.ozone.moderation.defs#modEventResolveAppeal",
                "lex:tools.ozone.moderation.defs#modEventDivert"
              ]
            },
            subject: {
              type: "union",
              refs: [
                "lex:com.atproto.admin.defs#repoRef",
                "lex:com.atproto.repo.strongRef"
              ]
            },
            subjectBlobCids: {
              type: "array",
              items: {
                type: "string"
              }
            },
            createdBy: {
              type: "string",
              format: "did"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            creatorHandle: {
              type: "string"
            },
            subjectHandle: {
              type: "string"
            }
          }
        },
        modEventViewDetail: {
          type: "object",
          required: [
            "id",
            "event",
            "subject",
            "subjectBlobs",
            "createdBy",
            "createdAt"
          ],
          properties: {
            id: {
              type: "integer"
            },
            event: {
              type: "union",
              refs: [
                "lex:tools.ozone.moderation.defs#modEventTakedown",
                "lex:tools.ozone.moderation.defs#modEventReverseTakedown",
                "lex:tools.ozone.moderation.defs#modEventComment",
                "lex:tools.ozone.moderation.defs#modEventReport",
                "lex:tools.ozone.moderation.defs#modEventLabel",
                "lex:tools.ozone.moderation.defs#modEventAcknowledge",
                "lex:tools.ozone.moderation.defs#modEventEscalate",
                "lex:tools.ozone.moderation.defs#modEventMute",
                "lex:tools.ozone.moderation.defs#modEventEmail",
                "lex:tools.ozone.moderation.defs#modEventResolveAppeal",
                "lex:tools.ozone.moderation.defs#modEventDivert"
              ]
            },
            subject: {
              type: "union",
              refs: [
                "lex:tools.ozone.moderation.defs#repoView",
                "lex:tools.ozone.moderation.defs#repoViewNotFound",
                "lex:tools.ozone.moderation.defs#recordView",
                "lex:tools.ozone.moderation.defs#recordViewNotFound"
              ]
            },
            subjectBlobs: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#blobView"
              }
            },
            createdBy: {
              type: "string",
              format: "did"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        subjectStatusView: {
          type: "object",
          required: ["id", "subject", "createdAt", "updatedAt", "reviewState"],
          properties: {
            id: {
              type: "integer"
            },
            subject: {
              type: "union",
              refs: [
                "lex:com.atproto.admin.defs#repoRef",
                "lex:com.atproto.repo.strongRef"
              ]
            },
            subjectBlobCids: {
              type: "array",
              items: {
                type: "string",
                format: "cid"
              }
            },
            subjectRepoHandle: {
              type: "string"
            },
            updatedAt: {
              type: "string",
              format: "datetime",
              description: "Timestamp referencing when the last update was made to the moderation status of the subject"
            },
            createdAt: {
              type: "string",
              format: "datetime",
              description: "Timestamp referencing the first moderation status impacting event was emitted on the subject"
            },
            reviewState: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#subjectReviewState"
            },
            comment: {
              type: "string",
              description: "Sticky comment on the subject."
            },
            muteUntil: {
              type: "string",
              format: "datetime"
            },
            lastReviewedBy: {
              type: "string",
              format: "did"
            },
            lastReviewedAt: {
              type: "string",
              format: "datetime"
            },
            lastReportedAt: {
              type: "string",
              format: "datetime"
            },
            lastAppealedAt: {
              type: "string",
              format: "datetime",
              description: "Timestamp referencing when the author of the subject appealed a moderation action"
            },
            takendown: {
              type: "boolean"
            },
            appealed: {
              type: "boolean",
              description: "True indicates that the a previously taken moderator action was appealed against, by the author of the content. False indicates last appeal was resolved by moderators."
            },
            suspendUntil: {
              type: "string",
              format: "datetime"
            },
            tags: {
              type: "array",
              items: {
                type: "string"
              }
            }
          }
        },
        subjectReviewState: {
          type: "string",
          knownValues: [
            "lex:tools.ozone.moderation.defs#reviewOpen",
            "lex:tools.ozone.moderation.defs#reviewEscalated",
            "lex:tools.ozone.moderation.defs#reviewClosed",
            "lex:tools.ozone.moderation.defs#reviewNone"
          ]
        },
        reviewOpen: {
          type: "token",
          description: "Moderator review status of a subject: Open. Indicates that the subject needs to be reviewed by a moderator"
        },
        reviewEscalated: {
          type: "token",
          description: "Moderator review status of a subject: Escalated. Indicates that the subject was escalated for review by a moderator"
        },
        reviewClosed: {
          type: "token",
          description: "Moderator review status of a subject: Closed. Indicates that the subject was already reviewed and resolved by a moderator"
        },
        reviewNone: {
          type: "token",
          description: "Moderator review status of a subject: Unnecessary. Indicates that the subject does not need a review at the moment but there is probably some moderation related metadata available for it"
        },
        modEventTakedown: {
          type: "object",
          description: "Take down a subject permanently or temporarily",
          properties: {
            comment: {
              type: "string"
            },
            durationInHours: {
              type: "integer",
              description: "Indicates how long the takedown should be in effect before automatically expiring."
            }
          }
        },
        modEventReverseTakedown: {
          type: "object",
          description: "Revert take down action on a subject",
          properties: {
            comment: {
              type: "string",
              description: "Describe reasoning behind the reversal."
            }
          }
        },
        modEventResolveAppeal: {
          type: "object",
          description: "Resolve appeal on a subject",
          properties: {
            comment: {
              type: "string",
              description: "Describe resolution."
            }
          }
        },
        modEventComment: {
          type: "object",
          description: "Add a comment to a subject",
          required: ["comment"],
          properties: {
            comment: {
              type: "string"
            },
            sticky: {
              type: "boolean",
              description: "Make the comment persistent on the subject"
            }
          }
        },
        modEventReport: {
          type: "object",
          description: "Report a subject",
          required: ["reportType"],
          properties: {
            comment: {
              type: "string"
            },
            reportType: {
              type: "ref",
              ref: "lex:com.atproto.moderation.defs#reasonType"
            }
          }
        },
        modEventLabel: {
          type: "object",
          description: "Apply/Negate labels on a subject",
          required: ["createLabelVals", "negateLabelVals"],
          properties: {
            comment: {
              type: "string"
            },
            createLabelVals: {
              type: "array",
              items: {
                type: "string"
              }
            },
            negateLabelVals: {
              type: "array",
              items: {
                type: "string"
              }
            }
          }
        },
        modEventAcknowledge: {
          type: "object",
          properties: {
            comment: {
              type: "string"
            }
          }
        },
        modEventEscalate: {
          type: "object",
          properties: {
            comment: {
              type: "string"
            }
          }
        },
        modEventMute: {
          type: "object",
          description: "Mute incoming reports on a subject",
          required: ["durationInHours"],
          properties: {
            comment: {
              type: "string"
            },
            durationInHours: {
              type: "integer",
              description: "Indicates how long the subject should remain muted."
            }
          }
        },
        modEventUnmute: {
          type: "object",
          description: "Unmute action on a subject",
          properties: {
            comment: {
              type: "string",
              description: "Describe reasoning behind the reversal."
            }
          }
        },
        modEventEmail: {
          type: "object",
          description: "Keep a log of outgoing email to a user",
          required: ["subjectLine"],
          properties: {
            subjectLine: {
              type: "string",
              description: "The subject line of the email sent to the user."
            },
            content: {
              type: "string",
              description: "The content of the email sent to the user."
            },
            comment: {
              type: "string",
              description: "Additional comment about the outgoing comm."
            }
          }
        },
        modEventDivert: {
          type: "object",
          description: "Divert a record's blobs to a 3rd party service for further scanning/tagging",
          properties: {
            comment: {
              type: "string"
            }
          }
        },
        modEventTag: {
          type: "object",
          description: "Add/Remove a tag on a subject",
          required: ["add", "remove"],
          properties: {
            add: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Tags to be added to the subject. If already exists, won't be duplicated."
            },
            remove: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Tags to be removed to the subject. Ignores a tag If it doesn't exist, won't be duplicated."
            },
            comment: {
              type: "string",
              description: "Additional comment about added/removed tags."
            }
          }
        },
        repoView: {
          type: "object",
          required: [
            "did",
            "handle",
            "relatedRecords",
            "indexedAt",
            "moderation"
          ],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            email: {
              type: "string"
            },
            relatedRecords: {
              type: "array",
              items: {
                type: "unknown"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            moderation: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#moderation"
            },
            invitedBy: {
              type: "ref",
              ref: "lex:com.atproto.server.defs#inviteCode"
            },
            invitesDisabled: {
              type: "boolean"
            },
            inviteNote: {
              type: "string"
            }
          }
        },
        repoViewDetail: {
          type: "object",
          required: [
            "did",
            "handle",
            "relatedRecords",
            "indexedAt",
            "moderation"
          ],
          properties: {
            did: {
              type: "string",
              format: "did"
            },
            handle: {
              type: "string",
              format: "handle"
            },
            email: {
              type: "string"
            },
            relatedRecords: {
              type: "array",
              items: {
                type: "unknown"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            moderation: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#moderationDetail"
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            invitedBy: {
              type: "ref",
              ref: "lex:com.atproto.server.defs#inviteCode"
            },
            invites: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.server.defs#inviteCode"
              }
            },
            invitesDisabled: {
              type: "boolean"
            },
            inviteNote: {
              type: "string"
            },
            emailConfirmedAt: {
              type: "string",
              format: "datetime"
            }
          }
        },
        repoViewNotFound: {
          type: "object",
          required: ["did"],
          properties: {
            did: {
              type: "string",
              format: "did"
            }
          }
        },
        recordView: {
          type: "object",
          required: [
            "uri",
            "cid",
            "value",
            "blobCids",
            "indexedAt",
            "moderation",
            "repo"
          ],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            value: {
              type: "unknown"
            },
            blobCids: {
              type: "array",
              items: {
                type: "string",
                format: "cid"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            moderation: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#moderation"
            },
            repo: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#repoView"
            }
          }
        },
        recordViewDetail: {
          type: "object",
          required: [
            "uri",
            "cid",
            "value",
            "blobs",
            "indexedAt",
            "moderation",
            "repo"
          ],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            },
            cid: {
              type: "string",
              format: "cid"
            },
            value: {
              type: "unknown"
            },
            blobs: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:tools.ozone.moderation.defs#blobView"
              }
            },
            labels: {
              type: "array",
              items: {
                type: "ref",
                ref: "lex:com.atproto.label.defs#label"
              }
            },
            indexedAt: {
              type: "string",
              format: "datetime"
            },
            moderation: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#moderationDetail"
            },
            repo: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#repoView"
            }
          }
        },
        recordViewNotFound: {
          type: "object",
          required: ["uri"],
          properties: {
            uri: {
              type: "string",
              format: "at-uri"
            }
          }
        },
        moderation: {
          type: "object",
          properties: {
            subjectStatus: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#subjectStatusView"
            }
          }
        },
        moderationDetail: {
          type: "object",
          properties: {
            subjectStatus: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#subjectStatusView"
            }
          }
        },
        blobView: {
          type: "object",
          required: ["cid", "mimeType", "size", "createdAt"],
          properties: {
            cid: {
              type: "string",
              format: "cid"
            },
            mimeType: {
              type: "string"
            },
            size: {
              type: "integer"
            },
            createdAt: {
              type: "string",
              format: "datetime"
            },
            details: {
              type: "union",
              refs: [
                "lex:tools.ozone.moderation.defs#imageDetails",
                "lex:tools.ozone.moderation.defs#videoDetails"
              ]
            },
            moderation: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#moderation"
            }
          }
        },
        imageDetails: {
          type: "object",
          required: ["width", "height"],
          properties: {
            width: {
              type: "integer"
            },
            height: {
              type: "integer"
            }
          }
        },
        videoDetails: {
          type: "object",
          required: ["width", "height", "length"],
          properties: {
            width: {
              type: "integer"
            },
            height: {
              type: "integer"
            },
            length: {
              type: "integer"
            }
          }
        }
      }
    },
    ToolsOzoneModerationEmitEvent: {
      lexicon: 1,
      id: "tools.ozone.moderation.emitEvent",
      defs: {
        main: {
          type: "procedure",
          description: "Take a moderation action on an actor.",
          input: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["event", "subject", "createdBy"],
              properties: {
                event: {
                  type: "union",
                  refs: [
                    "lex:tools.ozone.moderation.defs#modEventTakedown",
                    "lex:tools.ozone.moderation.defs#modEventAcknowledge",
                    "lex:tools.ozone.moderation.defs#modEventEscalate",
                    "lex:tools.ozone.moderation.defs#modEventComment",
                    "lex:tools.ozone.moderation.defs#modEventLabel",
                    "lex:tools.ozone.moderation.defs#modEventReport",
                    "lex:tools.ozone.moderation.defs#modEventMute",
                    "lex:tools.ozone.moderation.defs#modEventReverseTakedown",
                    "lex:tools.ozone.moderation.defs#modEventUnmute",
                    "lex:tools.ozone.moderation.defs#modEventEmail",
                    "lex:tools.ozone.moderation.defs#modEventTag"
                  ]
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                },
                subjectBlobCids: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "cid"
                  }
                },
                createdBy: {
                  type: "string",
                  format: "did"
                }
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#modEventView"
            }
          },
          errors: [
            {
              name: "SubjectHasAction"
            }
          ]
        }
      }
    },
    ToolsOzoneModerationGetEvent: {
      lexicon: 1,
      id: "tools.ozone.moderation.getEvent",
      defs: {
        main: {
          type: "query",
          description: "Get details about a moderation event.",
          parameters: {
            type: "params",
            required: ["id"],
            properties: {
              id: {
                type: "integer"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#modEventViewDetail"
            }
          }
        }
      }
    },
    ToolsOzoneModerationGetRecord: {
      lexicon: 1,
      id: "tools.ozone.moderation.getRecord",
      defs: {
        main: {
          type: "query",
          description: "Get details about a record.",
          parameters: {
            type: "params",
            required: ["uri"],
            properties: {
              uri: {
                type: "string",
                format: "at-uri"
              },
              cid: {
                type: "string",
                format: "cid"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#recordViewDetail"
            }
          },
          errors: [
            {
              name: "RecordNotFound"
            }
          ]
        }
      }
    },
    ToolsOzoneModerationGetRepo: {
      lexicon: 1,
      id: "tools.ozone.moderation.getRepo",
      defs: {
        main: {
          type: "query",
          description: "Get details about a repository.",
          parameters: {
            type: "params",
            required: ["did"],
            properties: {
              did: {
                type: "string",
                format: "did"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "ref",
              ref: "lex:tools.ozone.moderation.defs#repoViewDetail"
            }
          },
          errors: [
            {
              name: "RepoNotFound"
            }
          ]
        }
      }
    },
    ToolsOzoneModerationQueryEvents: {
      lexicon: 1,
      id: "tools.ozone.moderation.queryEvents",
      defs: {
        main: {
          type: "query",
          description: "List moderation events related to a subject.",
          parameters: {
            type: "params",
            properties: {
              types: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "The types of events (fully qualified string in the format of tools.ozone.moderation.defs#modEvent<name>) to filter by. If not specified, all events are returned."
              },
              createdBy: {
                type: "string",
                format: "did"
              },
              sortDirection: {
                type: "string",
                default: "desc",
                enum: ["asc", "desc"],
                description: "Sort direction for the events. Defaults to descending order of created at timestamp."
              },
              createdAfter: {
                type: "string",
                format: "datetime",
                description: "Retrieve events created after a given timestamp"
              },
              createdBefore: {
                type: "string",
                format: "datetime",
                description: "Retrieve events created before a given timestamp"
              },
              subject: {
                type: "string",
                format: "uri"
              },
              includeAllUserRecords: {
                type: "boolean",
                default: !1,
                description: "If true, events on all record types (posts, lists, profile etc.) owned by the did are returned"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              hasComment: {
                type: "boolean",
                description: "If true, only events with comments are returned"
              },
              comment: {
                type: "string",
                description: "If specified, only events with comments containing the keyword are returned"
              },
              addedLabels: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "If specified, only events where all of these labels were added are returned"
              },
              removedLabels: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "If specified, only events where all of these labels were removed are returned"
              },
              addedTags: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "If specified, only events where all of these tags were added are returned"
              },
              removedTags: {
                type: "array",
                items: {
                  type: "string"
                },
                description: "If specified, only events where all of these tags were removed are returned"
              },
              reportTypes: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["events"],
              properties: {
                cursor: {
                  type: "string"
                },
                events: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.moderation.defs#modEventView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneModerationQueryStatuses: {
      lexicon: 1,
      id: "tools.ozone.moderation.queryStatuses",
      defs: {
        main: {
          type: "query",
          description: "View moderation statuses of subjects (record or repo).",
          parameters: {
            type: "params",
            properties: {
              subject: {
                type: "string",
                format: "uri"
              },
              comment: {
                type: "string",
                description: "Search subjects by keyword from comments"
              },
              reportedAfter: {
                type: "string",
                format: "datetime",
                description: "Search subjects reported after a given timestamp"
              },
              reportedBefore: {
                type: "string",
                format: "datetime",
                description: "Search subjects reported before a given timestamp"
              },
              reviewedAfter: {
                type: "string",
                format: "datetime",
                description: "Search subjects reviewed after a given timestamp"
              },
              reviewedBefore: {
                type: "string",
                format: "datetime",
                description: "Search subjects reviewed before a given timestamp"
              },
              includeMuted: {
                type: "boolean",
                description: "By default, we don't include muted subjects in the results. Set this to true to include them."
              },
              reviewState: {
                type: "string",
                description: "Specify when fetching subjects in a certain state"
              },
              ignoreSubjects: {
                type: "array",
                items: {
                  type: "string",
                  format: "uri"
                }
              },
              lastReviewedBy: {
                type: "string",
                format: "did",
                description: "Get all subject statuses that were reviewed by a specific moderator"
              },
              sortField: {
                type: "string",
                default: "lastReportedAt",
                enum: ["lastReviewedAt", "lastReportedAt"]
              },
              sortDirection: {
                type: "string",
                default: "desc",
                enum: ["asc", "desc"]
              },
              takendown: {
                type: "boolean",
                description: "Get subjects that were taken down"
              },
              appealed: {
                type: "boolean",
                description: "Get subjects in unresolved appealed status"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              tags: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              excludeTags: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["subjectStatuses"],
              properties: {
                cursor: {
                  type: "string"
                },
                subjectStatuses: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.moderation.defs#subjectStatusView"
                  }
                }
              }
            }
          }
        }
      }
    },
    ToolsOzoneModerationSearchRepos: {
      lexicon: 1,
      id: "tools.ozone.moderation.searchRepos",
      defs: {
        main: {
          type: "query",
          description: "Find repositories based on a search term.",
          parameters: {
            type: "params",
            properties: {
              term: {
                type: "string",
                description: "DEPRECATED: use 'q' instead"
              },
              q: {
                type: "string"
              },
              limit: {
                type: "integer",
                minimum: 1,
                maximum: 100,
                default: 50
              },
              cursor: {
                type: "string"
              }
            }
          },
          output: {
            encoding: "application/json",
            schema: {
              type: "object",
              required: ["repos"],
              properties: {
                cursor: {
                  type: "string"
                },
                repos: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.moderation.defs#repoView"
                  }
                }
              }
            }
          }
        }
      }
    }
  }, t.schemas = Object.values(t.schemaDict), t.lexicons = new e.Lexicons(t.schemas), t.ids = {
    ComAtprotoAdminDefs: "com.atproto.admin.defs",
    ComAtprotoAdminDeleteAccount: "com.atproto.admin.deleteAccount",
    ComAtprotoAdminDisableAccountInvites: "com.atproto.admin.disableAccountInvites",
    ComAtprotoAdminDisableInviteCodes: "com.atproto.admin.disableInviteCodes",
    ComAtprotoAdminEnableAccountInvites: "com.atproto.admin.enableAccountInvites",
    ComAtprotoAdminGetAccountInfo: "com.atproto.admin.getAccountInfo",
    ComAtprotoAdminGetAccountInfos: "com.atproto.admin.getAccountInfos",
    ComAtprotoAdminGetInviteCodes: "com.atproto.admin.getInviteCodes",
    ComAtprotoAdminGetSubjectStatus: "com.atproto.admin.getSubjectStatus",
    ComAtprotoAdminSendEmail: "com.atproto.admin.sendEmail",
    ComAtprotoAdminUpdateAccountEmail: "com.atproto.admin.updateAccountEmail",
    ComAtprotoAdminUpdateAccountHandle: "com.atproto.admin.updateAccountHandle",
    ComAtprotoAdminUpdateAccountPassword: "com.atproto.admin.updateAccountPassword",
    ComAtprotoAdminUpdateSubjectStatus: "com.atproto.admin.updateSubjectStatus",
    ComAtprotoIdentityGetRecommendedDidCredentials: "com.atproto.identity.getRecommendedDidCredentials",
    ComAtprotoIdentityRequestPlcOperationSignature: "com.atproto.identity.requestPlcOperationSignature",
    ComAtprotoIdentityResolveHandle: "com.atproto.identity.resolveHandle",
    ComAtprotoIdentitySignPlcOperation: "com.atproto.identity.signPlcOperation",
    ComAtprotoIdentitySubmitPlcOperation: "com.atproto.identity.submitPlcOperation",
    ComAtprotoIdentityUpdateHandle: "com.atproto.identity.updateHandle",
    ComAtprotoLabelDefs: "com.atproto.label.defs",
    ComAtprotoLabelQueryLabels: "com.atproto.label.queryLabels",
    ComAtprotoLabelSubscribeLabels: "com.atproto.label.subscribeLabels",
    ComAtprotoModerationCreateReport: "com.atproto.moderation.createReport",
    ComAtprotoModerationDefs: "com.atproto.moderation.defs",
    ComAtprotoRepoApplyWrites: "com.atproto.repo.applyWrites",
    ComAtprotoRepoCreateRecord: "com.atproto.repo.createRecord",
    ComAtprotoRepoDeleteRecord: "com.atproto.repo.deleteRecord",
    ComAtprotoRepoDescribeRepo: "com.atproto.repo.describeRepo",
    ComAtprotoRepoGetRecord: "com.atproto.repo.getRecord",
    ComAtprotoRepoImportRepo: "com.atproto.repo.importRepo",
    ComAtprotoRepoListMissingBlobs: "com.atproto.repo.listMissingBlobs",
    ComAtprotoRepoListRecords: "com.atproto.repo.listRecords",
    ComAtprotoRepoPutRecord: "com.atproto.repo.putRecord",
    ComAtprotoRepoStrongRef: "com.atproto.repo.strongRef",
    ComAtprotoRepoUploadBlob: "com.atproto.repo.uploadBlob",
    ComAtprotoServerActivateAccount: "com.atproto.server.activateAccount",
    ComAtprotoServerCheckAccountStatus: "com.atproto.server.checkAccountStatus",
    ComAtprotoServerConfirmEmail: "com.atproto.server.confirmEmail",
    ComAtprotoServerCreateAccount: "com.atproto.server.createAccount",
    ComAtprotoServerCreateAppPassword: "com.atproto.server.createAppPassword",
    ComAtprotoServerCreateInviteCode: "com.atproto.server.createInviteCode",
    ComAtprotoServerCreateInviteCodes: "com.atproto.server.createInviteCodes",
    ComAtprotoServerCreateSession: "com.atproto.server.createSession",
    ComAtprotoServerDeactivateAccount: "com.atproto.server.deactivateAccount",
    ComAtprotoServerDefs: "com.atproto.server.defs",
    ComAtprotoServerDeleteAccount: "com.atproto.server.deleteAccount",
    ComAtprotoServerDeleteSession: "com.atproto.server.deleteSession",
    ComAtprotoServerDescribeServer: "com.atproto.server.describeServer",
    ComAtprotoServerGetAccountInviteCodes: "com.atproto.server.getAccountInviteCodes",
    ComAtprotoServerGetServiceAuth: "com.atproto.server.getServiceAuth",
    ComAtprotoServerGetSession: "com.atproto.server.getSession",
    ComAtprotoServerListAppPasswords: "com.atproto.server.listAppPasswords",
    ComAtprotoServerRefreshSession: "com.atproto.server.refreshSession",
    ComAtprotoServerRequestAccountDelete: "com.atproto.server.requestAccountDelete",
    ComAtprotoServerRequestEmailConfirmation: "com.atproto.server.requestEmailConfirmation",
    ComAtprotoServerRequestEmailUpdate: "com.atproto.server.requestEmailUpdate",
    ComAtprotoServerRequestPasswordReset: "com.atproto.server.requestPasswordReset",
    ComAtprotoServerReserveSigningKey: "com.atproto.server.reserveSigningKey",
    ComAtprotoServerResetPassword: "com.atproto.server.resetPassword",
    ComAtprotoServerRevokeAppPassword: "com.atproto.server.revokeAppPassword",
    ComAtprotoServerUpdateEmail: "com.atproto.server.updateEmail",
    ComAtprotoSyncGetBlob: "com.atproto.sync.getBlob",
    ComAtprotoSyncGetBlocks: "com.atproto.sync.getBlocks",
    ComAtprotoSyncGetCheckout: "com.atproto.sync.getCheckout",
    ComAtprotoSyncGetHead: "com.atproto.sync.getHead",
    ComAtprotoSyncGetLatestCommit: "com.atproto.sync.getLatestCommit",
    ComAtprotoSyncGetRecord: "com.atproto.sync.getRecord",
    ComAtprotoSyncGetRepo: "com.atproto.sync.getRepo",
    ComAtprotoSyncListBlobs: "com.atproto.sync.listBlobs",
    ComAtprotoSyncListRepos: "com.atproto.sync.listRepos",
    ComAtprotoSyncNotifyOfUpdate: "com.atproto.sync.notifyOfUpdate",
    ComAtprotoSyncRequestCrawl: "com.atproto.sync.requestCrawl",
    ComAtprotoSyncSubscribeRepos: "com.atproto.sync.subscribeRepos",
    ComAtprotoTempCheckSignupQueue: "com.atproto.temp.checkSignupQueue",
    ComAtprotoTempFetchLabels: "com.atproto.temp.fetchLabels",
    ComAtprotoTempRequestPhoneVerification: "com.atproto.temp.requestPhoneVerification",
    AppBskyActorDefs: "app.bsky.actor.defs",
    AppBskyActorGetPreferences: "app.bsky.actor.getPreferences",
    AppBskyActorGetProfile: "app.bsky.actor.getProfile",
    AppBskyActorGetProfiles: "app.bsky.actor.getProfiles",
    AppBskyActorGetSuggestions: "app.bsky.actor.getSuggestions",
    AppBskyActorProfile: "app.bsky.actor.profile",
    AppBskyActorPutPreferences: "app.bsky.actor.putPreferences",
    AppBskyActorSearchActors: "app.bsky.actor.searchActors",
    AppBskyActorSearchActorsTypeahead: "app.bsky.actor.searchActorsTypeahead",
    AppBskyEmbedExternal: "app.bsky.embed.external",
    AppBskyEmbedImages: "app.bsky.embed.images",
    AppBskyEmbedRecord: "app.bsky.embed.record",
    AppBskyEmbedRecordWithMedia: "app.bsky.embed.recordWithMedia",
    AppBskyFeedDefs: "app.bsky.feed.defs",
    AppBskyFeedDescribeFeedGenerator: "app.bsky.feed.describeFeedGenerator",
    AppBskyFeedGenerator: "app.bsky.feed.generator",
    AppBskyFeedGetActorFeeds: "app.bsky.feed.getActorFeeds",
    AppBskyFeedGetActorLikes: "app.bsky.feed.getActorLikes",
    AppBskyFeedGetAuthorFeed: "app.bsky.feed.getAuthorFeed",
    AppBskyFeedGetFeed: "app.bsky.feed.getFeed",
    AppBskyFeedGetFeedGenerator: "app.bsky.feed.getFeedGenerator",
    AppBskyFeedGetFeedGenerators: "app.bsky.feed.getFeedGenerators",
    AppBskyFeedGetFeedSkeleton: "app.bsky.feed.getFeedSkeleton",
    AppBskyFeedGetLikes: "app.bsky.feed.getLikes",
    AppBskyFeedGetListFeed: "app.bsky.feed.getListFeed",
    AppBskyFeedGetPostThread: "app.bsky.feed.getPostThread",
    AppBskyFeedGetPosts: "app.bsky.feed.getPosts",
    AppBskyFeedGetRepostedBy: "app.bsky.feed.getRepostedBy",
    AppBskyFeedGetSuggestedFeeds: "app.bsky.feed.getSuggestedFeeds",
    AppBskyFeedGetTimeline: "app.bsky.feed.getTimeline",
    AppBskyFeedLike: "app.bsky.feed.like",
    AppBskyFeedPost: "app.bsky.feed.post",
    AppBskyFeedRepost: "app.bsky.feed.repost",
    AppBskyFeedSearchPosts: "app.bsky.feed.searchPosts",
    AppBskyFeedSendInteractions: "app.bsky.feed.sendInteractions",
    AppBskyFeedThreadgate: "app.bsky.feed.threadgate",
    AppBskyGraphBlock: "app.bsky.graph.block",
    AppBskyGraphDefs: "app.bsky.graph.defs",
    AppBskyGraphFollow: "app.bsky.graph.follow",
    AppBskyGraphGetBlocks: "app.bsky.graph.getBlocks",
    AppBskyGraphGetFollowers: "app.bsky.graph.getFollowers",
    AppBskyGraphGetFollows: "app.bsky.graph.getFollows",
    AppBskyGraphGetList: "app.bsky.graph.getList",
    AppBskyGraphGetListBlocks: "app.bsky.graph.getListBlocks",
    AppBskyGraphGetListMutes: "app.bsky.graph.getListMutes",
    AppBskyGraphGetLists: "app.bsky.graph.getLists",
    AppBskyGraphGetMutes: "app.bsky.graph.getMutes",
    AppBskyGraphGetRelationships: "app.bsky.graph.getRelationships",
    AppBskyGraphGetSuggestedFollowsByActor: "app.bsky.graph.getSuggestedFollowsByActor",
    AppBskyGraphList: "app.bsky.graph.list",
    AppBskyGraphListblock: "app.bsky.graph.listblock",
    AppBskyGraphListitem: "app.bsky.graph.listitem",
    AppBskyGraphMuteActor: "app.bsky.graph.muteActor",
    AppBskyGraphMuteActorList: "app.bsky.graph.muteActorList",
    AppBskyGraphUnmuteActor: "app.bsky.graph.unmuteActor",
    AppBskyGraphUnmuteActorList: "app.bsky.graph.unmuteActorList",
    AppBskyLabelerDefs: "app.bsky.labeler.defs",
    AppBskyLabelerGetServices: "app.bsky.labeler.getServices",
    AppBskyLabelerService: "app.bsky.labeler.service",
    AppBskyNotificationGetUnreadCount: "app.bsky.notification.getUnreadCount",
    AppBskyNotificationListNotifications: "app.bsky.notification.listNotifications",
    AppBskyNotificationRegisterPush: "app.bsky.notification.registerPush",
    AppBskyNotificationUpdateSeen: "app.bsky.notification.updateSeen",
    AppBskyRichtextFacet: "app.bsky.richtext.facet",
    AppBskyUnspeccedDefs: "app.bsky.unspecced.defs",
    AppBskyUnspeccedGetPopularFeedGenerators: "app.bsky.unspecced.getPopularFeedGenerators",
    AppBskyUnspeccedGetSuggestionsSkeleton: "app.bsky.unspecced.getSuggestionsSkeleton",
    AppBskyUnspeccedGetTaggedSuggestions: "app.bsky.unspecced.getTaggedSuggestions",
    AppBskyUnspeccedSearchActorsSkeleton: "app.bsky.unspecced.searchActorsSkeleton",
    AppBskyUnspeccedSearchPostsSkeleton: "app.bsky.unspecced.searchPostsSkeleton",
    ToolsOzoneCommunicationCreateTemplate: "tools.ozone.communication.createTemplate",
    ToolsOzoneCommunicationDefs: "tools.ozone.communication.defs",
    ToolsOzoneCommunicationDeleteTemplate: "tools.ozone.communication.deleteTemplate",
    ToolsOzoneCommunicationListTemplates: "tools.ozone.communication.listTemplates",
    ToolsOzoneCommunicationUpdateTemplate: "tools.ozone.communication.updateTemplate",
    ToolsOzoneModerationDefs: "tools.ozone.moderation.defs",
    ToolsOzoneModerationEmitEvent: "tools.ozone.moderation.emitEvent",
    ToolsOzoneModerationGetEvent: "tools.ozone.moderation.getEvent",
    ToolsOzoneModerationGetRecord: "tools.ozone.moderation.getRecord",
    ToolsOzoneModerationGetRepo: "tools.ozone.moderation.getRepo",
    ToolsOzoneModerationQueryEvents: "tools.ozone.moderation.queryEvents",
    ToolsOzoneModerationQueryStatuses: "tools.ozone.moderation.queryStatuses",
    ToolsOzoneModerationSearchRepos: "tools.ozone.moderation.searchRepos"
  };
})(Ve);
var wa = {};
Object.defineProperty(wa, "__esModule", { value: !0 });
wa.toKnownErr = void 0;
const zy = te;
function Hy(t) {
  return t instanceof zy.XRPCError, t;
}
wa.toKnownErr = Hy;
var Sa = {};
Object.defineProperty(Sa, "__esModule", { value: !0 });
Sa.toKnownErr = void 0;
const Zy = te;
function Wy(t) {
  return t instanceof Zy.XRPCError, t;
}
Sa.toKnownErr = Wy;
var La = {};
Object.defineProperty(La, "__esModule", { value: !0 });
La.toKnownErr = void 0;
const Yy = te;
function Jy(t) {
  return t instanceof Yy.XRPCError, t;
}
La.toKnownErr = Jy;
var Ca = {};
Object.defineProperty(Ca, "__esModule", { value: !0 });
Ca.toKnownErr = void 0;
const Qy = te;
function eb(t) {
  return t instanceof Qy.XRPCError, t;
}
Ca.toKnownErr = eb;
var Da = {};
Object.defineProperty(Da, "__esModule", { value: !0 });
Da.toKnownErr = void 0;
const tb = te;
function rb(t) {
  return t instanceof tb.XRPCError, t;
}
Da.toKnownErr = rb;
var ka = {};
Object.defineProperty(ka, "__esModule", { value: !0 });
ka.toKnownErr = void 0;
const ib = te;
function nb(t) {
  return t instanceof ib.XRPCError, t;
}
ka.toKnownErr = nb;
var Pa = {};
Object.defineProperty(Pa, "__esModule", { value: !0 });
Pa.toKnownErr = void 0;
const ab = te;
function sb(t) {
  return t instanceof ab.XRPCError, t;
}
Pa.toKnownErr = sb;
var Ba = {};
Object.defineProperty(Ba, "__esModule", { value: !0 });
Ba.toKnownErr = void 0;
const ob = te;
function lb(t) {
  return t instanceof ob.XRPCError, t;
}
Ba.toKnownErr = lb;
var Ia = {};
Object.defineProperty(Ia, "__esModule", { value: !0 });
Ia.toKnownErr = void 0;
const ub = te;
function fb(t) {
  return t instanceof ub.XRPCError, t;
}
Ia.toKnownErr = fb;
var Ua = {};
Object.defineProperty(Ua, "__esModule", { value: !0 });
Ua.toKnownErr = void 0;
const cb = te;
function db(t) {
  return t instanceof cb.XRPCError, t;
}
Ua.toKnownErr = db;
var Oa = {};
Object.defineProperty(Oa, "__esModule", { value: !0 });
Oa.toKnownErr = void 0;
const pb = te;
function hb(t) {
  return t instanceof pb.XRPCError, t;
}
Oa.toKnownErr = hb;
var Ka = {};
Object.defineProperty(Ka, "__esModule", { value: !0 });
Ka.toKnownErr = void 0;
const mb = te;
function yb(t) {
  return t instanceof mb.XRPCError, t;
}
Ka.toKnownErr = yb;
var Na = {};
Object.defineProperty(Na, "__esModule", { value: !0 });
Na.toKnownErr = void 0;
const bb = te;
function xb(t) {
  return t instanceof bb.XRPCError, t;
}
Na.toKnownErr = xb;
var Va = {};
Object.defineProperty(Va, "__esModule", { value: !0 });
Va.toKnownErr = void 0;
const Eb = te;
function gb(t) {
  return t instanceof Eb.XRPCError, t;
}
Va.toKnownErr = gb;
var Ma = {};
Object.defineProperty(Ma, "__esModule", { value: !0 });
Ma.toKnownErr = void 0;
const vb = te;
function Rb(t) {
  return t instanceof vb.XRPCError, t;
}
Ma.toKnownErr = Rb;
var ja = {};
Object.defineProperty(ja, "__esModule", { value: !0 });
ja.toKnownErr = void 0;
const Ab = te;
function _b(t) {
  return t instanceof Ab.XRPCError, t;
}
ja.toKnownErr = _b;
var Fa = {};
Object.defineProperty(Fa, "__esModule", { value: !0 });
Fa.toKnownErr = void 0;
const Tb = te;
function wb(t) {
  return t instanceof Tb.XRPCError, t;
}
Fa.toKnownErr = wb;
var $a = {};
Object.defineProperty($a, "__esModule", { value: !0 });
$a.toKnownErr = void 0;
const Sb = te;
function Lb(t) {
  return t instanceof Sb.XRPCError, t;
}
$a.toKnownErr = Lb;
var Ga = {};
Object.defineProperty(Ga, "__esModule", { value: !0 });
Ga.toKnownErr = void 0;
const Cb = te;
function Db(t) {
  return t instanceof Cb.XRPCError, t;
}
Ga.toKnownErr = Db;
var qa = {};
Object.defineProperty(qa, "__esModule", { value: !0 });
qa.toKnownErr = void 0;
const kb = te;
function Pb(t) {
  return t instanceof kb.XRPCError, t;
}
qa.toKnownErr = Pb;
var Xa = {};
Object.defineProperty(Xa, "__esModule", { value: !0 });
Xa.toKnownErr = void 0;
const Bb = te;
function Ib(t) {
  return t instanceof Bb.XRPCError, t;
}
Xa.toKnownErr = Ib;
var Ot = {}, Ie = {};
Object.defineProperty(Ie, "__esModule", { value: !0 });
Ie.hasProp = Ie.isObj = void 0;
function Ub(t) {
  return typeof t == "object" && t !== null;
}
Ie.isObj = Ub;
function Ob(t, e) {
  return e in t;
}
Ie.hasProp = Ob;
Object.defineProperty(Ot, "__esModule", { value: !0 });
Ot.validateDelete = Ot.isDelete = Ot.validateUpdate = Ot.isUpdate = Ot.validateCreate = Ot.isCreate = Ot.toKnownErr = Ot.InvalidSwapError = void 0;
const Sc = te, Vn = Ie, Jl = Ne;
let Lc = class extends Sc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Ot.InvalidSwapError = Lc;
function Kb(t) {
  return t instanceof Sc.XRPCError && t.error === "InvalidSwap" ? new Lc(t) : t;
}
Ot.toKnownErr = Kb;
function Nb(t) {
  return (0, Vn.isObj)(t) && (0, Vn.hasProp)(t, "$type") && t.$type === "com.atproto.repo.applyWrites#create";
}
Ot.isCreate = Nb;
function Vb(t) {
  return Jl.lexicons.validate("com.atproto.repo.applyWrites#create", t);
}
Ot.validateCreate = Vb;
function Mb(t) {
  return (0, Vn.isObj)(t) && (0, Vn.hasProp)(t, "$type") && t.$type === "com.atproto.repo.applyWrites#update";
}
Ot.isUpdate = Mb;
function jb(t) {
  return Jl.lexicons.validate("com.atproto.repo.applyWrites#update", t);
}
Ot.validateUpdate = jb;
function Fb(t) {
  return (0, Vn.isObj)(t) && (0, Vn.hasProp)(t, "$type") && t.$type === "com.atproto.repo.applyWrites#delete";
}
Ot.isDelete = Fb;
function $b(t) {
  return Jl.lexicons.validate("com.atproto.repo.applyWrites#delete", t);
}
Ot.validateDelete = $b;
var ln = {};
Object.defineProperty(ln, "__esModule", { value: !0 });
ln.toKnownErr = ln.InvalidSwapError = void 0;
const Cc = te;
let Dc = class extends Cc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
ln.InvalidSwapError = Dc;
function Gb(t) {
  return t instanceof Cc.XRPCError && t.error === "InvalidSwap" ? new Dc(t) : t;
}
ln.toKnownErr = Gb;
var un = {};
Object.defineProperty(un, "__esModule", { value: !0 });
un.toKnownErr = un.InvalidSwapError = void 0;
const kc = te;
let Pc = class extends kc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
un.InvalidSwapError = Pc;
function qb(t) {
  return t instanceof kc.XRPCError && t.error === "InvalidSwap" ? new Pc(t) : t;
}
un.toKnownErr = qb;
var za = {};
Object.defineProperty(za, "__esModule", { value: !0 });
za.toKnownErr = void 0;
const Xb = te;
function zb(t) {
  return t instanceof Xb.XRPCError, t;
}
za.toKnownErr = zb;
var Ha = {};
Object.defineProperty(Ha, "__esModule", { value: !0 });
Ha.toKnownErr = void 0;
const Hb = te;
function Zb(t) {
  return t instanceof Hb.XRPCError, t;
}
Ha.toKnownErr = Zb;
var Za = {};
Object.defineProperty(Za, "__esModule", { value: !0 });
Za.toKnownErr = void 0;
const Wb = te;
function Yb(t) {
  return t instanceof Wb.XRPCError, t;
}
Za.toKnownErr = Yb;
var wi = {};
Object.defineProperty(wi, "__esModule", { value: !0 });
wi.validateRecordBlob = wi.isRecordBlob = wi.toKnownErr = void 0;
const Jb = te, $u = Ie, Qb = Ne;
function ex(t) {
  return t instanceof Jb.XRPCError, t;
}
wi.toKnownErr = ex;
function tx(t) {
  return (0, $u.isObj)(t) && (0, $u.hasProp)(t, "$type") && t.$type === "com.atproto.repo.listMissingBlobs#recordBlob";
}
wi.isRecordBlob = tx;
function rx(t) {
  return Qb.lexicons.validate("com.atproto.repo.listMissingBlobs#recordBlob", t);
}
wi.validateRecordBlob = rx;
var Si = {};
Object.defineProperty(Si, "__esModule", { value: !0 });
Si.validateRecord = Si.isRecord = Si.toKnownErr = void 0;
const ix = te, Gu = Ie, nx = Ne;
function ax(t) {
  return t instanceof ix.XRPCError, t;
}
Si.toKnownErr = ax;
function sx(t) {
  return (0, Gu.isObj)(t) && (0, Gu.hasProp)(t, "$type") && t.$type === "com.atproto.repo.listRecords#record";
}
Si.isRecord = sx;
function ox(t) {
  return nx.lexicons.validate("com.atproto.repo.listRecords#record", t);
}
Si.validateRecord = ox;
var fn = {};
Object.defineProperty(fn, "__esModule", { value: !0 });
fn.toKnownErr = fn.InvalidSwapError = void 0;
const Bc = te;
class Ic extends Bc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
fn.InvalidSwapError = Ic;
function lx(t) {
  return t instanceof Bc.XRPCError && t.error === "InvalidSwap" ? new Ic(t) : t;
}
fn.toKnownErr = lx;
var Wa = {};
Object.defineProperty(Wa, "__esModule", { value: !0 });
Wa.toKnownErr = void 0;
const ux = te;
function fx(t) {
  return t instanceof ux.XRPCError, t;
}
Wa.toKnownErr = fx;
var Ya = {};
Object.defineProperty(Ya, "__esModule", { value: !0 });
Ya.toKnownErr = void 0;
const cx = te;
function dx(t) {
  return t instanceof cx.XRPCError, t;
}
Ya.toKnownErr = dx;
var Ja = {};
Object.defineProperty(Ja, "__esModule", { value: !0 });
Ja.toKnownErr = void 0;
const px = te;
function hx(t) {
  return t instanceof px.XRPCError, t;
}
Ja.toKnownErr = hx;
var Lr = {};
Object.defineProperty(Lr, "__esModule", { value: !0 });
Lr.toKnownErr = Lr.InvalidEmailError = Lr.InvalidTokenError = Lr.ExpiredTokenError = Lr.AccountNotFoundError = void 0;
const Qa = te;
class Uc extends Qa.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Lr.AccountNotFoundError = Uc;
let Oc = class extends Qa.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Lr.ExpiredTokenError = Oc;
let Kc = class extends Qa.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Lr.InvalidTokenError = Kc;
class Nc extends Qa.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Lr.InvalidEmailError = Nc;
function mx(t) {
  if (t instanceof Qa.XRPCError) {
    if (t.error === "AccountNotFound")
      return new Uc(t);
    if (t.error === "ExpiredToken")
      return new Oc(t);
    if (t.error === "InvalidToken")
      return new Kc(t);
    if (t.error === "InvalidEmail")
      return new Nc(t);
  }
  return t;
}
Lr.toKnownErr = mx;
var Kt = {};
Object.defineProperty(Kt, "__esModule", { value: !0 });
Kt.toKnownErr = Kt.IncompatibleDidDocError = Kt.UnresolvableDidError = Kt.UnsupportedDomainError = Kt.HandleNotAvailableError = Kt.InvalidInviteCodeError = Kt.InvalidPasswordError = Kt.InvalidHandleError = void 0;
const en = te;
class Vc extends en.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Kt.InvalidHandleError = Vc;
class Mc extends en.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Kt.InvalidPasswordError = Mc;
class jc extends en.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Kt.InvalidInviteCodeError = jc;
class Fc extends en.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Kt.HandleNotAvailableError = Fc;
class $c extends en.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Kt.UnsupportedDomainError = $c;
class Gc extends en.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Kt.UnresolvableDidError = Gc;
class qc extends en.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Kt.IncompatibleDidDocError = qc;
function yx(t) {
  if (t instanceof en.XRPCError) {
    if (t.error === "InvalidHandle")
      return new Vc(t);
    if (t.error === "InvalidPassword")
      return new Mc(t);
    if (t.error === "InvalidInviteCode")
      return new jc(t);
    if (t.error === "HandleNotAvailable")
      return new Fc(t);
    if (t.error === "UnsupportedDomain")
      return new $c(t);
    if (t.error === "UnresolvableDid")
      return new Gc(t);
    if (t.error === "IncompatibleDidDoc")
      return new qc(t);
  }
  return t;
}
Kt.toKnownErr = yx;
var jr = {};
Object.defineProperty(jr, "__esModule", { value: !0 });
jr.validateAppPassword = jr.isAppPassword = jr.toKnownErr = jr.AccountTakedownError = void 0;
const Xc = te, qu = Ie, bx = Ne;
let zc = class extends Xc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
jr.AccountTakedownError = zc;
function xx(t) {
  return t instanceof Xc.XRPCError && t.error === "AccountTakedown" ? new zc(t) : t;
}
jr.toKnownErr = xx;
function Ex(t) {
  return (0, qu.isObj)(t) && (0, qu.hasProp)(t, "$type") && t.$type === "com.atproto.server.createAppPassword#appPassword";
}
jr.isAppPassword = Ex;
function gx(t) {
  return bx.lexicons.validate("com.atproto.server.createAppPassword#appPassword", t);
}
jr.validateAppPassword = gx;
var es = {};
Object.defineProperty(es, "__esModule", { value: !0 });
es.toKnownErr = void 0;
const vx = te;
function Rx(t) {
  return t instanceof vx.XRPCError, t;
}
es.toKnownErr = Rx;
var Li = {};
Object.defineProperty(Li, "__esModule", { value: !0 });
Li.validateAccountCodes = Li.isAccountCodes = Li.toKnownErr = void 0;
const Ax = te, Xu = Ie, _x = Ne;
function Tx(t) {
  return t instanceof Ax.XRPCError, t;
}
Li.toKnownErr = Tx;
function wx(t) {
  return (0, Xu.isObj)(t) && (0, Xu.hasProp)(t, "$type") && t.$type === "com.atproto.server.createInviteCodes#accountCodes";
}
Li.isAccountCodes = wx;
function Sx(t) {
  return _x.lexicons.validate("com.atproto.server.createInviteCodes#accountCodes", t);
}
Li.validateAccountCodes = Sx;
var Ci = {};
Object.defineProperty(Ci, "__esModule", { value: !0 });
Ci.toKnownErr = Ci.AuthFactorTokenRequiredError = Ci.AccountTakedownError = void 0;
const Ql = te;
let Hc = class extends Ql.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Ci.AccountTakedownError = Hc;
class Zc extends Ql.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Ci.AuthFactorTokenRequiredError = Zc;
function Lx(t) {
  if (t instanceof Ql.XRPCError) {
    if (t.error === "AccountTakedown")
      return new Hc(t);
    if (t.error === "AuthFactorTokenRequired")
      return new Zc(t);
  }
  return t;
}
Ci.toKnownErr = Lx;
var ts = {};
Object.defineProperty(ts, "__esModule", { value: !0 });
ts.toKnownErr = void 0;
const Cx = te;
function Dx(t) {
  return t instanceof Cx.XRPCError, t;
}
ts.toKnownErr = Dx;
var Di = {};
Object.defineProperty(Di, "__esModule", { value: !0 });
Di.toKnownErr = Di.InvalidTokenError = Di.ExpiredTokenError = void 0;
const eu = te;
let Wc = class extends eu.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Di.ExpiredTokenError = Wc;
let Yc = class extends eu.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Di.InvalidTokenError = Yc;
function kx(t) {
  if (t instanceof eu.XRPCError) {
    if (t.error === "ExpiredToken")
      return new Wc(t);
    if (t.error === "InvalidToken")
      return new Yc(t);
  }
  return t;
}
Di.toKnownErr = kx;
var rs = {};
Object.defineProperty(rs, "__esModule", { value: !0 });
rs.toKnownErr = void 0;
const Px = te;
function Bx(t) {
  return t instanceof Px.XRPCError, t;
}
rs.toKnownErr = Bx;
var Cr = {};
Object.defineProperty(Cr, "__esModule", { value: !0 });
Cr.validateContact = Cr.isContact = Cr.validateLinks = Cr.isLinks = Cr.toKnownErr = void 0;
const Ix = te, No = Ie, Jc = Ne;
function Ux(t) {
  return t instanceof Ix.XRPCError, t;
}
Cr.toKnownErr = Ux;
function Ox(t) {
  return (0, No.isObj)(t) && (0, No.hasProp)(t, "$type") && t.$type === "com.atproto.server.describeServer#links";
}
Cr.isLinks = Ox;
function Kx(t) {
  return Jc.lexicons.validate("com.atproto.server.describeServer#links", t);
}
Cr.validateLinks = Kx;
function Nx(t) {
  return (0, No.isObj)(t) && (0, No.hasProp)(t, "$type") && t.$type === "com.atproto.server.describeServer#contact";
}
Cr.isContact = Nx;
function Vx(t) {
  return Jc.lexicons.validate("com.atproto.server.describeServer#contact", t);
}
Cr.validateContact = Vx;
var cn = {};
Object.defineProperty(cn, "__esModule", { value: !0 });
cn.toKnownErr = cn.DuplicateCreateError = void 0;
const Qc = te;
class ed extends Qc.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
cn.DuplicateCreateError = ed;
function Mx(t) {
  return t instanceof Qc.XRPCError && t.error === "DuplicateCreate" ? new ed(t) : t;
}
cn.toKnownErr = Mx;
var is = {};
Object.defineProperty(is, "__esModule", { value: !0 });
is.toKnownErr = void 0;
const jx = te;
function Fx(t) {
  return t instanceof jx.XRPCError, t;
}
is.toKnownErr = Fx;
var ns = {};
Object.defineProperty(ns, "__esModule", { value: !0 });
ns.toKnownErr = void 0;
const $x = te;
function Gx(t) {
  return t instanceof $x.XRPCError, t;
}
ns.toKnownErr = Gx;
var Fr = {};
Object.defineProperty(Fr, "__esModule", { value: !0 });
Fr.validateAppPassword = Fr.isAppPassword = Fr.toKnownErr = Fr.AccountTakedownError = void 0;
const td = te, zu = Ie, qx = Ne;
let rd = class extends td.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Fr.AccountTakedownError = rd;
function Xx(t) {
  return t instanceof td.XRPCError && t.error === "AccountTakedown" ? new rd(t) : t;
}
Fr.toKnownErr = Xx;
function zx(t) {
  return (0, zu.isObj)(t) && (0, zu.hasProp)(t, "$type") && t.$type === "com.atproto.server.listAppPasswords#appPassword";
}
Fr.isAppPassword = zx;
function Hx(t) {
  return qx.lexicons.validate("com.atproto.server.listAppPasswords#appPassword", t);
}
Fr.validateAppPassword = Hx;
var dn = {};
Object.defineProperty(dn, "__esModule", { value: !0 });
dn.toKnownErr = dn.AccountTakedownError = void 0;
const id = te;
class nd extends id.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
dn.AccountTakedownError = nd;
function Zx(t) {
  return t instanceof id.XRPCError && t.error === "AccountTakedown" ? new nd(t) : t;
}
dn.toKnownErr = Zx;
var as = {};
Object.defineProperty(as, "__esModule", { value: !0 });
as.toKnownErr = void 0;
const Wx = te;
function Yx(t) {
  return t instanceof Wx.XRPCError, t;
}
as.toKnownErr = Yx;
var ss = {};
Object.defineProperty(ss, "__esModule", { value: !0 });
ss.toKnownErr = void 0;
const Jx = te;
function Qx(t) {
  return t instanceof Jx.XRPCError, t;
}
ss.toKnownErr = Qx;
var os = {};
Object.defineProperty(os, "__esModule", { value: !0 });
os.toKnownErr = void 0;
const eE = te;
function tE(t) {
  return t instanceof eE.XRPCError, t;
}
os.toKnownErr = tE;
var ls = {};
Object.defineProperty(ls, "__esModule", { value: !0 });
ls.toKnownErr = void 0;
const rE = te;
function iE(t) {
  return t instanceof rE.XRPCError, t;
}
ls.toKnownErr = iE;
var us = {};
Object.defineProperty(us, "__esModule", { value: !0 });
us.toKnownErr = void 0;
const nE = te;
function aE(t) {
  return t instanceof nE.XRPCError, t;
}
us.toKnownErr = aE;
var ki = {};
Object.defineProperty(ki, "__esModule", { value: !0 });
ki.toKnownErr = ki.InvalidTokenError = ki.ExpiredTokenError = void 0;
const tu = te;
let ad = class extends tu.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
ki.ExpiredTokenError = ad;
let sd = class extends tu.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
ki.InvalidTokenError = sd;
function sE(t) {
  if (t instanceof tu.XRPCError) {
    if (t.error === "ExpiredToken")
      return new ad(t);
    if (t.error === "InvalidToken")
      return new sd(t);
  }
  return t;
}
ki.toKnownErr = sE;
var fs = {};
Object.defineProperty(fs, "__esModule", { value: !0 });
fs.toKnownErr = void 0;
const oE = te;
function lE(t) {
  return t instanceof oE.XRPCError, t;
}
fs.toKnownErr = lE;
var $r = {};
Object.defineProperty($r, "__esModule", { value: !0 });
$r.toKnownErr = $r.TokenRequiredError = $r.InvalidTokenError = $r.ExpiredTokenError = void 0;
const el = te;
class od extends el.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
$r.ExpiredTokenError = od;
class ld extends el.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
$r.InvalidTokenError = ld;
class ud extends el.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
$r.TokenRequiredError = ud;
function uE(t) {
  if (t instanceof el.XRPCError) {
    if (t.error === "ExpiredToken")
      return new od(t);
    if (t.error === "InvalidToken")
      return new ld(t);
    if (t.error === "TokenRequired")
      return new ud(t);
  }
  return t;
}
$r.toKnownErr = uE;
var cs = {};
Object.defineProperty(cs, "__esModule", { value: !0 });
cs.toKnownErr = void 0;
const fE = te;
function cE(t) {
  return t instanceof fE.XRPCError, t;
}
cs.toKnownErr = cE;
var ds = {};
Object.defineProperty(ds, "__esModule", { value: !0 });
ds.toKnownErr = void 0;
const dE = te;
function pE(t) {
  return t instanceof dE.XRPCError, t;
}
ds.toKnownErr = pE;
var ps = {};
Object.defineProperty(ps, "__esModule", { value: !0 });
ps.toKnownErr = void 0;
const hE = te;
function mE(t) {
  return t instanceof hE.XRPCError, t;
}
ps.toKnownErr = mE;
var pn = {};
Object.defineProperty(pn, "__esModule", { value: !0 });
pn.toKnownErr = pn.HeadNotFoundError = void 0;
const fd = te;
class cd extends fd.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
pn.HeadNotFoundError = cd;
function yE(t) {
  return t instanceof fd.XRPCError && t.error === "HeadNotFound" ? new cd(t) : t;
}
pn.toKnownErr = yE;
var hn = {};
Object.defineProperty(hn, "__esModule", { value: !0 });
hn.toKnownErr = hn.RepoNotFoundError = void 0;
const dd = te;
let pd = class extends dd.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
hn.RepoNotFoundError = pd;
function bE(t) {
  return t instanceof dd.XRPCError && t.error === "RepoNotFound" ? new pd(t) : t;
}
hn.toKnownErr = bE;
var hs = {};
Object.defineProperty(hs, "__esModule", { value: !0 });
hs.toKnownErr = void 0;
const xE = te;
function EE(t) {
  return t instanceof xE.XRPCError, t;
}
hs.toKnownErr = EE;
var ms = {};
Object.defineProperty(ms, "__esModule", { value: !0 });
ms.toKnownErr = void 0;
const gE = te;
function vE(t) {
  return t instanceof gE.XRPCError, t;
}
ms.toKnownErr = vE;
var ys = {};
Object.defineProperty(ys, "__esModule", { value: !0 });
ys.toKnownErr = void 0;
const RE = te;
function AE(t) {
  return t instanceof RE.XRPCError, t;
}
ys.toKnownErr = AE;
var Pi = {};
Object.defineProperty(Pi, "__esModule", { value: !0 });
Pi.validateRepo = Pi.isRepo = Pi.toKnownErr = void 0;
const _E = te, Hu = Ie, TE = Ne;
function wE(t) {
  return t instanceof _E.XRPCError, t;
}
Pi.toKnownErr = wE;
function SE(t) {
  return (0, Hu.isObj)(t) && (0, Hu.hasProp)(t, "$type") && t.$type === "com.atproto.sync.listRepos#repo";
}
Pi.isRepo = SE;
function LE(t) {
  return TE.lexicons.validate("com.atproto.sync.listRepos#repo", t);
}
Pi.validateRepo = LE;
var bs = {};
Object.defineProperty(bs, "__esModule", { value: !0 });
bs.toKnownErr = void 0;
const CE = te;
function DE(t) {
  return t instanceof CE.XRPCError, t;
}
bs.toKnownErr = DE;
var xs = {};
Object.defineProperty(xs, "__esModule", { value: !0 });
xs.toKnownErr = void 0;
const kE = te;
function PE(t) {
  return t instanceof kE.XRPCError, t;
}
xs.toKnownErr = PE;
var Es = {};
Object.defineProperty(Es, "__esModule", { value: !0 });
Es.toKnownErr = void 0;
const BE = te;
function IE(t) {
  return t instanceof BE.XRPCError, t;
}
Es.toKnownErr = IE;
var gs = {};
Object.defineProperty(gs, "__esModule", { value: !0 });
gs.toKnownErr = void 0;
const UE = te;
function OE(t) {
  return t instanceof UE.XRPCError, t;
}
gs.toKnownErr = OE;
var vs = {};
Object.defineProperty(vs, "__esModule", { value: !0 });
vs.toKnownErr = void 0;
const KE = te;
function NE(t) {
  return t instanceof KE.XRPCError, t;
}
vs.toKnownErr = NE;
var Rs = {};
Object.defineProperty(Rs, "__esModule", { value: !0 });
Rs.toKnownErr = void 0;
const VE = te;
function ME(t) {
  return t instanceof VE.XRPCError, t;
}
Rs.toKnownErr = ME;
var As = {};
Object.defineProperty(As, "__esModule", { value: !0 });
As.toKnownErr = void 0;
const jE = te;
function FE(t) {
  return t instanceof jE.XRPCError, t;
}
As.toKnownErr = FE;
var _s = {};
Object.defineProperty(_s, "__esModule", { value: !0 });
_s.toKnownErr = void 0;
const $E = te;
function GE(t) {
  return t instanceof $E.XRPCError, t;
}
_s.toKnownErr = GE;
var Ts = {};
Object.defineProperty(Ts, "__esModule", { value: !0 });
Ts.toKnownErr = void 0;
const qE = te;
function XE(t) {
  return t instanceof qE.XRPCError, t;
}
Ts.toKnownErr = XE;
var ws = {};
Object.defineProperty(ws, "__esModule", { value: !0 });
ws.toKnownErr = void 0;
const zE = te;
function HE(t) {
  return t instanceof zE.XRPCError, t;
}
ws.toKnownErr = HE;
var Ss = {};
Object.defineProperty(Ss, "__esModule", { value: !0 });
Ss.toKnownErr = void 0;
const ZE = te;
function WE(t) {
  return t instanceof ZE.XRPCError, t;
}
Ss.toKnownErr = WE;
var Ls = {};
Object.defineProperty(Ls, "__esModule", { value: !0 });
Ls.toKnownErr = void 0;
const YE = te;
function JE(t) {
  return t instanceof YE.XRPCError, t;
}
Ls.toKnownErr = JE;
var Dr = {};
Object.defineProperty(Dr, "__esModule", { value: !0 });
Dr.validateLinks = Dr.isLinks = Dr.validateFeed = Dr.isFeed = Dr.toKnownErr = void 0;
const QE = te, Vo = Ie, hd = Ne;
function eg(t) {
  return t instanceof QE.XRPCError, t;
}
Dr.toKnownErr = eg;
function tg(t) {
  return (0, Vo.isObj)(t) && (0, Vo.hasProp)(t, "$type") && t.$type === "app.bsky.feed.describeFeedGenerator#feed";
}
Dr.isFeed = tg;
function rg(t) {
  return hd.lexicons.validate("app.bsky.feed.describeFeedGenerator#feed", t);
}
Dr.validateFeed = rg;
function ig(t) {
  return (0, Vo.isObj)(t) && (0, Vo.hasProp)(t, "$type") && t.$type === "app.bsky.feed.describeFeedGenerator#links";
}
Dr.isLinks = ig;
function ng(t) {
  return hd.lexicons.validate("app.bsky.feed.describeFeedGenerator#links", t);
}
Dr.validateLinks = ng;
var Cs = {};
Object.defineProperty(Cs, "__esModule", { value: !0 });
Cs.toKnownErr = void 0;
const ag = te;
function sg(t) {
  return t instanceof ag.XRPCError, t;
}
Cs.toKnownErr = sg;
var Bi = {};
Object.defineProperty(Bi, "__esModule", { value: !0 });
Bi.toKnownErr = Bi.BlockedByActorError = Bi.BlockedActorError = void 0;
const ru = te;
let md = class extends ru.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Bi.BlockedActorError = md;
let yd = class extends ru.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
Bi.BlockedByActorError = yd;
function og(t) {
  if (t instanceof ru.XRPCError) {
    if (t.error === "BlockedActor")
      return new md(t);
    if (t.error === "BlockedByActor")
      return new yd(t);
  }
  return t;
}
Bi.toKnownErr = og;
var Ii = {};
Object.defineProperty(Ii, "__esModule", { value: !0 });
Ii.toKnownErr = Ii.BlockedByActorError = Ii.BlockedActorError = void 0;
const iu = te;
class bd extends iu.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Ii.BlockedActorError = bd;
class xd extends iu.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Ii.BlockedByActorError = xd;
function lg(t) {
  if (t instanceof iu.XRPCError) {
    if (t.error === "BlockedActor")
      return new bd(t);
    if (t.error === "BlockedByActor")
      return new xd(t);
  }
  return t;
}
Ii.toKnownErr = lg;
var mn = {};
Object.defineProperty(mn, "__esModule", { value: !0 });
mn.toKnownErr = mn.UnknownFeedError = void 0;
const Ed = te;
let gd = class extends Ed.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
mn.UnknownFeedError = gd;
function ug(t) {
  return t instanceof Ed.XRPCError && t.error === "UnknownFeed" ? new gd(t) : t;
}
mn.toKnownErr = ug;
var Ds = {};
Object.defineProperty(Ds, "__esModule", { value: !0 });
Ds.toKnownErr = void 0;
const fg = te;
function cg(t) {
  return t instanceof fg.XRPCError, t;
}
Ds.toKnownErr = cg;
var ks = {};
Object.defineProperty(ks, "__esModule", { value: !0 });
ks.toKnownErr = void 0;
const dg = te;
function pg(t) {
  return t instanceof dg.XRPCError, t;
}
ks.toKnownErr = pg;
var yn = {};
Object.defineProperty(yn, "__esModule", { value: !0 });
yn.toKnownErr = yn.UnknownFeedError = void 0;
const vd = te;
class Rd extends vd.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
yn.UnknownFeedError = Rd;
function hg(t) {
  return t instanceof vd.XRPCError && t.error === "UnknownFeed" ? new Rd(t) : t;
}
yn.toKnownErr = hg;
var Ui = {};
Object.defineProperty(Ui, "__esModule", { value: !0 });
Ui.validateLike = Ui.isLike = Ui.toKnownErr = void 0;
const mg = te, Zu = Ie, yg = Ne;
function bg(t) {
  return t instanceof mg.XRPCError, t;
}
Ui.toKnownErr = bg;
function xg(t) {
  return (0, Zu.isObj)(t) && (0, Zu.hasProp)(t, "$type") && t.$type === "app.bsky.feed.getLikes#like";
}
Ui.isLike = xg;
function Eg(t) {
  return yg.lexicons.validate("app.bsky.feed.getLikes#like", t);
}
Ui.validateLike = Eg;
var bn = {};
Object.defineProperty(bn, "__esModule", { value: !0 });
bn.toKnownErr = bn.UnknownListError = void 0;
const Ad = te;
class _d extends Ad.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
bn.UnknownListError = _d;
function gg(t) {
  return t instanceof Ad.XRPCError && t.error === "UnknownList" ? new _d(t) : t;
}
bn.toKnownErr = gg;
var xn = {};
Object.defineProperty(xn, "__esModule", { value: !0 });
xn.toKnownErr = xn.NotFoundError = void 0;
const Td = te;
class wd extends Td.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
xn.NotFoundError = wd;
function vg(t) {
  return t instanceof Td.XRPCError && t.error === "NotFound" ? new wd(t) : t;
}
xn.toKnownErr = vg;
var Ps = {};
Object.defineProperty(Ps, "__esModule", { value: !0 });
Ps.toKnownErr = void 0;
const Rg = te;
function Ag(t) {
  return t instanceof Rg.XRPCError, t;
}
Ps.toKnownErr = Ag;
var Bs = {};
Object.defineProperty(Bs, "__esModule", { value: !0 });
Bs.toKnownErr = void 0;
const _g = te;
function Tg(t) {
  return t instanceof _g.XRPCError, t;
}
Bs.toKnownErr = Tg;
var Is = {};
Object.defineProperty(Is, "__esModule", { value: !0 });
Is.toKnownErr = void 0;
const wg = te;
function Sg(t) {
  return t instanceof wg.XRPCError, t;
}
Is.toKnownErr = Sg;
var Us = {};
Object.defineProperty(Us, "__esModule", { value: !0 });
Us.toKnownErr = void 0;
const Lg = te;
function Cg(t) {
  return t instanceof Lg.XRPCError, t;
}
Us.toKnownErr = Cg;
var En = {};
Object.defineProperty(En, "__esModule", { value: !0 });
En.toKnownErr = En.BadQueryStringError = void 0;
const Sd = te;
let Ld = class extends Sd.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
En.BadQueryStringError = Ld;
function Dg(t) {
  return t instanceof Sd.XRPCError && t.error === "BadQueryString" ? new Ld(t) : t;
}
En.toKnownErr = Dg;
var Os = {};
Object.defineProperty(Os, "__esModule", { value: !0 });
Os.toKnownErr = void 0;
const kg = te;
function Pg(t) {
  return t instanceof kg.XRPCError, t;
}
Os.toKnownErr = Pg;
var Ks = {};
Object.defineProperty(Ks, "__esModule", { value: !0 });
Ks.toKnownErr = void 0;
const Bg = te;
function Ig(t) {
  return t instanceof Bg.XRPCError, t;
}
Ks.toKnownErr = Ig;
var Ns = {};
Object.defineProperty(Ns, "__esModule", { value: !0 });
Ns.toKnownErr = void 0;
const Ug = te;
function Og(t) {
  return t instanceof Ug.XRPCError, t;
}
Ns.toKnownErr = Og;
var Vs = {};
Object.defineProperty(Vs, "__esModule", { value: !0 });
Vs.toKnownErr = void 0;
const Kg = te;
function Ng(t) {
  return t instanceof Kg.XRPCError, t;
}
Vs.toKnownErr = Ng;
var Ms = {};
Object.defineProperty(Ms, "__esModule", { value: !0 });
Ms.toKnownErr = void 0;
const Vg = te;
function Mg(t) {
  return t instanceof Vg.XRPCError, t;
}
Ms.toKnownErr = Mg;
var js = {};
Object.defineProperty(js, "__esModule", { value: !0 });
js.toKnownErr = void 0;
const jg = te;
function Fg(t) {
  return t instanceof jg.XRPCError, t;
}
js.toKnownErr = Fg;
var Fs = {};
Object.defineProperty(Fs, "__esModule", { value: !0 });
Fs.toKnownErr = void 0;
const $g = te;
function Gg(t) {
  return t instanceof $g.XRPCError, t;
}
Fs.toKnownErr = Gg;
var $s = {};
Object.defineProperty($s, "__esModule", { value: !0 });
$s.toKnownErr = void 0;
const qg = te;
function Xg(t) {
  return t instanceof qg.XRPCError, t;
}
$s.toKnownErr = Xg;
var Gs = {};
Object.defineProperty(Gs, "__esModule", { value: !0 });
Gs.toKnownErr = void 0;
const zg = te;
function Hg(t) {
  return t instanceof zg.XRPCError, t;
}
Gs.toKnownErr = Hg;
var gn = {};
Object.defineProperty(gn, "__esModule", { value: !0 });
gn.toKnownErr = gn.ActorNotFoundError = void 0;
const Cd = te;
class Dd extends Cd.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
gn.ActorNotFoundError = Dd;
function Zg(t) {
  return t instanceof Cd.XRPCError && t.error === "ActorNotFound" ? new Dd(t) : t;
}
gn.toKnownErr = Zg;
var qs = {};
Object.defineProperty(qs, "__esModule", { value: !0 });
qs.toKnownErr = void 0;
const Wg = te;
function Yg(t) {
  return t instanceof Wg.XRPCError, t;
}
qs.toKnownErr = Yg;
var Xs = {};
Object.defineProperty(Xs, "__esModule", { value: !0 });
Xs.toKnownErr = void 0;
const Jg = te;
function Qg(t) {
  return t instanceof Jg.XRPCError, t;
}
Xs.toKnownErr = Qg;
var zs = {};
Object.defineProperty(zs, "__esModule", { value: !0 });
zs.toKnownErr = void 0;
const ev = te;
function tv(t) {
  return t instanceof ev.XRPCError, t;
}
zs.toKnownErr = tv;
var Hs = {};
Object.defineProperty(Hs, "__esModule", { value: !0 });
Hs.toKnownErr = void 0;
const rv = te;
function iv(t) {
  return t instanceof rv.XRPCError, t;
}
Hs.toKnownErr = iv;
var Zs = {};
Object.defineProperty(Zs, "__esModule", { value: !0 });
Zs.toKnownErr = void 0;
const nv = te;
function av(t) {
  return t instanceof nv.XRPCError, t;
}
Zs.toKnownErr = av;
var Ws = {};
Object.defineProperty(Ws, "__esModule", { value: !0 });
Ws.toKnownErr = void 0;
const sv = te;
function ov(t) {
  return t instanceof sv.XRPCError, t;
}
Ws.toKnownErr = ov;
var Ys = {};
Object.defineProperty(Ys, "__esModule", { value: !0 });
Ys.toKnownErr = void 0;
const lv = te;
function uv(t) {
  return t instanceof lv.XRPCError, t;
}
Ys.toKnownErr = uv;
var Oi = {};
Object.defineProperty(Oi, "__esModule", { value: !0 });
Oi.validateNotification = Oi.isNotification = Oi.toKnownErr = void 0;
const fv = te, Wu = Ie, cv = Ne;
function dv(t) {
  return t instanceof fv.XRPCError, t;
}
Oi.toKnownErr = dv;
function pv(t) {
  return (0, Wu.isObj)(t) && (0, Wu.hasProp)(t, "$type") && t.$type === "app.bsky.notification.listNotifications#notification";
}
Oi.isNotification = pv;
function hv(t) {
  return cv.lexicons.validate("app.bsky.notification.listNotifications#notification", t);
}
Oi.validateNotification = hv;
var Js = {};
Object.defineProperty(Js, "__esModule", { value: !0 });
Js.toKnownErr = void 0;
const mv = te;
function yv(t) {
  return t instanceof mv.XRPCError, t;
}
Js.toKnownErr = yv;
var Qs = {};
Object.defineProperty(Qs, "__esModule", { value: !0 });
Qs.toKnownErr = void 0;
const bv = te;
function xv(t) {
  return t instanceof bv.XRPCError, t;
}
Qs.toKnownErr = xv;
var eo = {};
Object.defineProperty(eo, "__esModule", { value: !0 });
eo.toKnownErr = void 0;
const Ev = te;
function gv(t) {
  return t instanceof Ev.XRPCError, t;
}
eo.toKnownErr = gv;
var to = {};
Object.defineProperty(to, "__esModule", { value: !0 });
to.toKnownErr = void 0;
const vv = te;
function Rv(t) {
  return t instanceof vv.XRPCError, t;
}
to.toKnownErr = Rv;
var Ki = {};
Object.defineProperty(Ki, "__esModule", { value: !0 });
Ki.validateSuggestion = Ki.isSuggestion = Ki.toKnownErr = void 0;
const Av = te, Yu = Ie, _v = Ne;
function Tv(t) {
  return t instanceof Av.XRPCError, t;
}
Ki.toKnownErr = Tv;
function wv(t) {
  return (0, Yu.isObj)(t) && (0, Yu.hasProp)(t, "$type") && t.$type === "app.bsky.unspecced.getTaggedSuggestions#suggestion";
}
Ki.isSuggestion = wv;
function Sv(t) {
  return _v.lexicons.validate("app.bsky.unspecced.getTaggedSuggestions#suggestion", t);
}
Ki.validateSuggestion = Sv;
var vn = {};
Object.defineProperty(vn, "__esModule", { value: !0 });
vn.toKnownErr = vn.BadQueryStringError = void 0;
const kd = te;
let Pd = class extends kd.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
};
vn.BadQueryStringError = Pd;
function Lv(t) {
  return t instanceof kd.XRPCError && t.error === "BadQueryString" ? new Pd(t) : t;
}
vn.toKnownErr = Lv;
var Rn = {};
Object.defineProperty(Rn, "__esModule", { value: !0 });
Rn.toKnownErr = Rn.BadQueryStringError = void 0;
const Bd = te;
class Id extends Bd.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Rn.BadQueryStringError = Id;
function Cv(t) {
  return t instanceof Bd.XRPCError && t.error === "BadQueryString" ? new Id(t) : t;
}
Rn.toKnownErr = Cv;
var ro = {};
Object.defineProperty(ro, "__esModule", { value: !0 });
ro.toKnownErr = void 0;
const Dv = te;
function kv(t) {
  return t instanceof Dv.XRPCError, t;
}
ro.toKnownErr = kv;
var io = {};
Object.defineProperty(io, "__esModule", { value: !0 });
io.toKnownErr = void 0;
const Pv = te;
function Bv(t) {
  return t instanceof Pv.XRPCError, t;
}
io.toKnownErr = Bv;
var no = {};
Object.defineProperty(no, "__esModule", { value: !0 });
no.toKnownErr = void 0;
const Iv = te;
function Uv(t) {
  return t instanceof Iv.XRPCError, t;
}
no.toKnownErr = Uv;
var ao = {};
Object.defineProperty(ao, "__esModule", { value: !0 });
ao.toKnownErr = void 0;
const Ov = te;
function Kv(t) {
  return t instanceof Ov.XRPCError, t;
}
ao.toKnownErr = Kv;
var An = {};
Object.defineProperty(An, "__esModule", { value: !0 });
An.toKnownErr = An.SubjectHasActionError = void 0;
const Ud = te;
class Od extends Ud.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
An.SubjectHasActionError = Od;
function Nv(t) {
  return t instanceof Ud.XRPCError && t.error === "SubjectHasAction" ? new Od(t) : t;
}
An.toKnownErr = Nv;
var so = {};
Object.defineProperty(so, "__esModule", { value: !0 });
so.toKnownErr = void 0;
const Vv = te;
function Mv(t) {
  return t instanceof Vv.XRPCError, t;
}
so.toKnownErr = Mv;
var _n = {};
Object.defineProperty(_n, "__esModule", { value: !0 });
_n.toKnownErr = _n.RecordNotFoundError = void 0;
const Kd = te;
class Nd extends Kd.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
_n.RecordNotFoundError = Nd;
function jv(t) {
  return t instanceof Kd.XRPCError && t.error === "RecordNotFound" ? new Nd(t) : t;
}
_n.toKnownErr = jv;
var Tn = {};
Object.defineProperty(Tn, "__esModule", { value: !0 });
Tn.toKnownErr = Tn.RepoNotFoundError = void 0;
const Vd = te;
class Md extends Vd.XRPCError {
  constructor(e) {
    super(e.status, e.error, e.message, e.headers);
  }
}
Tn.RepoNotFoundError = Md;
function Fv(t) {
  return t instanceof Vd.XRPCError && t.error === "RepoNotFound" ? new Md(t) : t;
}
Tn.toKnownErr = Fv;
var oo = {};
Object.defineProperty(oo, "__esModule", { value: !0 });
oo.toKnownErr = void 0;
const $v = te;
function Gv(t) {
  return t instanceof $v.XRPCError, t;
}
oo.toKnownErr = Gv;
var lo = {};
Object.defineProperty(lo, "__esModule", { value: !0 });
lo.toKnownErr = void 0;
const qv = te;
function Xv(t) {
  return t instanceof qv.XRPCError, t;
}
lo.toKnownErr = Xv;
var uo = {};
Object.defineProperty(uo, "__esModule", { value: !0 });
uo.toKnownErr = void 0;
const zv = te;
function Hv(t) {
  return t instanceof zv.XRPCError, t;
}
uo.toKnownErr = Hv;
var Xt = {};
Object.defineProperty(Xt, "__esModule", { value: !0 });
Xt.validateRepoBlobRef = Xt.isRepoBlobRef = Xt.validateRepoRef = Xt.isRepoRef = Xt.validateAccountView = Xt.isAccountView = Xt.validateStatusAttr = Xt.isStatusAttr = void 0;
const qi = Ie, tl = Ne;
function Zv(t) {
  return (0, qi.isObj)(t) && (0, qi.hasProp)(t, "$type") && t.$type === "com.atproto.admin.defs#statusAttr";
}
Xt.isStatusAttr = Zv;
function Wv(t) {
  return tl.lexicons.validate("com.atproto.admin.defs#statusAttr", t);
}
Xt.validateStatusAttr = Wv;
function Yv(t) {
  return (0, qi.isObj)(t) && (0, qi.hasProp)(t, "$type") && t.$type === "com.atproto.admin.defs#accountView";
}
Xt.isAccountView = Yv;
function Jv(t) {
  return tl.lexicons.validate("com.atproto.admin.defs#accountView", t);
}
Xt.validateAccountView = Jv;
function Qv(t) {
  return (0, qi.isObj)(t) && (0, qi.hasProp)(t, "$type") && t.$type === "com.atproto.admin.defs#repoRef";
}
Xt.isRepoRef = Qv;
function eR(t) {
  return tl.lexicons.validate("com.atproto.admin.defs#repoRef", t);
}
Xt.validateRepoRef = eR;
function tR(t) {
  return (0, qi.isObj)(t) && (0, qi.hasProp)(t, "$type") && t.$type === "com.atproto.admin.defs#repoBlobRef";
}
Xt.isRepoBlobRef = tR;
function rR(t) {
  return tl.lexicons.validate("com.atproto.admin.defs#repoBlobRef", t);
}
Xt.validateRepoBlobRef = rR;
var wt = {};
Object.defineProperty(wt, "__esModule", { value: !0 });
wt.validateLabelValueDefinitionStrings = wt.isLabelValueDefinitionStrings = wt.validateLabelValueDefinition = wt.isLabelValueDefinition = wt.validateSelfLabel = wt.isSelfLabel = wt.validateSelfLabels = wt.isSelfLabels = wt.validateLabel = wt.isLabel = void 0;
const si = Ie, fo = Ne;
function iR(t) {
  return (0, si.isObj)(t) && (0, si.hasProp)(t, "$type") && t.$type === "com.atproto.label.defs#label";
}
wt.isLabel = iR;
function nR(t) {
  return fo.lexicons.validate("com.atproto.label.defs#label", t);
}
wt.validateLabel = nR;
function aR(t) {
  return (0, si.isObj)(t) && (0, si.hasProp)(t, "$type") && t.$type === "com.atproto.label.defs#selfLabels";
}
wt.isSelfLabels = aR;
function sR(t) {
  return fo.lexicons.validate("com.atproto.label.defs#selfLabels", t);
}
wt.validateSelfLabels = sR;
function oR(t) {
  return (0, si.isObj)(t) && (0, si.hasProp)(t, "$type") && t.$type === "com.atproto.label.defs#selfLabel";
}
wt.isSelfLabel = oR;
function lR(t) {
  return fo.lexicons.validate("com.atproto.label.defs#selfLabel", t);
}
wt.validateSelfLabel = lR;
function uR(t) {
  return (0, si.isObj)(t) && (0, si.hasProp)(t, "$type") && t.$type === "com.atproto.label.defs#labelValueDefinition";
}
wt.isLabelValueDefinition = uR;
function fR(t) {
  return fo.lexicons.validate("com.atproto.label.defs#labelValueDefinition", t);
}
wt.validateLabelValueDefinition = fR;
function cR(t) {
  return (0, si.isObj)(t) && (0, si.hasProp)(t, "$type") && t.$type === "com.atproto.label.defs#labelValueDefinitionStrings";
}
wt.isLabelValueDefinitionStrings = cR;
function dR(t) {
  return fo.lexicons.validate("com.atproto.label.defs#labelValueDefinitionStrings", t);
}
wt.validateLabelValueDefinitionStrings = dR;
var Qr = {};
Object.defineProperty(Qr, "__esModule", { value: !0 });
Qr.validateInfo = Qr.isInfo = Qr.validateLabels = Qr.isLabels = void 0;
const Mo = Ie, jd = Ne;
function pR(t) {
  return (0, Mo.isObj)(t) && (0, Mo.hasProp)(t, "$type") && t.$type === "com.atproto.label.subscribeLabels#labels";
}
Qr.isLabels = pR;
function hR(t) {
  return jd.lexicons.validate("com.atproto.label.subscribeLabels#labels", t);
}
Qr.validateLabels = hR;
function mR(t) {
  return (0, Mo.isObj)(t) && (0, Mo.hasProp)(t, "$type") && t.$type === "com.atproto.label.subscribeLabels#info";
}
Qr.isInfo = mR;
function yR(t) {
  return jd.lexicons.validate("com.atproto.label.subscribeLabels#info", t);
}
Qr.validateInfo = yR;
var or = {};
Object.defineProperty(or, "__esModule", { value: !0 });
or.REASONAPPEAL = or.REASONOTHER = or.REASONRUDE = or.REASONSEXUAL = or.REASONMISLEADING = or.REASONVIOLATION = or.REASONSPAM = void 0;
or.REASONSPAM = "com.atproto.moderation.defs#reasonSpam";
or.REASONVIOLATION = "com.atproto.moderation.defs#reasonViolation";
or.REASONMISLEADING = "com.atproto.moderation.defs#reasonMisleading";
or.REASONSEXUAL = "com.atproto.moderation.defs#reasonSexual";
or.REASONRUDE = "com.atproto.moderation.defs#reasonRude";
or.REASONOTHER = "com.atproto.moderation.defs#reasonOther";
or.REASONAPPEAL = "com.atproto.moderation.defs#reasonAppeal";
var Mn = {};
Object.defineProperty(Mn, "__esModule", { value: !0 });
Mn.validateMain = Mn.isMain = void 0;
const Ju = Ie, bR = Ne;
function xR(t) {
  return (0, Ju.isObj)(t) && (0, Ju.hasProp)(t, "$type") && (t.$type === "com.atproto.repo.strongRef#main" || t.$type === "com.atproto.repo.strongRef");
}
Mn.isMain = xR;
function ER(t) {
  return bR.lexicons.validate("com.atproto.repo.strongRef#main", t);
}
Mn.validateMain = ER;
var ei = {};
Object.defineProperty(ei, "__esModule", { value: !0 });
ei.validateInviteCodeUse = ei.isInviteCodeUse = ei.validateInviteCode = ei.isInviteCode = void 0;
const jo = Ie, Fd = Ne;
function gR(t) {
  return (0, jo.isObj)(t) && (0, jo.hasProp)(t, "$type") && t.$type === "com.atproto.server.defs#inviteCode";
}
ei.isInviteCode = gR;
function vR(t) {
  return Fd.lexicons.validate("com.atproto.server.defs#inviteCode", t);
}
ei.validateInviteCode = vR;
function RR(t) {
  return (0, jo.isObj)(t) && (0, jo.hasProp)(t, "$type") && t.$type === "com.atproto.server.defs#inviteCodeUse";
}
ei.isInviteCodeUse = RR;
function AR(t) {
  return Fd.lexicons.validate("com.atproto.server.defs#inviteCodeUse", t);
}
ei.validateInviteCodeUse = AR;
var it = {};
Object.defineProperty(it, "__esModule", { value: !0 });
it.validateRepoOp = it.isRepoOp = it.validateInfo = it.isInfo = it.validateTombstone = it.isTombstone = it.validateMigrate = it.isMigrate = it.validateHandle = it.isHandle = it.validateIdentity = it.isIdentity = it.validateCommit = it.isCommit = void 0;
const gr = Ie, Sn = Ne;
function _R(t) {
  return (0, gr.isObj)(t) && (0, gr.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#commit";
}
it.isCommit = _R;
function TR(t) {
  return Sn.lexicons.validate("com.atproto.sync.subscribeRepos#commit", t);
}
it.validateCommit = TR;
function wR(t) {
  return (0, gr.isObj)(t) && (0, gr.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#identity";
}
it.isIdentity = wR;
function SR(t) {
  return Sn.lexicons.validate("com.atproto.sync.subscribeRepos#identity", t);
}
it.validateIdentity = SR;
function LR(t) {
  return (0, gr.isObj)(t) && (0, gr.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#handle";
}
it.isHandle = LR;
function CR(t) {
  return Sn.lexicons.validate("com.atproto.sync.subscribeRepos#handle", t);
}
it.validateHandle = CR;
function DR(t) {
  return (0, gr.isObj)(t) && (0, gr.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#migrate";
}
it.isMigrate = DR;
function kR(t) {
  return Sn.lexicons.validate("com.atproto.sync.subscribeRepos#migrate", t);
}
it.validateMigrate = kR;
function PR(t) {
  return (0, gr.isObj)(t) && (0, gr.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#tombstone";
}
it.isTombstone = PR;
function BR(t) {
  return Sn.lexicons.validate("com.atproto.sync.subscribeRepos#tombstone", t);
}
it.validateTombstone = BR;
function IR(t) {
  return (0, gr.isObj)(t) && (0, gr.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#info";
}
it.isInfo = IR;
function UR(t) {
  return Sn.lexicons.validate("com.atproto.sync.subscribeRepos#info", t);
}
it.validateInfo = UR;
function OR(t) {
  return (0, gr.isObj)(t) && (0, gr.hasProp)(t, "$type") && t.$type === "com.atproto.sync.subscribeRepos#repoOp";
}
it.isRepoOp = OR;
function KR(t) {
  return Sn.lexicons.validate("com.atproto.sync.subscribeRepos#repoOp", t);
}
it.validateRepoOp = KR;
var ge = {};
Object.defineProperty(ge, "__esModule", { value: !0 });
ge.validateLabelerPrefItem = ge.isLabelerPrefItem = ge.validateLabelersPref = ge.isLabelersPref = ge.validateHiddenPostsPref = ge.isHiddenPostsPref = ge.validateMutedWordsPref = ge.isMutedWordsPref = ge.validateMutedWord = ge.isMutedWord = ge.validateInterestsPref = ge.isInterestsPref = ge.validateThreadViewPref = ge.isThreadViewPref = ge.validateFeedViewPref = ge.isFeedViewPref = ge.validatePersonalDetailsPref = ge.isPersonalDetailsPref = ge.validateSavedFeedsPref = ge.isSavedFeedsPref = ge.validateContentLabelPref = ge.isContentLabelPref = ge.validateAdultContentPref = ge.isAdultContentPref = ge.validateViewerState = ge.isViewerState = ge.validateProfileAssociated = ge.isProfileAssociated = ge.validateProfileViewDetailed = ge.isProfileViewDetailed = ge.validateProfileView = ge.isProfileView = ge.validateProfileViewBasic = ge.isProfileViewBasic = void 0;
const ze = Ie, ir = Ne;
function NR(t) {
  return (0, ze.isObj)(t) && (0, ze.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#profileViewBasic";
}
ge.isProfileViewBasic = NR;
function VR(t) {
  return ir.lexicons.validate("app.bsky.actor.defs#profileViewBasic", t);
}
ge.validateProfileViewBasic = VR;
function MR(t) {
  return (0, ze.isObj)(t) && (0, ze.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#profileView";
}
ge.isProfileView = MR;
function jR(t) {
  return ir.lexicons.validate("app.bsky.actor.defs#profileView", t);
}
ge.validateProfileView = jR;
function FR(t) {
  return (0, ze.isObj)(t) && (0, ze.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#profileViewDetailed";
}
ge.isProfileViewDetailed = FR;
function $R(t) {
  return ir.lexicons.validate("app.bsky.actor.defs#profileViewDetailed", t);
}
ge.validateProfileViewDetailed = $R;
function GR(t) {
  return (0, ze.isObj)(t) && (0, ze.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#profileAssociated";
}
ge.isProfileAssociated = GR;
function qR(t) {
  return ir.lexicons.validate("app.bsky.actor.defs#profileAssociated", t);
}
ge.validateProfileAssociated = qR;
function XR(t) {
  return (0, ze.isObj)(t) && (0, ze.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#viewerState";
}
ge.isViewerState = XR;
function zR(t) {
  return ir.lexicons.validate("app.bsky.actor.defs#viewerState", t);
}
ge.validateViewerState = zR;
function HR(t) {
  return (0, ze.isObj)(t) && (0, ze.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#adultContentPref";
}
ge.isAdultContentPref = HR;
function ZR(t) {
  return ir.lexicons.validate("app.bsky.actor.defs#adultContentPref", t);
}
ge.validateAdultContentPref = ZR;
function WR(t) {
  return (0, ze.isObj)(t) && (0, ze.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#contentLabelPref";
}
ge.isContentLabelPref = WR;
function YR(t) {
  return ir.lexicons.validate("app.bsky.actor.defs#contentLabelPref", t);
}
ge.validateContentLabelPref = YR;
function JR(t) {
  return (0, ze.isObj)(t) && (0, ze.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#savedFeedsPref";
}
ge.isSavedFeedsPref = JR;
function QR(t) {
  return ir.lexicons.validate("app.bsky.actor.defs#savedFeedsPref", t);
}
ge.validateSavedFeedsPref = QR;
function eA(t) {
  return (0, ze.isObj)(t) && (0, ze.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#personalDetailsPref";
}
ge.isPersonalDetailsPref = eA;
function tA(t) {
  return ir.lexicons.validate("app.bsky.actor.defs#personalDetailsPref", t);
}
ge.validatePersonalDetailsPref = tA;
function rA(t) {
  return (0, ze.isObj)(t) && (0, ze.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#feedViewPref";
}
ge.isFeedViewPref = rA;
function iA(t) {
  return ir.lexicons.validate("app.bsky.actor.defs#feedViewPref", t);
}
ge.validateFeedViewPref = iA;
function nA(t) {
  return (0, ze.isObj)(t) && (0, ze.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#threadViewPref";
}
ge.isThreadViewPref = nA;
function aA(t) {
  return ir.lexicons.validate("app.bsky.actor.defs#threadViewPref", t);
}
ge.validateThreadViewPref = aA;
function sA(t) {
  return (0, ze.isObj)(t) && (0, ze.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#interestsPref";
}
ge.isInterestsPref = sA;
function oA(t) {
  return ir.lexicons.validate("app.bsky.actor.defs#interestsPref", t);
}
ge.validateInterestsPref = oA;
function lA(t) {
  return (0, ze.isObj)(t) && (0, ze.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#mutedWord";
}
ge.isMutedWord = lA;
function uA(t) {
  return ir.lexicons.validate("app.bsky.actor.defs#mutedWord", t);
}
ge.validateMutedWord = uA;
function fA(t) {
  return (0, ze.isObj)(t) && (0, ze.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#mutedWordsPref";
}
ge.isMutedWordsPref = fA;
function cA(t) {
  return ir.lexicons.validate("app.bsky.actor.defs#mutedWordsPref", t);
}
ge.validateMutedWordsPref = cA;
function dA(t) {
  return (0, ze.isObj)(t) && (0, ze.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#hiddenPostsPref";
}
ge.isHiddenPostsPref = dA;
function pA(t) {
  return ir.lexicons.validate("app.bsky.actor.defs#hiddenPostsPref", t);
}
ge.validateHiddenPostsPref = pA;
function hA(t) {
  return (0, ze.isObj)(t) && (0, ze.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#labelersPref";
}
ge.isLabelersPref = hA;
function mA(t) {
  return ir.lexicons.validate("app.bsky.actor.defs#labelersPref", t);
}
ge.validateLabelersPref = mA;
function yA(t) {
  return (0, ze.isObj)(t) && (0, ze.hasProp)(t, "$type") && t.$type === "app.bsky.actor.defs#labelerPrefItem";
}
ge.isLabelerPrefItem = yA;
function bA(t) {
  return ir.lexicons.validate("app.bsky.actor.defs#labelerPrefItem", t);
}
ge.validateLabelerPrefItem = bA;
var jn = {};
Object.defineProperty(jn, "__esModule", { value: !0 });
jn.validateRecord = jn.isRecord = void 0;
const Qu = Ie, xA = Ne;
function EA(t) {
  return (0, Qu.isObj)(t) && (0, Qu.hasProp)(t, "$type") && (t.$type === "app.bsky.actor.profile#main" || t.$type === "app.bsky.actor.profile");
}
jn.isRecord = EA;
function gA(t) {
  return xA.lexicons.validate("app.bsky.actor.profile#main", t);
}
jn.validateRecord = gA;
var zt = {};
Object.defineProperty(zt, "__esModule", { value: !0 });
zt.validateViewExternal = zt.isViewExternal = zt.validateView = zt.isView = zt.validateExternal = zt.isExternal = zt.validateMain = zt.isMain = void 0;
const Xi = Ie, rl = Ne;
function vA(t) {
  return (0, Xi.isObj)(t) && (0, Xi.hasProp)(t, "$type") && (t.$type === "app.bsky.embed.external#main" || t.$type === "app.bsky.embed.external");
}
zt.isMain = vA;
function RA(t) {
  return rl.lexicons.validate("app.bsky.embed.external#main", t);
}
zt.validateMain = RA;
function AA(t) {
  return (0, Xi.isObj)(t) && (0, Xi.hasProp)(t, "$type") && t.$type === "app.bsky.embed.external#external";
}
zt.isExternal = AA;
function _A(t) {
  return rl.lexicons.validate("app.bsky.embed.external#external", t);
}
zt.validateExternal = _A;
function TA(t) {
  return (0, Xi.isObj)(t) && (0, Xi.hasProp)(t, "$type") && t.$type === "app.bsky.embed.external#view";
}
zt.isView = TA;
function wA(t) {
  return rl.lexicons.validate("app.bsky.embed.external#view", t);
}
zt.validateView = wA;
function SA(t) {
  return (0, Xi.isObj)(t) && (0, Xi.hasProp)(t, "$type") && t.$type === "app.bsky.embed.external#viewExternal";
}
zt.isViewExternal = SA;
function LA(t) {
  return rl.lexicons.validate("app.bsky.embed.external#viewExternal", t);
}
zt.validateViewExternal = LA;
var St = {};
Object.defineProperty(St, "__esModule", { value: !0 });
St.validateViewImage = St.isViewImage = St.validateView = St.isView = St.validateAspectRatio = St.isAspectRatio = St.validateImage = St.isImage = St.validateMain = St.isMain = void 0;
const oi = Ie, co = Ne;
function CA(t) {
  return (0, oi.isObj)(t) && (0, oi.hasProp)(t, "$type") && (t.$type === "app.bsky.embed.images#main" || t.$type === "app.bsky.embed.images");
}
St.isMain = CA;
function DA(t) {
  return co.lexicons.validate("app.bsky.embed.images#main", t);
}
St.validateMain = DA;
function kA(t) {
  return (0, oi.isObj)(t) && (0, oi.hasProp)(t, "$type") && t.$type === "app.bsky.embed.images#image";
}
St.isImage = kA;
function PA(t) {
  return co.lexicons.validate("app.bsky.embed.images#image", t);
}
St.validateImage = PA;
function BA(t) {
  return (0, oi.isObj)(t) && (0, oi.hasProp)(t, "$type") && t.$type === "app.bsky.embed.images#aspectRatio";
}
St.isAspectRatio = BA;
function IA(t) {
  return co.lexicons.validate("app.bsky.embed.images#aspectRatio", t);
}
St.validateAspectRatio = IA;
function UA(t) {
  return (0, oi.isObj)(t) && (0, oi.hasProp)(t, "$type") && t.$type === "app.bsky.embed.images#view";
}
St.isView = UA;
function OA(t) {
  return co.lexicons.validate("app.bsky.embed.images#view", t);
}
St.validateView = OA;
function KA(t) {
  return (0, oi.isObj)(t) && (0, oi.hasProp)(t, "$type") && t.$type === "app.bsky.embed.images#viewImage";
}
St.isViewImage = KA;
function NA(t) {
  return co.lexicons.validate("app.bsky.embed.images#viewImage", t);
}
St.validateViewImage = NA;
var Lt = {};
Object.defineProperty(Lt, "__esModule", { value: !0 });
Lt.validateViewBlocked = Lt.isViewBlocked = Lt.validateViewNotFound = Lt.isViewNotFound = Lt.validateViewRecord = Lt.isViewRecord = Lt.validateView = Lt.isView = Lt.validateMain = Lt.isMain = void 0;
const li = Ie, po = Ne;
function VA(t) {
  return (0, li.isObj)(t) && (0, li.hasProp)(t, "$type") && (t.$type === "app.bsky.embed.record#main" || t.$type === "app.bsky.embed.record");
}
Lt.isMain = VA;
function MA(t) {
  return po.lexicons.validate("app.bsky.embed.record#main", t);
}
Lt.validateMain = MA;
function jA(t) {
  return (0, li.isObj)(t) && (0, li.hasProp)(t, "$type") && t.$type === "app.bsky.embed.record#view";
}
Lt.isView = jA;
function FA(t) {
  return po.lexicons.validate("app.bsky.embed.record#view", t);
}
Lt.validateView = FA;
function $A(t) {
  return (0, li.isObj)(t) && (0, li.hasProp)(t, "$type") && t.$type === "app.bsky.embed.record#viewRecord";
}
Lt.isViewRecord = $A;
function GA(t) {
  return po.lexicons.validate("app.bsky.embed.record#viewRecord", t);
}
Lt.validateViewRecord = GA;
function qA(t) {
  return (0, li.isObj)(t) && (0, li.hasProp)(t, "$type") && t.$type === "app.bsky.embed.record#viewNotFound";
}
Lt.isViewNotFound = qA;
function XA(t) {
  return po.lexicons.validate("app.bsky.embed.record#viewNotFound", t);
}
Lt.validateViewNotFound = XA;
function zA(t) {
  return (0, li.isObj)(t) && (0, li.hasProp)(t, "$type") && t.$type === "app.bsky.embed.record#viewBlocked";
}
Lt.isViewBlocked = zA;
function HA(t) {
  return po.lexicons.validate("app.bsky.embed.record#viewBlocked", t);
}
Lt.validateViewBlocked = HA;
var ti = {};
Object.defineProperty(ti, "__esModule", { value: !0 });
ti.validateView = ti.isView = ti.validateMain = ti.isMain = void 0;
const Fo = Ie, $d = Ne;
function ZA(t) {
  return (0, Fo.isObj)(t) && (0, Fo.hasProp)(t, "$type") && (t.$type === "app.bsky.embed.recordWithMedia#main" || t.$type === "app.bsky.embed.recordWithMedia");
}
ti.isMain = ZA;
function WA(t) {
  return $d.lexicons.validate("app.bsky.embed.recordWithMedia#main", t);
}
ti.validateMain = WA;
function YA(t) {
  return (0, Fo.isObj)(t) && (0, Fo.hasProp)(t, "$type") && t.$type === "app.bsky.embed.recordWithMedia#view";
}
ti.isView = YA;
function JA(t) {
  return $d.lexicons.validate("app.bsky.embed.recordWithMedia#view", t);
}
ti.validateView = JA;
var he = {};
Object.defineProperty(he, "__esModule", { value: !0 });
he.INTERACTIONSHARE = he.INTERACTIONQUOTE = he.INTERACTIONREPLY = he.INTERACTIONREPOST = he.INTERACTIONLIKE = he.INTERACTIONSEEN = he.CLICKTHROUGHEMBED = he.CLICKTHROUGHREPOSTER = he.CLICKTHROUGHAUTHOR = he.CLICKTHROUGHITEM = he.REQUESTMORE = he.REQUESTLESS = he.validateInteraction = he.isInteraction = he.validateThreadgateView = he.isThreadgateView = he.validateSkeletonReasonRepost = he.isSkeletonReasonRepost = he.validateSkeletonFeedPost = he.isSkeletonFeedPost = he.validateGeneratorViewerState = he.isGeneratorViewerState = he.validateGeneratorView = he.isGeneratorView = he.validateBlockedAuthor = he.isBlockedAuthor = he.validateBlockedPost = he.isBlockedPost = he.validateNotFoundPost = he.isNotFoundPost = he.validateThreadViewPost = he.isThreadViewPost = he.validateReasonRepost = he.isReasonRepost = he.validateReplyRef = he.isReplyRef = he.validateFeedViewPost = he.isFeedViewPost = he.validateViewerState = he.isViewerState = he.validatePostView = he.isPostView = void 0;
const at = Ie, hr = Ne;
function QA(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#postView";
}
he.isPostView = QA;
function e_(t) {
  return hr.lexicons.validate("app.bsky.feed.defs#postView", t);
}
he.validatePostView = e_;
function t_(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#viewerState";
}
he.isViewerState = t_;
function r_(t) {
  return hr.lexicons.validate("app.bsky.feed.defs#viewerState", t);
}
he.validateViewerState = r_;
function i_(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#feedViewPost";
}
he.isFeedViewPost = i_;
function n_(t) {
  return hr.lexicons.validate("app.bsky.feed.defs#feedViewPost", t);
}
he.validateFeedViewPost = n_;
function a_(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#replyRef";
}
he.isReplyRef = a_;
function s_(t) {
  return hr.lexicons.validate("app.bsky.feed.defs#replyRef", t);
}
he.validateReplyRef = s_;
function o_(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#reasonRepost";
}
he.isReasonRepost = o_;
function l_(t) {
  return hr.lexicons.validate("app.bsky.feed.defs#reasonRepost", t);
}
he.validateReasonRepost = l_;
function u_(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#threadViewPost";
}
he.isThreadViewPost = u_;
function f_(t) {
  return hr.lexicons.validate("app.bsky.feed.defs#threadViewPost", t);
}
he.validateThreadViewPost = f_;
function c_(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#notFoundPost";
}
he.isNotFoundPost = c_;
function d_(t) {
  return hr.lexicons.validate("app.bsky.feed.defs#notFoundPost", t);
}
he.validateNotFoundPost = d_;
function p_(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#blockedPost";
}
he.isBlockedPost = p_;
function h_(t) {
  return hr.lexicons.validate("app.bsky.feed.defs#blockedPost", t);
}
he.validateBlockedPost = h_;
function m_(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#blockedAuthor";
}
he.isBlockedAuthor = m_;
function y_(t) {
  return hr.lexicons.validate("app.bsky.feed.defs#blockedAuthor", t);
}
he.validateBlockedAuthor = y_;
function b_(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#generatorView";
}
he.isGeneratorView = b_;
function x_(t) {
  return hr.lexicons.validate("app.bsky.feed.defs#generatorView", t);
}
he.validateGeneratorView = x_;
function E_(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#generatorViewerState";
}
he.isGeneratorViewerState = E_;
function g_(t) {
  return hr.lexicons.validate("app.bsky.feed.defs#generatorViewerState", t);
}
he.validateGeneratorViewerState = g_;
function v_(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#skeletonFeedPost";
}
he.isSkeletonFeedPost = v_;
function R_(t) {
  return hr.lexicons.validate("app.bsky.feed.defs#skeletonFeedPost", t);
}
he.validateSkeletonFeedPost = R_;
function A_(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#skeletonReasonRepost";
}
he.isSkeletonReasonRepost = A_;
function __(t) {
  return hr.lexicons.validate("app.bsky.feed.defs#skeletonReasonRepost", t);
}
he.validateSkeletonReasonRepost = __;
function T_(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#threadgateView";
}
he.isThreadgateView = T_;
function w_(t) {
  return hr.lexicons.validate("app.bsky.feed.defs#threadgateView", t);
}
he.validateThreadgateView = w_;
function S_(t) {
  return (0, at.isObj)(t) && (0, at.hasProp)(t, "$type") && t.$type === "app.bsky.feed.defs#interaction";
}
he.isInteraction = S_;
function L_(t) {
  return hr.lexicons.validate("app.bsky.feed.defs#interaction", t);
}
he.validateInteraction = L_;
he.REQUESTLESS = "app.bsky.feed.defs#requestLess";
he.REQUESTMORE = "app.bsky.feed.defs#requestMore";
he.CLICKTHROUGHITEM = "app.bsky.feed.defs#clickthroughItem";
he.CLICKTHROUGHAUTHOR = "app.bsky.feed.defs#clickthroughAuthor";
he.CLICKTHROUGHREPOSTER = "app.bsky.feed.defs#clickthroughReposter";
he.CLICKTHROUGHEMBED = "app.bsky.feed.defs#clickthroughEmbed";
he.INTERACTIONSEEN = "app.bsky.feed.defs#interactionSeen";
he.INTERACTIONLIKE = "app.bsky.feed.defs#interactionLike";
he.INTERACTIONREPOST = "app.bsky.feed.defs#interactionRepost";
he.INTERACTIONREPLY = "app.bsky.feed.defs#interactionReply";
he.INTERACTIONQUOTE = "app.bsky.feed.defs#interactionQuote";
he.INTERACTIONSHARE = "app.bsky.feed.defs#interactionShare";
var Fn = {};
Object.defineProperty(Fn, "__esModule", { value: !0 });
Fn.validateRecord = Fn.isRecord = void 0;
const ef = Ie, C_ = Ne;
function D_(t) {
  return (0, ef.isObj)(t) && (0, ef.hasProp)(t, "$type") && (t.$type === "app.bsky.feed.generator#main" || t.$type === "app.bsky.feed.generator");
}
Fn.isRecord = D_;
function k_(t) {
  return C_.lexicons.validate("app.bsky.feed.generator#main", t);
}
Fn.validateRecord = k_;
var $n = {};
Object.defineProperty($n, "__esModule", { value: !0 });
$n.validateRecord = $n.isRecord = void 0;
const tf = Ie, P_ = Ne;
function B_(t) {
  return (0, tf.isObj)(t) && (0, tf.hasProp)(t, "$type") && (t.$type === "app.bsky.feed.like#main" || t.$type === "app.bsky.feed.like");
}
$n.isRecord = B_;
function I_(t) {
  return P_.lexicons.validate("app.bsky.feed.like#main", t);
}
$n.validateRecord = I_;
var Ht = {};
Object.defineProperty(Ht, "__esModule", { value: !0 });
Ht.validateTextSlice = Ht.isTextSlice = Ht.validateEntity = Ht.isEntity = Ht.validateReplyRef = Ht.isReplyRef = Ht.validateRecord = Ht.isRecord = void 0;
const zi = Ie, il = Ne;
function U_(t) {
  return (0, zi.isObj)(t) && (0, zi.hasProp)(t, "$type") && (t.$type === "app.bsky.feed.post#main" || t.$type === "app.bsky.feed.post");
}
Ht.isRecord = U_;
function O_(t) {
  return il.lexicons.validate("app.bsky.feed.post#main", t);
}
Ht.validateRecord = O_;
function K_(t) {
  return (0, zi.isObj)(t) && (0, zi.hasProp)(t, "$type") && t.$type === "app.bsky.feed.post#replyRef";
}
Ht.isReplyRef = K_;
function N_(t) {
  return il.lexicons.validate("app.bsky.feed.post#replyRef", t);
}
Ht.validateReplyRef = N_;
function V_(t) {
  return (0, zi.isObj)(t) && (0, zi.hasProp)(t, "$type") && t.$type === "app.bsky.feed.post#entity";
}
Ht.isEntity = V_;
function M_(t) {
  return il.lexicons.validate("app.bsky.feed.post#entity", t);
}
Ht.validateEntity = M_;
function j_(t) {
  return (0, zi.isObj)(t) && (0, zi.hasProp)(t, "$type") && t.$type === "app.bsky.feed.post#textSlice";
}
Ht.isTextSlice = j_;
function F_(t) {
  return il.lexicons.validate("app.bsky.feed.post#textSlice", t);
}
Ht.validateTextSlice = F_;
var Gn = {};
Object.defineProperty(Gn, "__esModule", { value: !0 });
Gn.validateRecord = Gn.isRecord = void 0;
const rf = Ie, $_ = Ne;
function G_(t) {
  return (0, rf.isObj)(t) && (0, rf.hasProp)(t, "$type") && (t.$type === "app.bsky.feed.repost#main" || t.$type === "app.bsky.feed.repost");
}
Gn.isRecord = G_;
function q_(t) {
  return $_.lexicons.validate("app.bsky.feed.repost#main", t);
}
Gn.validateRecord = q_;
var Zt = {};
Object.defineProperty(Zt, "__esModule", { value: !0 });
Zt.validateListRule = Zt.isListRule = Zt.validateFollowingRule = Zt.isFollowingRule = Zt.validateMentionRule = Zt.isMentionRule = Zt.validateRecord = Zt.isRecord = void 0;
const Hi = Ie, nl = Ne;
function X_(t) {
  return (0, Hi.isObj)(t) && (0, Hi.hasProp)(t, "$type") && (t.$type === "app.bsky.feed.threadgate#main" || t.$type === "app.bsky.feed.threadgate");
}
Zt.isRecord = X_;
function z_(t) {
  return nl.lexicons.validate("app.bsky.feed.threadgate#main", t);
}
Zt.validateRecord = z_;
function H_(t) {
  return (0, Hi.isObj)(t) && (0, Hi.hasProp)(t, "$type") && t.$type === "app.bsky.feed.threadgate#mentionRule";
}
Zt.isMentionRule = H_;
function Z_(t) {
  return nl.lexicons.validate("app.bsky.feed.threadgate#mentionRule", t);
}
Zt.validateMentionRule = Z_;
function W_(t) {
  return (0, Hi.isObj)(t) && (0, Hi.hasProp)(t, "$type") && t.$type === "app.bsky.feed.threadgate#followingRule";
}
Zt.isFollowingRule = W_;
function Y_(t) {
  return nl.lexicons.validate("app.bsky.feed.threadgate#followingRule", t);
}
Zt.validateFollowingRule = Y_;
function J_(t) {
  return (0, Hi.isObj)(t) && (0, Hi.hasProp)(t, "$type") && t.$type === "app.bsky.feed.threadgate#listRule";
}
Zt.isListRule = J_;
function Q_(t) {
  return nl.lexicons.validate("app.bsky.feed.threadgate#listRule", t);
}
Zt.validateListRule = Q_;
var qn = {};
Object.defineProperty(qn, "__esModule", { value: !0 });
qn.validateRecord = qn.isRecord = void 0;
const nf = Ie, eT = Ne;
function tT(t) {
  return (0, nf.isObj)(t) && (0, nf.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.block#main" || t.$type === "app.bsky.graph.block");
}
qn.isRecord = tT;
function rT(t) {
  return eT.lexicons.validate("app.bsky.graph.block#main", t);
}
qn.validateRecord = rT;
var nt = {};
Object.defineProperty(nt, "__esModule", { value: !0 });
nt.validateRelationship = nt.isRelationship = nt.validateNotFoundActor = nt.isNotFoundActor = nt.validateListViewerState = nt.isListViewerState = nt.CURATELIST = nt.MODLIST = nt.validateListItemView = nt.isListItemView = nt.validateListView = nt.isListView = nt.validateListViewBasic = nt.isListViewBasic = void 0;
const Kr = Ie, ra = Ne;
function iT(t) {
  return (0, Kr.isObj)(t) && (0, Kr.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#listViewBasic";
}
nt.isListViewBasic = iT;
function nT(t) {
  return ra.lexicons.validate("app.bsky.graph.defs#listViewBasic", t);
}
nt.validateListViewBasic = nT;
function aT(t) {
  return (0, Kr.isObj)(t) && (0, Kr.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#listView";
}
nt.isListView = aT;
function sT(t) {
  return ra.lexicons.validate("app.bsky.graph.defs#listView", t);
}
nt.validateListView = sT;
function oT(t) {
  return (0, Kr.isObj)(t) && (0, Kr.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#listItemView";
}
nt.isListItemView = oT;
function lT(t) {
  return ra.lexicons.validate("app.bsky.graph.defs#listItemView", t);
}
nt.validateListItemView = lT;
nt.MODLIST = "app.bsky.graph.defs#modlist";
nt.CURATELIST = "app.bsky.graph.defs#curatelist";
function uT(t) {
  return (0, Kr.isObj)(t) && (0, Kr.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#listViewerState";
}
nt.isListViewerState = uT;
function fT(t) {
  return ra.lexicons.validate("app.bsky.graph.defs#listViewerState", t);
}
nt.validateListViewerState = fT;
function cT(t) {
  return (0, Kr.isObj)(t) && (0, Kr.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#notFoundActor";
}
nt.isNotFoundActor = cT;
function dT(t) {
  return ra.lexicons.validate("app.bsky.graph.defs#notFoundActor", t);
}
nt.validateNotFoundActor = dT;
function pT(t) {
  return (0, Kr.isObj)(t) && (0, Kr.hasProp)(t, "$type") && t.$type === "app.bsky.graph.defs#relationship";
}
nt.isRelationship = pT;
function hT(t) {
  return ra.lexicons.validate("app.bsky.graph.defs#relationship", t);
}
nt.validateRelationship = hT;
var Xn = {};
Object.defineProperty(Xn, "__esModule", { value: !0 });
Xn.validateRecord = Xn.isRecord = void 0;
const af = Ie, mT = Ne;
function yT(t) {
  return (0, af.isObj)(t) && (0, af.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.follow#main" || t.$type === "app.bsky.graph.follow");
}
Xn.isRecord = yT;
function bT(t) {
  return mT.lexicons.validate("app.bsky.graph.follow#main", t);
}
Xn.validateRecord = bT;
var zn = {};
Object.defineProperty(zn, "__esModule", { value: !0 });
zn.validateRecord = zn.isRecord = void 0;
const sf = Ie, xT = Ne;
function ET(t) {
  return (0, sf.isObj)(t) && (0, sf.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.list#main" || t.$type === "app.bsky.graph.list");
}
zn.isRecord = ET;
function gT(t) {
  return xT.lexicons.validate("app.bsky.graph.list#main", t);
}
zn.validateRecord = gT;
var Hn = {};
Object.defineProperty(Hn, "__esModule", { value: !0 });
Hn.validateRecord = Hn.isRecord = void 0;
const of = Ie, vT = Ne;
function RT(t) {
  return (0, of.isObj)(t) && (0, of.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.listblock#main" || t.$type === "app.bsky.graph.listblock");
}
Hn.isRecord = RT;
function AT(t) {
  return vT.lexicons.validate("app.bsky.graph.listblock#main", t);
}
Hn.validateRecord = AT;
var Zn = {};
Object.defineProperty(Zn, "__esModule", { value: !0 });
Zn.validateRecord = Zn.isRecord = void 0;
const lf = Ie, _T = Ne;
function TT(t) {
  return (0, lf.isObj)(t) && (0, lf.hasProp)(t, "$type") && (t.$type === "app.bsky.graph.listitem#main" || t.$type === "app.bsky.graph.listitem");
}
Zn.isRecord = TT;
function wT(t) {
  return _T.lexicons.validate("app.bsky.graph.listitem#main", t);
}
Zn.validateRecord = wT;
var Wt = {};
Object.defineProperty(Wt, "__esModule", { value: !0 });
Wt.validateLabelerPolicies = Wt.isLabelerPolicies = Wt.validateLabelerViewerState = Wt.isLabelerViewerState = Wt.validateLabelerViewDetailed = Wt.isLabelerViewDetailed = Wt.validateLabelerView = Wt.isLabelerView = void 0;
const Zi = Ie, al = Ne;
function ST(t) {
  return (0, Zi.isObj)(t) && (0, Zi.hasProp)(t, "$type") && t.$type === "app.bsky.labeler.defs#labelerView";
}
Wt.isLabelerView = ST;
function LT(t) {
  return al.lexicons.validate("app.bsky.labeler.defs#labelerView", t);
}
Wt.validateLabelerView = LT;
function CT(t) {
  return (0, Zi.isObj)(t) && (0, Zi.hasProp)(t, "$type") && t.$type === "app.bsky.labeler.defs#labelerViewDetailed";
}
Wt.isLabelerViewDetailed = CT;
function DT(t) {
  return al.lexicons.validate("app.bsky.labeler.defs#labelerViewDetailed", t);
}
Wt.validateLabelerViewDetailed = DT;
function kT(t) {
  return (0, Zi.isObj)(t) && (0, Zi.hasProp)(t, "$type") && t.$type === "app.bsky.labeler.defs#labelerViewerState";
}
Wt.isLabelerViewerState = kT;
function PT(t) {
  return al.lexicons.validate("app.bsky.labeler.defs#labelerViewerState", t);
}
Wt.validateLabelerViewerState = PT;
function BT(t) {
  return (0, Zi.isObj)(t) && (0, Zi.hasProp)(t, "$type") && t.$type === "app.bsky.labeler.defs#labelerPolicies";
}
Wt.isLabelerPolicies = BT;
function IT(t) {
  return al.lexicons.validate("app.bsky.labeler.defs#labelerPolicies", t);
}
Wt.validateLabelerPolicies = IT;
var Wn = {};
Object.defineProperty(Wn, "__esModule", { value: !0 });
Wn.validateRecord = Wn.isRecord = void 0;
const uf = Ie, UT = Ne;
function OT(t) {
  return (0, uf.isObj)(t) && (0, uf.hasProp)(t, "$type") && (t.$type === "app.bsky.labeler.service#main" || t.$type === "app.bsky.labeler.service");
}
Wn.isRecord = OT;
function KT(t) {
  return UT.lexicons.validate("app.bsky.labeler.service#main", t);
}
Wn.validateRecord = KT;
var Ct = {};
Object.defineProperty(Ct, "__esModule", { value: !0 });
Ct.validateByteSlice = Ct.isByteSlice = Ct.validateTag = Ct.isTag = Ct.validateLink = Ct.isLink = Ct.validateMention = Ct.isMention = Ct.validateMain = Ct.isMain = void 0;
const ui = Ie, ho = Ne;
function NT(t) {
  return (0, ui.isObj)(t) && (0, ui.hasProp)(t, "$type") && (t.$type === "app.bsky.richtext.facet#main" || t.$type === "app.bsky.richtext.facet");
}
Ct.isMain = NT;
function VT(t) {
  return ho.lexicons.validate("app.bsky.richtext.facet#main", t);
}
Ct.validateMain = VT;
function MT(t) {
  return (0, ui.isObj)(t) && (0, ui.hasProp)(t, "$type") && t.$type === "app.bsky.richtext.facet#mention";
}
Ct.isMention = MT;
function jT(t) {
  return ho.lexicons.validate("app.bsky.richtext.facet#mention", t);
}
Ct.validateMention = jT;
function FT(t) {
  return (0, ui.isObj)(t) && (0, ui.hasProp)(t, "$type") && t.$type === "app.bsky.richtext.facet#link";
}
Ct.isLink = FT;
function $T(t) {
  return ho.lexicons.validate("app.bsky.richtext.facet#link", t);
}
Ct.validateLink = $T;
function GT(t) {
  return (0, ui.isObj)(t) && (0, ui.hasProp)(t, "$type") && t.$type === "app.bsky.richtext.facet#tag";
}
Ct.isTag = GT;
function qT(t) {
  return ho.lexicons.validate("app.bsky.richtext.facet#tag", t);
}
Ct.validateTag = qT;
function XT(t) {
  return (0, ui.isObj)(t) && (0, ui.hasProp)(t, "$type") && t.$type === "app.bsky.richtext.facet#byteSlice";
}
Ct.isByteSlice = XT;
function zT(t) {
  return ho.lexicons.validate("app.bsky.richtext.facet#byteSlice", t);
}
Ct.validateByteSlice = zT;
var ri = {};
Object.defineProperty(ri, "__esModule", { value: !0 });
ri.validateSkeletonSearchActor = ri.isSkeletonSearchActor = ri.validateSkeletonSearchPost = ri.isSkeletonSearchPost = void 0;
const $o = Ie, Gd = Ne;
function HT(t) {
  return (0, $o.isObj)(t) && (0, $o.hasProp)(t, "$type") && t.$type === "app.bsky.unspecced.defs#skeletonSearchPost";
}
ri.isSkeletonSearchPost = HT;
function ZT(t) {
  return Gd.lexicons.validate("app.bsky.unspecced.defs#skeletonSearchPost", t);
}
ri.validateSkeletonSearchPost = ZT;
function WT(t) {
  return (0, $o.isObj)(t) && (0, $o.hasProp)(t, "$type") && t.$type === "app.bsky.unspecced.defs#skeletonSearchActor";
}
ri.isSkeletonSearchActor = WT;
function YT(t) {
  return Gd.lexicons.validate("app.bsky.unspecced.defs#skeletonSearchActor", t);
}
ri.validateSkeletonSearchActor = YT;
var Yn = {};
Object.defineProperty(Yn, "__esModule", { value: !0 });
Yn.validateTemplateView = Yn.isTemplateView = void 0;
const ff = Ie, JT = Ne;
function QT(t) {
  return (0, ff.isObj)(t) && (0, ff.hasProp)(t, "$type") && t.$type === "tools.ozone.communication.defs#templateView";
}
Yn.isTemplateView = QT;
function ew(t) {
  return JT.lexicons.validate("tools.ozone.communication.defs#templateView", t);
}
Yn.validateTemplateView = ew;
var ne = {};
Object.defineProperty(ne, "__esModule", { value: !0 });
ne.validateModeration = ne.isModeration = ne.validateRecordViewNotFound = ne.isRecordViewNotFound = ne.validateRecordViewDetail = ne.isRecordViewDetail = ne.validateRecordView = ne.isRecordView = ne.validateRepoViewNotFound = ne.isRepoViewNotFound = ne.validateRepoViewDetail = ne.isRepoViewDetail = ne.validateRepoView = ne.isRepoView = ne.validateModEventTag = ne.isModEventTag = ne.validateModEventDivert = ne.isModEventDivert = ne.validateModEventEmail = ne.isModEventEmail = ne.validateModEventUnmute = ne.isModEventUnmute = ne.validateModEventMute = ne.isModEventMute = ne.validateModEventEscalate = ne.isModEventEscalate = ne.validateModEventAcknowledge = ne.isModEventAcknowledge = ne.validateModEventLabel = ne.isModEventLabel = ne.validateModEventReport = ne.isModEventReport = ne.validateModEventComment = ne.isModEventComment = ne.validateModEventResolveAppeal = ne.isModEventResolveAppeal = ne.validateModEventReverseTakedown = ne.isModEventReverseTakedown = ne.validateModEventTakedown = ne.isModEventTakedown = ne.REVIEWNONE = ne.REVIEWCLOSED = ne.REVIEWESCALATED = ne.REVIEWOPEN = ne.validateSubjectStatusView = ne.isSubjectStatusView = ne.validateModEventViewDetail = ne.isModEventViewDetail = ne.validateModEventView = ne.isModEventView = void 0;
ne.validateVideoDetails = ne.isVideoDetails = ne.validateImageDetails = ne.isImageDetails = ne.validateBlobView = ne.isBlobView = ne.validateModerationDetail = ne.isModerationDetail = void 0;
const De = Ie, ct = Ne;
function tw(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventView";
}
ne.isModEventView = tw;
function rw(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#modEventView", t);
}
ne.validateModEventView = rw;
function iw(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventViewDetail";
}
ne.isModEventViewDetail = iw;
function nw(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#modEventViewDetail", t);
}
ne.validateModEventViewDetail = nw;
function aw(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#subjectStatusView";
}
ne.isSubjectStatusView = aw;
function sw(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#subjectStatusView", t);
}
ne.validateSubjectStatusView = sw;
ne.REVIEWOPEN = "tools.ozone.moderation.defs#reviewOpen";
ne.REVIEWESCALATED = "tools.ozone.moderation.defs#reviewEscalated";
ne.REVIEWCLOSED = "tools.ozone.moderation.defs#reviewClosed";
ne.REVIEWNONE = "tools.ozone.moderation.defs#reviewNone";
function ow(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventTakedown";
}
ne.isModEventTakedown = ow;
function lw(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#modEventTakedown", t);
}
ne.validateModEventTakedown = lw;
function uw(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventReverseTakedown";
}
ne.isModEventReverseTakedown = uw;
function fw(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#modEventReverseTakedown", t);
}
ne.validateModEventReverseTakedown = fw;
function cw(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventResolveAppeal";
}
ne.isModEventResolveAppeal = cw;
function dw(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#modEventResolveAppeal", t);
}
ne.validateModEventResolveAppeal = dw;
function pw(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventComment";
}
ne.isModEventComment = pw;
function hw(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#modEventComment", t);
}
ne.validateModEventComment = hw;
function mw(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventReport";
}
ne.isModEventReport = mw;
function yw(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#modEventReport", t);
}
ne.validateModEventReport = yw;
function bw(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventLabel";
}
ne.isModEventLabel = bw;
function xw(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#modEventLabel", t);
}
ne.validateModEventLabel = xw;
function Ew(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventAcknowledge";
}
ne.isModEventAcknowledge = Ew;
function gw(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#modEventAcknowledge", t);
}
ne.validateModEventAcknowledge = gw;
function vw(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventEscalate";
}
ne.isModEventEscalate = vw;
function Rw(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#modEventEscalate", t);
}
ne.validateModEventEscalate = Rw;
function Aw(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventMute";
}
ne.isModEventMute = Aw;
function _w(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#modEventMute", t);
}
ne.validateModEventMute = _w;
function Tw(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventUnmute";
}
ne.isModEventUnmute = Tw;
function ww(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#modEventUnmute", t);
}
ne.validateModEventUnmute = ww;
function Sw(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventEmail";
}
ne.isModEventEmail = Sw;
function Lw(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#modEventEmail", t);
}
ne.validateModEventEmail = Lw;
function Cw(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventDivert";
}
ne.isModEventDivert = Cw;
function Dw(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#modEventDivert", t);
}
ne.validateModEventDivert = Dw;
function kw(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#modEventTag";
}
ne.isModEventTag = kw;
function Pw(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#modEventTag", t);
}
ne.validateModEventTag = Pw;
function Bw(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#repoView";
}
ne.isRepoView = Bw;
function Iw(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#repoView", t);
}
ne.validateRepoView = Iw;
function Uw(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#repoViewDetail";
}
ne.isRepoViewDetail = Uw;
function Ow(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#repoViewDetail", t);
}
ne.validateRepoViewDetail = Ow;
function Kw(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#repoViewNotFound";
}
ne.isRepoViewNotFound = Kw;
function Nw(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#repoViewNotFound", t);
}
ne.validateRepoViewNotFound = Nw;
function Vw(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#recordView";
}
ne.isRecordView = Vw;
function Mw(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#recordView", t);
}
ne.validateRecordView = Mw;
function jw(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#recordViewDetail";
}
ne.isRecordViewDetail = jw;
function Fw(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#recordViewDetail", t);
}
ne.validateRecordViewDetail = Fw;
function $w(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#recordViewNotFound";
}
ne.isRecordViewNotFound = $w;
function Gw(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#recordViewNotFound", t);
}
ne.validateRecordViewNotFound = Gw;
function qw(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#moderation";
}
ne.isModeration = qw;
function Xw(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#moderation", t);
}
ne.validateModeration = Xw;
function zw(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#moderationDetail";
}
ne.isModerationDetail = zw;
function Hw(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#moderationDetail", t);
}
ne.validateModerationDetail = Hw;
function Zw(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#blobView";
}
ne.isBlobView = Zw;
function Ww(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#blobView", t);
}
ne.validateBlobView = Ww;
function Yw(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#imageDetails";
}
ne.isImageDetails = Yw;
function Jw(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#imageDetails", t);
}
ne.validateImageDetails = Jw;
function Qw(t) {
  return (0, De.isObj)(t) && (0, De.hasProp)(t, "$type") && t.$type === "tools.ozone.moderation.defs#videoDetails";
}
ne.isVideoDetails = Qw;
function eS(t) {
  return ct.lexicons.validate("tools.ozone.moderation.defs#videoDetails", t);
}
ne.validateVideoDetails = eS;
var tS = le && le.__createBinding || (Object.create ? function(t, e, r, a) {
  a === void 0 && (a = r);
  var u = Object.getOwnPropertyDescriptor(e, r);
  (!u || ("get" in u ? !e.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, a, u);
} : function(t, e, r, a) {
  a === void 0 && (a = r), t[a] = e[r];
}), rS = le && le.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), P = le && le.__importStar || function(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && tS(e, t, r);
  return rS(e, t), e;
};
Object.defineProperty(v, "__esModule", { value: !0 });
v.ComAtprotoServerGetAccountInviteCodes = v.ComAtprotoServerDescribeServer = v.ComAtprotoServerDeleteSession = v.ComAtprotoServerDeleteAccount = v.ComAtprotoServerDefs = v.ComAtprotoServerDeactivateAccount = v.ComAtprotoServerCreateSession = v.ComAtprotoServerCreateInviteCodes = v.ComAtprotoServerCreateInviteCode = v.ComAtprotoServerCreateAppPassword = v.ComAtprotoServerCreateAccount = v.ComAtprotoServerConfirmEmail = v.ComAtprotoServerCheckAccountStatus = v.ComAtprotoServerActivateAccount = v.ComAtprotoRepoUploadBlob = v.ComAtprotoRepoStrongRef = v.ComAtprotoRepoPutRecord = v.ComAtprotoRepoListRecords = v.ComAtprotoRepoListMissingBlobs = v.ComAtprotoRepoImportRepo = v.ComAtprotoRepoGetRecord = v.ComAtprotoRepoDescribeRepo = v.ComAtprotoRepoDeleteRecord = v.ComAtprotoRepoCreateRecord = v.ComAtprotoRepoApplyWrites = v.ComAtprotoModerationDefs = v.ComAtprotoModerationCreateReport = v.ComAtprotoLabelSubscribeLabels = v.ComAtprotoLabelQueryLabels = v.ComAtprotoLabelDefs = v.ComAtprotoIdentityUpdateHandle = v.ComAtprotoIdentitySubmitPlcOperation = v.ComAtprotoIdentitySignPlcOperation = v.ComAtprotoIdentityResolveHandle = v.ComAtprotoIdentityRequestPlcOperationSignature = v.ComAtprotoIdentityGetRecommendedDidCredentials = v.ComAtprotoAdminUpdateSubjectStatus = v.ComAtprotoAdminUpdateAccountPassword = v.ComAtprotoAdminUpdateAccountHandle = v.ComAtprotoAdminUpdateAccountEmail = v.ComAtprotoAdminSendEmail = v.ComAtprotoAdminGetSubjectStatus = v.ComAtprotoAdminGetInviteCodes = v.ComAtprotoAdminGetAccountInfos = v.ComAtprotoAdminGetAccountInfo = v.ComAtprotoAdminEnableAccountInvites = v.ComAtprotoAdminDisableInviteCodes = v.ComAtprotoAdminDisableAccountInvites = v.ComAtprotoAdminDeleteAccount = v.ComAtprotoAdminDefs = void 0;
v.AppBskyFeedGetFeedSkeleton = v.AppBskyFeedGetFeedGenerators = v.AppBskyFeedGetFeedGenerator = v.AppBskyFeedGetFeed = v.AppBskyFeedGetAuthorFeed = v.AppBskyFeedGetActorLikes = v.AppBskyFeedGetActorFeeds = v.AppBskyFeedGenerator = v.AppBskyFeedDescribeFeedGenerator = v.AppBskyFeedDefs = v.AppBskyEmbedRecordWithMedia = v.AppBskyEmbedRecord = v.AppBskyEmbedImages = v.AppBskyEmbedExternal = v.AppBskyActorSearchActorsTypeahead = v.AppBskyActorSearchActors = v.AppBskyActorPutPreferences = v.AppBskyActorProfile = v.AppBskyActorGetSuggestions = v.AppBskyActorGetProfiles = v.AppBskyActorGetProfile = v.AppBskyActorGetPreferences = v.AppBskyActorDefs = v.ComAtprotoTempRequestPhoneVerification = v.ComAtprotoTempFetchLabels = v.ComAtprotoTempCheckSignupQueue = v.ComAtprotoSyncSubscribeRepos = v.ComAtprotoSyncRequestCrawl = v.ComAtprotoSyncNotifyOfUpdate = v.ComAtprotoSyncListRepos = v.ComAtprotoSyncListBlobs = v.ComAtprotoSyncGetRepo = v.ComAtprotoSyncGetRecord = v.ComAtprotoSyncGetLatestCommit = v.ComAtprotoSyncGetHead = v.ComAtprotoSyncGetCheckout = v.ComAtprotoSyncGetBlocks = v.ComAtprotoSyncGetBlob = v.ComAtprotoServerUpdateEmail = v.ComAtprotoServerRevokeAppPassword = v.ComAtprotoServerResetPassword = v.ComAtprotoServerReserveSigningKey = v.ComAtprotoServerRequestPasswordReset = v.ComAtprotoServerRequestEmailUpdate = v.ComAtprotoServerRequestEmailConfirmation = v.ComAtprotoServerRequestAccountDelete = v.ComAtprotoServerRefreshSession = v.ComAtprotoServerListAppPasswords = v.ComAtprotoServerGetSession = v.ComAtprotoServerGetServiceAuth = void 0;
v.ToolsOzoneCommunicationDeleteTemplate = v.ToolsOzoneCommunicationDefs = v.ToolsOzoneCommunicationCreateTemplate = v.AppBskyUnspeccedSearchPostsSkeleton = v.AppBskyUnspeccedSearchActorsSkeleton = v.AppBskyUnspeccedGetTaggedSuggestions = v.AppBskyUnspeccedGetSuggestionsSkeleton = v.AppBskyUnspeccedGetPopularFeedGenerators = v.AppBskyUnspeccedDefs = v.AppBskyRichtextFacet = v.AppBskyNotificationUpdateSeen = v.AppBskyNotificationRegisterPush = v.AppBskyNotificationListNotifications = v.AppBskyNotificationGetUnreadCount = v.AppBskyLabelerService = v.AppBskyLabelerGetServices = v.AppBskyLabelerDefs = v.AppBskyGraphUnmuteActorList = v.AppBskyGraphUnmuteActor = v.AppBskyGraphMuteActorList = v.AppBskyGraphMuteActor = v.AppBskyGraphListitem = v.AppBskyGraphListblock = v.AppBskyGraphList = v.AppBskyGraphGetSuggestedFollowsByActor = v.AppBskyGraphGetRelationships = v.AppBskyGraphGetMutes = v.AppBskyGraphGetLists = v.AppBskyGraphGetListMutes = v.AppBskyGraphGetListBlocks = v.AppBskyGraphGetList = v.AppBskyGraphGetFollows = v.AppBskyGraphGetFollowers = v.AppBskyGraphGetBlocks = v.AppBskyGraphFollow = v.AppBskyGraphDefs = v.AppBskyGraphBlock = v.AppBskyFeedThreadgate = v.AppBskyFeedSendInteractions = v.AppBskyFeedSearchPosts = v.AppBskyFeedRepost = v.AppBskyFeedPost = v.AppBskyFeedLike = v.AppBskyFeedGetTimeline = v.AppBskyFeedGetSuggestedFeeds = v.AppBskyFeedGetRepostedBy = v.AppBskyFeedGetPosts = v.AppBskyFeedGetPostThread = v.AppBskyFeedGetListFeed = v.AppBskyFeedGetLikes = void 0;
v.ToolsOzoneNS = v.ToolsNS = v.AppBskyUnspeccedNS = v.AppBskyRichtextNS = v.AppBskyNotificationNS = v.ServiceRecord = v.AppBskyLabelerNS = v.ListitemRecord = v.ListblockRecord = v.ListRecord = v.FollowRecord = v.BlockRecord = v.AppBskyGraphNS = v.ThreadgateRecord = v.RepostRecord = v.PostRecord = v.LikeRecord = v.GeneratorRecord = v.AppBskyFeedNS = v.AppBskyEmbedNS = v.ProfileRecord = v.AppBskyActorNS = v.AppBskyNS = v.AppNS = v.ComAtprotoTempNS = v.ComAtprotoSyncNS = v.ComAtprotoServerNS = v.ComAtprotoRepoNS = v.ComAtprotoModerationNS = v.ComAtprotoLabelNS = v.ComAtprotoIdentityNS = v.ComAtprotoAdminNS = v.ComAtprotoNS = v.ComNS = v.AtpServiceClient = v.AtpBaseClient = v.TOOLS_OZONE_MODERATION = v.APP_BSKY_GRAPH = v.APP_BSKY_FEED = v.COM_ATPROTO_MODERATION = v.ToolsOzoneModerationSearchRepos = v.ToolsOzoneModerationQueryStatuses = v.ToolsOzoneModerationQueryEvents = v.ToolsOzoneModerationGetRepo = v.ToolsOzoneModerationGetRecord = v.ToolsOzoneModerationGetEvent = v.ToolsOzoneModerationEmitEvent = v.ToolsOzoneModerationDefs = v.ToolsOzoneCommunicationUpdateTemplate = v.ToolsOzoneCommunicationListTemplates = void 0;
v.ToolsOzoneModerationNS = v.ToolsOzoneCommunicationNS = void 0;
const iS = te, nS = Ne, aS = P(wa), sS = P(Sa), oS = P(La), lS = P(Ca), uS = P(Da), fS = P(ka), cS = P(Pa), dS = P(Ba), pS = P(Ia), hS = P(Ua), mS = P(Oa), yS = P(Ka), bS = P(Na), xS = P(Va), ES = P(Ma), gS = P(ja), vS = P(Fa), RS = P($a), AS = P(Ga), _S = P(qa), TS = P(Xa), wS = P(Ot), SS = P(ln), LS = P(un), CS = P(za), DS = P(Ha), kS = P(Za), PS = P(wi), BS = P(Si), IS = P(fn), US = P(Wa), OS = P(Ya), KS = P(Ja), NS = P(Lr), VS = P(Kt), MS = P(jr), jS = P(es), FS = P(Li), $S = P(Ci), GS = P(ts), qS = P(Di), XS = P(rs), zS = P(Cr), HS = P(cn), ZS = P(is), WS = P(ns), YS = P(Fr), JS = P(dn), QS = P(as), e1 = P(ss), t1 = P(os), r1 = P(ls), i1 = P(us), n1 = P(ki), a1 = P(fs), s1 = P($r), o1 = P(cs), l1 = P(ds), u1 = P(ps), f1 = P(pn), c1 = P(hn), d1 = P(hs), p1 = P(ms), h1 = P(ys), m1 = P(Pi), y1 = P(bs), b1 = P(xs), x1 = P(Es), E1 = P(gs), g1 = P(vs), v1 = P(Rs), R1 = P(As), A1 = P(_s), _1 = P(Ts), T1 = P(ws), w1 = P(Ss), S1 = P(Ls), L1 = P(Dr), C1 = P(Cs), D1 = P(Bi), k1 = P(Ii), P1 = P(mn), B1 = P(Ds), I1 = P(ks), U1 = P(yn), O1 = P(Ui), K1 = P(bn), N1 = P(xn), V1 = P(Ps), M1 = P(Bs), j1 = P(Is), F1 = P(Us), $1 = P(En), G1 = P(Os), q1 = P(Ks), X1 = P(Ns), z1 = P(Vs), H1 = P(Ms), Z1 = P(js), W1 = P(Fs), Y1 = P($s), J1 = P(Gs), Q1 = P(gn), eL = P(qs), tL = P(Xs), rL = P(zs), iL = P(Hs), nL = P(Zs), aL = P(Ws), sL = P(Ys), oL = P(Oi), lL = P(Js), uL = P(Qs), fL = P(eo), cL = P(to), dL = P(Ki), pL = P(vn), hL = P(Rn), mL = P(ro), yL = P(io), bL = P(no), xL = P(ao), EL = P(An), gL = P(so), vL = P(_n), RL = P(Tn), AL = P(oo), _L = P(lo), TL = P(uo);
v.ComAtprotoAdminDefs = P(Xt);
v.ComAtprotoAdminDeleteAccount = P(wa);
v.ComAtprotoAdminDisableAccountInvites = P(Sa);
v.ComAtprotoAdminDisableInviteCodes = P(La);
v.ComAtprotoAdminEnableAccountInvites = P(Ca);
v.ComAtprotoAdminGetAccountInfo = P(Da);
v.ComAtprotoAdminGetAccountInfos = P(ka);
v.ComAtprotoAdminGetInviteCodes = P(Pa);
v.ComAtprotoAdminGetSubjectStatus = P(Ba);
v.ComAtprotoAdminSendEmail = P(Ia);
v.ComAtprotoAdminUpdateAccountEmail = P(Ua);
v.ComAtprotoAdminUpdateAccountHandle = P(Oa);
v.ComAtprotoAdminUpdateAccountPassword = P(Ka);
v.ComAtprotoAdminUpdateSubjectStatus = P(Na);
v.ComAtprotoIdentityGetRecommendedDidCredentials = P(Va);
v.ComAtprotoIdentityRequestPlcOperationSignature = P(Ma);
v.ComAtprotoIdentityResolveHandle = P(ja);
v.ComAtprotoIdentitySignPlcOperation = P(Fa);
v.ComAtprotoIdentitySubmitPlcOperation = P($a);
v.ComAtprotoIdentityUpdateHandle = P(Ga);
v.ComAtprotoLabelDefs = P(wt);
v.ComAtprotoLabelQueryLabels = P(qa);
v.ComAtprotoLabelSubscribeLabels = P(Qr);
v.ComAtprotoModerationCreateReport = P(Xa);
v.ComAtprotoModerationDefs = P(or);
v.ComAtprotoRepoApplyWrites = P(Ot);
v.ComAtprotoRepoCreateRecord = P(ln);
v.ComAtprotoRepoDeleteRecord = P(un);
v.ComAtprotoRepoDescribeRepo = P(za);
v.ComAtprotoRepoGetRecord = P(Ha);
v.ComAtprotoRepoImportRepo = P(Za);
v.ComAtprotoRepoListMissingBlobs = P(wi);
v.ComAtprotoRepoListRecords = P(Si);
v.ComAtprotoRepoPutRecord = P(fn);
v.ComAtprotoRepoStrongRef = P(Mn);
v.ComAtprotoRepoUploadBlob = P(Wa);
v.ComAtprotoServerActivateAccount = P(Ya);
v.ComAtprotoServerCheckAccountStatus = P(Ja);
v.ComAtprotoServerConfirmEmail = P(Lr);
v.ComAtprotoServerCreateAccount = P(Kt);
v.ComAtprotoServerCreateAppPassword = P(Fr);
v.ComAtprotoServerCreateInviteCode = P(es);
v.ComAtprotoServerCreateInviteCodes = P(Li);
v.ComAtprotoServerCreateSession = P(Ci);
v.ComAtprotoServerDeactivateAccount = P(ts);
v.ComAtprotoServerDefs = P(ei);
v.ComAtprotoServerDeleteAccount = P(Di);
v.ComAtprotoServerDeleteSession = P(rs);
v.ComAtprotoServerDescribeServer = P(Cr);
v.ComAtprotoServerGetAccountInviteCodes = P(cn);
v.ComAtprotoServerGetServiceAuth = P(is);
v.ComAtprotoServerGetSession = P(ns);
v.ComAtprotoServerListAppPasswords = P($r);
v.ComAtprotoServerRefreshSession = P(dn);
v.ComAtprotoServerRequestAccountDelete = P(as);
v.ComAtprotoServerRequestEmailConfirmation = P(ss);
v.ComAtprotoServerRequestEmailUpdate = P(os);
v.ComAtprotoServerRequestPasswordReset = P(ls);
v.ComAtprotoServerReserveSigningKey = P(us);
v.ComAtprotoServerResetPassword = P(ki);
v.ComAtprotoServerRevokeAppPassword = P(fs);
v.ComAtprotoServerUpdateEmail = P(Gr);
v.ComAtprotoSyncGetBlob = P(cs);
v.ComAtprotoSyncGetBlocks = P(ds);
v.ComAtprotoSyncGetCheckout = P(ps);
v.ComAtprotoSyncGetHead = P(pn);
v.ComAtprotoSyncGetLatestCommit = P(hn);
v.ComAtprotoSyncGetRecord = P(hs);
v.ComAtprotoSyncGetRepo = P(ms);
v.ComAtprotoSyncListBlobs = P(ys);
v.ComAtprotoSyncListRepos = P(Pi);
v.ComAtprotoSyncNotifyOfUpdate = P(bs);
v.ComAtprotoSyncRequestCrawl = P(xs);
v.ComAtprotoSyncSubscribeRepos = P(it);
v.ComAtprotoTempCheckSignupQueue = P(Es);
v.ComAtprotoTempFetchLabels = P(gs);
v.ComAtprotoTempRequestPhoneVerification = P(vs);
v.AppBskyActorDefs = P(ge);
v.AppBskyActorGetPreferences = P(Rs);
v.AppBskyActorGetProfile = P(As);
v.AppBskyActorGetProfiles = P(_s);
v.AppBskyActorGetSuggestions = P(Ts);
v.AppBskyActorProfile = P(jn);
v.AppBskyActorPutPreferences = P(ws);
v.AppBskyActorSearchActors = P(Ss);
v.AppBskyActorSearchActorsTypeahead = P(Ls);
v.AppBskyEmbedExternal = P(zt);
v.AppBskyEmbedImages = P(St);
v.AppBskyEmbedRecord = P(Lt);
v.AppBskyEmbedRecordWithMedia = P(ti);
v.AppBskyFeedDefs = P(me);
v.AppBskyFeedDescribeFeedGenerator = P(Dr);
v.AppBskyFeedGenerator = P(Fn);
v.AppBskyFeedGetActorFeeds = P(Cs);
v.AppBskyFeedGetActorLikes = P(Bi);
v.AppBskyFeedGetAuthorFeed = P(Ii);
v.AppBskyFeedGetFeed = P(mn);
v.AppBskyFeedGetFeedGenerator = P(Ds);
v.AppBskyFeedGetFeedGenerators = P(ks);
v.AppBskyFeedGetFeedSkeleton = P(yn);
v.AppBskyFeedGetLikes = P(Ui);
v.AppBskyFeedGetListFeed = P(bn);
v.AppBskyFeedGetPostThread = P(xn);
v.AppBskyFeedGetPosts = P(Ps);
v.AppBskyFeedGetRepostedBy = P(Bs);
v.AppBskyFeedGetSuggestedFeeds = P(Is);
v.AppBskyFeedGetTimeline = P(Us);
v.AppBskyFeedLike = P($n);
v.AppBskyFeedPost = P(Ht);
v.AppBskyFeedRepost = P(Gn);
v.AppBskyFeedSearchPosts = P(En);
v.AppBskyFeedSendInteractions = P(Os);
v.AppBskyFeedThreadgate = P(Zt);
v.AppBskyGraphBlock = P(qn);
v.AppBskyGraphDefs = P(nt);
v.AppBskyGraphFollow = P(Xn);
v.AppBskyGraphGetBlocks = P(Ks);
v.AppBskyGraphGetFollowers = P(Ns);
v.AppBskyGraphGetFollows = P(Vs);
v.AppBskyGraphGetList = P(Ms);
v.AppBskyGraphGetListBlocks = P(js);
v.AppBskyGraphGetListMutes = P(Fs);
v.AppBskyGraphGetLists = P($s);
v.AppBskyGraphGetMutes = P(Gs);
v.AppBskyGraphGetRelationships = P(gn);
v.AppBskyGraphGetSuggestedFollowsByActor = P(qs);
v.AppBskyGraphList = P(zn);
v.AppBskyGraphListblock = P(Hn);
v.AppBskyGraphListitem = P(Zn);
v.AppBskyGraphMuteActor = P(Xs);
v.AppBskyGraphMuteActorList = P(zs);
v.AppBskyGraphUnmuteActor = P(Hs);
v.AppBskyGraphUnmuteActorList = P(Zs);
v.AppBskyLabelerDefs = P(Wt);
v.AppBskyLabelerGetServices = P(Ws);
v.AppBskyLabelerService = P(Wn);
v.AppBskyNotificationGetUnreadCount = P(Ys);
v.AppBskyNotificationListNotifications = P(Oi);
v.AppBskyNotificationRegisterPush = P(Js);
v.AppBskyNotificationUpdateSeen = P(Qs);
v.AppBskyRichtextFacet = P(Ct);
v.AppBskyUnspeccedDefs = P(ri);
v.AppBskyUnspeccedGetPopularFeedGenerators = P(eo);
v.AppBskyUnspeccedGetSuggestionsSkeleton = P(to);
v.AppBskyUnspeccedGetTaggedSuggestions = P(Ki);
v.AppBskyUnspeccedSearchActorsSkeleton = P(vn);
v.AppBskyUnspeccedSearchPostsSkeleton = P(Rn);
v.ToolsOzoneCommunicationCreateTemplate = P(ro);
v.ToolsOzoneCommunicationDefs = P(Yn);
v.ToolsOzoneCommunicationDeleteTemplate = P(io);
v.ToolsOzoneCommunicationListTemplates = P(no);
v.ToolsOzoneCommunicationUpdateTemplate = P(ao);
v.ToolsOzoneModerationDefs = P(ne);
v.ToolsOzoneModerationEmitEvent = P(An);
v.ToolsOzoneModerationGetEvent = P(so);
v.ToolsOzoneModerationGetRecord = P(_n);
v.ToolsOzoneModerationGetRepo = P(Tn);
v.ToolsOzoneModerationQueryEvents = P(oo);
v.ToolsOzoneModerationQueryStatuses = P(lo);
v.ToolsOzoneModerationSearchRepos = P(uo);
v.COM_ATPROTO_MODERATION = {
  DefsReasonSpam: "com.atproto.moderation.defs#reasonSpam",
  DefsReasonViolation: "com.atproto.moderation.defs#reasonViolation",
  DefsReasonMisleading: "com.atproto.moderation.defs#reasonMisleading",
  DefsReasonSexual: "com.atproto.moderation.defs#reasonSexual",
  DefsReasonRude: "com.atproto.moderation.defs#reasonRude",
  DefsReasonOther: "com.atproto.moderation.defs#reasonOther",
  DefsReasonAppeal: "com.atproto.moderation.defs#reasonAppeal"
};
v.APP_BSKY_FEED = {
  DefsRequestLess: "app.bsky.feed.defs#requestLess",
  DefsRequestMore: "app.bsky.feed.defs#requestMore",
  DefsClickthroughItem: "app.bsky.feed.defs#clickthroughItem",
  DefsClickthroughAuthor: "app.bsky.feed.defs#clickthroughAuthor",
  DefsClickthroughReposter: "app.bsky.feed.defs#clickthroughReposter",
  DefsClickthroughEmbed: "app.bsky.feed.defs#clickthroughEmbed",
  DefsInteractionSeen: "app.bsky.feed.defs#interactionSeen",
  DefsInteractionLike: "app.bsky.feed.defs#interactionLike",
  DefsInteractionRepost: "app.bsky.feed.defs#interactionRepost",
  DefsInteractionReply: "app.bsky.feed.defs#interactionReply",
  DefsInteractionQuote: "app.bsky.feed.defs#interactionQuote",
  DefsInteractionShare: "app.bsky.feed.defs#interactionShare"
};
v.APP_BSKY_GRAPH = {
  DefsModlist: "app.bsky.graph.defs#modlist",
  DefsCuratelist: "app.bsky.graph.defs#curatelist"
};
v.TOOLS_OZONE_MODERATION = {
  DefsReviewOpen: "tools.ozone.moderation.defs#reviewOpen",
  DefsReviewEscalated: "tools.ozone.moderation.defs#reviewEscalated",
  DefsReviewClosed: "tools.ozone.moderation.defs#reviewClosed",
  DefsReviewNone: "tools.ozone.moderation.defs#reviewNone"
};
class wL {
  constructor() {
    Object.defineProperty(this, "xrpc", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new iS.Client()
    }), this.xrpc.addLexicons(nS.schemas);
  }
  service(e) {
    return new qd(this, this.xrpc.service(e));
  }
}
v.AtpBaseClient = wL;
class qd {
  constructor(e, r) {
    Object.defineProperty(this, "_baseClient", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "xrpc", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "com", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "app", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tools", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._baseClient = e, this.xrpc = r, this.com = new Xd(this), this.app = new rp(this), this.tools = new _p(this);
  }
  setHeader(e, r) {
    this.xrpc.setHeader(e, r);
  }
}
v.AtpServiceClient = qd;
class Xd {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "atproto", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.atproto = new zd(e);
  }
}
v.ComNS = Xd;
class zd {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "admin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "identity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "label", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "moderation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "repo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "server", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "sync", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "temp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.admin = new Hd(e), this.identity = new Zd(e), this.label = new Wd(e), this.moderation = new Yd(e), this.repo = new Jd(e), this.server = new Qd(e), this.sync = new ep(e), this.temp = new tp(e);
  }
}
v.ComAtprotoNS = zd;
class Hd {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  deleteAccount(e, r) {
    return this._service.xrpc.call("com.atproto.admin.deleteAccount", r?.qp, e, r).catch((a) => {
      throw aS.toKnownErr(a);
    });
  }
  disableAccountInvites(e, r) {
    return this._service.xrpc.call("com.atproto.admin.disableAccountInvites", r?.qp, e, r).catch((a) => {
      throw sS.toKnownErr(a);
    });
  }
  disableInviteCodes(e, r) {
    return this._service.xrpc.call("com.atproto.admin.disableInviteCodes", r?.qp, e, r).catch((a) => {
      throw oS.toKnownErr(a);
    });
  }
  enableAccountInvites(e, r) {
    return this._service.xrpc.call("com.atproto.admin.enableAccountInvites", r?.qp, e, r).catch((a) => {
      throw lS.toKnownErr(a);
    });
  }
  getAccountInfo(e, r) {
    return this._service.xrpc.call("com.atproto.admin.getAccountInfo", e, void 0, r).catch((a) => {
      throw uS.toKnownErr(a);
    });
  }
  getAccountInfos(e, r) {
    return this._service.xrpc.call("com.atproto.admin.getAccountInfos", e, void 0, r).catch((a) => {
      throw fS.toKnownErr(a);
    });
  }
  getInviteCodes(e, r) {
    return this._service.xrpc.call("com.atproto.admin.getInviteCodes", e, void 0, r).catch((a) => {
      throw cS.toKnownErr(a);
    });
  }
  getSubjectStatus(e, r) {
    return this._service.xrpc.call("com.atproto.admin.getSubjectStatus", e, void 0, r).catch((a) => {
      throw dS.toKnownErr(a);
    });
  }
  sendEmail(e, r) {
    return this._service.xrpc.call("com.atproto.admin.sendEmail", r?.qp, e, r).catch((a) => {
      throw pS.toKnownErr(a);
    });
  }
  updateAccountEmail(e, r) {
    return this._service.xrpc.call("com.atproto.admin.updateAccountEmail", r?.qp, e, r).catch((a) => {
      throw hS.toKnownErr(a);
    });
  }
  updateAccountHandle(e, r) {
    return this._service.xrpc.call("com.atproto.admin.updateAccountHandle", r?.qp, e, r).catch((a) => {
      throw mS.toKnownErr(a);
    });
  }
  updateAccountPassword(e, r) {
    return this._service.xrpc.call("com.atproto.admin.updateAccountPassword", r?.qp, e, r).catch((a) => {
      throw yS.toKnownErr(a);
    });
  }
  updateSubjectStatus(e, r) {
    return this._service.xrpc.call("com.atproto.admin.updateSubjectStatus", r?.qp, e, r).catch((a) => {
      throw bS.toKnownErr(a);
    });
  }
}
v.ComAtprotoAdminNS = Hd;
class Zd {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getRecommendedDidCredentials(e, r) {
    return this._service.xrpc.call("com.atproto.identity.getRecommendedDidCredentials", e, void 0, r).catch((a) => {
      throw xS.toKnownErr(a);
    });
  }
  requestPlcOperationSignature(e, r) {
    return this._service.xrpc.call("com.atproto.identity.requestPlcOperationSignature", r?.qp, e, r).catch((a) => {
      throw ES.toKnownErr(a);
    });
  }
  resolveHandle(e, r) {
    return this._service.xrpc.call("com.atproto.identity.resolveHandle", e, void 0, r).catch((a) => {
      throw gS.toKnownErr(a);
    });
  }
  signPlcOperation(e, r) {
    return this._service.xrpc.call("com.atproto.identity.signPlcOperation", r?.qp, e, r).catch((a) => {
      throw vS.toKnownErr(a);
    });
  }
  submitPlcOperation(e, r) {
    return this._service.xrpc.call("com.atproto.identity.submitPlcOperation", r?.qp, e, r).catch((a) => {
      throw RS.toKnownErr(a);
    });
  }
  updateHandle(e, r) {
    return this._service.xrpc.call("com.atproto.identity.updateHandle", r?.qp, e, r).catch((a) => {
      throw AS.toKnownErr(a);
    });
  }
}
v.ComAtprotoIdentityNS = Zd;
class Wd {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  queryLabels(e, r) {
    return this._service.xrpc.call("com.atproto.label.queryLabels", e, void 0, r).catch((a) => {
      throw _S.toKnownErr(a);
    });
  }
}
v.ComAtprotoLabelNS = Wd;
class Yd {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  createReport(e, r) {
    return this._service.xrpc.call("com.atproto.moderation.createReport", r?.qp, e, r).catch((a) => {
      throw TS.toKnownErr(a);
    });
  }
}
v.ComAtprotoModerationNS = Yd;
class Jd {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  applyWrites(e, r) {
    return this._service.xrpc.call("com.atproto.repo.applyWrites", r?.qp, e, r).catch((a) => {
      throw wS.toKnownErr(a);
    });
  }
  createRecord(e, r) {
    return this._service.xrpc.call("com.atproto.repo.createRecord", r?.qp, e, r).catch((a) => {
      throw SS.toKnownErr(a);
    });
  }
  deleteRecord(e, r) {
    return this._service.xrpc.call("com.atproto.repo.deleteRecord", r?.qp, e, r).catch((a) => {
      throw LS.toKnownErr(a);
    });
  }
  describeRepo(e, r) {
    return this._service.xrpc.call("com.atproto.repo.describeRepo", e, void 0, r).catch((a) => {
      throw CS.toKnownErr(a);
    });
  }
  getRecord(e, r) {
    return this._service.xrpc.call("com.atproto.repo.getRecord", e, void 0, r).catch((a) => {
      throw DS.toKnownErr(a);
    });
  }
  importRepo(e, r) {
    return this._service.xrpc.call("com.atproto.repo.importRepo", r?.qp, e, r).catch((a) => {
      throw kS.toKnownErr(a);
    });
  }
  listMissingBlobs(e, r) {
    return this._service.xrpc.call("com.atproto.repo.listMissingBlobs", e, void 0, r).catch((a) => {
      throw PS.toKnownErr(a);
    });
  }
  listRecords(e, r) {
    return this._service.xrpc.call("com.atproto.repo.listRecords", e, void 0, r).catch((a) => {
      throw BS.toKnownErr(a);
    });
  }
  putRecord(e, r) {
    return this._service.xrpc.call("com.atproto.repo.putRecord", r?.qp, e, r).catch((a) => {
      throw IS.toKnownErr(a);
    });
  }
  uploadBlob(e, r) {
    return this._service.xrpc.call("com.atproto.repo.uploadBlob", r?.qp, e, r).catch((a) => {
      throw US.toKnownErr(a);
    });
  }
}
v.ComAtprotoRepoNS = Jd;
class Qd {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  activateAccount(e, r) {
    return this._service.xrpc.call("com.atproto.server.activateAccount", r?.qp, e, r).catch((a) => {
      throw OS.toKnownErr(a);
    });
  }
  checkAccountStatus(e, r) {
    return this._service.xrpc.call("com.atproto.server.checkAccountStatus", e, void 0, r).catch((a) => {
      throw KS.toKnownErr(a);
    });
  }
  confirmEmail(e, r) {
    return this._service.xrpc.call("com.atproto.server.confirmEmail", r?.qp, e, r).catch((a) => {
      throw NS.toKnownErr(a);
    });
  }
  createAccount(e, r) {
    return this._service.xrpc.call("com.atproto.server.createAccount", r?.qp, e, r).catch((a) => {
      throw VS.toKnownErr(a);
    });
  }
  createAppPassword(e, r) {
    return this._service.xrpc.call("com.atproto.server.createAppPassword", r?.qp, e, r).catch((a) => {
      throw MS.toKnownErr(a);
    });
  }
  createInviteCode(e, r) {
    return this._service.xrpc.call("com.atproto.server.createInviteCode", r?.qp, e, r).catch((a) => {
      throw jS.toKnownErr(a);
    });
  }
  createInviteCodes(e, r) {
    return this._service.xrpc.call("com.atproto.server.createInviteCodes", r?.qp, e, r).catch((a) => {
      throw FS.toKnownErr(a);
    });
  }
  createSession(e, r) {
    return this._service.xrpc.call("com.atproto.server.createSession", r?.qp, e, r).catch((a) => {
      throw $S.toKnownErr(a);
    });
  }
  deactivateAccount(e, r) {
    return this._service.xrpc.call("com.atproto.server.deactivateAccount", r?.qp, e, r).catch((a) => {
      throw GS.toKnownErr(a);
    });
  }
  deleteAccount(e, r) {
    return this._service.xrpc.call("com.atproto.server.deleteAccount", r?.qp, e, r).catch((a) => {
      throw qS.toKnownErr(a);
    });
  }
  deleteSession(e, r) {
    return this._service.xrpc.call("com.atproto.server.deleteSession", r?.qp, e, r).catch((a) => {
      throw XS.toKnownErr(a);
    });
  }
  describeServer(e, r) {
    return this._service.xrpc.call("com.atproto.server.describeServer", e, void 0, r).catch((a) => {
      throw zS.toKnownErr(a);
    });
  }
  getAccountInviteCodes(e, r) {
    return this._service.xrpc.call("com.atproto.server.getAccountInviteCodes", e, void 0, r).catch((a) => {
      throw HS.toKnownErr(a);
    });
  }
  getServiceAuth(e, r) {
    return this._service.xrpc.call("com.atproto.server.getServiceAuth", e, void 0, r).catch((a) => {
      throw ZS.toKnownErr(a);
    });
  }
  getSession(e, r) {
    return this._service.xrpc.call("com.atproto.server.getSession", e, void 0, r).catch((a) => {
      throw WS.toKnownErr(a);
    });
  }
  listAppPasswords(e, r) {
    return this._service.xrpc.call("com.atproto.server.listAppPasswords", e, void 0, r).catch((a) => {
      throw YS.toKnownErr(a);
    });
  }
  refreshSession(e, r) {
    return this._service.xrpc.call("com.atproto.server.refreshSession", r?.qp, e, r).catch((a) => {
      throw JS.toKnownErr(a);
    });
  }
  requestAccountDelete(e, r) {
    return this._service.xrpc.call("com.atproto.server.requestAccountDelete", r?.qp, e, r).catch((a) => {
      throw QS.toKnownErr(a);
    });
  }
  requestEmailConfirmation(e, r) {
    return this._service.xrpc.call("com.atproto.server.requestEmailConfirmation", r?.qp, e, r).catch((a) => {
      throw e1.toKnownErr(a);
    });
  }
  requestEmailUpdate(e, r) {
    return this._service.xrpc.call("com.atproto.server.requestEmailUpdate", r?.qp, e, r).catch((a) => {
      throw t1.toKnownErr(a);
    });
  }
  requestPasswordReset(e, r) {
    return this._service.xrpc.call("com.atproto.server.requestPasswordReset", r?.qp, e, r).catch((a) => {
      throw r1.toKnownErr(a);
    });
  }
  reserveSigningKey(e, r) {
    return this._service.xrpc.call("com.atproto.server.reserveSigningKey", r?.qp, e, r).catch((a) => {
      throw i1.toKnownErr(a);
    });
  }
  resetPassword(e, r) {
    return this._service.xrpc.call("com.atproto.server.resetPassword", r?.qp, e, r).catch((a) => {
      throw n1.toKnownErr(a);
    });
  }
  revokeAppPassword(e, r) {
    return this._service.xrpc.call("com.atproto.server.revokeAppPassword", r?.qp, e, r).catch((a) => {
      throw a1.toKnownErr(a);
    });
  }
  updateEmail(e, r) {
    return this._service.xrpc.call("com.atproto.server.updateEmail", r?.qp, e, r).catch((a) => {
      throw s1.toKnownErr(a);
    });
  }
}
v.ComAtprotoServerNS = Qd;
class ep {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getBlob(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getBlob", e, void 0, r).catch((a) => {
      throw o1.toKnownErr(a);
    });
  }
  getBlocks(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getBlocks", e, void 0, r).catch((a) => {
      throw l1.toKnownErr(a);
    });
  }
  getCheckout(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getCheckout", e, void 0, r).catch((a) => {
      throw u1.toKnownErr(a);
    });
  }
  getHead(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getHead", e, void 0, r).catch((a) => {
      throw f1.toKnownErr(a);
    });
  }
  getLatestCommit(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getLatestCommit", e, void 0, r).catch((a) => {
      throw c1.toKnownErr(a);
    });
  }
  getRecord(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getRecord", e, void 0, r).catch((a) => {
      throw d1.toKnownErr(a);
    });
  }
  getRepo(e, r) {
    return this._service.xrpc.call("com.atproto.sync.getRepo", e, void 0, r).catch((a) => {
      throw p1.toKnownErr(a);
    });
  }
  listBlobs(e, r) {
    return this._service.xrpc.call("com.atproto.sync.listBlobs", e, void 0, r).catch((a) => {
      throw h1.toKnownErr(a);
    });
  }
  listRepos(e, r) {
    return this._service.xrpc.call("com.atproto.sync.listRepos", e, void 0, r).catch((a) => {
      throw m1.toKnownErr(a);
    });
  }
  notifyOfUpdate(e, r) {
    return this._service.xrpc.call("com.atproto.sync.notifyOfUpdate", r?.qp, e, r).catch((a) => {
      throw y1.toKnownErr(a);
    });
  }
  requestCrawl(e, r) {
    return this._service.xrpc.call("com.atproto.sync.requestCrawl", r?.qp, e, r).catch((a) => {
      throw b1.toKnownErr(a);
    });
  }
}
v.ComAtprotoSyncNS = ep;
class tp {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  checkSignupQueue(e, r) {
    return this._service.xrpc.call("com.atproto.temp.checkSignupQueue", e, void 0, r).catch((a) => {
      throw x1.toKnownErr(a);
    });
  }
  fetchLabels(e, r) {
    return this._service.xrpc.call("com.atproto.temp.fetchLabels", e, void 0, r).catch((a) => {
      throw E1.toKnownErr(a);
    });
  }
  requestPhoneVerification(e, r) {
    return this._service.xrpc.call("com.atproto.temp.requestPhoneVerification", r?.qp, e, r).catch((a) => {
      throw g1.toKnownErr(a);
    });
  }
}
v.ComAtprotoTempNS = tp;
class rp {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "bsky", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.bsky = new ip(e);
  }
}
v.AppNS = rp;
class ip {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "actor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "embed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "feed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "graph", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "labeler", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "notification", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "richtext", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "unspecced", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.actor = new np(e), this.embed = new sp(e), this.feed = new op(e), this.graph = new pp(e), this.labeler = new Ep(e), this.notification = new vp(e), this.richtext = new Rp(e), this.unspecced = new Ap(e);
  }
}
v.AppBskyNS = ip;
class np {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "profile", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.profile = new ap(e);
  }
  getPreferences(e, r) {
    return this._service.xrpc.call("app.bsky.actor.getPreferences", e, void 0, r).catch((a) => {
      throw v1.toKnownErr(a);
    });
  }
  getProfile(e, r) {
    return this._service.xrpc.call("app.bsky.actor.getProfile", e, void 0, r).catch((a) => {
      throw R1.toKnownErr(a);
    });
  }
  getProfiles(e, r) {
    return this._service.xrpc.call("app.bsky.actor.getProfiles", e, void 0, r).catch((a) => {
      throw A1.toKnownErr(a);
    });
  }
  getSuggestions(e, r) {
    return this._service.xrpc.call("app.bsky.actor.getSuggestions", e, void 0, r).catch((a) => {
      throw _1.toKnownErr(a);
    });
  }
  putPreferences(e, r) {
    return this._service.xrpc.call("app.bsky.actor.putPreferences", r?.qp, e, r).catch((a) => {
      throw T1.toKnownErr(a);
    });
  }
  searchActors(e, r) {
    return this._service.xrpc.call("app.bsky.actor.searchActors", e, void 0, r).catch((a) => {
      throw w1.toKnownErr(a);
    });
  }
  searchActorsTypeahead(e, r) {
    return this._service.xrpc.call("app.bsky.actor.searchActorsTypeahead", e, void 0, r).catch((a) => {
      throw S1.toKnownErr(a);
    });
  }
}
v.AppBskyActorNS = np;
class ap {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.actor.profile",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.actor.profile",
      ...e
    })).data;
  }
  async create(e, r, a) {
    return r.$type = "app.bsky.actor.profile", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.actor.profile", rkey: "self", ...e, record: r }, { encoding: "application/json", headers: a })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.actor.profile", ...e }, { headers: r });
  }
}
v.ProfileRecord = ap;
class sp {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
}
v.AppBskyEmbedNS = sp;
class op {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "generator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "like", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "post", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "repost", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "threadgate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.generator = new lp(e), this.like = new up(e), this.post = new fp(e), this.repost = new cp(e), this.threadgate = new dp(e);
  }
  describeFeedGenerator(e, r) {
    return this._service.xrpc.call("app.bsky.feed.describeFeedGenerator", e, void 0, r).catch((a) => {
      throw L1.toKnownErr(a);
    });
  }
  getActorFeeds(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getActorFeeds", e, void 0, r).catch((a) => {
      throw C1.toKnownErr(a);
    });
  }
  getActorLikes(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getActorLikes", e, void 0, r).catch((a) => {
      throw D1.toKnownErr(a);
    });
  }
  getAuthorFeed(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getAuthorFeed", e, void 0, r).catch((a) => {
      throw k1.toKnownErr(a);
    });
  }
  getFeed(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getFeed", e, void 0, r).catch((a) => {
      throw P1.toKnownErr(a);
    });
  }
  getFeedGenerator(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getFeedGenerator", e, void 0, r).catch((a) => {
      throw B1.toKnownErr(a);
    });
  }
  getFeedGenerators(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getFeedGenerators", e, void 0, r).catch((a) => {
      throw I1.toKnownErr(a);
    });
  }
  getFeedSkeleton(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getFeedSkeleton", e, void 0, r).catch((a) => {
      throw U1.toKnownErr(a);
    });
  }
  getLikes(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getLikes", e, void 0, r).catch((a) => {
      throw O1.toKnownErr(a);
    });
  }
  getListFeed(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getListFeed", e, void 0, r).catch((a) => {
      throw K1.toKnownErr(a);
    });
  }
  getPostThread(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getPostThread", e, void 0, r).catch((a) => {
      throw N1.toKnownErr(a);
    });
  }
  getPosts(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getPosts", e, void 0, r).catch((a) => {
      throw V1.toKnownErr(a);
    });
  }
  getRepostedBy(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getRepostedBy", e, void 0, r).catch((a) => {
      throw M1.toKnownErr(a);
    });
  }
  getSuggestedFeeds(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getSuggestedFeeds", e, void 0, r).catch((a) => {
      throw j1.toKnownErr(a);
    });
  }
  getTimeline(e, r) {
    return this._service.xrpc.call("app.bsky.feed.getTimeline", e, void 0, r).catch((a) => {
      throw F1.toKnownErr(a);
    });
  }
  searchPosts(e, r) {
    return this._service.xrpc.call("app.bsky.feed.searchPosts", e, void 0, r).catch((a) => {
      throw $1.toKnownErr(a);
    });
  }
  sendInteractions(e, r) {
    return this._service.xrpc.call("app.bsky.feed.sendInteractions", r?.qp, e, r).catch((a) => {
      throw G1.toKnownErr(a);
    });
  }
}
v.AppBskyFeedNS = op;
class lp {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.feed.generator",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.feed.generator",
      ...e
    })).data;
  }
  async create(e, r, a) {
    return r.$type = "app.bsky.feed.generator", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.generator", ...e, record: r }, { encoding: "application/json", headers: a })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.generator", ...e }, { headers: r });
  }
}
v.GeneratorRecord = lp;
class up {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.feed.like",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.feed.like",
      ...e
    })).data;
  }
  async create(e, r, a) {
    return r.$type = "app.bsky.feed.like", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.like", ...e, record: r }, { encoding: "application/json", headers: a })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.like", ...e }, { headers: r });
  }
}
v.LikeRecord = up;
class fp {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.feed.post",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.feed.post",
      ...e
    })).data;
  }
  async create(e, r, a) {
    return r.$type = "app.bsky.feed.post", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.post", ...e, record: r }, { encoding: "application/json", headers: a })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.post", ...e }, { headers: r });
  }
}
v.PostRecord = fp;
class cp {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.feed.repost",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.feed.repost",
      ...e
    })).data;
  }
  async create(e, r, a) {
    return r.$type = "app.bsky.feed.repost", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.repost", ...e, record: r }, { encoding: "application/json", headers: a })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.repost", ...e }, { headers: r });
  }
}
v.RepostRecord = cp;
class dp {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.feed.threadgate",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.feed.threadgate",
      ...e
    })).data;
  }
  async create(e, r, a) {
    return r.$type = "app.bsky.feed.threadgate", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.feed.threadgate", ...e, record: r }, { encoding: "application/json", headers: a })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.threadgate", ...e }, { headers: r });
  }
}
v.ThreadgateRecord = dp;
class pp {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "block", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "follow", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "list", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "listblock", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "listitem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.block = new hp(e), this.follow = new mp(e), this.list = new yp(e), this.listblock = new bp(e), this.listitem = new xp(e);
  }
  getBlocks(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getBlocks", e, void 0, r).catch((a) => {
      throw q1.toKnownErr(a);
    });
  }
  getFollowers(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getFollowers", e, void 0, r).catch((a) => {
      throw X1.toKnownErr(a);
    });
  }
  getFollows(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getFollows", e, void 0, r).catch((a) => {
      throw z1.toKnownErr(a);
    });
  }
  getList(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getList", e, void 0, r).catch((a) => {
      throw H1.toKnownErr(a);
    });
  }
  getListBlocks(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getListBlocks", e, void 0, r).catch((a) => {
      throw Z1.toKnownErr(a);
    });
  }
  getListMutes(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getListMutes", e, void 0, r).catch((a) => {
      throw W1.toKnownErr(a);
    });
  }
  getLists(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getLists", e, void 0, r).catch((a) => {
      throw Y1.toKnownErr(a);
    });
  }
  getMutes(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getMutes", e, void 0, r).catch((a) => {
      throw J1.toKnownErr(a);
    });
  }
  getRelationships(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getRelationships", e, void 0, r).catch((a) => {
      throw Q1.toKnownErr(a);
    });
  }
  getSuggestedFollowsByActor(e, r) {
    return this._service.xrpc.call("app.bsky.graph.getSuggestedFollowsByActor", e, void 0, r).catch((a) => {
      throw eL.toKnownErr(a);
    });
  }
  muteActor(e, r) {
    return this._service.xrpc.call("app.bsky.graph.muteActor", r?.qp, e, r).catch((a) => {
      throw tL.toKnownErr(a);
    });
  }
  muteActorList(e, r) {
    return this._service.xrpc.call("app.bsky.graph.muteActorList", r?.qp, e, r).catch((a) => {
      throw rL.toKnownErr(a);
    });
  }
  unmuteActor(e, r) {
    return this._service.xrpc.call("app.bsky.graph.unmuteActor", r?.qp, e, r).catch((a) => {
      throw iL.toKnownErr(a);
    });
  }
  unmuteActorList(e, r) {
    return this._service.xrpc.call("app.bsky.graph.unmuteActorList", r?.qp, e, r).catch((a) => {
      throw nL.toKnownErr(a);
    });
  }
}
v.AppBskyGraphNS = pp;
class hp {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.block",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.block",
      ...e
    })).data;
  }
  async create(e, r, a) {
    return r.$type = "app.bsky.graph.block", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.block", ...e, record: r }, { encoding: "application/json", headers: a })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.block", ...e }, { headers: r });
  }
}
v.BlockRecord = hp;
class mp {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.follow",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.follow",
      ...e
    })).data;
  }
  async create(e, r, a) {
    return r.$type = "app.bsky.graph.follow", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.follow", ...e, record: r }, { encoding: "application/json", headers: a })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.follow", ...e }, { headers: r });
  }
}
v.FollowRecord = mp;
class yp {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.list",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.list",
      ...e
    })).data;
  }
  async create(e, r, a) {
    return r.$type = "app.bsky.graph.list", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.list", ...e, record: r }, { encoding: "application/json", headers: a })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.list", ...e }, { headers: r });
  }
}
v.ListRecord = yp;
class bp {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.listblock",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.listblock",
      ...e
    })).data;
  }
  async create(e, r, a) {
    return r.$type = "app.bsky.graph.listblock", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.listblock", ...e, record: r }, { encoding: "application/json", headers: a })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.listblock", ...e }, { headers: r });
  }
}
v.ListblockRecord = bp;
class xp {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.graph.listitem",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.graph.listitem",
      ...e
    })).data;
  }
  async create(e, r, a) {
    return r.$type = "app.bsky.graph.listitem", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, { collection: "app.bsky.graph.listitem", ...e, record: r }, { encoding: "application/json", headers: a })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.listitem", ...e }, { headers: r });
  }
}
v.ListitemRecord = xp;
class Ep {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.service = new gp(e);
  }
  getServices(e, r) {
    return this._service.xrpc.call("app.bsky.labeler.getServices", e, void 0, r).catch((a) => {
      throw aL.toKnownErr(a);
    });
  }
}
v.AppBskyLabelerNS = Ep;
class gp {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  async list(e) {
    return (await this._service.xrpc.call("com.atproto.repo.listRecords", {
      collection: "app.bsky.labeler.service",
      ...e
    })).data;
  }
  async get(e) {
    return (await this._service.xrpc.call("com.atproto.repo.getRecord", {
      collection: "app.bsky.labeler.service",
      ...e
    })).data;
  }
  async create(e, r, a) {
    return r.$type = "app.bsky.labeler.service", (await this._service.xrpc.call("com.atproto.repo.createRecord", void 0, {
      collection: "app.bsky.labeler.service",
      rkey: "self",
      ...e,
      record: r
    }, { encoding: "application/json", headers: a })).data;
  }
  async delete(e, r) {
    await this._service.xrpc.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.labeler.service", ...e }, { headers: r });
  }
}
v.ServiceRecord = gp;
class vp {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getUnreadCount(e, r) {
    return this._service.xrpc.call("app.bsky.notification.getUnreadCount", e, void 0, r).catch((a) => {
      throw sL.toKnownErr(a);
    });
  }
  listNotifications(e, r) {
    return this._service.xrpc.call("app.bsky.notification.listNotifications", e, void 0, r).catch((a) => {
      throw oL.toKnownErr(a);
    });
  }
  registerPush(e, r) {
    return this._service.xrpc.call("app.bsky.notification.registerPush", r?.qp, e, r).catch((a) => {
      throw lL.toKnownErr(a);
    });
  }
  updateSeen(e, r) {
    return this._service.xrpc.call("app.bsky.notification.updateSeen", r?.qp, e, r).catch((a) => {
      throw uL.toKnownErr(a);
    });
  }
}
v.AppBskyNotificationNS = vp;
class Rp {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
}
v.AppBskyRichtextNS = Rp;
class Ap {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  getPopularFeedGenerators(e, r) {
    return this._service.xrpc.call("app.bsky.unspecced.getPopularFeedGenerators", e, void 0, r).catch((a) => {
      throw fL.toKnownErr(a);
    });
  }
  getSuggestionsSkeleton(e, r) {
    return this._service.xrpc.call("app.bsky.unspecced.getSuggestionsSkeleton", e, void 0, r).catch((a) => {
      throw cL.toKnownErr(a);
    });
  }
  getTaggedSuggestions(e, r) {
    return this._service.xrpc.call("app.bsky.unspecced.getTaggedSuggestions", e, void 0, r).catch((a) => {
      throw dL.toKnownErr(a);
    });
  }
  searchActorsSkeleton(e, r) {
    return this._service.xrpc.call("app.bsky.unspecced.searchActorsSkeleton", e, void 0, r).catch((a) => {
      throw pL.toKnownErr(a);
    });
  }
  searchPostsSkeleton(e, r) {
    return this._service.xrpc.call("app.bsky.unspecced.searchPostsSkeleton", e, void 0, r).catch((a) => {
      throw hL.toKnownErr(a);
    });
  }
}
v.AppBskyUnspeccedNS = Ap;
class _p {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "ozone", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.ozone = new Tp(e);
  }
}
v.ToolsNS = _p;
class Tp {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "communication", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "moderation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e, this.communication = new wp(e), this.moderation = new Sp(e);
  }
}
v.ToolsOzoneNS = Tp;
class wp {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  createTemplate(e, r) {
    return this._service.xrpc.call("tools.ozone.communication.createTemplate", r?.qp, e, r).catch((a) => {
      throw mL.toKnownErr(a);
    });
  }
  deleteTemplate(e, r) {
    return this._service.xrpc.call("tools.ozone.communication.deleteTemplate", r?.qp, e, r).catch((a) => {
      throw yL.toKnownErr(a);
    });
  }
  listTemplates(e, r) {
    return this._service.xrpc.call("tools.ozone.communication.listTemplates", e, void 0, r).catch((a) => {
      throw bL.toKnownErr(a);
    });
  }
  updateTemplate(e, r) {
    return this._service.xrpc.call("tools.ozone.communication.updateTemplate", r?.qp, e, r).catch((a) => {
      throw xL.toKnownErr(a);
    });
  }
}
v.ToolsOzoneCommunicationNS = wp;
class Sp {
  constructor(e) {
    Object.defineProperty(this, "_service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._service = e;
  }
  emitEvent(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.emitEvent", r?.qp, e, r).catch((a) => {
      throw EL.toKnownErr(a);
    });
  }
  getEvent(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.getEvent", e, void 0, r).catch((a) => {
      throw gL.toKnownErr(a);
    });
  }
  getRecord(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.getRecord", e, void 0, r).catch((a) => {
      throw vL.toKnownErr(a);
    });
  }
  getRepo(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.getRepo", e, void 0, r).catch((a) => {
      throw RL.toKnownErr(a);
    });
  }
  queryEvents(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.queryEvents", e, void 0, r).catch((a) => {
      throw AL.toKnownErr(a);
    });
  }
  queryStatuses(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.queryStatuses", e, void 0, r).catch((a) => {
      throw _L.toKnownErr(a);
    });
  }
  searchRepos(e, r) {
    return this._service.xrpc.call("tools.ozone.moderation.searchRepos", e, void 0, r).catch((a) => {
      throw TL.toKnownErr(a);
    });
  }
}
v.ToolsOzoneModerationNS = Sp;
var Jn = {};
Object.defineProperty(Jn, "__esModule", { value: !0 });
Jn.AtpAgent = void 0;
const SL = te, Lo = te, cf = Ji, LL = v, CL = _a, DL = 10, kL = "com.atproto.server.refreshSession";
class Sr {
  get com() {
    return this.api.com;
  }
  /**
   * Configures the API globally.
   */
  static configure(e) {
    e.fetch && (Sr.fetch = e.fetch), e.appLabelers && (Sr.appLabelers = e.appLabelers);
  }
  constructor(e) {
    Object.defineProperty(this, "service", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "api", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "session", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "labelersHeader", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "proxyHeader", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "pdsUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_baseClient", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_persistSession", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_refreshSessionPromise", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "uploadBlob", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (r, a) => this.api.com.atproto.repo.uploadBlob(r, a)
    }), Object.defineProperty(this, "resolveHandle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (r, a) => this.api.com.atproto.identity.resolveHandle(r, a)
    }), Object.defineProperty(this, "updateHandle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (r, a) => this.api.com.atproto.identity.updateHandle(r, a)
    }), Object.defineProperty(this, "createModerationReport", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (r, a) => this.api.com.atproto.moderation.createReport(r, a)
    }), this.service = e.service instanceof URL ? e.service : new URL(e.service), this._persistSession = e.persistSession, this._baseClient = new LL.AtpBaseClient(), this._baseClient.xrpc.fetch = this._fetch.bind(this), this.api = this._baseClient.service(e.service);
  }
  clone() {
    const e = new Sr({
      service: this.service
    });
    return this.copyInto(e), e;
  }
  copyInto(e) {
    e.session = this.session, e.labelersHeader = this.labelersHeader, e.proxyHeader = this.proxyHeader, e.pdsUrl = this.pdsUrl, e.api.xrpc.uri = this.pdsUrl || this.service;
  }
  withProxy(e, r) {
    const a = this.clone();
    return a.configureProxyHeader(e, r), a;
  }
  /**
   * Is there any active session?
   */
  get hasSession() {
    return !!this.session;
  }
  /**
   * Sets the "Persist Session" method which can be used to store access tokens
   * as they change.
   */
  setPersistSessionHandler(e) {
    this._persistSession = e;
  }
  /**
   * Configures the moderation services to be applied on requests.
   * NOTE: this is called automatically by getPreferences() and the relevant moderation config
   * methods in BskyAgent instances.
   */
  configureLabelersHeader(e) {
    this.labelersHeader = e;
  }
  /**
   * Configures the atproto-proxy header to be applied on requests
   */
  configureProxyHeader(e, r) {
    r.startsWith("did:") && (this.proxyHeader = `${r}#${e}`);
  }
  /**
   * Create a new account and hydrate its session in this agent.
   */
  async createAccount(e) {
    try {
      const r = await this.api.com.atproto.server.createAccount(e);
      return this.session = {
        accessJwt: r.data.accessJwt,
        refreshJwt: r.data.refreshJwt,
        handle: r.data.handle,
        did: r.data.did,
        email: e.email,
        emailConfirmed: !1,
        emailAuthFactor: !1
      }, this._updateApiEndpoint(r.data.didDoc), r;
    } catch (r) {
      throw this.session = void 0, r;
    } finally {
      this.session ? this._persistSession?.("create", this.session) : this._persistSession?.("create-failed", void 0);
    }
  }
  /**
   * Start a new session with this agent.
   */
  async login(e) {
    try {
      const r = await this.api.com.atproto.server.createSession({
        identifier: e.identifier,
        password: e.password,
        authFactorToken: e.authFactorToken
      });
      return this.session = {
        accessJwt: r.data.accessJwt,
        refreshJwt: r.data.refreshJwt,
        handle: r.data.handle,
        did: r.data.did,
        email: r.data.email,
        emailConfirmed: r.data.emailConfirmed,
        emailAuthFactor: r.data.emailAuthFactor
      }, this._updateApiEndpoint(r.data.didDoc), r;
    } catch (r) {
      throw this.session = void 0, r;
    } finally {
      this.session ? this._persistSession?.("create", this.session) : this._persistSession?.("create-failed", void 0);
    }
  }
  /**
   * Resume a pre-existing session with this agent.
   */
  async resumeSession(e) {
    try {
      this.session = e;
      const r = await this.api.com.atproto.server.getSession();
      if (r.data.did !== this.session.did)
        throw new Lo.XRPCError(Lo.ResponseType.InvalidRequest, "Invalid session", "InvalidDID");
      return this.session.email = r.data.email, this.session.handle = r.data.handle, this.session.emailConfirmed = r.data.emailConfirmed, this.session.emailAuthFactor = r.data.emailAuthFactor, this._updateApiEndpoint(r.data.didDoc), this._persistSession?.("update", this.session), r;
    } catch (r) {
      throw this.session = void 0, r instanceof Lo.XRPCError ? [1, 408, 425, 429, 500, 502, 503, 504, 522, 524].includes(r.status) ? this._persistSession?.("network-error", void 0) : this._persistSession?.("expired", void 0) : this._persistSession?.("network-error", void 0), r;
    }
  }
  /**
   * Internal helper to add authorization headers to requests.
   */
  _addHeaders(e) {
    return !e.authorization && this.session?.accessJwt && (e = {
      ...e,
      authorization: `Bearer ${this.session.accessJwt}`
    }), this.proxyHeader && (e = {
      ...e,
      "atproto-proxy": this.proxyHeader
    }), e = {
      ...e,
      "atproto-accept-labelers": Sr.appLabelers.map((r) => `${r};redact`).concat(this.labelersHeader.filter((r) => r.startsWith("did:"))).slice(0, DL).join(", ")
    }, e;
  }
  /**
   * Internal fetch handler which adds access-token management
   */
  async _fetch(e, r, a, u) {
    if (!Sr.fetch)
      throw new Error("AtpAgent fetch() method not configured");
    await this._refreshSessionPromise;
    let x = await Sr.fetch(e, r, this._addHeaders(a), u);
    return df(x, ["ExpiredToken"]) && this.session?.refreshJwt && (await this.refreshSession(), x = await Sr.fetch(e, r, this._addHeaders(a), u)), x;
  }
  /**
   * Internal helper to refresh sessions
   * - Wraps the actual implementation in a promise-guard to ensure only
   *   one refresh is attempted at a time.
   */
  async refreshSession() {
    if (this._refreshSessionPromise)
      return this._refreshSessionPromise;
    this._refreshSessionPromise = this._refreshSessionInner();
    try {
      await this._refreshSessionPromise;
    } finally {
      this._refreshSessionPromise = void 0;
    }
  }
  /**
   * Internal helper to refresh sessions (actual behavior)
   */
  async _refreshSessionInner() {
    if (!Sr.fetch)
      throw new Error("AtpAgent fetch() method not configured");
    if (!this.session?.refreshJwt)
      return;
    const e = new URL((this.pdsUrl || this.service).origin);
    e.pathname = `/xrpc/${kL}`;
    const r = await Sr.fetch(e.toString(), "POST", {
      authorization: `Bearer ${this.session.refreshJwt}`
    }, void 0);
    df(r, ["ExpiredToken", "InvalidToken"]) ? (this.session = void 0, this._persistSession?.("expired", void 0)) : BL(this._baseClient, r.body) && (this.session = {
      ...this.session || {},
      accessJwt: r.body.accessJwt,
      refreshJwt: r.body.refreshJwt,
      handle: r.body.handle,
      did: r.body.did
    }, this._updateApiEndpoint(r.body.didDoc), this._persistSession?.("update", this.session));
  }
  /**
   * Helper to update the pds endpoint dynamically.
   *
   * The session methods (create, resume, refresh) may respond with the user's
   * did document which contains the user's canonical PDS endpoint. That endpoint
   * may differ from the endpoint used to contact the server. We capture that
   * PDS endpoint and update the client to use that given endpoint for future
   * requests. (This helps ensure smooth migrations between PDSes, especially
   * when the PDSes are operated by a single org.)
   */
  _updateApiEndpoint(e) {
    if ((0, cf.isValidDidDoc)(e)) {
      const r = (0, cf.getPdsEndpoint)(e);
      this.pdsUrl = r ? new URL(r) : void 0;
    }
    this.api.xrpc.uri = this.pdsUrl || this.service;
  }
}
Jn.AtpAgent = Sr;
Object.defineProperty(Sr, "fetch", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Lo.defaultFetchHandler
});
Object.defineProperty(Sr, "appLabelers", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: [CL.BSKY_LABELER_DID]
});
function PL(t) {
  return SL.errorResponseBody.safeParse(t).success;
}
function df(t, e) {
  return t.status !== 400 || !PL(t.body) ? !1 : typeof t.body.error == "string" && e.includes(t.body.error);
}
function BL(t, e) {
  try {
    return t.xrpc.lex.assertValidXrpcOutput("com.atproto.server.refreshSession", e), !0;
  } catch {
    return !1;
  }
}
var Qn = {}, ia = {};
Object.defineProperty(ia, "__esModule", { value: !0 });
ia.UnicodeString = void 0;
const IL = Ji, pf = new TextEncoder(), UL = new TextDecoder();
class OL {
  constructor(e) {
    Object.defineProperty(this, "utf16", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "utf8", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_graphemeLen", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.utf16 = e, this.utf8 = pf.encode(e);
  }
  get length() {
    return this.utf8.byteLength;
  }
  get graphemeLength() {
    return this._graphemeLen || (this._graphemeLen = (0, IL.graphemeLen)(this.utf16)), this._graphemeLen;
  }
  slice(e, r) {
    return UL.decode(this.utf8.slice(e, r));
  }
  utf16IndexToUtf8Index(e) {
    return pf.encode(this.utf16.slice(0, e)).byteLength;
  }
  toString() {
    return this.utf16;
  }
}
ia.UnicodeString = OL;
var mo = {};
Object.defineProperty(mo, "__esModule", { value: !0 });
mo.sanitizeRichText = void 0;
const KL = ia, NL = /[\r\n]([\u00AD\u2060\u200D\u200C\u200B\s]*[\r\n]){2,}/, VL = `

`;
function ML(t, e) {
  return e.cleanNewlines && (t = jL(t, NL, VL)), t;
}
mo.sanitizeRichText = ML;
function jL(t, e, r) {
  t = t.clone();
  let a = t.unicodeText.utf16.match(e);
  for (; a && typeof a.index < "u"; ) {
    const u = t.unicodeText, x = t.unicodeText.utf16IndexToUtf8Index(a.index), y = x + new KL.UnicodeString(a[0]).length;
    if (t.delete(x, y), t.unicodeText.utf16 === u.utf16)
      break;
    t.insert(x, r), a = t.unicodeText.utf16.match(e);
  }
  return t;
}
var sl = {};
const FL = [
  "aaa",
  "aarp",
  "abb",
  "abbott",
  "abbvie",
  "abc",
  "able",
  "abogado",
  "abudhabi",
  "ac",
  "academy",
  "accenture",
  "accountant",
  "accountants",
  "aco",
  "actor",
  "ad",
  "ads",
  "adult",
  "ae",
  "aeg",
  "aero",
  "aetna",
  "af",
  "afl",
  "africa",
  "ag",
  "agakhan",
  "agency",
  "ai",
  "aig",
  "airbus",
  "airforce",
  "airtel",
  "akdn",
  "al",
  "alibaba",
  "alipay",
  "allfinanz",
  "allstate",
  "ally",
  "alsace",
  "alstom",
  "am",
  "amazon",
  "americanexpress",
  "americanfamily",
  "amex",
  "amfam",
  "amica",
  "amsterdam",
  "analytics",
  "android",
  "anquan",
  "anz",
  "ao",
  "aol",
  "apartments",
  "app",
  "apple",
  "aq",
  "aquarelle",
  "ar",
  "arab",
  "aramco",
  "archi",
  "army",
  "arpa",
  "art",
  "arte",
  "as",
  "asda",
  "asia",
  "associates",
  "at",
  "athleta",
  "attorney",
  "au",
  "auction",
  "audi",
  "audible",
  "audio",
  "auspost",
  "author",
  "auto",
  "autos",
  "avianca",
  "aw",
  "aws",
  "ax",
  "axa",
  "az",
  "azure",
  "ba",
  "baby",
  "baidu",
  "banamex",
  "band",
  "bank",
  "bar",
  "barcelona",
  "barclaycard",
  "barclays",
  "barefoot",
  "bargains",
  "baseball",
  "basketball",
  "bauhaus",
  "bayern",
  "bb",
  "bbc",
  "bbt",
  "bbva",
  "bcg",
  "bcn",
  "bd",
  "be",
  "beats",
  "beauty",
  "beer",
  "bentley",
  "berlin",
  "best",
  "bestbuy",
  "bet",
  "bf",
  "bg",
  "bh",
  "bharti",
  "bi",
  "bible",
  "bid",
  "bike",
  "bing",
  "bingo",
  "bio",
  "biz",
  "bj",
  "black",
  "blackfriday",
  "blockbuster",
  "blog",
  "bloomberg",
  "blue",
  "bm",
  "bms",
  "bmw",
  "bn",
  "bnpparibas",
  "bo",
  "boats",
  "boehringer",
  "bofa",
  "bom",
  "bond",
  "boo",
  "book",
  "booking",
  "bosch",
  "bostik",
  "boston",
  "bot",
  "boutique",
  "box",
  "br",
  "bradesco",
  "bridgestone",
  "broadway",
  "broker",
  "brother",
  "brussels",
  "bs",
  "bt",
  "build",
  "builders",
  "business",
  "buy",
  "buzz",
  "bv",
  "bw",
  "by",
  "bz",
  "bzh",
  "ca",
  "cab",
  "cafe",
  "cal",
  "call",
  "calvinklein",
  "cam",
  "camera",
  "camp",
  "canon",
  "capetown",
  "capital",
  "capitalone",
  "car",
  "caravan",
  "cards",
  "care",
  "career",
  "careers",
  "cars",
  "casa",
  "case",
  "cash",
  "casino",
  "cat",
  "catering",
  "catholic",
  "cba",
  "cbn",
  "cbre",
  "cc",
  "cd",
  "center",
  "ceo",
  "cern",
  "cf",
  "cfa",
  "cfd",
  "cg",
  "ch",
  "chanel",
  "channel",
  "charity",
  "chase",
  "chat",
  "cheap",
  "chintai",
  "christmas",
  "chrome",
  "church",
  "ci",
  "cipriani",
  "circle",
  "cisco",
  "citadel",
  "citi",
  "citic",
  "city",
  "ck",
  "cl",
  "claims",
  "cleaning",
  "click",
  "clinic",
  "clinique",
  "clothing",
  "cloud",
  "club",
  "clubmed",
  "cm",
  "cn",
  "co",
  "coach",
  "codes",
  "coffee",
  "college",
  "cologne",
  "com",
  "commbank",
  "community",
  "company",
  "compare",
  "computer",
  "comsec",
  "condos",
  "construction",
  "consulting",
  "contact",
  "contractors",
  "cooking",
  "cool",
  "coop",
  "corsica",
  "country",
  "coupon",
  "coupons",
  "courses",
  "cpa",
  "cr",
  "credit",
  "creditcard",
  "creditunion",
  "cricket",
  "crown",
  "crs",
  "cruise",
  "cruises",
  "cu",
  "cuisinella",
  "cv",
  "cw",
  "cx",
  "cy",
  "cymru",
  "cyou",
  "cz",
  "dabur",
  "dad",
  "dance",
  "data",
  "date",
  "dating",
  "datsun",
  "day",
  "dclk",
  "dds",
  "de",
  "deal",
  "dealer",
  "deals",
  "degree",
  "delivery",
  "dell",
  "deloitte",
  "delta",
  "democrat",
  "dental",
  "dentist",
  "desi",
  "design",
  "dev",
  "dhl",
  "diamonds",
  "diet",
  "digital",
  "direct",
  "directory",
  "discount",
  "discover",
  "dish",
  "diy",
  "dj",
  "dk",
  "dm",
  "dnp",
  "do",
  "docs",
  "doctor",
  "dog",
  "domains",
  "dot",
  "download",
  "drive",
  "dtv",
  "dubai",
  "dunlop",
  "dupont",
  "durban",
  "dvag",
  "dvr",
  "dz",
  "earth",
  "eat",
  "ec",
  "eco",
  "edeka",
  "edu",
  "education",
  "ee",
  "eg",
  "email",
  "emerck",
  "energy",
  "engineer",
  "engineering",
  "enterprises",
  "epson",
  "equipment",
  "er",
  "ericsson",
  "erni",
  "es",
  "esq",
  "estate",
  "et",
  "eu",
  "eurovision",
  "eus",
  "events",
  "exchange",
  "expert",
  "exposed",
  "express",
  "extraspace",
  "fage",
  "fail",
  "fairwinds",
  "faith",
  "family",
  "fan",
  "fans",
  "farm",
  "farmers",
  "fashion",
  "fast",
  "fedex",
  "feedback",
  "ferrari",
  "ferrero",
  "fi",
  "fidelity",
  "fido",
  "film",
  "final",
  "finance",
  "financial",
  "fire",
  "firestone",
  "firmdale",
  "fish",
  "fishing",
  "fit",
  "fitness",
  "fj",
  "fk",
  "flickr",
  "flights",
  "flir",
  "florist",
  "flowers",
  "fly",
  "fm",
  "fo",
  "foo",
  "food",
  "football",
  "ford",
  "forex",
  "forsale",
  "forum",
  "foundation",
  "fox",
  "fr",
  "free",
  "fresenius",
  "frl",
  "frogans",
  "frontier",
  "ftr",
  "fujitsu",
  "fun",
  "fund",
  "furniture",
  "futbol",
  "fyi",
  "ga",
  "gal",
  "gallery",
  "gallo",
  "gallup",
  "game",
  "games",
  "gap",
  "garden",
  "gay",
  "gb",
  "gbiz",
  "gd",
  "gdn",
  "ge",
  "gea",
  "gent",
  "genting",
  "george",
  "gf",
  "gg",
  "ggee",
  "gh",
  "gi",
  "gift",
  "gifts",
  "gives",
  "giving",
  "gl",
  "glass",
  "gle",
  "global",
  "globo",
  "gm",
  "gmail",
  "gmbh",
  "gmo",
  "gmx",
  "gn",
  "godaddy",
  "gold",
  "goldpoint",
  "golf",
  "goo",
  "goodyear",
  "goog",
  "google",
  "gop",
  "got",
  "gov",
  "gp",
  "gq",
  "gr",
  "grainger",
  "graphics",
  "gratis",
  "green",
  "gripe",
  "grocery",
  "group",
  "gs",
  "gt",
  "gu",
  "guardian",
  "gucci",
  "guge",
  "guide",
  "guitars",
  "guru",
  "gw",
  "gy",
  "hair",
  "hamburg",
  "hangout",
  "haus",
  "hbo",
  "hdfc",
  "hdfcbank",
  "health",
  "healthcare",
  "help",
  "helsinki",
  "here",
  "hermes",
  "hiphop",
  "hisamitsu",
  "hitachi",
  "hiv",
  "hk",
  "hkt",
  "hm",
  "hn",
  "hockey",
  "holdings",
  "holiday",
  "homedepot",
  "homegoods",
  "homes",
  "homesense",
  "honda",
  "horse",
  "hospital",
  "host",
  "hosting",
  "hot",
  "hotels",
  "hotmail",
  "house",
  "how",
  "hr",
  "hsbc",
  "ht",
  "hu",
  "hughes",
  "hyatt",
  "hyundai",
  "ibm",
  "icbc",
  "ice",
  "icu",
  "id",
  "ie",
  "ieee",
  "ifm",
  "ikano",
  "il",
  "im",
  "imamat",
  "imdb",
  "immo",
  "immobilien",
  "in",
  "inc",
  "industries",
  "infiniti",
  "info",
  "ing",
  "ink",
  "institute",
  "insurance",
  "insure",
  "int",
  "international",
  "intuit",
  "investments",
  "io",
  "ipiranga",
  "iq",
  "ir",
  "irish",
  "is",
  "ismaili",
  "ist",
  "istanbul",
  "it",
  "itau",
  "itv",
  "jaguar",
  "java",
  "jcb",
  "je",
  "jeep",
  "jetzt",
  "jewelry",
  "jio",
  "jll",
  "jm",
  "jmp",
  "jnj",
  "jo",
  "jobs",
  "joburg",
  "jot",
  "joy",
  "jp",
  "jpmorgan",
  "jprs",
  "juegos",
  "juniper",
  "kaufen",
  "kddi",
  "ke",
  "kerryhotels",
  "kerrylogistics",
  "kerryproperties",
  "kfh",
  "kg",
  "kh",
  "ki",
  "kia",
  "kids",
  "kim",
  "kindle",
  "kitchen",
  "kiwi",
  "km",
  "kn",
  "koeln",
  "komatsu",
  "kosher",
  "kp",
  "kpmg",
  "kpn",
  "kr",
  "krd",
  "kred",
  "kuokgroup",
  "kw",
  "ky",
  "kyoto",
  "kz",
  "la",
  "lacaixa",
  "lamborghini",
  "lamer",
  "lancaster",
  "land",
  "landrover",
  "lanxess",
  "lasalle",
  "lat",
  "latino",
  "latrobe",
  "law",
  "lawyer",
  "lb",
  "lc",
  "lds",
  "lease",
  "leclerc",
  "lefrak",
  "legal",
  "lego",
  "lexus",
  "lgbt",
  "li",
  "lidl",
  "life",
  "lifeinsurance",
  "lifestyle",
  "lighting",
  "like",
  "lilly",
  "limited",
  "limo",
  "lincoln",
  "link",
  "lipsy",
  "live",
  "living",
  "lk",
  "llc",
  "llp",
  "loan",
  "loans",
  "locker",
  "locus",
  "lol",
  "london",
  "lotte",
  "lotto",
  "love",
  "lpl",
  "lplfinancial",
  "lr",
  "ls",
  "lt",
  "ltd",
  "ltda",
  "lu",
  "lundbeck",
  "luxe",
  "luxury",
  "lv",
  "ly",
  "ma",
  "madrid",
  "maif",
  "maison",
  "makeup",
  "man",
  "management",
  "mango",
  "map",
  "market",
  "marketing",
  "markets",
  "marriott",
  "marshalls",
  "mattel",
  "mba",
  "mc",
  "mckinsey",
  "md",
  "me",
  "med",
  "media",
  "meet",
  "melbourne",
  "meme",
  "memorial",
  "men",
  "menu",
  "merckmsd",
  "mg",
  "mh",
  "miami",
  "microsoft",
  "mil",
  "mini",
  "mint",
  "mit",
  "mitsubishi",
  "mk",
  "ml",
  "mlb",
  "mls",
  "mm",
  "mma",
  "mn",
  "mo",
  "mobi",
  "mobile",
  "moda",
  "moe",
  "moi",
  "mom",
  "monash",
  "money",
  "monster",
  "mormon",
  "mortgage",
  "moscow",
  "moto",
  "motorcycles",
  "mov",
  "movie",
  "mp",
  "mq",
  "mr",
  "ms",
  "msd",
  "mt",
  "mtn",
  "mtr",
  "mu",
  "museum",
  "music",
  "mv",
  "mw",
  "mx",
  "my",
  "mz",
  "na",
  "nab",
  "nagoya",
  "name",
  "natura",
  "navy",
  "nba",
  "nc",
  "ne",
  "nec",
  "net",
  "netbank",
  "netflix",
  "network",
  "neustar",
  "new",
  "news",
  "next",
  "nextdirect",
  "nexus",
  "nf",
  "nfl",
  "ng",
  "ngo",
  "nhk",
  "ni",
  "nico",
  "nike",
  "nikon",
  "ninja",
  "nissan",
  "nissay",
  "nl",
  "no",
  "nokia",
  "norton",
  "now",
  "nowruz",
  "nowtv",
  "np",
  "nr",
  "nra",
  "nrw",
  "ntt",
  "nu",
  "nyc",
  "nz",
  "obi",
  "observer",
  "office",
  "okinawa",
  "olayan",
  "olayangroup",
  "ollo",
  "om",
  "omega",
  "one",
  "ong",
  "onl",
  "online",
  "ooo",
  "open",
  "oracle",
  "orange",
  "org",
  "organic",
  "origins",
  "osaka",
  "otsuka",
  "ott",
  "ovh",
  "pa",
  "page",
  "panasonic",
  "paris",
  "pars",
  "partners",
  "parts",
  "party",
  "pay",
  "pccw",
  "pe",
  "pet",
  "pf",
  "pfizer",
  "pg",
  "ph",
  "pharmacy",
  "phd",
  "philips",
  "phone",
  "photo",
  "photography",
  "photos",
  "physio",
  "pics",
  "pictet",
  "pictures",
  "pid",
  "pin",
  "ping",
  "pink",
  "pioneer",
  "pizza",
  "pk",
  "pl",
  "place",
  "play",
  "playstation",
  "plumbing",
  "plus",
  "pm",
  "pn",
  "pnc",
  "pohl",
  "poker",
  "politie",
  "porn",
  "post",
  "pr",
  "pramerica",
  "praxi",
  "press",
  "prime",
  "pro",
  "prod",
  "productions",
  "prof",
  "progressive",
  "promo",
  "properties",
  "property",
  "protection",
  "pru",
  "prudential",
  "ps",
  "pt",
  "pub",
  "pw",
  "pwc",
  "py",
  "qa",
  "qpon",
  "quebec",
  "quest",
  "racing",
  "radio",
  "re",
  "read",
  "realestate",
  "realtor",
  "realty",
  "recipes",
  "red",
  "redstone",
  "redumbrella",
  "rehab",
  "reise",
  "reisen",
  "reit",
  "reliance",
  "ren",
  "rent",
  "rentals",
  "repair",
  "report",
  "republican",
  "rest",
  "restaurant",
  "review",
  "reviews",
  "rexroth",
  "rich",
  "richardli",
  "ricoh",
  "ril",
  "rio",
  "rip",
  "ro",
  "rocks",
  "rodeo",
  "rogers",
  "room",
  "rs",
  "rsvp",
  "ru",
  "rugby",
  "ruhr",
  "run",
  "rw",
  "rwe",
  "ryukyu",
  "sa",
  "saarland",
  "safe",
  "safety",
  "sakura",
  "sale",
  "salon",
  "samsclub",
  "samsung",
  "sandvik",
  "sandvikcoromant",
  "sanofi",
  "sap",
  "sarl",
  "sas",
  "save",
  "saxo",
  "sb",
  "sbi",
  "sbs",
  "sc",
  "scb",
  "schaeffler",
  "schmidt",
  "scholarships",
  "school",
  "schule",
  "schwarz",
  "science",
  "scot",
  "sd",
  "se",
  "search",
  "seat",
  "secure",
  "security",
  "seek",
  "select",
  "sener",
  "services",
  "seven",
  "sew",
  "sex",
  "sexy",
  "sfr",
  "sg",
  "sh",
  "shangrila",
  "sharp",
  "shaw",
  "shell",
  "shia",
  "shiksha",
  "shoes",
  "shop",
  "shopping",
  "shouji",
  "show",
  "si",
  "silk",
  "sina",
  "singles",
  "site",
  "sj",
  "sk",
  "ski",
  "skin",
  "sky",
  "skype",
  "sl",
  "sling",
  "sm",
  "smart",
  "smile",
  "sn",
  "sncf",
  "so",
  "soccer",
  "social",
  "softbank",
  "software",
  "sohu",
  "solar",
  "solutions",
  "song",
  "sony",
  "soy",
  "spa",
  "space",
  "sport",
  "spot",
  "sr",
  "srl",
  "ss",
  "st",
  "stada",
  "staples",
  "star",
  "statebank",
  "statefarm",
  "stc",
  "stcgroup",
  "stockholm",
  "storage",
  "store",
  "stream",
  "studio",
  "study",
  "style",
  "su",
  "sucks",
  "supplies",
  "supply",
  "support",
  "surf",
  "surgery",
  "suzuki",
  "sv",
  "swatch",
  "swiss",
  "sx",
  "sy",
  "sydney",
  "systems",
  "sz",
  "tab",
  "taipei",
  "talk",
  "taobao",
  "target",
  "tatamotors",
  "tatar",
  "tattoo",
  "tax",
  "taxi",
  "tc",
  "tci",
  "td",
  "tdk",
  "team",
  "tech",
  "technology",
  "tel",
  "temasek",
  "tennis",
  "teva",
  "tf",
  "tg",
  "th",
  "thd",
  "theater",
  "theatre",
  "tiaa",
  "tickets",
  "tienda",
  "tips",
  "tires",
  "tirol",
  "tj",
  "tjmaxx",
  "tjx",
  "tk",
  "tkmaxx",
  "tl",
  "tm",
  "tmall",
  "tn",
  "to",
  "today",
  "tokyo",
  "tools",
  "top",
  "toray",
  "toshiba",
  "total",
  "tours",
  "town",
  "toyota",
  "toys",
  "tr",
  "trade",
  "trading",
  "training",
  "travel",
  "travelers",
  "travelersinsurance",
  "trust",
  "trv",
  "tt",
  "tube",
  "tui",
  "tunes",
  "tushu",
  "tv",
  "tvs",
  "tw",
  "tz",
  "ua",
  "ubank",
  "ubs",
  "ug",
  "uk",
  "unicom",
  "university",
  "uno",
  "uol",
  "ups",
  "us",
  "uy",
  "uz",
  "va",
  "vacations",
  "vana",
  "vanguard",
  "vc",
  "ve",
  "vegas",
  "ventures",
  "verisign",
  "vermgensberater",
  "vermgensberatung",
  "versicherung",
  "vet",
  "vg",
  "vi",
  "viajes",
  "video",
  "vig",
  "viking",
  "villas",
  "vin",
  "vip",
  "virgin",
  "visa",
  "vision",
  "viva",
  "vivo",
  "vlaanderen",
  "vn",
  "vodka",
  "volvo",
  "vote",
  "voting",
  "voto",
  "voyage",
  "vu",
  "wales",
  "walmart",
  "walter",
  "wang",
  "wanggou",
  "watch",
  "watches",
  "weather",
  "weatherchannel",
  "webcam",
  "weber",
  "website",
  "wed",
  "wedding",
  "weibo",
  "weir",
  "wf",
  "whoswho",
  "wien",
  "wiki",
  "williamhill",
  "win",
  "windows",
  "wine",
  "winners",
  "wme",
  "wolterskluwer",
  "woodside",
  "work",
  "works",
  "world",
  "wow",
  "ws",
  "wtc",
  "wtf",
  "xbox",
  "xerox",
  "xihuan",
  "xin",
  "xxx",
  "xyz",
  "yachts",
  "yahoo",
  "yamaxun",
  "yandex",
  "ye",
  "yodobashi",
  "yoga",
  "yokohama",
  "you",
  "youtube",
  "yt",
  "yun",
  "za",
  "zappos",
  "zara",
  "zero",
  "zip",
  "zm",
  "zone",
  "zuerich",
  "zw",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
];
var Gr = {};
Object.defineProperty(Gr, "__esModule", { value: !0 });
Gr.TAG_REGEX = Gr.TRAILING_PUNCTUATION_REGEX = Gr.URL_REGEX = Gr.MENTION_REGEX = void 0;
Gr.MENTION_REGEX = /(^|\s|\()(@)([a-zA-Z0-9.-]+)(\b)/g;
Gr.URL_REGEX = /(^|\s|\()((https?:\/\/[\S]+)|((?<domain>[a-z][a-z0-9]*(\.[a-z0-9]+)+)[\S]*))/gim;
Gr.TRAILING_PUNCTUATION_REGEX = /\p{P}+$/gu;
Gr.TAG_REGEX = /(^|\s)[#]((?!\ufe0f)[^\s\u00AD\u2060\u200A\u200B\u200C\u200D\u20e2]*[^\d\s\p{P}\u00AD\u2060\u200A\u200B\u200C\u200D\u20e2]+[^\s\u00AD\u2060\u200A\u200B\u200C\u200D\u20e2]*)?/gu;
var $L = le && le.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(sl, "__esModule", { value: !0 });
sl.detectFacets = void 0;
const GL = $L(FL), So = Gr;
function qL(t) {
  let e;
  const r = [];
  {
    const a = So.MENTION_REGEX;
    for (; e = a.exec(t.utf16); ) {
      if (!hf(e[3]) && !e[3].endsWith(".test"))
        continue;
      const u = t.utf16.indexOf(e[3], e.index) - 1;
      r.push({
        $type: "app.bsky.richtext.facet",
        index: {
          byteStart: t.utf16IndexToUtf8Index(u),
          byteEnd: t.utf16IndexToUtf8Index(u + e[3].length + 1)
        },
        features: [
          {
            $type: "app.bsky.richtext.facet#mention",
            did: e[3]
            // must be resolved afterwards
          }
        ]
      });
    }
  }
  {
    const a = So.URL_REGEX;
    for (; e = a.exec(t.utf16); ) {
      let u = e[2];
      if (!u.startsWith("http")) {
        const p = e.groups?.domain;
        if (!p || !hf(p))
          continue;
        u = `https://${u}`;
      }
      const x = t.utf16.indexOf(e[2], e.index), y = { start: x, end: x + e[2].length };
      /[.,;:!?]$/.test(u) && (u = u.slice(0, -1), y.end--), /[)]$/.test(u) && !u.includes("(") && (u = u.slice(0, -1), y.end--), r.push({
        index: {
          byteStart: t.utf16IndexToUtf8Index(y.start),
          byteEnd: t.utf16IndexToUtf8Index(y.end)
        },
        features: [
          {
            $type: "app.bsky.richtext.facet#link",
            uri: u
          }
        ]
      });
    }
  }
  {
    const a = So.TAG_REGEX;
    for (; e = a.exec(t.utf16); ) {
      let [, u, x] = e;
      if (!x || (x = x.trim().replace(So.TRAILING_PUNCTUATION_REGEX, ""), x.length === 0 || x.length > 64))
        continue;
      const y = e.index + u.length;
      r.push({
        index: {
          byteStart: t.utf16IndexToUtf8Index(y),
          byteEnd: t.utf16IndexToUtf8Index(y + 1 + x.length)
        },
        features: [
          {
            $type: "app.bsky.richtext.facet#tag",
            tag: x
          }
        ]
      });
    }
  }
  return r.length > 0 ? r : void 0;
}
sl.detectFacets = qL;
function hf(t) {
  return !!GL.default.find((e) => {
    const r = t.lastIndexOf(e);
    return r === -1 ? !1 : t.charAt(r - 1) === "." && r === t.length - e.length;
  });
}
Object.defineProperty(Qn, "__esModule", { value: !0 });
Qn.RichText = Qn.RichTextSegment = void 0;
const sn = v, Tl = ia, XL = mo, mf = sl;
class Bn {
  constructor(e, r) {
    Object.defineProperty(this, "text", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "facet", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    });
  }
  get link() {
    const e = this.facet?.features.find(sn.AppBskyRichtextFacet.isLink);
    if (sn.AppBskyRichtextFacet.isLink(e))
      return e;
  }
  isLink() {
    return !!this.link;
  }
  get mention() {
    const e = this.facet?.features.find(sn.AppBskyRichtextFacet.isMention);
    if (sn.AppBskyRichtextFacet.isMention(e))
      return e;
  }
  isMention() {
    return !!this.mention;
  }
  get tag() {
    const e = this.facet?.features.find(sn.AppBskyRichtextFacet.isTag);
    if (sn.AppBskyRichtextFacet.isTag(e))
      return e;
  }
  isTag() {
    return !!this.tag;
  }
}
Qn.RichTextSegment = Bn;
class nu {
  constructor(e, r) {
    Object.defineProperty(this, "unicodeText", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "facets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.unicodeText = new Tl.UnicodeString(e.text), this.facets = e.facets, !this.facets?.length && e.entities?.length && (this.facets = zL(this.unicodeText, e.entities)), this.facets && this.facets.sort(wl), r?.cleanNewlines && (0, XL.sanitizeRichText)(this, { cleanNewlines: !0 }).copyInto(this);
  }
  get text() {
    return this.unicodeText.toString();
  }
  get length() {
    return this.unicodeText.length;
  }
  get graphemeLength() {
    return this.unicodeText.graphemeLength;
  }
  clone() {
    return new nu({
      text: this.unicodeText.utf16,
      facets: yf(this.facets)
    });
  }
  copyInto(e) {
    e.unicodeText = this.unicodeText, e.facets = yf(this.facets);
  }
  *segments() {
    const e = this.facets || [];
    if (!e.length) {
      yield new Bn(this.unicodeText.utf16);
      return;
    }
    let r = 0, a = 0;
    do {
      const u = e[a];
      if (r < u.index.byteStart)
        yield new Bn(this.unicodeText.slice(r, u.index.byteStart));
      else if (r > u.index.byteStart) {
        a++;
        continue;
      }
      if (u.index.byteStart < u.index.byteEnd) {
        const x = this.unicodeText.slice(u.index.byteStart, u.index.byteEnd);
        x.trim() ? yield new Bn(x, u) : yield new Bn(x);
      }
      r = u.index.byteEnd, a++;
    } while (a < e.length);
    r < this.unicodeText.length && (yield new Bn(this.unicodeText.slice(r, this.unicodeText.length)));
  }
  insert(e, r) {
    if (this.unicodeText = new Tl.UnicodeString(this.unicodeText.slice(0, e) + r + this.unicodeText.slice(e)), !this.facets?.length)
      return this;
    const a = r.length;
    for (const u of this.facets)
      e <= u.index.byteStart ? (u.index.byteStart += a, u.index.byteEnd += a) : e >= u.index.byteStart && e < u.index.byteEnd && (u.index.byteEnd += a);
    return this;
  }
  delete(e, r) {
    if (this.unicodeText = new Tl.UnicodeString(this.unicodeText.slice(0, e) + this.unicodeText.slice(r)), !this.facets?.length)
      return this;
    const a = r - e;
    for (const u of this.facets)
      e <= u.index.byteStart && r >= u.index.byteEnd ? (u.index.byteStart = 0, u.index.byteEnd = 0) : e > u.index.byteEnd || (e > u.index.byteStart && e <= u.index.byteEnd && r > u.index.byteEnd ? u.index.byteEnd = e : e >= u.index.byteStart && r <= u.index.byteEnd ? u.index.byteEnd -= a : e < u.index.byteStart && r >= u.index.byteStart && r <= u.index.byteEnd ? (u.index.byteStart = e, u.index.byteEnd -= a) : r < u.index.byteStart && (u.index.byteStart -= a, u.index.byteEnd -= a));
    return this.facets = this.facets.filter((u) => u.index.byteStart < u.index.byteEnd), this;
  }
  /**
   * Detects facets such as links and mentions
   * Note: Overwrites the existing facets with auto-detected facets
   */
  async detectFacets(e) {
    if (this.facets = (0, mf.detectFacets)(this.unicodeText), this.facets) {
      for (const r of this.facets)
        for (const a of r.features)
          if (sn.AppBskyRichtextFacet.isMention(a)) {
            const u = await e.resolveHandle({ handle: a.did }).catch((x) => {
            }).then((x) => x?.data.did);
            a.did = u || "";
          }
      this.facets.sort(wl);
    }
  }
  /**
   * Detects facets such as links and mentions but does not resolve them
   * Will produce invalid facets! For instance, mentions will not have their DIDs set.
   * Note: Overwrites the existing facets with auto-detected facets
   */
  detectFacetsWithoutResolution() {
    this.facets = (0, mf.detectFacets)(this.unicodeText), this.facets && this.facets.sort(wl);
  }
}
Qn.RichText = nu;
const wl = (t, e) => t.index.byteStart - e.index.byteStart;
function zL(t, e) {
  const r = [];
  for (const a of e)
    a.type === "link" ? r.push({
      $type: "app.bsky.richtext.facet",
      index: {
        byteStart: t.utf16IndexToUtf8Index(a.index.start),
        byteEnd: t.utf16IndexToUtf8Index(a.index.end)
      },
      features: [{ $type: "app.bsky.richtext.facet#link", uri: a.value }]
    }) : a.type === "mention" && r.push({
      $type: "app.bsky.richtext.facet",
      index: {
        byteStart: t.utf16IndexToUtf8Index(a.index.start),
        byteEnd: t.utf16IndexToUtf8Index(a.index.end)
      },
      features: [
        { $type: "app.bsky.richtext.facet#mention", did: a.value }
      ]
    });
  return r;
}
function yf(t) {
  return typeof t > "u" ? t : JSON.parse(JSON.stringify(t));
}
var au = {}, fi = {}, Xr = {}, pr = {};
Object.defineProperty(pr, "__esModule", { value: !0 });
pr.NOOP_BEHAVIOR = pr.HIDE_BEHAVIOR = pr.MUTEWORD_BEHAVIOR = pr.MUTE_BEHAVIOR = pr.BLOCK_BEHAVIOR = pr.CUSTOM_LABEL_VALUE_RE = void 0;
pr.CUSTOM_LABEL_VALUE_RE = /^[a-z-]+$/;
pr.BLOCK_BEHAVIOR = {
  profileList: "blur",
  profileView: "alert",
  avatar: "blur",
  banner: "blur",
  contentList: "blur",
  contentView: "blur"
};
pr.MUTE_BEHAVIOR = {
  profileList: "inform",
  profileView: "alert",
  contentList: "blur",
  contentView: "inform"
};
pr.MUTEWORD_BEHAVIOR = {
  contentList: "blur",
  contentView: "blur"
};
pr.HIDE_BEHAVIOR = {
  contentList: "blur",
  contentView: "blur"
};
pr.NOOP_BEHAVIOR = {};
var yo = {};
Object.defineProperty(yo, "__esModule", { value: !0 });
yo.ModerationUI = void 0;
class HL {
  constructor() {
    Object.defineProperty(this, "noOverride", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "filters", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "blurs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "alerts", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "informs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  get filter() {
    return this.filters.length !== 0;
  }
  get blur() {
    return this.blurs.length !== 0;
  }
  get alert() {
    return this.alerts.length !== 0;
  }
  get inform() {
    return this.informs.length !== 0;
  }
}
yo.ModerationUI = HL;
var Wi = {};
Object.defineProperty(Wi, "__esModule", { value: !0 });
Wi.LABELS = Wi.DEFAULT_LABEL_SETTINGS = void 0;
Wi.DEFAULT_LABEL_SETTINGS = {
  porn: "hide",
  sexual: "warn",
  nudity: "ignore",
  "graphic-media": "warn"
};
Wi.LABELS = {
  "!hide": {
    identifier: "!hide",
    configurable: !1,
    defaultSetting: "hide",
    flags: ["no-override", "no-self"],
    severity: "alert",
    blurs: "content",
    behaviors: {
      account: {
        profileList: "blur",
        profileView: "blur",
        avatar: "blur",
        banner: "blur",
        displayName: "blur",
        contentList: "blur",
        contentView: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur",
        displayName: "blur"
      },
      content: {
        contentList: "blur",
        contentView: "blur"
      }
    },
    locales: []
  },
  "!warn": {
    identifier: "!warn",
    configurable: !1,
    defaultSetting: "warn",
    flags: ["no-self"],
    severity: "none",
    blurs: "content",
    behaviors: {
      account: {
        profileList: "blur",
        profileView: "blur",
        avatar: "blur",
        banner: "blur",
        contentList: "blur",
        contentView: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur",
        displayName: "blur"
      },
      content: {
        contentList: "blur",
        contentView: "blur"
      }
    },
    locales: []
  },
  "!no-unauthenticated": {
    identifier: "!no-unauthenticated",
    configurable: !1,
    defaultSetting: "hide",
    flags: ["no-override", "unauthed"],
    severity: "none",
    blurs: "content",
    behaviors: {
      account: {
        profileList: "blur",
        profileView: "blur",
        avatar: "blur",
        banner: "blur",
        displayName: "blur",
        contentList: "blur",
        contentView: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur",
        displayName: "blur"
      },
      content: {
        contentList: "blur",
        contentView: "blur"
      }
    },
    locales: []
  },
  porn: {
    identifier: "porn",
    configurable: !0,
    defaultSetting: "hide",
    flags: ["adult"],
    severity: "none",
    blurs: "media",
    behaviors: {
      account: {
        avatar: "blur",
        banner: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur"
      },
      content: {
        contentMedia: "blur"
      }
    },
    locales: []
  },
  sexual: {
    identifier: "sexual",
    configurable: !0,
    defaultSetting: "warn",
    flags: ["adult"],
    severity: "none",
    blurs: "media",
    behaviors: {
      account: {
        avatar: "blur",
        banner: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur"
      },
      content: {
        contentMedia: "blur"
      }
    },
    locales: []
  },
  nudity: {
    identifier: "nudity",
    configurable: !0,
    defaultSetting: "ignore",
    flags: [],
    severity: "none",
    blurs: "media",
    behaviors: {
      account: {
        avatar: "blur",
        banner: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur"
      },
      content: {
        contentMedia: "blur"
      }
    },
    locales: []
  },
  "graphic-media": {
    identifier: "graphic-media",
    flags: ["adult"],
    configurable: !0,
    defaultSetting: "warn",
    severity: "none",
    blurs: "media",
    behaviors: {
      account: {
        avatar: "blur",
        banner: "blur"
      },
      profile: {
        avatar: "blur",
        banner: "blur"
      },
      content: {
        contentMedia: "blur"
      }
    },
    locales: []
  }
};
Object.defineProperty(qr, "__esModule", { value: !0 });
qr.ModerationDecision = void 0;
const xr = pr, ZL = yo, bf = Wi;
var $i;
(function(t) {
  t[t.High = 0] = "High", t[t.Medium = 1] = "Medium", t[t.Low = 2] = "Low";
})($i || ($i = {}));
class su {
  constructor() {
    Object.defineProperty(this, "did", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "isMe", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "causes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  static merge(...e) {
    const r = e.filter((u) => !!u), a = new su();
    return r[0] && (a.did = r[0].did, a.isMe = r[0].isMe), a.causes = r.flatMap((u) => u.causes), a;
  }
  downgrade() {
    for (const e of this.causes)
      e.downgraded = !0;
    return this;
  }
  get blocked() {
    return !!this.blockCause;
  }
  get muted() {
    return !!this.muteCause;
  }
  get blockCause() {
    return this.causes.find((e) => e.type === "blocking" || e.type === "blocked-by" || e.type === "block-other");
  }
  get muteCause() {
    return this.causes.find((e) => e.type === "muted");
  }
  get labelCauses() {
    return this.causes.filter((e) => e.type === "label");
  }
  ui(e) {
    const r = new ZL.ModerationUI();
    if (this.isMe)
      return r;
    for (const a of this.causes)
      a.type === "blocking" || a.type === "blocked-by" || a.type === "block-other" ? ((e === "profileList" || e === "contentList") && r.filters.push(a), a.downgraded || (xr.BLOCK_BEHAVIOR[e] === "blur" ? (r.noOverride = !0, r.blurs.push(a)) : xr.BLOCK_BEHAVIOR[e] === "alert" ? r.alerts.push(a) : xr.BLOCK_BEHAVIOR[e] === "inform" && r.informs.push(a))) : a.type === "muted" ? ((e === "profileList" || e === "contentList") && r.filters.push(a), a.downgraded || (xr.MUTE_BEHAVIOR[e] === "blur" ? r.blurs.push(a) : xr.MUTE_BEHAVIOR[e] === "alert" ? r.alerts.push(a) : xr.MUTE_BEHAVIOR[e] === "inform" && r.informs.push(a))) : a.type === "mute-word" ? (e === "contentList" && r.filters.push(a), a.downgraded || (xr.MUTEWORD_BEHAVIOR[e] === "blur" ? r.blurs.push(a) : xr.MUTEWORD_BEHAVIOR[e] === "alert" ? r.alerts.push(a) : xr.MUTEWORD_BEHAVIOR[e] === "inform" && r.informs.push(a))) : a.type === "hidden" ? ((e === "profileList" || e === "contentList") && r.filters.push(a), a.downgraded || (xr.HIDE_BEHAVIOR[e] === "blur" ? r.blurs.push(a) : xr.HIDE_BEHAVIOR[e] === "alert" ? r.alerts.push(a) : xr.HIDE_BEHAVIOR[e] === "inform" && r.informs.push(a))) : a.type === "label" && (e === "profileList" && a.target === "account" ? a.setting === "hide" && r.filters.push(a) : e === "contentList" && (a.target === "account" || a.target === "content") && a.setting === "hide" && r.filters.push(a), a.downgraded || (a.behavior[e] === "blur" ? (r.blurs.push(a), a.noOverride && (r.noOverride = !0)) : a.behavior[e] === "alert" ? r.alerts.push(a) : a.behavior[e] === "inform" && r.informs.push(a)));
    return r.filters.sort(xf), r.blurs.sort(xf), r;
  }
  setDid(e) {
    this.did = e;
  }
  setIsMe(e) {
    this.isMe = e;
  }
  addHidden(e) {
    e && this.causes.push({
      type: "hidden",
      source: { type: "user" },
      priority: 6
    });
  }
  addMutedWord(e) {
    e && this.causes.push({
      type: "mute-word",
      source: { type: "user" },
      priority: 6
    });
  }
  addBlocking(e) {
    e && this.causes.push({
      type: "blocking",
      source: { type: "user" },
      priority: 3
    });
  }
  addBlockingByList(e) {
    e && this.causes.push({
      type: "blocking",
      source: { type: "list", list: e },
      priority: 3
    });
  }
  addBlockedBy(e) {
    e && this.causes.push({
      type: "blocked-by",
      source: { type: "user" },
      priority: 4
    });
  }
  addBlockOther(e) {
    e && this.causes.push({
      type: "block-other",
      source: { type: "user" },
      priority: 4
    });
  }
  addLabel(e, r, a) {
    const u = xr.CUSTOM_LABEL_VALUE_RE.test(r.val) && a.labelDefs?.[r.src]?.find((T) => T.identifier === r.val) || bf.LABELS[r.val];
    if (!u)
      return;
    const x = r.src === this.did, y = x ? void 0 : a.prefs.labelers.find((T) => T.did === r.src);
    if (!x && !y || x && u.flags.includes("no-self"))
      return;
    let p = u.defaultSetting || "ignore";
    if (u.configurable ? u.flags.includes("adult") && !a.prefs.adultContentEnabled ? p = "hide" : y?.labels[u.identifier] ? p = y?.labels[u.identifier] : a.prefs.labels[u.identifier] && (p = a.prefs.labels[u.identifier]) : p = u.defaultSetting || "hide", p === "ignore" || u.flags.includes("unauthed") && a.userDid)
      return;
    let m;
    const h = WL(u.behaviors[e]);
    u.flags.includes("no-override") || u.flags.includes("adult") && !a.prefs.adultContentEnabled ? m = 1 : p === "hide" ? m = 2 : h === $i.High ? m = 5 : h === $i.Medium ? m = 7 : m = 8;
    let d = !1;
    (u.flags.includes("no-override") || u.flags.includes("adult") && !a.prefs.adultContentEnabled) && (d = !0), this.causes.push({
      type: "label",
      source: x || !y ? { type: "user" } : { type: "labeler", did: y.did },
      label: r,
      labelDef: u,
      target: e,
      setting: p,
      behavior: u.behaviors[e] || xr.NOOP_BEHAVIOR,
      noOverride: d,
      priority: h
    });
  }
  addMuted(e) {
    e && this.causes.push({
      type: "muted",
      source: { type: "user" },
      priority: 6
    });
  }
  addMutedByList(e) {
    e && this.causes.push({
      type: "muted",
      source: { type: "list", list: e },
      priority: 6
    });
  }
}
qr.ModerationDecision = su;
function WL(t) {
  return t ? t.profileView === "blur" || t.contentView === "blur" ? $i.High : t.contentList === "blur" || t.contentMedia === "blur" ? $i.Medium : $i.Low : $i.Low;
}
function xf(t, e) {
  return t.priority - e.priority;
}
Object.defineProperty(fi, "__esModule", { value: !0 });
fi.filterAccountLabels = fi.decideAccount = void 0;
const YL = qr;
function JL(t, e) {
  const r = new YL.ModerationDecision();
  r.setDid(t.did), r.setIsMe(t.did === e.userDid), t.viewer?.muted && (t.viewer?.mutedByList ? r.addMutedByList(t.viewer?.mutedByList) : r.addMuted(t.viewer?.muted)), t.viewer?.blocking && (t.viewer?.blockingByList ? r.addBlockingByList(t.viewer?.blockingByList) : r.addBlocking(t.viewer?.blocking)), r.addBlockedBy(t.viewer?.blockedBy);
  for (const a of Lp(t.labels))
    r.addLabel("account", a, e);
  return r;
}
fi.decideAccount = JL;
function Lp(t) {
  return t ? t.filter((e) => !e.uri.endsWith("/app.bsky.actor.profile/self") || e.val === "!no-unauthenticated") : [];
}
fi.filterAccountLabels = Lp;
var ci = {};
Object.defineProperty(ci, "__esModule", { value: !0 });
ci.filterProfileLabels = ci.decideProfile = void 0;
const QL = qr;
function eC(t, e) {
  const r = new QL.ModerationDecision();
  r.setDid(t.did), r.setIsMe(t.did === e.userDid);
  for (const a of Cp(t.labels))
    r.addLabel("profile", a, e);
  return r;
}
ci.decideProfile = eC;
function Cp(t) {
  return t ? t.filter((e) => e.uri.endsWith("/app.bsky.actor.profile/self")) : [];
}
ci.filterProfileLabels = Cp;
var ol = {};
Object.defineProperty(ol, "__esModule", { value: !0 });
ol.decideNotification = void 0;
const Ef = qr, tC = fi, rC = ci;
function iC(t, e) {
  const r = new Ef.ModerationDecision();
  if (r.setDid(t.author.did), r.setIsMe(t.author.did === e.userDid), t.labels?.length)
    for (const a of t.labels)
      r.addLabel("content", a, e);
  return Ef.ModerationDecision.merge(r, (0, tC.decideAccount)(t.author, e), (0, rC.decideProfile)(t.author, e));
}
ol.decideNotification = iC;
var ll = {}, bo = {};
Object.defineProperty(bo, "__esModule", { value: !0 });
bo.hasMutedWord = void 0;
const nC = v, gf = {
  LEADING_TRAILING_PUNCTUATION: /(?:^\p{P}+|\p{P}+$)/gu,
  ESCAPE: /[[\]{}()*+?.\\^$|\s]/g,
  SEPARATORS: /[/\-()[\]_]+/g,
  WORD_BOUNDARY: /[\s\n\t\r\f\v]+?/g
}, aC = [
  "ja",
  // Japanese
  "zh",
  // Chinese
  "ko",
  // Korean
  "th",
  // Thai
  "vi"
  // Vietnamese
];
function sC({ mutedWords: t, text: e, facets: r, outlineTags: a, languages: u }) {
  const x = aC.includes(u?.[0] || ""), y = [].concat(a || []).concat(r?.filter((p) => p.features.find((m) => nC.AppBskyRichtextFacet.isTag(m))).map((p) => p.features[0].tag) || []).map((p) => p.toLowerCase());
  for (const p of t) {
    const h = p.value.toLowerCase(), m = e.toLowerCase();
    if (y.includes(h))
      return !0;
    if (!p.targets.includes("content"))
      continue;
    if ((h.length === 1 || x) && m.includes(h))
      return !0;
    if (h.length > m.length)
      continue;
    if (h === m || /(?:\s|\p{P})+?/u.test(h) && m.includes(h))
      return !0;
    const d = m.split(gf.WORD_BOUNDARY);
    for (const T of d) {
      if (T === h)
        return !0;
      const S = T.replace(gf.LEADING_TRAILING_PUNCTUATION, "");
      if (m === S)
        return !0;
      if (!(m.length > S.length) && /\p{P}+/u.test(S)) {
        const B = S.replace(/\p{P}+/gu, " ");
        if (B === m || B.replace(/\s/gu, "") === m)
          return !0;
        const O = S.split(/\p{P}+/u);
        for (const F of O)
          if (F === m)
            return !0;
      }
    }
  }
  return !1;
}
bo.hasMutedWord = sC;
Object.defineProperty(ll, "__esModule", { value: !0 });
ll.decidePost = void 0;
const ya = qr, xt = v, Wr = bo, Dp = fi, kp = ci;
function oC(t, e) {
  const r = new ya.ModerationDecision();
  if (r.setDid(t.author.did), r.setIsMe(t.author.did === e.userDid), t.labels?.length)
    for (const u of t.labels)
      r.addLabel("content", u, e);
  r.addHidden(lC(t, e.prefs.hiddenPosts)), r.isMe || r.addMutedWord(uC(t, e.prefs.mutedWords));
  let a;
  return t.embed && (xt.AppBskyEmbedRecord.isViewRecord(t.embed.record) ? a = vf(t.embed.record, e) : xt.AppBskyEmbedRecordWithMedia.isView(t.embed) && xt.AppBskyEmbedRecord.isViewRecord(t.embed.record.record) ? a = vf(t.embed.record.record, e) : xt.AppBskyEmbedRecord.isViewBlocked(t.embed.record) ? a = Rf(t.embed.record, e) : xt.AppBskyEmbedRecordWithMedia.isView(t.embed) && xt.AppBskyEmbedRecord.isViewBlocked(t.embed.record.record) && (a = Rf(t.embed.record.record, e))), ya.ModerationDecision.merge(r, a?.downgrade(), (0, Dp.decideAccount)(t.author, e), (0, kp.decideProfile)(t.author, e));
}
ll.decidePost = oC;
function vf(t, e) {
  const r = new ya.ModerationDecision();
  if (r.setDid(t.author.did), r.setIsMe(t.author.did === e.userDid), t.labels?.length)
    for (const a of t.labels)
      r.addLabel("content", a, e);
  return ya.ModerationDecision.merge(r, (0, Dp.decideAccount)(t.author, e), (0, kp.decideProfile)(t.author, e));
}
function Rf(t, e) {
  const r = new ya.ModerationDecision();
  return r.setDid(t.author.did), r.setIsMe(t.author.did === e.userDid), t.author.viewer?.muted && (t.author.viewer?.mutedByList ? r.addMutedByList(t.author.viewer?.mutedByList) : r.addMuted(t.author.viewer?.muted)), t.author.viewer?.blocking && (t.author.viewer?.blockingByList ? r.addBlockingByList(t.author.viewer?.blockingByList) : r.addBlocking(t.author.viewer?.blocking)), r.addBlockedBy(t.author.viewer?.blockedBy), r;
}
function lC(t, e) {
  return e?.length ? !!(e.includes(t.uri) || t.embed && (xt.AppBskyEmbedRecord.isViewRecord(t.embed.record) && e.includes(t.embed.record.uri) || xt.AppBskyEmbedRecordWithMedia.isView(t.embed) && xt.AppBskyEmbedRecord.isViewRecord(t.embed.record.record) && e.includes(t.embed.record.record.uri))) : !1;
}
function uC(t, e) {
  if (!e?.length)
    return !1;
  if (xt.AppBskyFeedPost.isRecord(t.record)) {
    if ((0, Yr.hasMutedWord)({
      mutedWords: e,
      text: t.record.text,
      facets: t.record.facets,
      outlineTags: t.record.tags,
      languages: t.record.langs
    }))
      return !0;
    if (t.record.embed && xt.AppBskyEmbedImages.isMain(t.record.embed)) {
      for (const r of t.record.embed.images)
        if ((0, Yr.hasMutedWord)({
          mutedWords: e,
          text: r.alt,
          languages: t.record.langs
        }))
          return !0;
    }
  }
  if (t.embed) {
    if (xt.AppBskyEmbedRecord.isViewRecord(t.embed.record)) {
      if (xt.AppBskyFeedPost.isRecord(t.embed.record.value)) {
        const r = t.embed.record.value;
        if ((0, Yr.hasMutedWord)({
          mutedWords: e,
          text: r.text,
          facets: r.facets,
          outlineTags: r.tags,
          languages: r.langs
        }))
          return !0;
        if (xt.AppBskyEmbedImages.isMain(r.embed)) {
          for (const a of r.embed.images)
            if ((0, Yr.hasMutedWord)({
              mutedWords: e,
              text: a.alt,
              languages: r.langs
            }))
              return !0;
        }
        if (xt.AppBskyEmbedExternal.isMain(r.embed)) {
          const { external: a } = r.embed;
          if ((0, Yr.hasMutedWord)({
            mutedWords: e,
            text: a.title + " " + a.description,
            languages: []
          }))
            return !0;
        }
        if (xt.AppBskyEmbedRecordWithMedia.isMain(r.embed)) {
          if (xt.AppBskyEmbedExternal.isMain(r.embed.media)) {
            const { external: a } = r.embed.media;
            if ((0, Yr.hasMutedWord)({
              mutedWords: e,
              text: a.title + " " + a.description,
              languages: []
            }))
              return !0;
          }
          if (xt.AppBskyEmbedImages.isMain(r.embed.media)) {
            for (const a of r.embed.media.images)
              if ((0, Yr.hasMutedWord)({
                mutedWords: e,
                text: a.alt,
                languages: xt.AppBskyFeedPost.isRecord(r.record) ? r.langs : []
              }))
                return !0;
          }
        }
      }
    } else if (xt.AppBskyEmbedExternal.isView(t.embed)) {
      const { external: r } = t.embed;
      if ((0, Yr.hasMutedWord)({
        mutedWords: e,
        text: r.title + " " + r.description,
        languages: []
      }))
        return !0;
    } else if (xt.AppBskyEmbedRecordWithMedia.isView(t.embed) && xt.AppBskyEmbedRecord.isViewRecord(t.embed.record.record)) {
      if (xt.AppBskyFeedPost.isRecord(t.embed.record.record.value)) {
        const r = t.embed.record.record.value;
        if ((0, Yr.hasMutedWord)({
          mutedWords: e,
          text: r.text,
          facets: r.facets,
          outlineTags: r.tags,
          languages: r.langs
        }))
          return !0;
      }
      if (xt.AppBskyEmbedImages.isView(t.embed.media)) {
        for (const r of t.embed.media.images)
          if ((0, Yr.hasMutedWord)({
            mutedWords: e,
            text: r.alt,
            languages: xt.AppBskyFeedPost.isRecord(t.record) ? t.record.langs : []
          }))
            return !0;
      }
    }
  }
  return !1;
}
var ul = {};
Object.defineProperty(ul, "__esModule", { value: !0 });
ul.decideFeedGenerator = void 0;
const Af = qr, fC = fi, cC = ci;
function dC(t, e) {
  const r = new Af.ModerationDecision();
  if (r.setDid(t.creator.did), r.setIsMe(t.creator.did === e.userDid), t.labels?.length)
    for (const a of t.labels)
      r.addLabel("content", a, e);
  return Af.ModerationDecision.merge(r, (0, fC.decideAccount)(t.creator, e), (0, cC.decideProfile)(t.creator, e));
}
ul.decideFeedGenerator = dC;
var fl = {};
Object.defineProperty(fl, "__esModule", { value: !0 });
fl.decideUserList = void 0;
const pC = ea, _f = qr, hC = fi, mC = ci;
function yC(t, e) {
  const r = new _f.ModerationDecision(), a = bC(t.creator) ? t.creator : void 0;
  if (a) {
    if (r.setDid(a.did), r.setIsMe(a.did === e.userDid), t.labels?.length)
      for (const x of t.labels)
        r.addLabel("content", x, e);
    return _f.ModerationDecision.merge(r, (0, hC.decideAccount)(a, e), (0, mC.decideProfile)(a, e));
  }
  const u = new pC.AtUri(t.uri).hostname;
  if (r.setDid(u), r.setIsMe(u === e.userDid), t.labels?.length)
    for (const x of t.labels)
      r.addLabel("content", x, e);
  return r;
}
fl.decideUserList = yC;
function bC(t) {
  return t && typeof t == "object" && "did" in t;
}
var ii = {};
Object.defineProperty(ii, "__esModule", { value: !0 });
ii.interpretLabelValueDefinitions = ii.interpretLabelValueDefinition = ii.isQuotedPostWithMedia = ii.isQuotedPost = void 0;
const ou = v;
function xC(t) {
  return !!(t && ou.AppBskyEmbedRecord.isView(t));
}
ii.isQuotedPost = xC;
function EC(t) {
  return !!(t && ou.AppBskyEmbedRecordWithMedia.isView(t));
}
ii.isQuotedPostWithMedia = EC;
function Pp(t, e) {
  const r = {
    account: {},
    profile: {},
    content: {}
  }, a = t.severity === "alert" ? "alert" : t.severity === "inform" ? "inform" : void 0;
  t.blurs === "content" ? (r.account.profileList = a, r.account.profileView = a, r.account.contentList = "blur", r.account.contentView = t.adultOnly ? "blur" : a, r.profile.profileList = a, r.profile.profileView = a, r.content.contentList = "blur", r.content.contentView = t.adultOnly ? "blur" : a) : t.blurs === "media" ? (r.account.profileList = a, r.account.profileView = a, r.account.avatar = "blur", r.account.banner = "blur", r.profile.profileList = a, r.profile.profileView = a, r.profile.avatar = "blur", r.profile.banner = "blur", r.content.contentMedia = "blur") : t.blurs === "none" && (r.account.profileList = a, r.account.profileView = a, r.account.contentList = a, r.account.contentView = a, r.profile.profileList = a, r.profile.profileView = a, r.content.contentList = a, r.content.contentView = a);
  let u = "warn";
  (t.defaultSetting === "hide" || t.defaultSetting === "ignore") && (u = t.defaultSetting);
  const x = ["no-self"];
  return t.adultOnly && x.push("adult"), {
    ...t,
    definedBy: e,
    configurable: !0,
    defaultSetting: u,
    flags: x,
    behaviors: r
  };
}
ii.interpretLabelValueDefinition = Pp;
function gC(t) {
  return (t.policies?.labelValueDefinitions || []).filter((e) => ou.ComAtprotoLabelDefs.validateLabelValueDefinition(e).success).map((e) => Pp(e, t.creator.did));
}
ii.interpretLabelValueDefinitions = gC;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.moderateUserList = t.moderateFeedGenerator = t.moderateNotification = t.moderatePost = t.moderateProfile = t.interpretLabelValueDefinitions = t.interpretLabelValueDefinition = t.hasMutedWord = t.ModerationDecision = t.ModerationUI = void 0;
  const e = fi, r = ci, a = ol, u = ll, x = ul, y = fl, p = Xr;
  var h = yo;
  Object.defineProperty(t, "ModerationUI", { enumerable: !0, get: function() {
    return h.ModerationUI;
  } });
  var m = Xr;
  Object.defineProperty(t, "ModerationDecision", { enumerable: !0, get: function() {
    return m.ModerationDecision;
  } });
  var d = bo;
  Object.defineProperty(t, "hasMutedWord", { enumerable: !0, get: function() {
    return d.hasMutedWord;
  } });
  var T = ii;
  Object.defineProperty(t, "interpretLabelValueDefinition", { enumerable: !0, get: function() {
    return T.interpretLabelValueDefinition;
  } }), Object.defineProperty(t, "interpretLabelValueDefinitions", { enumerable: !0, get: function() {
    return T.interpretLabelValueDefinitions;
  } });
  function S(V, z) {
    return p.ModerationDecision.merge((0, e.decideAccount)(V, z), (0, r.decideProfile)(V, z));
  }
  t.moderateProfile = S;
  function B(V, z) {
    return (0, u.decidePost)(V, z);
  }
  t.moderatePost = B;
  function I($, z) {
    return (0, a.decideNotification)($, z);
  }
  t.moderateNotification = I;
  function O($, z) {
    return (0, x.decideFeedGenerator)($, z);
  }
  t.moderateFeedGenerator = O;
  function j($, z) {
    return (0, y.decideUserList)($, z);
  }
  t.moderateUserList = j;
})(au);
var cl = {};
Object.defineProperty(cl, "__esModule", { value: !0 });
cl.mock = void 0;
const ca = "bafyreiclp443lavogvhj3d2ob2cxbfuscni2k5jk7bebjzg7khl3esabwq";
cl.mock = {
  post({ text: t, facets: e, reply: r, embed: a }) {
    return {
      $type: "app.bsky.feed.post",
      text: t,
      facets: e,
      reply: r,
      embed: a,
      langs: ["en"],
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  },
  postView({ record: t, author: e, embed: r, replyCount: a, repostCount: u, likeCount: x, viewer: y, labels: p }) {
    return {
      $type: "app.bsky.feed.defs#postView",
      uri: `at://${e.did}/app.bsky.feed.post/fake`,
      cid: ca,
      author: e,
      record: t,
      embed: r,
      replyCount: a,
      repostCount: u,
      likeCount: x,
      indexedAt: (/* @__PURE__ */ new Date()).toISOString(),
      viewer: y,
      labels: p
    };
  },
  embedRecordView({ record: t, author: e, labels: r }) {
    return {
      $type: "app.bsky.embed.record#view",
      record: {
        $type: "app.bsky.embed.record#viewRecord",
        uri: `at://${e.did}/app.bsky.feed.post/fake`,
        cid: ca,
        author: e,
        value: t,
        labels: r,
        indexedAt: (/* @__PURE__ */ new Date()).toISOString()
      }
    };
  },
  profileViewBasic({ handle: t, displayName: e, description: r, viewer: a, labels: u }) {
    return {
      did: `did:web:${t}`,
      handle: t,
      displayName: e,
      description: r,
      // technically not in ProfileViewBasic but useful in some cases
      viewer: a,
      labels: u
    };
  },
  actorViewerState({ muted: t, mutedByList: e, blockedBy: r, blocking: a, blockingByList: u, following: x, followedBy: y }) {
    return {
      muted: t,
      mutedByList: e,
      blockedBy: r,
      blocking: a,
      blockingByList: u,
      following: x,
      followedBy: y
    };
  },
  listViewBasic({ name: t }) {
    return {
      uri: "at://did:plc:fake/app.bsky.graph.list/fake",
      cid: ca,
      name: t,
      purpose: "app.bsky.graph.defs#modlist",
      indexedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  },
  replyNotification({ author: t, record: e, labels: r }) {
    return {
      uri: `at://${t.did}/app.bsky.feed.post/fake`,
      cid: ca,
      author: t,
      reason: "reply",
      reasonSubject: `at://${t.did}/app.bsky.feed.post/fake-parent`,
      record: e,
      isRead: !1,
      indexedAt: (/* @__PURE__ */ new Date()).toISOString(),
      labels: r
    };
  },
  followNotification({ author: t, subjectDid: e, labels: r }) {
    return {
      uri: `at://${t.did}/app.bsky.graph.follow/fake`,
      cid: ca,
      author: t,
      reason: "follow",
      record: {
        $type: "app.bsky.graph.follow",
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        subject: e
      },
      isRead: !1,
      indexedAt: (/* @__PURE__ */ new Date()).toISOString(),
      labels: r
    };
  },
  label({ val: t, uri: e, src: r }) {
    return {
      src: r || "did:plc:fake-labeler",
      uri: e,
      val: t,
      cts: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
};
var dl = {};
Object.defineProperty(dl, "__esModule", { value: !0 });
dl.BskyAgent = void 0;
const Pn = ea, vC = Jn, xe = v, RC = Wi, Tf = Ta, AC = au, wf = {
  hideReplies: !1,
  hideRepliesByUnfollowed: !0,
  hideRepliesByLikeCount: 0,
  hideReposts: !1,
  hideQuotePosts: !1
}, _C = {
  sort: "oldest",
  prioritizeFollowedUsers: !0
};
class In extends vC.AtpAgent {
  constructor() {
    super(...arguments), Object.defineProperty(this, "getTimeline", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getTimeline(e, r)
    }), Object.defineProperty(this, "getAuthorFeed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getAuthorFeed(e, r)
    }), Object.defineProperty(this, "getActorLikes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getActorLikes(e, r)
    }), Object.defineProperty(this, "getPostThread", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getPostThread(e, r)
    }), Object.defineProperty(this, "getPost", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e) => this.api.app.bsky.feed.post.get(e)
    }), Object.defineProperty(this, "getPosts", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getPosts(e, r)
    }), Object.defineProperty(this, "getLikes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getLikes(e, r)
    }), Object.defineProperty(this, "getRepostedBy", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.feed.getRepostedBy(e, r)
    }), Object.defineProperty(this, "getFollows", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.graph.getFollows(e, r)
    }), Object.defineProperty(this, "getFollowers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.graph.getFollowers(e, r)
    }), Object.defineProperty(this, "getProfile", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.actor.getProfile(e, r)
    }), Object.defineProperty(this, "getProfiles", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.actor.getProfiles(e, r)
    }), Object.defineProperty(this, "getSuggestions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.actor.getSuggestions(e, r)
    }), Object.defineProperty(this, "searchActors", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.actor.searchActors(e, r)
    }), Object.defineProperty(this, "searchActorsTypeahead", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.actor.searchActorsTypeahead(e, r)
    }), Object.defineProperty(this, "listNotifications", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.notification.listNotifications(e, r)
    }), Object.defineProperty(this, "countUnreadNotifications", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.notification.getUnreadCount(e, r)
    }), Object.defineProperty(this, "getLabelers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (e, r) => this.api.app.bsky.labeler.getServices(e, r)
    });
  }
  clone() {
    const e = new In({
      service: this.service
    });
    return this.copyInto(e), e;
  }
  get app() {
    return this.api.app;
  }
  async getLabelDefinitions(e) {
    let r = In.appLabelers;
    SC(e) ? r = r.concat(e.moderationPrefs.labelers.map((x) => x.did)) : Bp(e) ? r = r.concat(e.labelers.map((x) => x.did)) : r = r.concat(e);
    const a = await this.getLabelers({
      dids: r,
      detailed: !0
    }), u = {};
    if (a.data)
      for (const x of a.data.views)
        u[x.creator.did] = (0, AC.interpretLabelValueDefinitions)(x);
    return u;
  }
  async post(e) {
    if (!this.session)
      throw new Error("Not logged in");
    return e.createdAt = e.createdAt || (/* @__PURE__ */ new Date()).toISOString(), this.api.app.bsky.feed.post.create({ repo: this.session.did }, e);
  }
  async deletePost(e) {
    if (!this.session)
      throw new Error("Not logged in");
    const r = new Pn.AtUri(e);
    return await this.api.app.bsky.feed.post.delete({
      repo: r.hostname,
      rkey: r.rkey
    });
  }
  async like(e, r) {
    if (!this.session)
      throw new Error("Not logged in");
    return await this.api.app.bsky.feed.like.create({ repo: this.session.did }, {
      subject: { uri: e, cid: r },
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  async deleteLike(e) {
    if (!this.session)
      throw new Error("Not logged in");
    const r = new Pn.AtUri(e);
    return await this.api.app.bsky.feed.like.delete({
      repo: r.hostname,
      rkey: r.rkey
    });
  }
  async repost(e, r) {
    if (!this.session)
      throw new Error("Not logged in");
    return await this.api.app.bsky.feed.repost.create({ repo: this.session.did }, {
      subject: { uri: e, cid: r },
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  async deleteRepost(e) {
    if (!this.session)
      throw new Error("Not logged in");
    const r = new Pn.AtUri(e);
    return await this.api.app.bsky.feed.repost.delete({
      repo: r.hostname,
      rkey: r.rkey
    });
  }
  async follow(e) {
    if (!this.session)
      throw new Error("Not logged in");
    return await this.api.app.bsky.graph.follow.create({ repo: this.session.did }, {
      subject: e,
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  async deleteFollow(e) {
    if (!this.session)
      throw new Error("Not logged in");
    const r = new Pn.AtUri(e);
    return await this.api.app.bsky.graph.follow.delete({
      repo: r.hostname,
      rkey: r.rkey
    });
  }
  async upsertProfile(e) {
    if (!this.session)
      throw new Error("Not logged in");
    let r = 5;
    for (; r >= 0; ) {
      const a = await this.com.atproto.repo.getRecord({
        repo: this.session.did,
        collection: "app.bsky.actor.profile",
        rkey: "self"
      }).catch((y) => {
      }), u = await e(a?.data.value);
      u && (u.$type = "app.bsky.actor.profile");
      const x = xe.AppBskyActorProfile.validateRecord(u);
      if (!x.success)
        throw x.error;
      try {
        await this.com.atproto.repo.putRecord({
          repo: this.session.did,
          collection: "app.bsky.actor.profile",
          rkey: "self",
          record: u,
          swapRecord: a?.data.cid || null
        });
      } catch (y) {
        if (r > 0 && y instanceof xe.ComAtprotoRepoPutRecord.InvalidSwapError) {
          r--;
          continue;
        } else
          throw y;
      }
      break;
    }
  }
  async mute(e) {
    return this.api.app.bsky.graph.muteActor({ actor: e });
  }
  async unmute(e) {
    return this.api.app.bsky.graph.unmuteActor({ actor: e });
  }
  async muteModList(e) {
    return this.api.app.bsky.graph.muteActorList({
      list: e
    });
  }
  async unmuteModList(e) {
    return this.api.app.bsky.graph.unmuteActorList({
      list: e
    });
  }
  async blockModList(e) {
    if (!this.session)
      throw new Error("Not logged in");
    return await this.api.app.bsky.graph.listblock.create({ repo: this.session.did }, {
      subject: e,
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  async unblockModList(e) {
    if (!this.session)
      throw new Error("Not logged in");
    const r = await this.api.app.bsky.graph.getList({
      list: e,
      limit: 1
    });
    if (!r.data.list.viewer?.blocked)
      return;
    const { rkey: a } = new Pn.AtUri(r.data.list.viewer.blocked);
    return await this.api.app.bsky.graph.listblock.delete({
      repo: this.session.did,
      rkey: a
    });
  }
  async updateSeenNotifications(e) {
    return e = e || (/* @__PURE__ */ new Date()).toISOString(), this.api.app.bsky.notification.updateSeen({
      seenAt: e
    });
  }
  async getPreferences() {
    const e = {
      feeds: {
        saved: void 0,
        pinned: void 0
      },
      feedViewPrefs: {
        home: {
          ...wf
        }
      },
      threadViewPrefs: { ..._C },
      moderationPrefs: {
        adultContentEnabled: !1,
        labels: { ...RC.DEFAULT_LABEL_SETTINGS },
        labelers: In.appLabelers.map((u) => ({ did: u, labels: {} })),
        mutedWords: [],
        hiddenPosts: []
      },
      birthDate: void 0,
      interests: {
        tags: []
      }
    }, r = await this.app.bsky.actor.getPreferences({}), a = [];
    for (const u of r.data.preferences)
      if (xe.AppBskyActorDefs.isAdultContentPref(u) && xe.AppBskyActorDefs.validateAdultContentPref(u).success)
        e.moderationPrefs.adultContentEnabled = u.enabled;
      else if (xe.AppBskyActorDefs.isContentLabelPref(u) && xe.AppBskyActorDefs.validateContentLabelPref(u).success) {
        const x = TC(u);
        a.push(x);
      } else if (xe.AppBskyActorDefs.isLabelersPref(u) && xe.AppBskyActorDefs.validateLabelersPref(u).success)
        e.moderationPrefs.labelers = In.appLabelers.map((x) => ({ did: x, labels: {} })).concat(u.labelers.map((x) => ({
          ...x,
          labels: {}
        })));
      else if (xe.AppBskyActorDefs.isSavedFeedsPref(u) && xe.AppBskyActorDefs.validateSavedFeedsPref(u).success)
        e.feeds.saved = u.saved, e.feeds.pinned = u.pinned;
      else if (xe.AppBskyActorDefs.isPersonalDetailsPref(u) && xe.AppBskyActorDefs.validatePersonalDetailsPref(u).success)
        u.birthDate && (e.birthDate = new Date(u.birthDate));
      else if (xe.AppBskyActorDefs.isFeedViewPref(u) && xe.AppBskyActorDefs.validateFeedViewPref(u).success) {
        const { $type: x, feed: y, ...p } = u;
        e.feedViewPrefs[u.feed] = { ...wf, ...p };
      } else if (xe.AppBskyActorDefs.isThreadViewPref(u) && xe.AppBskyActorDefs.validateThreadViewPref(u).success) {
        const { $type: x, ...y } = u;
        e.threadViewPrefs = { ...e.threadViewPrefs, ...y };
      } else if (xe.AppBskyActorDefs.isInterestsPref(u) && xe.AppBskyActorDefs.validateInterestsPref(u).success) {
        const { $type: x, ...y } = u;
        e.interests = { ...e.interests, ...y };
      } else if (xe.AppBskyActorDefs.isMutedWordsPref(u) && xe.AppBskyActorDefs.validateMutedWordsPref(u).success) {
        const { $type: x, ...y } = u;
        e.moderationPrefs.mutedWords = y.items;
      } else if (xe.AppBskyActorDefs.isHiddenPostsPref(u) && xe.AppBskyActorDefs.validateHiddenPostsPref(u).success) {
        const { $type: x, ...y } = u;
        e.moderationPrefs.hiddenPosts = y.items;
      }
    for (const u of a)
      if (u.labelerDid) {
        const x = e.moderationPrefs.labelers.find((y) => y.did === u.labelerDid);
        if (!x)
          continue;
        x.labels[u.label] = u.visibility;
      } else
        e.moderationPrefs.labels[u.label] = u.visibility;
    return e.moderationPrefs.labels = wC(e.moderationPrefs.labels), this.configureLabelersHeader(Sl(r.data.preferences)), e;
  }
  async setSavedFeeds(e, r) {
    return da(this, () => ({
      saved: e,
      pinned: r
    }));
  }
  async addSavedFeed(e) {
    return da(this, (r, a) => ({
      saved: [...r.filter((u) => u !== e), e],
      pinned: a
    }));
  }
  async removeSavedFeed(e) {
    return da(this, (r, a) => ({
      saved: r.filter((u) => u !== e),
      pinned: a.filter((u) => u !== e)
    }));
  }
  async addPinnedFeed(e) {
    return da(this, (r, a) => ({
      saved: [...r.filter((u) => u !== e), e],
      pinned: [...a.filter((u) => u !== e), e]
    }));
  }
  async removePinnedFeed(e) {
    return da(this, (r, a) => ({
      saved: r,
      pinned: a.filter((u) => u !== e)
    }));
  }
  async setAdultContentEnabled(e) {
    await Tr(this, (r) => {
      let a = r.findLast((u) => xe.AppBskyActorDefs.isAdultContentPref(u) && xe.AppBskyActorDefs.validateAdultContentPref(u).success);
      return a ? a.enabled = e : a = {
        $type: "app.bsky.actor.defs#adultContentPref",
        enabled: e
      }, r.filter((u) => !xe.AppBskyActorDefs.isAdultContentPref(u)).concat([a]);
    });
  }
  async setContentLabelPref(e, r, a) {
    a && (0, Pn.ensureValidDid)(a), await Tr(this, (u) => {
      let x = u.findLast((p) => xe.AppBskyActorDefs.isContentLabelPref(p) && xe.AppBskyActorDefs.validateContentLabelPref(p).success && p.label === e && p.labelerDid === a), y;
      if (x ? x.visibility = r : x = {
        $type: "app.bsky.actor.defs#contentLabelPref",
        label: e,
        labelerDid: a,
        visibility: r
      }, xe.AppBskyActorDefs.isContentLabelPref(x) && !x.labelerDid) {
        const p = {
          "graphic-media": "gore",
          porn: "nsfw",
          sexual: "suggestive"
        }[x.label];
        p && (y = u.findLast((m) => xe.AppBskyActorDefs.isContentLabelPref(m) && xe.AppBskyActorDefs.validateContentLabelPref(m).success && m.label === p && m.labelerDid === void 0), y ? y.visibility = r : y = {
          $type: "app.bsky.actor.defs#contentLabelPref",
          label: p,
          labelerDid: void 0,
          visibility: r
        });
      }
      return u.filter((p) => !xe.AppBskyActorDefs.isContentLabelPref(p) || !(p.label === e && p.labelerDid === a)).concat([x]).filter((p) => y ? !xe.AppBskyActorDefs.isContentLabelPref(p) || !(p.label === y.label && p.labelerDid === void 0) : !0).concat(y ? [y] : []);
    });
  }
  async addLabeler(e) {
    const r = await Tr(this, (a) => {
      let u = a.findLast((x) => xe.AppBskyActorDefs.isLabelersPref(x) && xe.AppBskyActorDefs.validateLabelersPref(x).success);
      if (u || (u = {
        $type: "app.bsky.actor.defs#labelersPref",
        labelers: []
      }), xe.AppBskyActorDefs.isLabelersPref(u)) {
        let x = u.labelers.find((y) => y.did === e);
        x || (x = {
          did: e
        }, u.labelers.push(x));
      }
      return a.filter((x) => !xe.AppBskyActorDefs.isLabelersPref(x)).concat([u]);
    });
    this.configureLabelersHeader(Sl(r));
  }
  async removeLabeler(e) {
    const r = await Tr(this, (a) => {
      let u = a.findLast((x) => xe.AppBskyActorDefs.isLabelersPref(x) && xe.AppBskyActorDefs.validateLabelersPref(x).success);
      return u || (u = {
        $type: "app.bsky.actor.defs#labelersPref",
        labelers: []
      }), xe.AppBskyActorDefs.isLabelersPref(u) && (u.labelers = u.labelers.filter((x) => x.did !== e)), a.filter((x) => !xe.AppBskyActorDefs.isLabelersPref(x)).concat([u]);
    });
    this.configureLabelersHeader(Sl(r));
  }
  async setPersonalDetails({ birthDate: e }) {
    e = e instanceof Date ? e.toISOString() : e, await Tr(this, (r) => {
      let a = r.findLast((u) => xe.AppBskyActorDefs.isPersonalDetailsPref(u) && xe.AppBskyActorDefs.validatePersonalDetailsPref(u).success);
      return a ? a.birthDate = e : a = {
        $type: "app.bsky.actor.defs#personalDetailsPref",
        birthDate: e
      }, r.filter((u) => !xe.AppBskyActorDefs.isPersonalDetailsPref(u)).concat([a]);
    });
  }
  async setFeedViewPrefs(e, r) {
    await Tr(this, (a) => {
      const u = a.findLast((x) => xe.AppBskyActorDefs.isFeedViewPref(x) && xe.AppBskyActorDefs.validateFeedViewPref(x).success && x.feed === e);
      return u && (r = { ...u, ...r }), a.filter((x) => !xe.AppBskyActorDefs.isFeedViewPref(r) || x.feed !== e).concat([{ ...r, $type: "app.bsky.actor.defs#feedViewPref", feed: e }]);
    });
  }
  async setThreadViewPrefs(e) {
    await Tr(this, (r) => {
      const a = r.findLast((u) => xe.AppBskyActorDefs.isThreadViewPref(u) && xe.AppBskyActorDefs.validateThreadViewPref(u).success);
      return a && (e = { ...a, ...e }), r.filter((u) => !xe.AppBskyActorDefs.isThreadViewPref(u)).concat([{ ...e, $type: "app.bsky.actor.defs#threadViewPref" }]);
    });
  }
  async setInterestsPref(e) {
    await Tr(this, (r) => {
      const a = r.findLast((u) => xe.AppBskyActorDefs.isInterestsPref(u) && xe.AppBskyActorDefs.validateInterestsPref(u).success);
      return a && (e = { ...a, ...e }), r.filter((u) => !xe.AppBskyActorDefs.isInterestsPref(u)).concat([{ ...e, $type: "app.bsky.actor.defs#interestsPref" }]);
    });
  }
  async upsertMutedWords(e) {
    await Tr(this, (r) => {
      let a = r.findLast((u) => xe.AppBskyActorDefs.isMutedWordsPref(u) && xe.AppBskyActorDefs.validateMutedWordsPref(u).success);
      if (a && xe.AppBskyActorDefs.isMutedWordsPref(a))
        for (const u of e) {
          let x = !1;
          const y = (0, Tf.sanitizeMutedWordValue)(u.value);
          if (y) {
            for (const p of a.items)
              if (p.value === y) {
                p.targets = Array.from(/* @__PURE__ */ new Set([...p.targets, ...u.targets])), x = !0;
                break;
              }
            x || a.items.push({
              ...u,
              value: y
            });
          }
        }
      else
        a = {
          items: e.map((u) => ({
            ...u,
            value: (0, Tf.sanitizeMutedWordValue)(u.value)
          }))
        };
      return r.filter((u) => !xe.AppBskyActorDefs.isMutedWordsPref(u)).concat([
        { ...a, $type: "app.bsky.actor.defs#mutedWordsPref" }
      ]);
    });
  }
  async updateMutedWord(e) {
    await Tr(this, (r) => {
      const a = r.findLast((u) => xe.AppBskyActorDefs.isMutedWordsPref(u) && xe.AppBskyActorDefs.validateMutedWordsPref(u).success);
      if (a && xe.AppBskyActorDefs.isMutedWordsPref(a)) {
        for (const u of a.items)
          if (u.value === e.value) {
            u.targets = e.targets;
            break;
          }
      }
      return r.filter((u) => !xe.AppBskyActorDefs.isMutedWordsPref(u)).concat([
        { ...a, $type: "app.bsky.actor.defs#mutedWordsPref" }
      ]);
    });
  }
  async removeMutedWord(e) {
    await Tr(this, (r) => {
      const a = r.findLast((u) => xe.AppBskyActorDefs.isMutedWordsPref(u) && xe.AppBskyActorDefs.validateMutedWordsPref(u).success);
      if (a && xe.AppBskyActorDefs.isMutedWordsPref(a)) {
        for (let u = 0; u < a.items.length; u++)
          if (a.items[u].value === e.value) {
            a.items.splice(u, 1);
            break;
          }
      }
      return r.filter((u) => !xe.AppBskyActorDefs.isMutedWordsPref(u)).concat([
        { ...a, $type: "app.bsky.actor.defs#mutedWordsPref" }
      ]);
    });
  }
  async hidePost(e) {
    await Sf(this, e, "hide");
  }
  async unhidePost(e) {
    await Sf(this, e, "unhide");
  }
}
dl.BskyAgent = In;
async function Tr(t, e) {
  const r = await t.app.bsky.actor.getPreferences({}), a = e(r.data.preferences);
  return a === !1 ? r.data.preferences : (await t.app.bsky.actor.putPreferences({
    preferences: a
  }), a);
}
async function da(t, e) {
  let r;
  return await Tr(t, (a) => {
    let u = a.findLast((x) => xe.AppBskyActorDefs.isSavedFeedsPref(x) && xe.AppBskyActorDefs.validateSavedFeedsPref(x).success);
    return u ? (r = e(u.saved, u.pinned), u.saved = r.saved, u.pinned = r.pinned) : (r = e([], []), u = {
      $type: "app.bsky.actor.defs#savedFeedsPref",
      saved: r.saved,
      pinned: r.pinned
    }), a.filter((x) => !xe.AppBskyActorDefs.isSavedFeedsPref(x)).concat([u]);
  }), r;
}
function TC(t) {
  let e = t.visibility;
  return e === "show" && (e = "ignore"), { ...t, visibility: e };
}
function wC(t) {
  const e = { ...t }, r = {
    gore: "graphic-media",
    nsfw: "porn",
    suggestive: "sexual"
  };
  for (const a in e) {
    const u = r[a];
    u && (e[u] = e[a]);
  }
  return e;
}
function Sl(t) {
  const e = t.findLast((a) => xe.AppBskyActorDefs.isLabelersPref(a) && xe.AppBskyActorDefs.validateLabelersPref(a).success);
  let r = [];
  return e && (r = e.labelers.map((a) => a.did)), r;
}
async function Sf(t, e, r) {
  await Tr(t, (a) => {
    let u = a.findLast((x) => xe.AppBskyActorDefs.isHiddenPostsPref(x) && xe.AppBskyActorDefs.validateHiddenPostsPref(x).success);
    return u && xe.AppBskyActorDefs.isHiddenPostsPref(u) ? u.items = r === "hide" ? Array.from(/* @__PURE__ */ new Set([...u.items, e])) : u.items.filter((x) => x !== e) : r === "hide" && (u = {
      $type: "app.bsky.actor.defs#hiddenPostsPref",
      items: [e]
    }), a.filter((x) => !xe.AppBskyActorDefs.isInterestsPref(x)).concat([{ ...u, $type: "app.bsky.actor.defs#hiddenPostsPref" }]);
  });
}
function SC(t) {
  return t && typeof t == "object" && "moderationPrefs" in t && Bp(t.moderationPrefs);
}
function Bp(t) {
  return t && typeof t == "object" && "labelers" in t;
}
(function(t) {
  var e = le && le.__createBinding || (Object.create ? function(h, d, T, S) {
    S === void 0 && (S = T);
    var B = Object.getOwnPropertyDescriptor(d, T);
    (!B || ("get" in B ? !d.__esModule : B.writable || B.configurable)) && (B = { enumerable: !0, get: function() {
      return d[T];
    } }), Object.defineProperty(h, S, B);
  } : function(h, d, T, S) {
    S === void 0 && (S = T), h[S] = d[T];
  }), r = le && le.__exportStar || function(h, d) {
    for (var T in h) T !== "default" && !Object.prototype.hasOwnProperty.call(d, T) && e(d, h, T);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.default = t.BskyAgent = t.DEFAULT_LABEL_SETTINGS = t.LABELS = t.parseLanguage = t.jsonStringToLex = t.jsonToLex = t.stringifyLex = t.lexToJson = t.BlobRef = t.AtUri = void 0;
  var a = ea;
  Object.defineProperty(t, "AtUri", { enumerable: !0, get: function() {
    return a.AtUri;
  } });
  var u = ga;
  Object.defineProperty(t, "BlobRef", { enumerable: !0, get: function() {
    return u.BlobRef;
  } }), Object.defineProperty(t, "lexToJson", { enumerable: !0, get: function() {
    return u.lexToJson;
  } }), Object.defineProperty(t, "stringifyLex", { enumerable: !0, get: function() {
    return u.stringifyLex;
  } }), Object.defineProperty(t, "jsonToLex", { enumerable: !0, get: function() {
    return u.jsonToLex;
  } }), Object.defineProperty(t, "jsonStringToLex", { enumerable: !0, get: function() {
    return u.jsonStringToLex;
  } });
  var x = Ji;
  Object.defineProperty(t, "parseLanguage", { enumerable: !0, get: function() {
    return x.parseLanguage;
  } }), r(Rc, t), r(_a, t), r(Ta, t), r(v, t), r(Jn, t), r(Qn, t), r(mo, t), r(ia, t), r(Gr, t), r(au, t), r(pr, t), r(cl, t);
  var y = Wi;
  Object.defineProperty(t, "LABELS", { enumerable: !0, get: function() {
    return y.LABELS;
  } }), Object.defineProperty(t, "DEFAULT_LABEL_SETTINGS", { enumerable: !0, get: function() {
    return y.DEFAULT_LABEL_SETTINGS;
  } });
  var p = dl;
  Object.defineProperty(t, "BskyAgent", { enumerable: !0, get: function() {
    return p.BskyAgent;
  } });
  var h = Jn;
  Object.defineProperty(t, "default", { enumerable: !0, get: function() {
    return h.AtpAgent;
  } });
})(Ml);
const Ll = new Ml.BskyAgent({
  service: "https://api.bsky.app"
});
var Ip = { exports: {} };
(function(t, e) {
  (function(a, u) {
    t.exports = u();
  })(le, function() {
    return (
      /******/
      function(r) {
        var a = {};
        function u(x) {
          if (a[x])
            return a[x].exports;
          var y = a[x] = {
            /******/
            i: x,
            /******/
            l: !1,
            /******/
            exports: {}
            /******/
          };
          return r[x].call(y.exports, y, y.exports, u), y.l = !0, y.exports;
        }
        return u.m = r, u.c = a, u.d = function(x, y, p) {
          u.o(x, y) || Object.defineProperty(x, y, {
            /******/
            configurable: !1,
            /******/
            enumerable: !0,
            /******/
            get: p
            /******/
          });
        }, u.n = function(x) {
          var y = x && x.__esModule ? (
            /******/
            function() {
              return x.default;
            }
          ) : (
            /******/
            function() {
              return x;
            }
          );
          return u.d(y, "a", y), y;
        }, u.o = function(x, y) {
          return Object.prototype.hasOwnProperty.call(x, y);
        }, u.p = "/dist/", u(u.s = 8);
      }([
        /* 0 */
        /***/
        function(r, a, u) {
          u.d(a, "a", function() {
            return S;
          }), u.d(a, "b", function() {
            return B;
          });
          var x = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(I) {
            return typeof I;
          } : function(I) {
            return I && typeof Symbol == "function" && I.constructor === Symbol && I !== Symbol.prototype ? "symbol" : typeof I;
          };
          function y() {
          }
          var p = {
            trace: y,
            debug: y,
            log: y,
            warn: y,
            info: y,
            error: y
          }, h = p;
          function m(I, O) {
            return O = "[" + I + "] > " + O, O;
          }
          function d(I) {
            var O = self.console[I];
            return O ? function() {
              for (var j = arguments.length, $ = Array(j), z = 0; z < j; z++)
                $[z] = arguments[z];
              $[0] && ($[0] = m(I, $[0])), O.apply(self.console, $);
            } : y;
          }
          function T(I) {
            for (var O = arguments.length, j = Array(O > 1 ? O - 1 : 0), $ = 1; $ < O; $++)
              j[$ - 1] = arguments[$];
            j.forEach(function(z) {
              h[z] = I[z] ? I[z].bind(I) : d(z);
            });
          }
          var S = function(O) {
            if (O === !0 || (typeof O > "u" ? "undefined" : x(O)) === "object") {
              T(
                O,
                // Remove out from list here to hard-disable a log-level
                //'trace',
                "debug",
                "log",
                "info",
                "warn",
                "error"
              );
              try {
                h.log();
              } catch {
                h = p;
              }
            } else
              h = p;
          }, B = h;
        },
        /* 1 */
        /***/
        function(r, a, u) {
          a.a = {
            // fired before MediaSource is attaching to media element - data: { media }
            MEDIA_ATTACHING: "hlsMediaAttaching",
            // fired when MediaSource has been succesfully attached to media element - data: { }
            MEDIA_ATTACHED: "hlsMediaAttached",
            // fired before detaching MediaSource from media element - data: { }
            MEDIA_DETACHING: "hlsMediaDetaching",
            // fired when MediaSource has been detached from media element - data: { }
            MEDIA_DETACHED: "hlsMediaDetached",
            // fired when we buffer is going to be reset - data: { }
            BUFFER_RESET: "hlsBufferReset",
            // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
            BUFFER_CODECS: "hlsBufferCodecs",
            // fired when sourcebuffers have been created - data: { tracks : tracks }
            BUFFER_CREATED: "hlsBufferCreated",
            // fired when we append a segment to the buffer - data: { segment: segment object }
            BUFFER_APPENDING: "hlsBufferAppending",
            // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}
            BUFFER_APPENDED: "hlsBufferAppended",
            // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }
            BUFFER_EOS: "hlsBufferEos",
            // fired when the media buffer should be flushed - data { startOffset, endOffset }
            BUFFER_FLUSHING: "hlsBufferFlushing",
            // fired when the media buffer has been flushed - data: { }
            BUFFER_FLUSHED: "hlsBufferFlushed",
            // fired to signal that a manifest loading starts - data: { url : manifestURL}
            MANIFEST_LOADING: "hlsManifestLoading",
            // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
            MANIFEST_LOADED: "hlsManifestLoaded",
            // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}
            MANIFEST_PARSED: "hlsManifestParsed",
            // fired when a level switch is requested - data: { level : id of new level } // deprecated in favor LEVEL_SWITCHING
            LEVEL_SWITCH: "hlsLevelSwitch",
            // fired when a level switch is requested - data: { level : id of new level }
            LEVEL_SWITCHING: "hlsLevelSwitching",
            // fired when a level switch is effective - data: { level : id of new level }
            LEVEL_SWITCHED: "hlsLevelSwitched",
            // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}
            LEVEL_LOADING: "hlsLevelLoading",
            // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
            LEVEL_LOADED: "hlsLevelLoaded",
            // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }
            LEVEL_UPDATED: "hlsLevelUpdated",
            // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
            LEVEL_PTS_UPDATED: "hlsLevelPtsUpdated",
            // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }
            AUDIO_TRACKS_UPDATED: "hlsAudioTracksUpdated",
            // fired when an audio track switch occurs - data: { id : audio track id } // deprecated in favor AUDIO_TRACK_SWITCHING
            AUDIO_TRACK_SWITCH: "hlsAudioTrackSwitch",
            // fired when an audio track switching is requested - data: { id : audio track id }
            AUDIO_TRACK_SWITCHING: "hlsAudioTrackSwitching",
            // fired when an audio track switch actually occurs - data: { id : audio track id }
            AUDIO_TRACK_SWITCHED: "hlsAudioTrackSwitched",
            // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }
            AUDIO_TRACK_LOADING: "hlsAudioTrackLoading",
            // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime } }
            AUDIO_TRACK_LOADED: "hlsAudioTrackLoaded",
            // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }
            SUBTITLE_TRACKS_UPDATED: "hlsSubtitleTracksUpdated",
            // fired when an subtitle track switch occurs - data: { id : subtitle track id }
            SUBTITLE_TRACK_SWITCH: "hlsSubtitleTrackSwitch",
            // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }
            SUBTITLE_TRACK_LOADING: "hlsSubtitleTrackLoading",
            // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : { trequest, tfirst, tload, mtime } }
            SUBTITLE_TRACK_LOADED: "hlsSubtitleTrackLoaded",
            // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }
            SUBTITLE_FRAG_PROCESSED: "hlsSubtitleFragProcessed",
            // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, frag : fragment object }
            INIT_PTS_FOUND: "hlsInitPtsFound",
            // fired when a fragment loading starts - data: { frag : fragment object }
            FRAG_LOADING: "hlsFragLoading",
            // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }
            FRAG_LOAD_PROGRESS: "hlsFragLoadProgress",
            // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }
            FRAG_LOAD_EMERGENCY_ABORTED: "hlsFragLoadEmergencyAborted",
            // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length } }
            FRAG_LOADED: "hlsFragLoaded",
            // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, payload : fragment payload, stats : { tstart, tdecrypt } }
            FRAG_DECRYPTED: "hlsFragDecrypted",
            // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }
            FRAG_PARSING_INIT_SEGMENT: "hlsFragParsingInitSegment",
            // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }
            FRAG_PARSING_USERDATA: "hlsFragParsingUserdata",
            // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }
            FRAG_PARSING_METADATA: "hlsFragParsingMetadata",
            // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
            FRAG_PARSING_DATA: "hlsFragParsingData",
            // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }
            FRAG_PARSED: "hlsFragParsed",
            // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length, bwEstimate } }
            FRAG_BUFFERED: "hlsFragBuffered",
            // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
            FRAG_CHANGED: "hlsFragChanged",
            // Identifier for a FPS drop event - data: { curentDropped, currentDecoded, totalDroppedFrames }
            FPS_DROP: "hlsFpsDrop",
            //triggered when FPS drop triggers auto level capping - data: { level, droppedlevel }
            FPS_DROP_LEVEL_CAPPING: "hlsFpsDropLevelCapping",
            // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }
            ERROR: "hlsError",
            // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }
            DESTROYING: "hlsDestroying",
            // fired when a decrypt key loading starts - data: { frag : fragment object }
            KEY_LOADING: "hlsKeyLoading",
            // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length } }
            KEY_LOADED: "hlsKeyLoaded",
            // fired upon stream controller state transitions - data: { previousState, nextState }
            STREAM_STATE_TRANSITION: "hlsStreamStateTransition"
          };
        },
        /* 2 */
        /***/
        function(r, a, u) {
          u.d(a, "b", function() {
            return x;
          }), u.d(a, "a", function() {
            return y;
          });
          var x = {
            // Identifier for a network error (loading error / timeout ...)
            NETWORK_ERROR: "networkError",
            // Identifier for a media Error (video/parsing/mediasource error)
            MEDIA_ERROR: "mediaError",
            // Identifier for a mux Error (demuxing/remuxing)
            MUX_ERROR: "muxError",
            // Identifier for all other errors
            OTHER_ERROR: "otherError"
          }, y = {
            // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}
            MANIFEST_LOAD_ERROR: "manifestLoadError",
            // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
            MANIFEST_LOAD_TIMEOUT: "manifestLoadTimeOut",
            // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}
            MANIFEST_PARSING_ERROR: "manifestParsingError",
            // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}
            MANIFEST_INCOMPATIBLE_CODECS_ERROR: "manifestIncompatibleCodecsError",
            // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}
            LEVEL_LOAD_ERROR: "levelLoadError",
            // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
            LEVEL_LOAD_TIMEOUT: "levelLoadTimeOut",
            // Identifier for a level switch error - data: { level : faulty level Id, event : error description}
            LEVEL_SWITCH_ERROR: "levelSwitchError",
            // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}
            AUDIO_TRACK_LOAD_ERROR: "audioTrackLoadError",
            // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
            AUDIO_TRACK_LOAD_TIMEOUT: "audioTrackLoadTimeOut",
            // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}
            FRAG_LOAD_ERROR: "fragLoadError",
            // Identifier for fragment loop loading error - data: { frag : fragment object}
            FRAG_LOOP_LOADING_ERROR: "fragLoopLoadingError",
            // Identifier for fragment load timeout error - data: { frag : fragment object}
            FRAG_LOAD_TIMEOUT: "fragLoadTimeOut",
            // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }
            FRAG_DECRYPT_ERROR: "fragDecryptError",
            // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }
            // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release
            FRAG_PARSING_ERROR: "fragParsingError",
            // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }
            REMUX_ALLOC_ERROR: "remuxAllocError",
            // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}
            KEY_LOAD_ERROR: "keyLoadError",
            // Identifier for decrypt key load timeout error - data: { frag : fragment object}
            KEY_LOAD_TIMEOUT: "keyLoadTimeOut",
            // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : {  err : exception , mimeType : mimeType }
            BUFFER_ADD_CODEC_ERROR: "bufferAddCodecError",
            // Identifier for a buffer append error - data: append error description
            BUFFER_APPEND_ERROR: "bufferAppendError",
            // Identifier for a buffer appending error event - data: appending error description
            BUFFER_APPENDING_ERROR: "bufferAppendingError",
            // Identifier for a buffer stalled error event
            BUFFER_STALLED_ERROR: "bufferStalledError",
            // Identifier for a buffer full event
            BUFFER_FULL_ERROR: "bufferFullError",
            // Identifier for a buffer seek over hole event
            BUFFER_SEEK_OVER_HOLE: "bufferSeekOverHole",
            // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)
            BUFFER_NUDGE_ON_STALL: "bufferNudgeOnStall",
            // Identifier for an internal exception happening inside hls.js while handling an event
            INTERNAL_EXCEPTION: "internalException"
          };
        },
        /* 3 */
        /***/
        function(r, a, u) {
          function x(z, Y) {
            if (!(z instanceof Y))
              throw new TypeError("Cannot call a class as a function");
          }
          var y = function() {
            function z(Y, ie) {
              x(this, z), this.subtle = Y, this.aesIV = ie;
            }
            return z.prototype.decrypt = function(ie, ye) {
              return this.subtle.decrypt({ name: "AES-CBC", iv: this.aesIV }, ye, ie);
            }, z;
          }(), p = y;
          function h(z, Y) {
            if (!(z instanceof Y))
              throw new TypeError("Cannot call a class as a function");
          }
          var m = function() {
            function z(Y, ie) {
              h(this, z), this.subtle = Y, this.key = ie;
            }
            return z.prototype.expandKey = function() {
              return this.subtle.importKey("raw", this.key, { name: "AES-CBC" }, !1, ["encrypt", "decrypt"]);
            }, z;
          }(), d = m;
          function T(z, Y) {
            if (!(z instanceof Y))
              throw new TypeError("Cannot call a class as a function");
          }
          var S = function() {
            function z() {
              T(this, z), this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.initTable();
            }
            return z.prototype.uint8ArrayToUint32Array_ = function(ie) {
              for (var ye = new DataView(ie), ve = new Uint32Array(4), Ae = 0; Ae < 4; Ae++)
                ve[Ae] = ye.getUint32(Ae * 4);
              return ve;
            }, z.prototype.initTable = function() {
              var ie = this.sBox, ye = this.invSBox, ve = this.subMix, Ae = ve[0], Ee = ve[1], Ce = ve[2], Ve = ve[3], Ue = this.invSubMix, He = Ue[0], dt = Ue[1], Je = Ue[2], Nt = Ue[3], $e = new Uint32Array(256), vt = 0, pt = 0, st = 0;
              for (st = 0; st < 256; st++)
                st < 128 ? $e[st] = st << 1 : $e[st] = st << 1 ^ 283;
              for (st = 0; st < 256; st++) {
                var Qe = pt ^ pt << 1 ^ pt << 2 ^ pt << 3 ^ pt << 4;
                Qe = Qe >>> 8 ^ Qe & 255 ^ 99, ie[vt] = Qe, ye[Qe] = vt;
                var ht = $e[vt], Me = $e[ht], Yt = $e[Me], et = $e[Qe] * 257 ^ Qe * 16843008;
                Ae[vt] = et << 24 | et >>> 8, Ee[vt] = et << 16 | et >>> 16, Ce[vt] = et << 8 | et >>> 24, Ve[vt] = et, et = Yt * 16843009 ^ Me * 65537 ^ ht * 257 ^ vt * 16843008, He[Qe] = et << 24 | et >>> 8, dt[Qe] = et << 16 | et >>> 16, Je[Qe] = et << 8 | et >>> 24, Nt[Qe] = et, vt ? (vt = ht ^ $e[$e[$e[Yt ^ ht]]], pt ^= $e[$e[pt]]) : vt = pt = 1;
              }
            }, z.prototype.expandKey = function(ie) {
              for (var ye = this.uint8ArrayToUint32Array_(ie), ve = !0, Ae = 0; Ae < ye.length && ve; )
                ve = ye[Ae] === this.key[Ae], Ae++;
              if (!ve) {
                this.key = ye;
                var Ee = this.keySize = ye.length;
                if (Ee !== 4 && Ee !== 6 && Ee !== 8)
                  throw new Error("Invalid aes key size=" + Ee);
                var Ce = this.ksRows = (Ee + 6 + 1) * 4, Ve = void 0, Ue = void 0, He = this.keySchedule = new Uint32Array(Ce), dt = this.invKeySchedule = new Uint32Array(Ce), Je = this.sBox, Nt = this.rcon, $e = this.invSubMix, vt = $e[0], pt = $e[1], st = $e[2], Qe = $e[3], ht = void 0, Me = void 0;
                for (Ve = 0; Ve < Ce; Ve++) {
                  if (Ve < Ee) {
                    ht = He[Ve] = ye[Ve];
                    continue;
                  }
                  Me = ht, Ve % Ee === 0 ? (Me = Me << 8 | Me >>> 24, Me = Je[Me >>> 24] << 24 | Je[Me >>> 16 & 255] << 16 | Je[Me >>> 8 & 255] << 8 | Je[Me & 255], Me ^= Nt[Ve / Ee | 0] << 24) : Ee > 6 && Ve % Ee === 4 && (Me = Je[Me >>> 24] << 24 | Je[Me >>> 16 & 255] << 16 | Je[Me >>> 8 & 255] << 8 | Je[Me & 255]), He[Ve] = ht = (He[Ve - Ee] ^ Me) >>> 0;
                }
                for (Ue = 0; Ue < Ce; Ue++)
                  Ve = Ce - Ue, Ue & 3 ? Me = He[Ve] : Me = He[Ve - 4], Ue < 4 || Ve <= 4 ? dt[Ue] = Me : dt[Ue] = vt[Je[Me >>> 24]] ^ pt[Je[Me >>> 16 & 255]] ^ st[Je[Me >>> 8 & 255]] ^ Qe[Je[Me & 255]], dt[Ue] = dt[Ue] >>> 0;
              }
            }, z.prototype.networkToHostOrderSwap = function(ie) {
              return ie << 24 | (ie & 65280) << 8 | (ie & 16711680) >> 8 | ie >>> 24;
            }, z.prototype.decrypt = function(ie, ye, ve) {
              for (var Ae = this.keySize + 6, Ee = this.invKeySchedule, Ce = this.invSBox, Ve = this.invSubMix, Ue = Ve[0], He = Ve[1], dt = Ve[2], Je = Ve[3], Nt = this.uint8ArrayToUint32Array_(ve), $e = Nt[0], vt = Nt[1], pt = Nt[2], st = Nt[3], Qe = new Int32Array(ie), ht = new Int32Array(Qe.length), Me = void 0, Yt = void 0, et = void 0, fr = void 0, Rt = void 0, lt = void 0, It = void 0, Ze = void 0, Vt = void 0, qe = void 0, ot = void 0, Ut = void 0, At, mr, Mt = this.networkToHostOrderSwap; ye < Qe.length; ) {
                for (Vt = Mt(Qe[ye]), qe = Mt(Qe[ye + 1]), ot = Mt(Qe[ye + 2]), Ut = Mt(Qe[ye + 3]), Rt = Vt ^ Ee[0], lt = Ut ^ Ee[1], It = ot ^ Ee[2], Ze = qe ^ Ee[3], At = 4, mr = 1; mr < Ae; mr++)
                  Me = Ue[Rt >>> 24] ^ He[lt >> 16 & 255] ^ dt[It >> 8 & 255] ^ Je[Ze & 255] ^ Ee[At], Yt = Ue[lt >>> 24] ^ He[It >> 16 & 255] ^ dt[Ze >> 8 & 255] ^ Je[Rt & 255] ^ Ee[At + 1], et = Ue[It >>> 24] ^ He[Ze >> 16 & 255] ^ dt[Rt >> 8 & 255] ^ Je[lt & 255] ^ Ee[At + 2], fr = Ue[Ze >>> 24] ^ He[Rt >> 16 & 255] ^ dt[lt >> 8 & 255] ^ Je[It & 255] ^ Ee[At + 3], Rt = Me, lt = Yt, It = et, Ze = fr, At = At + 4;
                Me = Ce[Rt >>> 24] << 24 ^ Ce[lt >> 16 & 255] << 16 ^ Ce[It >> 8 & 255] << 8 ^ Ce[Ze & 255] ^ Ee[At], Yt = Ce[lt >>> 24] << 24 ^ Ce[It >> 16 & 255] << 16 ^ Ce[Ze >> 8 & 255] << 8 ^ Ce[Rt & 255] ^ Ee[At + 1], et = Ce[It >>> 24] << 24 ^ Ce[Ze >> 16 & 255] << 16 ^ Ce[Rt >> 8 & 255] << 8 ^ Ce[lt & 255] ^ Ee[At + 2], fr = Ce[Ze >>> 24] << 24 ^ Ce[Rt >> 16 & 255] << 16 ^ Ce[lt >> 8 & 255] << 8 ^ Ce[It & 255] ^ Ee[At + 3], At = At + 3, ht[ye] = Mt(Me ^ $e), ht[ye + 1] = Mt(fr ^ vt), ht[ye + 2] = Mt(et ^ pt), ht[ye + 3] = Mt(Yt ^ st), $e = Vt, vt = qe, pt = ot, st = Ut, ye = ye + 4;
              }
              return ht.buffer;
            }, z.prototype.destroy = function() {
              this.key = void 0, this.keySize = void 0, this.ksRows = void 0, this.sBox = void 0, this.invSBox = void 0, this.subMix = void 0, this.invSubMix = void 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.rcon = void 0;
            }, z;
          }(), B = S, I = u(2), O = u(0);
          function F(z, J) {
            if (!(z instanceof J))
              throw new TypeError("Cannot call a class as a function");
          }
          var $ = function() {
            function z(Y, ie) {
              j(this, z), this.observer = Y, this.config = ie, this.logEnabled = !0;
              try {
                var ye = crypto || self.crypto;
                this.subtle = ye.subtle || ye.webkitSubtle;
              } catch {
              }
              this.disableWebCrypto = !this.subtle;
            }
            return z.prototype.isSync = function() {
              return this.disableWebCrypto && this.config.enableSoftwareAES;
            }, z.prototype.decrypt = function(ie, ye, ve, Ae) {
              var Ee = this;
              if (this.disableWebCrypto && this.config.enableSoftwareAES) {
                this.logEnabled && (O.b.log("JS AES decrypt"), this.logEnabled = !1);
                var Ce = this.decryptor;
                Ce || (this.decryptor = Ce = new B()), Ce.expandKey(ye), Ae(Ce.decrypt(ie, 0, ve));
              } else {
                this.logEnabled && (O.b.log("WebCrypto AES decrypt"), this.logEnabled = !1);
                var Ve = this.subtle;
                this.key !== ye && (this.key = ye, this.fastAesKey = new d(Ve, ye)), this.fastAesKey.expandKey().then(function(Ue) {
                  var He = new p(Ve, ve);
                  He.decrypt(ie, Ue).catch(function(dt) {
                    Ee.onWebCryptoError(dt, ie, ye, ve, Ae);
                  }).then(function(dt) {
                    Ae(dt);
                  });
                }).catch(function(Ue) {
                  Ee.onWebCryptoError(Ue, ie, ye, ve, Ae);
                });
              }
            }, z.prototype.onWebCryptoError = function(ie, ye, ve, Ae, Ee) {
              this.config.enableSoftwareAES ? (O.b.log("WebCrypto Error, disable WebCrypto API"), this.disableWebCrypto = !0, this.logEnabled = !0, this.decrypt(ye, ve, Ae, Ee)) : (O.b.error("decrypting error : " + ie.message), this.observer.trigger(Event.ERROR, { type: I.b.MEDIA_ERROR, details: I.a.FRAG_DECRYPT_ERROR, fatal: !0, reason: ie.message }));
            }, z.prototype.destroy = function() {
              var ie = this.decryptor;
              ie && (ie.destroy(), this.decryptor = void 0);
            }, z;
          }();
          a.a = $;
        },
        /* 4 */
        /***/
        function(r, a, u) {
          function x(p, h) {
            if (!(p instanceof h))
              throw new TypeError("Cannot call a class as a function");
          }
          var y = function() {
            function p() {
              x(this, p);
            }
            return p.isHeader = function(h, d) {
              return d + 10 <= h.length && h[d] === 73 && h[d + 1] === 68 && h[d + 2] === 51 && h[d + 3] < 255 && h[d + 4] < 255 && h[d + 6] < 128 && h[d + 7] < 128 && h[d + 8] < 128 && h[d + 9] < 128;
            }, p.isFooter = function(h, d) {
              return d + 10 <= h.length && h[d] === 51 && h[d + 1] === 68 && h[d + 2] === 73 && h[d + 3] < 255 && h[d + 4] < 255 && h[d + 6] < 128 && h[d + 7] < 128 && h[d + 8] < 128 && h[d + 9] < 128;
            }, p.getID3Data = function(h, d) {
              for (var T = d, S = 0; p.isHeader(h, d); ) {
                S += 10;
                var B = p._readSize(h, d + 6);
                S += B, p.isFooter(h, d + 10) && (S += 10), d += S;
              }
              if (S > 0)
                return h.subarray(T, T + S);
            }, p._readSize = function(h, d) {
              var T = 0;
              return T = (h[d] & 127) << 21, T |= (h[d + 1] & 127) << 14, T |= (h[d + 2] & 127) << 7, T |= h[d + 3] & 127, T;
            }, p.getTimeStamp = function(h) {
              for (var d = p.getID3Frames(h), T = 0; T < d.length; T++) {
                var S = d[T];
                if (p.isTimeStampFrame(S))
                  return p._readTimeStamp(S);
              }
            }, p.isTimeStampFrame = function(h) {
              return h && h.key === "PRIV" && h.info === "com.apple.streaming.transportStreamTimestamp";
            }, p._getFrameData = function(h) {
              var d = String.fromCharCode(h[0], h[1], h[2], h[3]), T = p._readSize(h, 4), S = 10;
              return { type: d, size: T, data: h.subarray(S, S + T) };
            }, p.getID3Frames = function(h) {
              for (var d = 0, T = []; p.isHeader(h, d); ) {
                var S = p._readSize(h, d + 6);
                d += 10;
                for (var B = d + S; d + 8 < B; ) {
                  var I = p._getFrameData(h.subarray(d)), O = p._decodeFrame(I);
                  O && T.push(O), d += I.size + 10;
                }
                p.isFooter(m, d) && (d += 10);
              }
              return T;
            }, p._decodeFrame = function(h) {
              if (h.type === "PRIV")
                return p._decodePrivFrame(h);
              if (h.type[0] === "T")
                return p._decodeTextFrame(h);
              if (h.type[0] === "W")
                return p._decodeURLFrame(h);
            }, p._readTimeStamp = function(h) {
              if (h.data.byteLength === 8) {
                var d = new Uint8Array(h.data), T = d[3] & 1, S = (d[4] << 23) + (d[5] << 15) + (d[6] << 7) + d[7];
                return S /= 45, T && (S += 4772185884e-2), Math.round(S);
              }
            }, p._decodePrivFrame = function(m) {
              if (!(m.size < 2)) {
                var d = p._utf8ArrayToStr(m.data), T = new Uint8Array(m.data.subarray(d.length + 1));
                return { key: m.type, info: d, data: T.buffer };
              }
            }, p._decodeTextFrame = function(m) {
              if (!(m.size < 2))
                if (m.type === "TXXX") {
                  var d = 1, T = p._utf8ArrayToStr(m.data.subarray(d));
                  d += T.length + 1;
                  var S = p._utf8ArrayToStr(h.data.subarray(d));
                  return { key: h.type, info: T, data: S };
                } else {
                  var B = p._utf8ArrayToStr(m.data.subarray(1));
                  return { key: m.type, data: B };
                }
            }, p._decodeURLFrame = function(m) {
              if (m.type === "WXXX") {
                if (m.size < 2)
                  return;
                var d = 1, T = p._utf8ArrayToStr(m.data.subarray(d));
                d += T.length + 1;
                var S = p._utf8ArrayToStr(h.data.subarray(d));
                return { key: h.type, info: T, data: S };
              } else {
                var B = p._utf8ArrayToStr(m.data);
                return { key: m.type, data: B };
              }
            }, p._utf8ArrayToStr = function(h) {
              for (var d = void 0, T = void 0, S = "", B = 0, I = h.length; B < I; ) {
                var O = h[B++];
                switch (O >> 4) {
                  case 0:
                    return S;
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                  case 5:
                  case 6:
                  case 7:
                    S += String.fromCharCode(O);
                    break;
                  case 12:
                  case 13:
                    d = h[B++], S += String.fromCharCode((O & 31) << 6 | d & 63);
                    break;
                  case 14:
                    d = h[B++], T = h[B++], S += String.fromCharCode((O & 15) << 12 | (d & 63) << 6 | (T & 63) << 0);
                    break;
                }
              }
              return S;
            }, p;
          }();
          a.a = y;
        },
        /* 5 */
        /***/
        function(r, a) {
          function u() {
            this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;
          }
          r.exports = u, u.EventEmitter = u, u.prototype._events = void 0, u.prototype._maxListeners = void 0, u.defaultMaxListeners = 10, u.prototype.setMaxListeners = function(m) {
            if (!y(m) || m < 0 || isNaN(m))
              throw TypeError("n must be a positive number");
            return this._maxListeners = h, this;
          }, u.prototype.emit = function(h) {
            var d, T, S, B, I, O;
            if (this._events || (this._events = {}), h === "error" && (!this._events.error || p(this._events.error) && !this._events.error.length)) {
              if (d = arguments[1], d instanceof Error)
                throw d;
              var j = new Error('Uncaught, unspecified "error" event. (' + d + ")");
              throw j.context = d, j;
            }
            if (T = this._events[m], h(T))
              return !1;
            if (x(T))
              switch (arguments.length) {
                case 1:
                  T.call(this);
                  break;
                case 2:
                  T.call(this, arguments[1]);
                  break;
                case 3:
                  T.call(this, arguments[1], arguments[2]);
                  break;
                default:
                  B = Array.prototype.slice.call(arguments, 1), T.apply(this, B);
              }
            else if (p(T))
              for (B = Array.prototype.slice.call(arguments, 1), O = T.slice(), S = O.length, I = 0; I < S; I++)
                O[I].apply(this, B);
            return !0;
          }, u.prototype.addListener = function(m, d) {
            var T;
            if (!x(d))
              throw TypeError("listener must be a function");
            return this._events || (this._events = {}), this._events.newListener && this.emit(
              "newListener",
              m,
              x(d.listener) ? d.listener : d
            ), this._events[m] ? p(this._events[m]) ? this._events[m].push(d) : this._events[m] = [this._events[m], d] : this._events[m] = d, p(this._events[m]) && !this._events[m].warned && (h(this._maxListeners) ? T = u.defaultMaxListeners : T = this._maxListeners, T && T > 0 && this._events[m].length > T && (this._events[m].warned = !0, console.error(
              "(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",
              this._events[m].length
            ), typeof console.trace == "function" && console.trace())), this;
          }, u.prototype.on = u.prototype.addListener, u.prototype.once = function(m, d) {
            if (!x(d))
              throw TypeError("listener must be a function");
            var T = !1;
            function S() {
              this.removeListener(h, S), T || (T = !0, d.apply(this, arguments));
            }
            return S.listener = d, this.on(h, S), this;
          }, u.prototype.removeListener = function(h, d) {
            var T, S, B, I;
            if (!x(d))
              throw TypeError("listener must be a function");
            if (!this._events || !this._events[m])
              return this;
            if (T = this._events[h], B = T.length, S = -1, T === d || x(T.listener) && T.listener === d)
              delete this._events[h], this._events.removeListener && this.emit("removeListener", h, d);
            else if (p(T)) {
              for (I = B; I-- > 0; )
                if (T[I] === d || T[I].listener && T[I].listener === d) {
                  S = I;
                  break;
                }
              if (S < 0)
                return this;
              T.length === 1 ? (T.length = 0, delete this._events[h]) : T.splice(S, 1), this._events.removeListener && this.emit("removeListener", h, d);
            }
            return this;
          }, u.prototype.removeAllListeners = function(m) {
            var d, T;
            if (!this._events)
              return this;
            if (!this._events.removeListener)
              return arguments.length === 0 ? this._events = {} : this._events[m] && delete this._events[m], this;
            if (arguments.length === 0) {
              for (d in this._events)
                d !== "removeListener" && this.removeAllListeners(d);
              return this.removeAllListeners("removeListener"), this._events = {}, this;
            }
            if (T = this._events[m], x(T))
              this.removeListener(m, T);
            else if (T)
              for (; T.length; )
                this.removeListener(m, T[T.length - 1]);
            return delete this._events[m], this;
          }, u.prototype.listeners = function(m) {
            var d;
            return !this._events || !this._events[m] ? d = [] : x(this._events[m]) ? d = [this._events[m]] : d = this._events[m].slice(), d;
          }, u.prototype.listenerCount = function(m) {
            if (this._events) {
              var d = this._events[m];
              if (x(d))
                return 1;
              if (d)
                return d.length;
            }
            return 0;
          }, u.listenerCount = function(m, d) {
            return m.listenerCount(d);
          };
          function x(m) {
            return typeof m == "function";
          }
          function y(m) {
            return typeof m == "number";
          }
          function p(m) {
            return typeof m == "object" && m !== null;
          }
          function h(m) {
            return m === void 0;
          }
        },
        /* 6 */
        /***/
        function(r, a, u) {
          (function(x) {
            var y = /^((?:[^\/;?#]+:)?)(\/\/[^\/\;?#]*)?(.*?)??(;.*?)?(\?.*?)?(#.*?)?$/, p = /^([^\/;?#]*)(.*)$/, h = /(?:\/|^)\.(?=\/)/g, m = /(?:\/|^)\.\.\/(?!\.\.\/).*?(?=\/)/g, d = {
              // jshint ignore:line
              // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
              // E.g
              // With opts.alwaysNormalize = false (default, spec compliant)
              // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
              // With opts.alwaysNormalize = true (default, not spec compliant)
              // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
              buildAbsoluteURL: function(T, S, B) {
                if (B = B || {}, T = T.trim(), S = S.trim(), !S) {
                  if (!B.alwaysNormalize)
                    return T;
                  var I = this.parseURL(T);
                  if (!j)
                    throw new Error("Error trying to parse base URL.");
                  return I.path = d.normalizePath(I.path), d.buildURLFromParts(I);
                }
                var O = this.parseURL(S);
                if (!O)
                  throw new Error("Error trying to parse relative URL.");
                if (O.scheme)
                  return B.alwaysNormalize ? (O.path = d.normalizePath(O.path), d.buildURLFromParts(O)) : S;
                var F = this.parseURL(T);
                if (!F)
                  throw new Error("Error trying to parse base URL.");
                if (!j.netLoc && j.path && j.path[0] !== "/") {
                  var $ = p.exec(j.path);
                  j.netLoc = $[1], j.path = $[2];
                }
                j.netLoc && !j.path && (j.path = "/");
                var z = {
                  // 2c) Otherwise, the embedded URL inherits the scheme of
                  // the base URL.
                  scheme: j.scheme,
                  netLoc: O.netLoc,
                  path: null,
                  params: O.params,
                  query: O.query,
                  fragment: O.fragment
                };
                if (!O.netLoc && (z.netLoc = j.netLoc, O.path[0] !== "/"))
                  if (!O.path)
                    z.path = j.path, O.params || (z.params = j.params, O.query || (z.query = j.query));
                  else {
                    var Y = j.path, ie = Y.substring(0, Y.lastIndexOf("/") + 1) + O.path;
                    z.path = d.normalizePath(ie);
                  }
                return z.path === null && (z.path = B.alwaysNormalize ? d.normalizePath(O.path) : O.path), d.buildURLFromParts(z);
              },
              parseURL: function(T) {
                var S = y.exec(T);
                return S ? {
                  scheme: S[1] || "",
                  netLoc: S[2] || "",
                  path: S[3] || "",
                  params: S[4] || "",
                  query: S[5] || "",
                  fragment: S[6] || ""
                } : null;
              },
              normalizePath: function(T) {
                for (T = T.split("").reverse().join("").replace(h, ""); T.length !== (T = T.replace(m, "")).length; )
                  ;
                return T.split("").reverse().join("");
              },
              buildURLFromParts: function(T) {
                return T.scheme + T.netLoc + T.path + T.params + T.query + T.fragment;
              }
            };
            r.exports = d;
          })();
        },
        /* 7 */
        /***/
        function(r, a, u) {
          var x = u(1), y = u(2), p = u(3), h = u(0);
          function m(_, X, b, L) {
            var k, U, V, Z, H, ee = navigator.userAgent.toLowerCase(), re = L, Q = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
            if (k = ((X[b + 2] & 192) >>> 6) + 1, U = (X[b + 2] & 60) >>> 2, U > Q.length - 1) {
              _.trigger(Event.ERROR, { type: y.b.MEDIA_ERROR, details: y.a.FRAG_PARSING_ERROR, fatal: !0, reason: "invalid ADTS sampling index:" + U });
              return;
            }
            return Z = (X[b + 2] & 1) << 2, Z |= (X[b + 3] & 192) >>> 6, h.b.log("manifest codec:" + L + ",ADTS data:type:" + k + ",sampleingIndex:" + U + "[" + Q[U] + "Hz],channelConfig:" + Z), /firefox/i.test(ee) ? U >= 6 ? (k = 5, H = new Array(4), V = U - 3) : (k = 2, H = new Array(2), V = U) : ee.indexOf("android") !== -1 ? (k = 2, H = new Array(2), V = U) : (k = 5, H = new Array(4), L && (L.indexOf("mp4a.40.29") !== -1 || L.indexOf("mp4a.40.5") !== -1) || !L && U >= 6 ? V = U - 3 : ((L && L.indexOf("mp4a.40.2") !== -1 && (U >= 6 && Z === 1 || /vivaldi/i.test(ee)) || !L && Z === 1) && (k = 2, H = new Array(2)), V = U)), H[0] = k << 3, H[0] |= (U & 14) >> 1, H[1] |= (U & 1) << 7, H[1] |= Z << 3, k === 5 && (H[1] |= (V & 14) >> 1, H[2] = (V & 1) << 7, H[2] |= 8, H[3] = 0), { config: H, samplerate: Q[U], channelCount: Z, codec: "mp4a.40." + k, manifestCodec: re };
          }
          function d(_, X) {
            return _[X] === 255 && (_[X + 1] & 246) === 240;
          }
          function T(_, X) {
            return _[X + 1] & 1 ? 7 : 9;
          }
          function S(_, X) {
            return (_[X + 3] & 3) << 11 | _[X + 4] << 3 | (_[X + 5] & 224) >>> 5;
          }
          function B(_, X) {
            return !!(X + 1 < _.length && d(_, X));
          }
          function I(_, X) {
            if (X + 1 < _.length && d(_, X)) {
              var b = T(_, X), L = b;
              X + 5 < _.length && (L = S(_, X));
              var k = X + L;
              if (k === _.length || k + 1 < _.length && d(_, k))
                return !0;
            }
            return !1;
          }
          function O(_, X, b, L, k) {
            if (!_.samplerate) {
              var U = m(X, b, L, k);
              _.config = U.config, _.samplerate = U.samplerate, _.channelCount = U.channelCount, _.codec = U.codec, _.manifestCodec = U.manifestCodec, h.b.log("parsed codec:" + _.codec + ",rate:" + U.samplerate + ",nb channel:" + U.channelCount);
            }
          }
          function j(_) {
            return 1024 * 9e4 / _;
          }
          function V(_, X, b, L, k) {
            var U, M, Z, H = _.length;
            if (U = T(_, X), M = S(_, X), M -= U, M > 0 && X + U + M <= H)
              return Z = b + L * k, { headerLength: U, frameLength: M, stamp: Z };
          }
          function z(_, X, b, L, k) {
            var U = j(_.samplerate), V = $(X, b, L, k, U);
            if (V) {
              var Z = V.stamp, H = V.headerLength, ee = V.frameLength, re = {
                unit: X.subarray(b + H, b + H + ee),
                pts: Z,
                dts: Z
              };
              return _.samples.push(re), _.len += ee, { sample: re, length: ee + H };
            }
          }
          var Y = u(4);
          function ie(_, X) {
            if (!(_ instanceof X))
              throw new TypeError("Cannot call a class as a function");
          }
          var ye = function() {
            function _(X, b, L) {
              ie(this, _), this.observer = X, this.config = L, this.remuxer = b;
            }
            return _.prototype.resetInitSegment = function(b, L, k, U) {
              this._audioTrack = { container: "audio/adts", type: "audio", id: 0, sequenceNumber: 0, isAAC: !0, samples: [], len: 0, manifestCodec: L, duration: U, inputTimeScale: 9e4 };
            }, _.prototype.resetTimeStamp = function() {
            }, _.probe = function(b) {
              if (!b)
                return !1;
              for (var L = Y.a.getID3Data(b, 0) || [], k = L.length, U = b.length; k < U; k++)
                if (I(b, k))
                  return h.b.log("ADTS sync word found !"), !0;
              return !1;
            }, _.prototype.append = function(b, L, k, U) {
              for (var V = this._audioTrack, Z = Y.a.getID3Data(b, 0) || [], H = Y.a.getTimeStamp(Z), ee = H ? 90 * H : L * 9e4, re = 0, Q = ee, oe = b.length, se = Z.length, ce = [{ pts: Q, dts: Q, data: Z }]; se < oe - 1; )
                if (B(b, se) && se + 5 < oe) {
                  O(V, this.observer, b, se, V.manifestCodec);
                  var de = z(V, b, se, ee, re);
                  if (de)
                    se += de.length, Q = de.sample.pts, re++;
                  else {
                    h.b.log("Unable to parse AAC frame");
                    break;
                  }
                } else J.a.isHeader(b, se) ? (Z = J.a.getID3Data(b, se), ce.push({ pts: Q, dts: Q, data: Z }), se += Z.length) : se++;
              this.remuxer.remux(M, { samples: [] }, { samples: ce, inputTimeScale: 9e4 }, { samples: [] }, L, k, U);
            }, _.prototype.destroy = function() {
            }, _;
          }(), ve = ye;
          function Ae(_, X) {
            if (!(_ instanceof X))
              throw new TypeError("Cannot call a class as a function");
          }
          var Ee = Math.pow(2, 32) - 1, Ce = function() {
            function _(X, b) {
              Ae(this, _), this.observer = X, this.remuxer = b;
            }
            return _.prototype.resetTimeStamp = function(b) {
              this.initPTS = b;
            }, _.prototype.resetInitSegment = function(b, L, k, U) {
              if (b && b.byteLength) {
                var V = this.initData = _.parseInitSegment(b);
                L == null && (L = "mp4a.40.5"), k == null && (k = "avc1.42e01e");
                var Z = {};
                V.audio && V.video ? Z.audiovideo = { container: "video/mp4", codec: L + "," + k, initSegment: U ? b : null } : (V.audio && (Z.audio = { container: "audio/mp4", codec: L, initSegment: U ? b : null }), V.video && (Z.video = { container: "video/mp4", codec: k, initSegment: U ? b : null })), this.observer.trigger(x.a.FRAG_PARSING_INIT_SEGMENT, { tracks: Z });
              } else
                L && (this.audioCodec = L), k && (this.videoCodec = k);
            }, _.probe = function(b) {
              return _.findBox({ data: b, start: 0, end: Math.min(b.length, 16384) }, ["moof"]).length > 0;
            }, _.bin2str = function(b) {
              return String.fromCharCode.apply(null, b);
            }, _.readUint32 = function(b, L) {
              b.data && (L += b.start, b = b.data);
              var k = b[L] << 24 | b[L + 1] << 16 | b[L + 2] << 8 | b[L + 3];
              return k < 0 ? 4294967296 + k : k;
            }, _.writeUint32 = function(b, L, k) {
              b.data && (L += b.start, b = b.data), b[L] = k >> 24, b[L + 1] = k >> 16 & 255, b[L + 2] = k >> 8 & 255, b[L + 3] = k & 255;
            }, _.findBox = function(b, L) {
              var k = [], U, V, Z, H, ee, re, Q;
              if (b.data ? (re = b.start, H = b.end, b = b.data) : (re = 0, H = b.byteLength), !L.length)
                return null;
              for (U = re; U < H; )
                V = _.readUint32(b, U), Z = _.bin2str(b.subarray(U + 4, U + 8)), Q = V > 1 ? U + V : H, Z === L[0] && (L.length === 1 ? k.push({ data: b, start: U + 8, end: Q }) : (ee = _.findBox({ data: b, start: U + 8, end: Q }, L.slice(1)), ee.length && (k = k.concat(ee)))), U = Q;
              return k;
            }, _.parseInitSegment = function(b) {
              var L = [], k = _.findBox(b, ["moov", "trak"]);
              return k.forEach(function(U) {
                var V = _.findBox(U, ["tkhd"])[0];
                if (V) {
                  var Z = V.data[V.start], H = Z === 0 ? 12 : 20, ee = _.readUint32(V, H), re = _.findBox(U, ["mdia", "mdhd"])[0];
                  if (re) {
                    Z = re.data[re.start], H = Z === 0 ? 12 : 20;
                    var Q = _.readUint32(re, H), oe = _.findBox(U, ["mdia", "hdlr"])[0];
                    if (oe) {
                      var se = _.bin2str(oe.data.subarray(oe.start + 8, oe.start + 12)), ce = { soun: "audio", vide: "video" }[se];
                      if (ce) {
                        var de = _.findBox(U, ["mdia", "minf", "stbl", "stsd"]);
                        if (de.length) {
                          de = de[0];
                          var pe = _.bin2str(de.data.subarray(de.start + 12, de.start + 16));
                          h.b.log("MP4Demuxer:" + ce + ":" + pe + " found");
                        }
                        L[ee] = { timescale: Q, type: ce }, L[ce] = { timescale: Q, id: ee };
                      }
                    }
                  }
                }
              }), L;
            }, _.getStartDTS = function(b, L) {
              var k, U, V;
              return k = _.findBox(L, ["moof", "traf"]), U = [].concat.apply([], k.map(function(Z) {
                return _.findBox(Z, ["tfhd"]).map(function(H) {
                  var ee, re, Q;
                  return ee = _.readUint32(H, 4), re = b[ee].timescale || 9e4, Q = _.findBox(Z, ["tfdt"]).map(function(oe) {
                    var se, ce;
                    return se = oe.data[oe.start], ce = _.readUint32(oe, 4), se === 1 && (ce *= Math.pow(2, 32), ce += _.readUint32(oe, 8)), ce;
                  })[0], Q / re;
                });
              })), V = Math.min.apply(null, U), isFinite(V) ? V : 0;
            }, _.offsetStartDTS = function(b, L, k) {
              _.findBox(L, ["moof", "traf"]).map(function(U) {
                return _.findBox(U, ["tfhd"]).map(function(V) {
                  var Z = _.readUint32(V, 4), H = b[Z].timescale || 9e4;
                  _.findBox(U, ["tfdt"]).map(function(ee) {
                    var re = ee.data[ee.start], Q = _.readUint32(ee, 4);
                    if (re === 0)
                      _.writeUint32(ee, 4, Q - k * H);
                    else {
                      Q *= Math.pow(2, 32), Q += _.readUint32(ee, 8), Q -= k * H, Q = Math.max(Q, 0);
                      var oe = Math.floor(Q / (Ee + 1)), se = Math.floor(Q % (Ee + 1));
                      _.writeUint32(ee, 4, oe), _.writeUint32(ee, 8, se);
                    }
                  });
                });
              });
            }, _.prototype.append = function(b, L, k, U) {
              var V = this.initData;
              V || (this.resetInitSegment(b, this.audioCodec, this.videoCodec), V = this.initData);
              var Z = void 0, H = this.initPTS;
              if (H === void 0) {
                var ee = _.getStartDTS(V, b);
                this.initPTS = H = ee - L, this.observer.trigger(x.a.INIT_PTS_FOUND, { initPTS: H });
              }
              _.offsetStartDTS(V, b, H), Z = _.getStartDTS(V, b), this.remuxer.remux(V.audio, V.video, null, null, Z, k, U, b);
            }, _.prototype.destroy = function() {
            }, _;
          }(), Ve = Ce, Ue = {
            BitratesMap: [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],
            SamplingRateMap: [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],
            appendFrame: function(X, b, L, k, U) {
              if (!(L + 24 > b.length)) {
                var V = this.parseHeader(b, L);
                if (V && L + V.frameLength <= b.length) {
                  var Z = 10368e4 / V.sampleRate, H = k + U * Z, ee = { unit: b.subarray(L, L + V.frameLength), pts: H, dts: H };
                  return X.config = [], X.channelCount = V.channelCount, X.samplerate = V.sampleRate, X.samples.push(ee), X.len += V.frameLength, { sample: ee, length: V.frameLength };
                }
              }
            },
            parseHeader: function(X, b) {
              var L = X[b + 1] >> 3 & 3, k = X[b + 1] >> 1 & 3, U = X[b + 2] >> 4 & 15, M = X[b + 2] >> 2 & 3, Z = !!(X[b + 2] & 2);
              if (L !== 1 && U !== 0 && U !== 15 && M !== 3) {
                var H = L === 3 ? 3 - k : k === 3 ? 3 : 4, ee = Ue.BitratesMap[H * 14 + U - 1] * 1e3, re = L === 3 ? 0 : L === 2 ? 1 : 2, Q = Ue.SamplingRateMap[re * 3 + M], oe = Z ? 1 : 0, se = X[b + 3] >> 6 === 3 ? 1 : 2, ce = k === 3 ? (L === 3 ? 12 : 6) * ee / Q + oe << 2 : (L === 3 ? 144 : 72) * ee / Q + oe | 0;
                return { sampleRate: Q, channelCount: se, frameLength: ce };
              }
            },
            isHeaderPattern: function(X, b) {
              return X[b] === 255 && (X[b + 1] & 224) === 224 && (X[b + 1] & 6) !== 0;
            },
            isHeader: function(X, b) {
              return !!(b + 1 < X.length && this.isHeaderPattern(X, b));
            },
            probe: function(X, b) {
              if (b + 1 < X.length && this.isHeaderPattern(X, b)) {
                var L = 4, k = this.parseHeader(X, b), U = L;
                k && k.frameLength && (U = k.frameLength);
                var V = b + U;
                if (V === X.length || V + 1 < X.length && this.isHeaderPattern(X, V))
                  return !0;
              }
              return !1;
            }
          }, He = Ue;
          function dt(_, X) {
            if (!(_ instanceof X))
              throw new TypeError("Cannot call a class as a function");
          }
          var Je = function() {
            function _(X) {
              dt(this, _), this.data = X, this.bytesAvailable = X.byteLength, this.word = 0, this.bitsAvailable = 0;
            }
            return _.prototype.loadWord = function() {
              var b = this.data, L = this.bytesAvailable, k = b.byteLength - L, U = new Uint8Array(4), V = Math.min(4, L);
              if (V === 0)
                throw new Error("no bytes available");
              U.set(b.subarray(k, k + V)), this.word = new DataView(U.buffer).getUint32(0), this.bitsAvailable = V * 8, this.bytesAvailable -= V;
            }, _.prototype.skipBits = function(b) {
              var L;
              this.bitsAvailable > b ? (this.word <<= b, this.bitsAvailable -= b) : (b -= this.bitsAvailable, L = b >> 3, b -= L >> 3, this.bytesAvailable -= L, this.loadWord(), this.word <<= b, this.bitsAvailable -= b);
            }, _.prototype.readBits = function(b) {
              var L = Math.min(this.bitsAvailable, b), k = this.word >>> 32 - L;
              return b > 32 && h.b.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= L, this.bitsAvailable > 0 ? this.word <<= L : this.bytesAvailable > 0 && this.loadWord(), L = b - L, L > 0 && this.bitsAvailable ? k << L | this.readBits(L) : k;
            }, _.prototype.skipLZ = function() {
              var b;
              for (b = 0; b < this.bitsAvailable; ++b)
                if (this.word & 2147483648 >>> b)
                  return this.word <<= b, this.bitsAvailable -= b, b;
              return this.loadWord(), b + this.skipLZ();
            }, _.prototype.skipUEG = function() {
              this.skipBits(1 + this.skipLZ());
            }, _.prototype.skipEG = function() {
              this.skipBits(1 + this.skipLZ());
            }, _.prototype.readUEG = function() {
              var b = this.skipLZ();
              return this.readBits(b + 1) - 1;
            }, _.prototype.readEG = function() {
              var b = this.readUEG();
              return 1 & b ? 1 + b >>> 1 : -1 * (b >>> 1);
            }, _.prototype.readBoolean = function() {
              return this.readBits(1) === 1;
            }, _.prototype.readUByte = function() {
              return this.readBits(8);
            }, _.prototype.readUShort = function() {
              return this.readBits(16);
            }, _.prototype.readUInt = function() {
              return this.readBits(32);
            }, _.prototype.skipScalingList = function(b) {
              var L = 8, k = 8, U, V;
              for (U = 0; U < b; U++)
                k !== 0 && (V = this.readEG(), k = (L + V + 256) % 256), L = k === 0 ? L : k;
            }, _.prototype.readSPS = function() {
              var b = 0, L = 0, k = 0, U = 0, M, Z, H, ee, re, Q, oe, se = this.readUByte.bind(this), ce = this.readBits.bind(this), de = this.readUEG.bind(this), pe = this.readBoolean.bind(this), W = this.skipBits.bind(this), Oe = this.skipEG.bind(this), tt = this.skipUEG.bind(this), rt = this.skipScalingList.bind(this);
              if (se(), M = se(), ce(5), W(3), se(), tt(), M === 100 || M === 110 || M === 122 || M === 244 || M === 44 || M === 83 || M === 86 || M === 118 || M === 128) {
                var Xe = de();
                if (Xe === 3 && W(1), tt(), tt(), W(1), pe())
                  for (Q = Xe !== 3 ? 8 : 12, oe = 0; oe < Q; oe++)
                    pe() && (oe < 6 ? rt(16) : rt(64));
              }
              tt();
              var Ye = de();
              if (Ye === 0)
                de();
              else if (Ye === 1)
                for (W(1), Oe(), Oe(), Z = de(), oe = 0; oe < Z; oe++)
                  Oe();
              tt(), W(1), H = de(), ee = de(), re = ce(1), re === 0 && W(1), W(1), pe() && (b = de(), L = de(), k = de(), U = de());
              var Se = [1, 1];
              if (pe() && pe()) {
                var ut = se();
                switch (ut) {
                  case 1:
                    Le = [1, 1];
                    break;
                  case 2:
                    Le = [12, 11];
                    break;
                  case 3:
                    Le = [10, 11];
                    break;
                  case 4:
                    Le = [16, 11];
                    break;
                  case 5:
                    Le = [40, 33];
                    break;
                  case 6:
                    Le = [24, 11];
                    break;
                  case 7:
                    Le = [20, 11];
                    break;
                  case 8:
                    Le = [32, 11];
                    break;
                  case 9:
                    Le = [80, 33];
                    break;
                  case 10:
                    Le = [18, 11];
                    break;
                  case 11:
                    Le = [15, 11];
                    break;
                  case 12:
                    Le = [64, 33];
                    break;
                  case 13:
                    Le = [160, 99];
                    break;
                  case 14:
                    Le = [4, 3];
                    break;
                  case 15:
                    Le = [3, 2];
                    break;
                  case 16:
                    Le = [2, 1];
                    break;
                  case 255: {
                    Le = [se() << 8 | se(), se() << 8 | se()];
                    break;
                  }
                }
              }
              return {
                width: Math.ceil((H + 1) * 16 - b * 2 - L * 2),
                height: (2 - re) * (ee + 1) * 16 - (re ? 2 : 4) * (k + U),
                pixelRatio: Le
              };
            }, _.prototype.readSliceType = function() {
              return this.readUByte(), this.readUEG(), this.readUEG();
            }, _;
          }(), Nt = Je;
          function $e(_, X) {
            if (!(_ instanceof X))
              throw new TypeError("Cannot call a class as a function");
          }
          var vt = function() {
            function _(X, b, L, k) {
              $e(this, _), this.decryptdata = L, this.discardEPB = k, this.decrypter = new p.a(X, b);
            }
            return _.prototype.decryptBuffer = function(b, L) {
              this.decrypter.decrypt(b, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, L);
            }, _.prototype.decryptAacSample = function(b, L, k, U) {
              var V = b[L].unit, Z = V.subarray(16, V.length - V.length % 16), H = Z.buffer.slice(Z.byteOffset, Z.byteOffset + Z.length), ee = this;
              this.decryptBuffer(H, function(re) {
                re = new Uint8Array(re), V.set(re, 16), U || ee.decryptAacSamples(b, L + 1, k);
              });
            }, _.prototype.decryptAacSamples = function(b, L, k) {
              for (; ; L++) {
                if (L >= b.length) {
                  k();
                  return;
                }
                if (!(b[L].unit.length < 32)) {
                  var U = this.decrypter.isSync();
                  if (this.decryptAacSample(b, L, k, U), !U)
                    return;
                }
              }
            }, _.prototype.getAvcEncryptedData = function(b) {
              for (var L = Math.floor((b.length - 48) / 160) * 16 + 16, k = new Int8Array(L), U = 0, V = 32; V <= b.length - 16; V += 160, U += 16)
                k.set(b.subarray(V, V + 16), U);
              return k;
            }, _.prototype.getAvcDecryptedUnit = function(b, L) {
              L = new Uint8Array(L);
              for (var k = 0, U = 32; U <= b.length - 16; U += 160, k += 16)
                b.set(L.subarray(k, k + 16), U);
              return b;
            }, _.prototype.decryptAvcSample = function(b, L, k, U, V, Z) {
              var H = this.discardEPB(V.data), ee = this.getAvcEncryptedData(H), re = this;
              this.decryptBuffer(ee.buffer, function(Q) {
                V.data = re.getAvcDecryptedUnit(H, Q), Z || re.decryptAvcSamples(b, L, k + 1, U);
              });
            }, _.prototype.decryptAvcSamples = function(b, L, k, U) {
              for (; ; L++, k = 0) {
                if (L >= b.length) {
                  U();
                  return;
                }
                for (var V = b[L].units; !(k >= V.length); k++) {
                  var Z = V[k];
                  if (!(Z.length <= 48 || Z.type !== 1 && Z.type !== 5)) {
                    var H = this.decrypter.isSync();
                    if (this.decryptAvcSample(b, L, k, U, Z, H), !H)
                      return;
                  }
                }
              }
            }, _;
          }(), pt = vt;
          function st(_, X) {
            if (!(_ instanceof X))
              throw new TypeError("Cannot call a class as a function");
          }
          var Qe = function() {
            function _(X, b, L, k) {
              st(this, _), this.observer = X, this.config = L, this.typeSupported = k, this.remuxer = b, this.sampleAes = null;
            }
            return _.prototype.setDecryptData = function(b) {
              b != null && b.key != null && b.method === "SAMPLE-AES" ? this.sampleAes = new pt(this.observer, this.config, b, this.discardEPB) : this.sampleAes = null;
            }, _.probe = function(b) {
              var L = _._syncOffset(b);
              return L < 0 ? !1 : (L && h.b.warn("MPEG2-TS detected but first sync word found @ offset " + L + ", junk ahead ?"), !0);
            }, _._syncOffset = function(b) {
              for (var L = Math.min(1e3, b.length - 564), k = 0; k < L; ) {
                if (b[k] === 71 && b[k + 188] === 71 && b[k + 2 * 188] === 71)
                  return k;
                k++;
              }
              return -1;
            }, _.prototype.resetInitSegment = function(b, L, k, U) {
              this.pmtParsed = !1, this._pmtId = -1, this._avcTrack = { container: "video/mp2t", type: "video", id: -1, inputTimeScale: 9e4, sequenceNumber: 0, samples: [], len: 0, dropped: 0 }, this._audioTrack = { container: "video/mp2t", type: "audio", id: -1, inputTimeScale: 9e4, duration: U, sequenceNumber: 0, samples: [], len: 0, isAAC: !0 }, this._id3Track = { type: "id3", id: -1, inputTimeScale: 9e4, sequenceNumber: 0, samples: [], len: 0 }, this._txtTrack = { type: "text", id: -1, inputTimeScale: 9e4, sequenceNumber: 0, samples: [], len: 0 }, this.aacOverFlow = null, this.aacLastPTS = null, this.avcSample = null, this.audioCodec = L, this.videoCodec = k, this._duration = U;
            }, _.prototype.resetTimeStamp = function() {
            }, _.prototype.append = function(b, L, k, U) {
              var V, Z = b.length, H, ee, re, Q, oe, se = !1;
              this.contiguous = k;
              var ce = this.pmtParsed, de = this._avcTrack, pe = this._audioTrack, W = this._id3Track, Oe = de.id, tt = pe.id, rt = W.id, Xe = this._pmtId, Ye = de.pesData, Se = pe.pesData, ut = W.pesData, _t = this._parsePAT, ft = this._parsePMT, Et = this._parsePES, Dt = this._parseAVCPES.bind(this), Jt = this._parseAACPES.bind(this), Pt = this._parseMPEGPES.bind(this), cr = this._parseID3PES.bind(this), jt = _._syncOffset(b);
              for (Z -= (Z + jt) % 188, M = jt; M < Z; M += 188)
                if (b[M] === 71) {
                  if (H = !!(b[M + 1] & 64), ee = ((b[M + 1] & 31) << 8) + b[M + 2], re = (b[M + 3] & 48) >> 4, re > 1) {
                    if (Q = M + 5 + b[M + 4], Q === M + 188)
                      continue;
                  } else
                    Q = V + 4;
                  switch (ee) {
                    case Oe:
                      H && (Ye && (oe = Et(Ye)) && Dt(oe, !1), Ye = { data: [], size: 0 }), Ye && (Ye.data.push(b.subarray(Q, M + 188)), Ye.size += M + 188 - Q);
                      break;
                    case tt:
                      H && (Se && (oe = Et(Se)) && (pe.isAAC ? Jt(oe) : Pt(oe)), Se = { data: [], size: 0 }), Se && (Se.data.push(b.subarray(Q, M + 188)), Se.size += M + 188 - Q);
                      break;
                    case rt:
                      H && (ut && (oe = Et(ut)) && cr(oe), ut = { data: [], size: 0 }), ut && (ut.data.push(b.subarray(Q, M + 188)), ut.size += M + 188 - Q);
                      break;
                    case 0:
                      H && (Q += b[Q] + 1), Xe = this._pmtId = _t(b, Q);
                      break;
                    case Xe:
                      H && (Q += b[Q] + 1);
                      var Qt = ft(b, Q, this.typeSupported.mpeg === !0 || this.typeSupported.mp3 === !0, this.sampleAes != null);
                      Oe = Qt.avc, Oe > 0 && (de.id = Oe), tt = Qt.audio, tt > 0 && (pe.id = tt, pe.isAAC = Qt.isAAC), rt = Qt.id3, rt > 0 && (W.id = rt), se && !ce && (m.b.log("reparse from beginning"), se = !1, M = jt - 188), ce = this.pmtParsed = !0;
                      break;
                    case 17:
                    case 8191:
                      break;
                    default:
                      se = !0;
                      break;
                  }
                } else
                  this.observer.trigger(x.a.ERROR, { type: y.b.MEDIA_ERROR, details: y.a.FRAG_PARSING_ERROR, fatal: !1, reason: "TS packet did not start with 0x47" });
              Ye && (oe = Et(Ye)) ? (Dt(oe, !0), de.pesData = null) : de.pesData = Ye, Se && (oe = Et(Se)) ? (pe.isAAC ? Jt(oe) : Pt(oe), pe.pesData = null) : (Se && Se.size && m.b.log("last AAC PES packet truncated,might overlap between fragments"), pe.pesData = Se), ut && (oe = Et(ut)) ? (cr(oe), W.pesData = null) : W.pesData = ut, this.sampleAes == null ? this.remuxer.remux(pe, de, W, this._txtTrack, L, k, U) : this.decryptAndRemux(pe, de, W, this._txtTrack, L, k, U);
            }, _.prototype.decryptAndRemux = function(b, L, k, U, M, Z, H) {
              if (b.samples && b.isAAC) {
                var ee = this;
                this.sampleAes.decryptAacSamples(b.samples, 0, function() {
                  ee.decryptAndRemuxAvc(b, L, k, U, V, Z, H);
                });
              } else
                this.decryptAndRemuxAvc(b, L, k, U, V, Z, H);
            }, _.prototype.decryptAndRemuxAvc = function(b, L, k, U, V, Z, H) {
              if (L.samples) {
                var ee = this;
                this.sampleAes.decryptAvcSamples(L.samples, 0, 0, function() {
                  ee.remuxer.remux(b, L, k, U, V, Z, H);
                });
              } else
                this.remuxer.remux(b, L, k, U, V, Z, H);
            }, _.prototype.destroy = function() {
              this._initPTS = this._initDTS = void 0, this._duration = 0;
            }, _.prototype._parsePAT = function(b, L) {
              return (b[L + 10] & 31) << 8 | b[L + 11];
            }, _.prototype._parsePMT = function(b, L, k, U) {
              var V, Z, H, ee, re = { audio: -1, avc: -1, id3: -1, isAAC: !0 };
              for (V = (b[L + 1] & 15) << 8 | b[L + 2], Z = L + 3 + V - 4, H = (b[L + 10] & 15) << 8 | b[L + 11], L += 12 + H; L < Z; ) {
                switch (ee = (b[L + 1] & 31) << 8 | b[L + 2], b[L]) {
                  case 207:
                    if (!U) {
                      h.b.log("unkown stream type:" + b[L]);
                      break;
                    }
                  case 15:
                    re.audio === -1 && (re.audio = ee);
                    break;
                  case 21:
                    re.id3 === -1 && (re.id3 = ee);
                    break;
                  case 219:
                    if (!U) {
                      h.b.log("unkown stream type:" + b[L]);
                      break;
                    }
                  case 27:
                    re.avc === -1 && (re.avc = ee);
                    break;
                  case 3:
                  case 4:
                    k ? re.audio === -1 && (re.audio = ee, re.isAAC = !1) : h.b.log("MPEG audio found, not supported in this browser for now");
                    break;
                  case 36:
                    h.b.warn("HEVC stream type found, not supported for now");
                    break;
                  default:
                    h.b.log("unkown stream type:" + b[L]);
                    break;
                }
                L += ((b[L + 3] & 15) << 8 | b[L + 4]) + 5;
              }
              return re;
            }, _.prototype._parsePES = function(b) {
              var L = 0, k, U, V, Z, H, ee, re, Q, oe, se = b.data;
              if (!b || b.size === 0)
                return null;
              for (; se[0].length < 19 && se.length > 1; ) {
                var ce = new Uint8Array(se[0].length + se[1].length);
                ce.set(se[0]), ce.set(se[1], se[0].length), se[0] = ce, se.splice(1, 1);
              }
              if (k = se[0], V = (k[0] << 16) + (k[1] << 8) + k[2], V === 1) {
                if (Z = (k[4] << 8) + k[5], Z && Z > b.size - 6)
                  return null;
                U = k[7], U & 192 && (re = (k[9] & 14) * 536870912 + // 1 << 29
                (k[10] & 255) * 4194304 + // 1 << 22
                (k[11] & 254) * 16384 + // 1 << 14
                (k[12] & 255) * 128 + // 1 << 7
                (k[13] & 254) / 2, re > 4294967295 && (re -= 8589934592), U & 64 ? (Q = (k[14] & 14) * 536870912 + // 1 << 29
                (k[15] & 255) * 4194304 + // 1 << 22
                (k[16] & 254) * 16384 + // 1 << 14
                (k[17] & 255) * 128 + // 1 << 7
                (k[18] & 254) / 2, Q > 4294967295 && (Q -= 8589934592), re - Q > 60 * 9e4 && (h.b.warn(Math.round((re - Q) / 9e4) + "s delta between PTS and DTS, align them"), re = Q)) : Q = re), H = k[8], oe = H + 9, b.size -= oe, ee = new Uint8Array(b.size);
                for (var de = 0, pe = se.length; de < pe; de++) {
                  k = se[de];
                  var W = k.byteLength;
                  if (oe)
                    if (oe > W) {
                      oe -= W;
                      continue;
                    } else
                      k = k.subarray(oe), W -= oe, oe = 0;
                  ee.set(k, L), L += W;
                }
                return Z && (Z -= H + 3), { data: ee, pts: re, dts: Q, len: Z };
              } else
                return null;
            }, _.prototype.pushAccesUnit = function(b, L) {
              if (b.units.length && b.frame) {
                var k = L.samples, U = k.length;
                !this.config.forceKeyFrameOnDiscontinuity || b.key === !0 || L.sps && (U || this.contiguous) ? (b.id = U, k.push(b)) : L.dropped++;
              }
              b.debug.length && h.b.log(b.pts + "/" + b.dts + ":" + b.debug);
            }, _.prototype._parseAVCPES = function(b, L) {
              var k = this, U = this._avcTrack, V = this._parseAVCNALu(b.data), Z, H = this.avcSample, ee, re = !1, Q, oe = this.pushAccesUnit.bind(this), se = function(de, pe, W, Ke) {
                return { key: de, pts: pe, dts: W, units: [], debug: Ke };
              };
              b.data = null, H && V.length && !U.audFound && (oe(H, U), H = this.avcSample = se(!1, b.pts, b.dts, "")), V.forEach(function(ce) {
                switch (ce.type) {
                  case 1:
                    ee = !0, H || (H = k.avcSample = se(!0, b.pts, b.dts, "")), H.frame = !0;
                    var de = ce.data;
                    if (re && de.length > 4) {
                      var pe = new Nt(de).readSliceType();
                      (pe === 2 || pe === 4 || pe === 7 || pe === 9) && (H.key = !0);
                    }
                    break;
                  case 5:
                    ee = !0, H || (H = k.avcSample = se(!0, b.pts, b.dts, "")), H.key = !0, H.frame = !0;
                    break;
                  case 6:
                    ee = !0, Z = new Nt(k.discardEPB(ce.data)), Z.readUByte();
                    for (var W = 0, Oe = 0, tt = !1, rt = 0; !tt && Z.bytesAvailable > 1; ) {
                      W = 0;
                      do
                        rt = Z.readUByte(), W += rt;
                      while (rt === 255);
                      Oe = 0;
                      do
                        rt = Z.readUByte(), Oe += rt;
                      while (rt === 255);
                      if (W === 4 && Z.bytesAvailable !== 0) {
                        tt = !0;
                        var Xe = Z.readUByte();
                        if (Xe === 181) {
                          var Ye = Z.readUShort();
                          if (Ye === 49) {
                            var Se = Z.readUInt();
                            if (Se === 1195456820) {
                              var ut = Z.readUByte();
                              if (ut === 3) {
                                var _t = Z.readUByte(), ft = Z.readUByte(), Et = 31 & _t, Dt = [_t, ft];
                                for (Q = 0; Q < Et; Q++)
                                  Dt.push(Z.readUByte()), Dt.push(Z.readUByte()), Dt.push(Z.readUByte());
                                k._insertSampleInOrder(k._txtTrack.samples, { type: 3, pts: b.pts, bytes: Dt });
                              }
                            }
                          }
                        }
                      } else if (Ke < Z.bytesAvailable)
                        for (Q = 0; Q < Ke; Q++)
                          Z.readUByte();
                    }
                    break;
                  case 7:
                    if (ee = !0, re = !0, !U.sps) {
                      Z = new Nt(ce.data);
                      var Jt = Z.readSPS();
                      U.width = Jt.width, U.height = Jt.height, U.pixelRatio = Jt.pixelRatio, U.sps = [ce.data], U.duration = k._duration;
                      var Pt = ce.data.subarray(1, 4), cr = "avc1.";
                      for (Q = 0; Q < 3; Q++) {
                        var jt = Pt[Q].toString(16);
                        jt.length < 2 && (jt = "0" + jt), cr += jt;
                      }
                      U.codec = cr;
                    }
                    break;
                  case 8:
                    ee = !0, U.pps || (U.pps = [ce.data]);
                    break;
                  case 9:
                    ee = !1, U.audFound = !0, H && oe(H, U), H = k.avcSample = se(!1, b.pts, b.dts, "");
                    break;
                  case 12:
                    ee = !1;
                    break;
                  default:
                    ee = !1, H && (H.debug += "unknown NAL " + ce.type + " ");
                    break;
                }
                if (H && ee) {
                  var Qt = H.units;
                  Qt.push(ce);
                }
              }), L && H && (oe(H, U), this.avcSample = null);
            }, _.prototype._insertSampleInOrder = function(b, L) {
              var k = b.length;
              if (k > 0) {
                if (L.pts >= b[k - 1].pts)
                  b.push(L);
                else
                  for (var U = k - 1; U >= 0; U--)
                    if (L.pts < b[U].pts) {
                      b.splice(U, 0, L);
                      break;
                    }
              } else
                b.push(L);
            }, _.prototype._getLastNalUnit = function() {
              var b = this.avcSample, L = void 0;
              if (!b || b.units.length === 0) {
                var k = this._avcTrack, U = k.samples;
                b = U[U.length - 1];
              }
              if (b) {
                var V = b.units;
                L = V[V.length - 1];
              }
              return L;
            }, _.prototype._parseAVCNALu = function(b) {
              var L = 0, k = b.byteLength, U, V, Z = this._avcTrack, H = Z.naluState || 0, ee = H, re = [], Q, oe, se = -1, ce;
              for (H === -1 && (se = 0, ce = b[0] & 31, H = 0, L = 1); L < k; ) {
                if (U = b[L++], !H) {
                  H = U ? 0 : 1;
                  continue;
                }
                if (H === 1) {
                  H = U ? 0 : 2;
                  continue;
                }
                if (!U)
                  H = 3;
                else if (U === 1) {
                  if (se >= 0)
                    Q = { data: b.subarray(se, L - H - 1), type: ce }, re.push(Q);
                  else {
                    var de = this._getLastNalUnit();
                    if (de && (ee && L <= 4 - ee && de.state && (de.data = de.data.subarray(0, de.data.byteLength - ee)), V = L - H - 1, V > 0)) {
                      var pe = new Uint8Array(de.data.byteLength + V);
                      pe.set(de.data, 0), pe.set(b.subarray(0, V), de.data.byteLength), de.data = pe;
                    }
                  }
                  L < k ? (oe = b[L] & 31, se = L, ce = oe, H = 0) : H = -1;
                } else
                  H = 0;
              }
              if (se >= 0 && H >= 0 && (Q = { data: b.subarray(se, k), type: ce, state: H }, re.push(Q)), re.length === 0) {
                var W = this._getLastNalUnit();
                if (W) {
                  var Ke = new Uint8Array(W.data.byteLength + b.byteLength);
                  Ke.set(W.data, 0), Ke.set(b, W.data.byteLength), W.data = Ke;
                }
              }
              return Z.naluState = H, re;
            }, _.prototype.discardEPB = function(b) {
              for (var L = b.byteLength, k = [], U = 1, V, Z; U < L - 2; )
                b[U] === 0 && b[U + 1] === 0 && b[U + 2] === 3 ? (k.push(U + 2), U += 2) : U++;
              if (k.length === 0)
                return b;
              V = L - k.length, Z = new Uint8Array(V);
              var H = 0;
              for (U = 0; U < V; H++, U++)
                H === k[0] && (H++, k.shift()), Z[U] = b[H];
              return Z;
            }, _.prototype._parseAACPES = function(b) {
              var L = this._audioTrack, k = b.data, U = b.pts, V = 0, Z = this.aacOverFlow, H = this.aacLastPTS, ee, re, Q, oe, se;
              if (Z) {
                var ce = new Uint8Array(Z.byteLength + k.byteLength);
                ce.set(Z, 0), ce.set(k, Z.byteLength), k = ce;
              }
              for (Q = V, se = k.length; Q < se - 1 && !B(k, Q); Q++)
                ;
              if (Q) {
                var de, pe;
                if (Q < se - 1 ? (de = "AAC PES did not start with ADTS header,offset:" + Q, pe = !1) : (de = "no ADTS header found in AAC PES", pe = !0), h.b.warn("parsing error:" + de), this.observer.trigger(x.a.ERROR, { type: y.b.MEDIA_ERROR, details: y.a.FRAG_PARSING_ERROR, fatal: pe, reason: de }), pe)
                  return;
              }
              if (O(L, this.observer, k, Q, this.audioCodec), re = 0, ee = j(L.samplerate), Z && H) {
                var W = H + ee;
                Math.abs(W - U) > 1 && (h.b.log("AAC: align PTS for overlapping frames by " + Math.round((W - U) / 90)), U = W);
              }
              for (; Q < se; )
                if (B(k, Q) && Q + 5 < se) {
                  var Ke = z(L, k, Q, U, re);
                  if (Ke)
                    Q += Ke.length, oe = Ke.sample.pts, re++;
                  else
                    break;
                } else
                  Q++;
              Q < se ? Z = k.subarray(Q, se) : Z = null, this.aacOverFlow = Z, this.aacLastPTS = oe;
            }, _.prototype._parseMPEGPES = function(b) {
              for (var L = b.data, k = L.length, U = 0, M = 0, Z = b.pts; M < k; )
                if (He.isHeader(L, M)) {
                  var H = He.appendFrame(this._audioTrack, L, M, Z, U);
                  if (H)
                    V += H.length, U++;
                  else
                    break;
                } else
                  V++;
            }, _.prototype._parseID3PES = function(b) {
              this._id3Track.samples.push(b);
            }, _;
          }(), ht = Qe;
          function Me(_, X) {
            if (!(_ instanceof X))
              throw new TypeError("Cannot call a class as a function");
          }
          var Yt = function() {
            function _(X, b, L) {
              Me(this, _), this.observer = X, this.config = L, this.remuxer = b;
            }
            return _.prototype.resetInitSegment = function(b, L, k, U) {
              this._audioTrack = { container: "audio/mpeg", type: "audio", id: -1, sequenceNumber: 0, isAAC: !1, samples: [], len: 0, manifestCodec: L, duration: U, inputTimeScale: 9e4 };
            }, _.prototype.resetTimeStamp = function() {
            }, _.probe = function(b) {
              var L, k, U = Y.a.getID3Data(b, 0);
              if (U && Y.a.getTimeStamp(U) !== void 0) {
                for (L = U.length, k = Math.min(b.length - 1, L + 100); L < k; L++)
                  if (He.probe(b, L))
                    return m.b.log("MPEG Audio sync word found !"), !0;
              }
              return !1;
            }, _.prototype.append = function(b, L, k, U) {
              for (var M = J.a.getID3Data(b, 0), Z = 90 * J.a.getTimeStamp(M), H = M.length, ee = b.length, re = 0, Q = 0, oe = this._audioTrack, se = [{ pts: Z, dts: Z, data: M }]; H < ee; )
                if (He.isHeader(b, H)) {
                  var ce = He.appendFrame(oe, b, H, Z, re);
                  if (ce)
                    H += ce.length, Q = ce.sample.pts, re++;
                  else
                    break;
                } else J.a.isHeader(b, H) ? (M = J.a.getID3Data(b, H), se.push({ pts: Q, dts: Q, data: M }), H += M.length) : H++;
              this.remuxer.remux(oe, { samples: [] }, { samples: se, inputTimeScale: 9e4 }, { samples: [] }, L, k, U);
            }, _.prototype.destroy = function() {
            }, _;
          }(), et = Yt;
          function fr(_, X) {
            if (!(_ instanceof X))
              throw new TypeError("Cannot call a class as a function");
          }
          var Rt = function() {
            function _() {
              fr(this, _);
            }
            return _.getSilentFrame = function(b, L) {
              switch (b) {
                case "mp4a.40.2":
                  if (L === 1)
                    return new Uint8Array([0, 200, 0, 128, 35, 128]);
                  if (L === 2)
                    return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
                  if (L === 3)
                    return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
                  if (L === 4)
                    return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
                  if (L === 5)
                    return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
                  if (L === 6)
                    return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
                  break;
                default:
                  if (L === 1)
                    return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                  if (L === 2)
                    return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                  if (L === 3)
                    return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                  break;
              }
              return null;
            }, _;
          }(), lt = Rt;
          function It(_, X) {
            if (!(_ instanceof X))
              throw new TypeError("Cannot call a class as a function");
          }
          var Ze = Math.pow(2, 32) - 1, Vt = function() {
            function _() {
              It(this, _);
            }
            return _.init = function() {
              _.types = {
                avc1: [],
                // codingname
                avcC: [],
                btrt: [],
                dinf: [],
                dref: [],
                esds: [],
                ftyp: [],
                hdlr: [],
                mdat: [],
                mdhd: [],
                mdia: [],
                mfhd: [],
                minf: [],
                moof: [],
                moov: [],
                mp4a: [],
                ".mp3": [],
                mvex: [],
                mvhd: [],
                pasp: [],
                sdtp: [],
                stbl: [],
                stco: [],
                stsc: [],
                stsd: [],
                stsz: [],
                stts: [],
                tfdt: [],
                tfhd: [],
                traf: [],
                trak: [],
                trun: [],
                trex: [],
                tkhd: [],
                vmhd: [],
                smhd: []
              };
              var b;
              for (b in _.types)
                _.types.hasOwnProperty(b) && (_.types[b] = [b.charCodeAt(0), b.charCodeAt(1), b.charCodeAt(2), b.charCodeAt(3)]);
              var L = new Uint8Array([
                0,
                // version 0
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                0,
                // pre_defined
                118,
                105,
                100,
                101,
                // handler_type: 'vide'
                0,
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                0,
                // reserved
                86,
                105,
                100,
                101,
                111,
                72,
                97,
                110,
                100,
                108,
                101,
                114,
                0
                // name: 'VideoHandler'
              ]), k = new Uint8Array([
                0,
                // version 0
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                0,
                // pre_defined
                115,
                111,
                117,
                110,
                // handler_type: 'soun'
                0,
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                0,
                // reserved
                83,
                111,
                117,
                110,
                100,
                72,
                97,
                110,
                100,
                108,
                101,
                114,
                0
                // name: 'SoundHandler'
              ]);
              _.HDLR_TYPES = {
                video: L,
                audio: k
              };
              var U = new Uint8Array([
                0,
                // version 0
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                1,
                // entry_count
                0,
                0,
                0,
                12,
                // entry_size
                117,
                114,
                108,
                32,
                // 'url' type
                0,
                // version 0
                0,
                0,
                1
                // entry_flags
              ]), V = new Uint8Array([
                0,
                // version
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                0
                // entry_count
              ]);
              _.STTS = _.STSC = _.STCO = V, _.STSZ = new Uint8Array([
                0,
                // version
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                0,
                // sample_size
                0,
                0,
                0,
                0
              ]), _.VMHD = new Uint8Array([
                0,
                // version
                0,
                0,
                1,
                // flags
                0,
                0,
                // graphicsmode
                0,
                0,
                0,
                0,
                0,
                0
                // opcolor
              ]), _.SMHD = new Uint8Array([
                0,
                // version
                0,
                0,
                0,
                // flags
                0,
                0,
                // balance
                0,
                0
                // reserved
              ]), _.STSD = new Uint8Array([
                0,
                // version 0
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                1
              ]);
              var Z = new Uint8Array([105, 115, 111, 109]), H = new Uint8Array([97, 118, 99, 49]), ee = new Uint8Array([0, 0, 0, 1]);
              _.FTYP = _.box(_.types.ftyp, Z, ee, Z, H), _.DINF = _.box(_.types.dinf, _.box(_.types.dref, U));
            }, _.box = function(b) {
              for (var L = Array.prototype.slice.call(arguments, 1), k = 8, U = L.length, V = U, Z; U--; )
                k += L[U].byteLength;
              for (Z = new Uint8Array(k), Z[0] = k >> 24 & 255, Z[1] = k >> 16 & 255, Z[2] = k >> 8 & 255, Z[3] = k & 255, Z.set(b, 4), U = 0, k = 8; U < V; U++)
                Z.set(L[U], k), k += L[U].byteLength;
              return Z;
            }, _.hdlr = function(b) {
              return _.box(_.types.hdlr, _.HDLR_TYPES[b]);
            }, _.mdat = function(b) {
              return _.box(_.types.mdat, b);
            }, _.mdhd = function(b, L) {
              L *= b;
              var k = Math.floor(L / (Ze + 1)), U = Math.floor(L % (Ze + 1));
              return _.box(_.types.mdhd, new Uint8Array([
                1,
                // version 1
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                2,
                // creation_time
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                3,
                // modification_time
                b >> 24 & 255,
                b >> 16 & 255,
                b >> 8 & 255,
                b & 255,
                // timescale
                k >> 24,
                k >> 16 & 255,
                k >> 8 & 255,
                k & 255,
                U >> 24,
                U >> 16 & 255,
                U >> 8 & 255,
                U & 255,
                85,
                196,
                // 'und' language (undetermined)
                0,
                0
              ]));
            }, _.mdia = function(b) {
              return _.box(_.types.mdia, _.mdhd(b.timescale, b.duration), _.hdlr(b.type), _.minf(b));
            }, _.mfhd = function(b) {
              return _.box(
                _.types.mfhd,
                new Uint8Array([
                  0,
                  0,
                  0,
                  0,
                  // flags
                  b >> 24,
                  b >> 16 & 255,
                  b >> 8 & 255,
                  b & 255
                ])
                // sequence_number
              );
            }, _.minf = function(b) {
              return b.type === "audio" ? _.box(_.types.minf, _.box(_.types.smhd, _.SMHD), _.DINF, _.stbl(b)) : _.box(_.types.minf, _.box(_.types.vmhd, _.VMHD), _.DINF, _.stbl(b));
            }, _.moof = function(b, L, k) {
              return _.box(_.types.moof, _.mfhd(b), _.traf(k, L));
            }, _.moov = function(b) {
              for (var L = b.length, k = []; L--; )
                k[L] = _.trak(b[L]);
              return _.box.apply(null, [_.types.moov, _.mvhd(b[0].timescale, b[0].duration)].concat(k).concat(_.mvex(b)));
            }, _.mvex = function(b) {
              for (var L = b.length, k = []; L--; )
                k[L] = _.trex(b[L]);
              return _.box.apply(null, [_.types.mvex].concat(k));
            }, _.mvhd = function(b, L) {
              L *= b;
              var k = Math.floor(L / (Ze + 1)), U = Math.floor(L % (Ze + 1)), M = new Uint8Array([
                1,
                // version 1
                0,
                0,
                0,
                // flags
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                2,
                // creation_time
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                3,
                // modification_time
                b >> 24 & 255,
                b >> 16 & 255,
                b >> 8 & 255,
                b & 255,
                // timescale
                k >> 24,
                k >> 16 & 255,
                k >> 8 & 255,
                k & 255,
                U >> 24,
                U >> 16 & 255,
                U >> 8 & 255,
                U & 255,
                0,
                1,
                0,
                0,
                // 1.0 rate
                1,
                0,
                // 1.0 volume
                0,
                0,
                // reserved
                0,
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                0,
                // reserved
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                64,
                0,
                0,
                0,
                // transformation: unity matrix
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                // pre_defined
                255,
                255,
                255,
                255
                // next_track_ID
              ]);
              return _.box(_.types.mvhd, V);
            }, _.sdtp = function(b) {
              var L = b.samples || [], k = new Uint8Array(4 + L.length), U, V;
              for (V = 0; V < L.length; V++)
                U = L[V].flags, k[V + 4] = U.dependsOn << 4 | U.isDependedOn << 2 | U.hasRedundancy;
              return _.box(_.types.sdtp, k);
            }, _.stbl = function(b) {
              return _.box(_.types.stbl, _.stsd(b), _.box(_.types.stts, _.STTS), _.box(_.types.stsc, _.STSC), _.box(_.types.stsz, _.STSZ), _.box(_.types.stco, _.STCO));
            }, _.avc1 = function(b) {
              var L = [], k = [], U, V, Z;
              for (U = 0; U < b.sps.length; U++)
                V = b.sps[U], Z = V.byteLength, L.push(Z >>> 8 & 255), L.push(Z & 255), L = L.concat(Array.prototype.slice.call(V));
              for (U = 0; U < b.pps.length; U++)
                V = b.pps[U], Z = V.byteLength, k.push(Z >>> 8 & 255), k.push(Z & 255), k = k.concat(Array.prototype.slice.call(V));
              var H = _.box(_.types.avcC, new Uint8Array([
                1,
                // version
                L[3],
                // profile
                L[4],
                // profile compat
                L[5],
                // level
                255,
                // lengthSizeMinusOne, hard-coded to 4 bytes
                224 | b.sps.length
                // 3bit reserved (111) + numOfSequenceParameterSets
              ].concat(L).concat([
                b.pps.length
                // numOfPictureParameterSets
              ]).concat(k))), ee = b.width, re = b.height, Q = b.pixelRatio[0], oe = b.pixelRatio[1];
              return _.box(
                _.types.avc1,
                new Uint8Array([
                  0,
                  0,
                  0,
                  // reserved
                  0,
                  0,
                  0,
                  // reserved
                  0,
                  1,
                  // data_reference_index
                  0,
                  0,
                  // pre_defined
                  0,
                  0,
                  // reserved
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  // pre_defined
                  ee >> 8 & 255,
                  ee & 255,
                  // width
                  re >> 8 & 255,
                  re & 255,
                  // height
                  0,
                  72,
                  0,
                  0,
                  // horizresolution
                  0,
                  72,
                  0,
                  0,
                  // vertresolution
                  0,
                  0,
                  0,
                  0,
                  // reserved
                  0,
                  1,
                  // frame_count
                  18,
                  100,
                  97,
                  105,
                  108,
                  //dailymotion/hls.js
                  121,
                  109,
                  111,
                  116,
                  105,
                  111,
                  110,
                  47,
                  104,
                  108,
                  115,
                  46,
                  106,
                  115,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  // compressorname
                  0,
                  24,
                  // depth = 24
                  17,
                  17
                ]),
                // pre_defined = -1
                H,
                _.box(_.types.btrt, new Uint8Array([
                  0,
                  28,
                  156,
                  128,
                  // bufferSizeDB
                  0,
                  45,
                  198,
                  192,
                  // maxBitrate
                  0,
                  45,
                  198,
                  192
                ])),
                // avgBitrate
                _.box(_.types.pasp, new Uint8Array([
                  Q >> 24,
                  // hSpacing
                  Q >> 16 & 255,
                  Q >> 8 & 255,
                  Q & 255,
                  oe >> 24,
                  // vSpacing
                  oe >> 16 & 255,
                  oe >> 8 & 255,
                  oe & 255
                ]))
              );
            }, _.esds = function(b) {
              var L = b.config.length;
              return new Uint8Array([
                0,
                // version 0
                0,
                0,
                0,
                // flags
                3,
                // descriptor_type
                23 + L,
                // length
                0,
                1,
                //es_id
                0,
                // stream_priority
                4,
                // descriptor_type
                15 + L,
                // length
                64,
                //codec : mpeg4_audio
                21,
                // stream_type
                0,
                0,
                0,
                // buffer_size
                0,
                0,
                0,
                0,
                // maxBitrate
                0,
                0,
                0,
                0,
                // avgBitrate
                5
                // descriptor_type
              ].concat([L]).concat(b.config).concat([6, 1, 2]));
            }, _.mp4a = function(b) {
              var L = b.samplerate;
              return _.box(_.types.mp4a, new Uint8Array([
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                // reserved
                0,
                1,
                // data_reference_index
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                // reserved
                0,
                b.channelCount,
                // channelcount
                0,
                16,
                // sampleSize:16bits
                0,
                0,
                0,
                0,
                // reserved2
                L >> 8 & 255,
                L & 255,
                //
                0,
                0
              ]), _.box(_.types.esds, _.esds(b)));
            }, _.mp3 = function(b) {
              var L = b.samplerate;
              return _.box(_.types[".mp3"], new Uint8Array([
                0,
                0,
                0,
                // reserved
                0,
                0,
                0,
                // reserved
                0,
                1,
                // data_reference_index
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                // reserved
                0,
                b.channelCount,
                // channelcount
                0,
                16,
                // sampleSize:16bits
                0,
                0,
                0,
                0,
                // reserved2
                L >> 8 & 255,
                L & 255,
                //
                0,
                0
              ]));
            }, _.stsd = function(b) {
              return b.type === "audio" ? !b.isAAC && b.codec === "mp3" ? _.box(_.types.stsd, _.STSD, _.mp3(b)) : _.box(_.types.stsd, _.STSD, _.mp4a(b)) : _.box(_.types.stsd, _.STSD, _.avc1(b));
            }, _.tkhd = function(b) {
              var L = b.id, k = b.duration * b.timescale, U = b.width, M = b.height, Z = Math.floor(k / (Ze + 1)), H = Math.floor(k % (Ze + 1));
              return _.box(_.types.tkhd, new Uint8Array([
                1,
                // version 1
                0,
                0,
                7,
                // flags
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                2,
                // creation_time
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                3,
                // modification_time
                L >> 24 & 255,
                L >> 16 & 255,
                L >> 8 & 255,
                L & 255,
                // track_ID
                0,
                0,
                0,
                0,
                // reserved
                Z >> 24,
                Z >> 16 & 255,
                Z >> 8 & 255,
                Z & 255,
                H >> 24,
                H >> 16 & 255,
                H >> 8 & 255,
                H & 255,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                // reserved
                0,
                0,
                // layer
                0,
                0,
                // alternate_group
                0,
                0,
                // non-audio track volume
                0,
                0,
                // reserved
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                64,
                0,
                0,
                0,
                // transformation: unity matrix
                U >> 8 & 255,
                U & 255,
                0,
                0,
                // width
                V >> 8 & 255,
                V & 255,
                0,
                0
                // height
              ]));
            }, _.traf = function(b, L) {
              var k = _.sdtp(b), U = b.id, M = Math.floor(L / (Ze + 1)), Z = Math.floor(L % (Ze + 1));
              return _.box(
                _.types.traf,
                _.box(
                  _.types.tfhd,
                  new Uint8Array([
                    0,
                    // version 0
                    0,
                    0,
                    0,
                    // flags
                    U >> 24,
                    U >> 16 & 255,
                    U >> 8 & 255,
                    U & 255
                  ])
                  // track_ID
                ),
                _.box(_.types.tfdt, new Uint8Array([
                  1,
                  // version 1
                  0,
                  0,
                  0,
                  // flags
                  V >> 24,
                  V >> 16 & 255,
                  V >> 8 & 255,
                  V & 255,
                  Z >> 24,
                  Z >> 16 & 255,
                  Z >> 8 & 255,
                  Z & 255
                ])),
                _.trun(b, k.length + 16 + // tfhd
                20 + // tfdt
                8 + // traf header
                16 + // mfhd
                8 + // moof header
                8),
                // mdat header
                k
              );
            }, _.trak = function(b) {
              return b.duration = b.duration || 4294967295, _.box(_.types.trak, _.tkhd(b), _.mdia(b));
            }, _.trex = function(b) {
              var L = b.id;
              return _.box(_.types.trex, new Uint8Array([
                0,
                // version 0
                0,
                0,
                0,
                // flags
                L >> 24,
                L >> 16 & 255,
                L >> 8 & 255,
                L & 255,
                // track_ID
                0,
                0,
                0,
                1,
                // default_sample_description_index
                0,
                0,
                0,
                0,
                // default_sample_duration
                0,
                0,
                0,
                0,
                // default_sample_size
                0,
                1,
                0,
                1
                // default_sample_flags
              ]));
            }, _.trun = function(b, L) {
              var k = b.samples || [], U = k.length, V = 12 + 16 * U, Z = new Uint8Array(V), H, ee, re, Q, oe, se;
              for (L += 8 + V, Z.set([
                0,
                // version 0
                0,
                15,
                1,
                // flags
                U >>> 24 & 255,
                U >>> 16 & 255,
                U >>> 8 & 255,
                U & 255,
                // sample_count
                L >>> 24 & 255,
                L >>> 16 & 255,
                L >>> 8 & 255,
                L & 255
                // data_offset
              ], 0), H = 0; H < U; H++)
                ee = k[H], re = ee.duration, Q = ee.size, oe = ee.flags, se = ee.cts, Z.set([
                  re >>> 24 & 255,
                  re >>> 16 & 255,
                  re >>> 8 & 255,
                  re & 255,
                  // sample_duration
                  Q >>> 24 & 255,
                  Q >>> 16 & 255,
                  Q >>> 8 & 255,
                  Q & 255,
                  // sample_size
                  oe.isLeading << 2 | oe.dependsOn,
                  oe.isDependedOn << 6 | oe.hasRedundancy << 4 | oe.paddingValue << 1 | oe.isNonSync,
                  oe.degradPrio & 61440,
                  oe.degradPrio & 15,
                  // sample_flags
                  se >>> 24 & 255,
                  se >>> 16 & 255,
                  se >>> 8 & 255,
                  se & 255
                  // sample_composition_time_offset
                ], 12 + 16 * H);
              return _.box(_.types.trun, Z);
            }, _.initSegment = function(b) {
              _.types || _.init();
              var L = _.moov(b), k;
              return k = new Uint8Array(_.FTYP.byteLength + L.byteLength), k.set(_.FTYP), k.set(L, _.FTYP.byteLength), k;
            }, _;
          }(), qe = Vt;
          function ot(_, X) {
            if (!(_ instanceof X))
              throw new TypeError("Cannot call a class as a function");
          }
          var Ut = 10 * 1e3, At = function() {
            function _(X, b, L, k) {
              ot(this, _), this.observer = X, this.config = b, this.typeSupported = L;
              var U = navigator.userAgent;
              this.isSafari = k && k.indexOf("Apple") > -1 && U && !U.match("CriOS"), this.ISGenerated = !1;
            }
            return _.prototype.destroy = function() {
            }, _.prototype.resetTimeStamp = function(b) {
              this._initPTS = this._initDTS = b;
            }, _.prototype.resetInitSegment = function() {
              this.ISGenerated = !1;
            }, _.prototype.remux = function(b, L, k, U, V, Z, H) {
              if (this.ISGenerated || this.generateIS(b, L, V), this.ISGenerated) {
                var ee = b.samples.length, re = L.samples.length, Q = V, oe = V;
                if (ee && re) {
                  var se = (b.samples[0].dts - L.samples[0].dts) / L.inputTimeScale;
                  Q += Math.max(0, se), oe += Math.max(0, -se);
                }
                if (ee) {
                  b.timescale || (h.b.warn("regenerate InitSegment as audio detected"), this.generateIS(b, L, V));
                  var ce = this.remuxAudio(b, Q, Z, H);
                  if (re) {
                    var de = void 0;
                    ce && (de = ce.endPTS - ce.startPTS), L.timescale || (h.b.warn("regenerate InitSegment as video detected"), this.generateIS(b, L, V)), this.remuxVideo(L, oe, Z, de, H);
                  }
                } else {
                  var pe = void 0;
                  re && (pe = this.remuxVideo(L, oe, Z, H)), pe && b.codec && this.remuxEmptyAudio(b, Q, Z, pe);
                }
              }
              k.samples.length && this.remuxID3(k, V), U.samples.length && this.remuxText(U, V), this.observer.trigger(x.a.FRAG_PARSED);
            }, _.prototype.generateIS = function(b, L, k) {
              var U = this.observer, V = b.samples, Z = L.samples, H = this.typeSupported, ee = "audio/mp4", re = {}, Q = { tracks: re }, oe = this._initPTS === void 0, se, ce;
              if (oe && (se = ce = 1 / 0), b.config && V.length && (b.timescale = b.samplerate, h.b.log("audio sampling rate : " + b.samplerate), b.isAAC || (H.mpeg ? (ee = "audio/mpeg", b.codec = "") : H.mp3 && (b.codec = "mp3")), re.audio = {
                container: ee,
                codec: b.codec,
                initSegment: !b.isAAC && H.mpeg ? new Uint8Array() : qe.initSegment([b]),
                metadata: {
                  channelCount: b.channelCount
                }
              }, oe && (se = ce = V[0].pts - b.inputTimeScale * k)), L.sps && L.pps && Z.length) {
                var de = L.inputTimeScale;
                L.timescale = de, re.video = {
                  container: "video/mp4",
                  codec: L.codec,
                  initSegment: qe.initSegment([L]),
                  metadata: {
                    width: L.width,
                    height: L.height
                  }
                }, oe && (se = Math.min(se, Z[0].pts - de * k), ce = Math.min(ce, Z[0].dts - de * k), this.observer.trigger(x.a.INIT_PTS_FOUND, { initPTS: se }));
              }
              Object.keys(re).length ? (U.trigger(x.a.FRAG_PARSING_INIT_SEGMENT, Q), this.ISGenerated = !0, oe && (this._initPTS = se, this._initDTS = ce)) : U.trigger(x.a.ERROR, { type: y.b.MEDIA_ERROR, details: y.a.FRAG_PARSING_ERROR, fatal: !1, reason: "no audio/video samples found" });
            }, _.prototype.remuxVideo = function(b, L, k, U, M) {
              var Z = 8, H = b.timescale, ee, re, Q, oe, se, ce, de, pe = b.samples, W = [], Oe = pe.length, tt = this._PTSNormalize, rt = this._initDTS, Xe = this.nextAvcDts, Ye = this.isSafari;
              Ye && (k |= pe.length && Xe && (M && Math.abs(L - Xe / H) < 0.1 || Math.abs(pe[0].pts - Xe - rt) < H / 5)), k || (Xe = L * H), pe.forEach(function(N) {
                N.pts = tt(N.pts - rt, Xe), N.dts = tt(N.dts - rt, Xe);
              }), pe.sort(function(N, f) {
                var R = N.dts - f.dts, C = N.pts - f.pts;
                return R || C || N.id - f.id;
              });
              var Le = pe.reduce(function(N, f) {
                return Math.max(Math.min(N, f.pts - f.dts), -18e3);
              }, 0);
              if (Se < 0) {
                m.b.warn("PTS < DTS detected in video samples, shifting DTS by " + Math.round(Se / 90) + " ms to overcome this issue");
                for (var ut = 0; ut < pe.length; ut++)
                  pe[ut].dts += Se;
              }
              var _t = pe[0];
              se = Math.max(_t.dts, 0), oe = Math.max(_t.pts, 0);
              var ft = Math.round((se - Xe) / 90);
              k && ft && (ft > 1 ? m.b.log("AVC:" + ft + " ms hole between fragments detected,filling it") : ft < -1 && m.b.log("AVC:" + -ft + " ms overlapping between fragments detected"), se = Xe, pe[0].dts = se, oe = Math.max(oe - ft, Xe), pe[0].pts = oe, m.b.log("Video/PTS/DTS adjusted: " + Math.round(oe / 90) + "/" + Math.round(se / 90) + ",delta:" + ft + " ms")), _t = pe[pe.length - 1], de = Math.max(_t.dts, 0), ce = Math.max(_t.pts, 0, de), Ye && (ee = Math.round((de - se) / (pe.length - 1)));
              for (var Et = 0, Dt = 0, Jt = 0; Jt < Oe; Jt++) {
                for (var Pt = pe[Jt], cr = Pt.units, jt = cr.length, Qt = 0, kr = 0; kr < jt; kr++)
                  Qt += cr[kr].data.length;
                Dt += Qt, Et += jt, Pt.length = Qt, Ye ? Pt.dts = se + Jt * ee : Pt.dts = Math.max(Pt.dts, se), Pt.pts = Math.max(Pt.pts, Pt.dts);
              }
              var zr = Dt + 4 * Et + 8;
              try {
                re = new Uint8Array(zr);
              } catch {
                this.observer.trigger(x.a.ERROR, { type: y.b.MUX_ERROR, details: y.a.REMUX_ALLOC_ERROR, fatal: !1, bytes: zr, reason: "fail allocating video mdat " + zr });
                return;
              }
              var di = new DataView(re.buffer);
              di.setUint32(0, zr), re.set(qe.types.mdat, 4);
              for (var Ft = 0; Ft < Ke; Ft++) {
                for (var Tt = pe[Ft], Rr = Tt.units, Vr = 0, Pr = void 0, pi = 0, Vi = Rr.length; pi < Vi; pi++) {
                  var hi = Rr[pi], mi = hi.data, Br = hi.data.byteLength;
                  di.setUint32(Z, Br), Z += 4, re.set(mi, Z), Z += Br, Vr += 4 + Br;
                }
                if (Ye)
                  Pr = Math.max(0, ee * Math.round((Tt.pts - Tt.dts) / ee));
                else {
                  if (Ft < Ke - 1)
                    ee = pe[Ft + 1].dts - Tt.dts;
                  else {
                    var Hr = this.config, Ir = Tt.dts - pe[Ft > 0 ? Ft - 1 : Ft].dts;
                    if (Hr.stretchShortVideoTrack) {
                      var Mi = Hr.maxBufferHole, Ur = Hr.maxSeekHole, tn = Math.floor(Math.min(Mi, Ur) * H), rn = (U ? oe + U * H : this.nextAudioPts) - Tt.pts;
                      rn > tn ? (ee = rn - Ir, ee < 0 && (ee = Ir), h.b.log("It is approximately " + rn / 90 + " ms to the next segment; using duration " + ee / 90 + " ms for the last video frame.")) : ee = Ir;
                    } else
                      ee = Ir;
                  }
                  Pr = Math.round(Tt.pts - Tt.dts);
                }
                W.push({
                  size: Vr,
                  // constant duration
                  duration: ee,
                  cts: Pr,
                  flags: {
                    isLeading: 0,
                    isDependedOn: 0,
                    hasRedundancy: 0,
                    degradPrio: 0,
                    dependsOn: Tt.key ? 2 : 1,
                    isNonSync: Tt.key ? 0 : 1
                  }
                });
              }
              this.nextAvcDts = de + ee;
              var na = b.dropped;
              if (b.len = 0, b.nbNalu = 0, b.dropped = 0, W.length && navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
                var Ln = W[0].flags;
                Ln.dependsOn = 2, Ln.isNonSync = 0;
              }
              b.samples = W, Q = qe.moof(b.sequenceNumber++, se, b), b.samples = [];
              var Cn = {
                data1: Q,
                data2: re,
                startPTS: oe / H,
                endPTS: (ce + ee) / H,
                startDTS: se / H,
                endDTS: this.nextAvcDts / H,
                type: "video",
                nb: W.length,
                dropped: na
              };
              return this.observer.trigger(x.a.FRAG_PARSING_DATA, Cn), Cn;
            }, _.prototype.remuxAudio = function(b, L, k, U) {
              var M = b.inputTimeScale, Z = b.timescale, H = M / Z, ee = b.isAAC ? 1024 : 1152, re = ee * H, Q = this._PTSNormalize, oe = this._initDTS, se = !b.isAAC && this.typeSupported.mpeg, ce, de, pe, W, Oe, tt, rt, Xe = b.samples, Ye = [], Se = this.nextAudioPts;
              if (k |= Xe.length && Se && (U && Math.abs(L - Se / M) < 0.1 || Math.abs(Xe[0].pts - Se - oe) < 20 * re), k || (Se = L * M), Xe.forEach(function(Ur) {
                Ur.pts = Ur.dts = Q(Ur.pts - oe, Se);
              }), Xe.sort(function(Ur, tn) {
                return Ur.pts - tn.pts;
              }), U && b.isAAC)
                for (var ut = this.config.maxAudioFramesDrift, _t = 0, ft = Se; _t < Xe.length; ) {
                  var Et = Xe[_t], Dt, Jt = Et.pts;
                  Dt = Jt - ft;
                  var Pt = Math.abs(1e3 * Dt / M);
                  if (Dt <= -ut * re)
                    m.b.warn("Dropping 1 audio frame @ " + (ft / M).toFixed(3) + "s due to " + Math.round(Pt) + " ms overlap."), Xe.splice(_t, 1), b.len -= Et.unit.length;
                  else if (Dt >= ut * re && Pt < Ut && ft) {
                    var cr = Math.round(Dt / re);
                    m.b.warn("Injecting " + cr + " audio frame @ " + (ft / M).toFixed(3) + "s due to " + Math.round(1e3 * Dt / M) + " ms gap.");
                    for (var jt = 0; jt < cr; jt++) {
                      var Qt = Math.max(ft, 0);
                      pe = lt.getSilentFrame(b.manifestCodec || b.codec, b.channelCount), pe || (m.b.log("Unable to get silent frame for given audio codec; duplicating last frame instead."), pe = Et.unit.subarray()), Xe.splice(_t, 0, { unit: pe, pts: Qt, dts: Qt }), b.len += pe.length, ft += re, _t++;
                    }
                    Et.pts = Et.dts = ft, ft += re, _t++;
                  } else
                    Et.pts = Et.dts = ft, ft += re, _t++;
                }
              for (var kr = 0, zr = Xe.length; kr < zr; kr++) {
                var di = Xe[kr], Ft = di.unit, Tt = di.pts;
                if (rt !== void 0)
                  de.duration = Math.round((Tt - rt) / H);
                else {
                  var Rr = Math.round(1e3 * (Tt - Le) / V), Vr = 0;
                  if (k && b.isAAC && Rr) {
                    if (Rr > 0 && Rr < Ut)
                      Vr = Math.round((Tt - Se) / re), m.b.log(Rr + " ms hole between AAC samples detected,filling it"), Vr > 0 && (pe = lt.getSilentFrame(b.manifestCodec || b.codec, b.channelCount), pe || (pe = Ft.subarray()), b.len += Vr * pe.length);
                    else if (Rr < -12) {
                      h.b.log("drop overlapping AAC sample, expected/parsed/delta:" + (Le / V).toFixed(3) + "s/" + (Tt / V).toFixed(3) + "s/" + -Rr + "ms"), b.len -= Ft.byteLength;
                      continue;
                    }
                    Tt = Le;
                  }
                  if (tt = Math.max(0, Tt), b.len > 0) {
                    var Pr = se ? b.len : b.len + 8;
                    ce = se ? 0 : 8;
                    try {
                      W = new Uint8Array(Pr);
                    } catch {
                      this.observer.trigger(x.a.ERROR, { type: y.b.MUX_ERROR, details: y.a.REMUX_ALLOC_ERROR, fatal: !1, bytes: Pr, reason: "fail allocating audio mdat " + Pr });
                      return;
                    }
                    if (!se) {
                      var pi = new DataView(W.buffer);
                      pi.setUint32(0, Pr), W.set(qe.types.mdat, 4);
                    }
                  } else
                    return;
                  for (var Vi = 0; Vi < Vr; Vi++)
                    pe = lt.getSilentFrame(b.manifestCodec || b.codec, b.channelCount), pe || (m.b.log("Unable to get silent frame for given audio codec; duplicating this frame instead."), pe = Ft.subarray()), W.set(pe, ce), ce += pe.byteLength, de = {
                      size: pe.byteLength,
                      cts: 0,
                      duration: 1024,
                      flags: {
                        isLeading: 0,
                        isDependedOn: 0,
                        hasRedundancy: 0,
                        degradPrio: 0,
                        dependsOn: 1
                      }
                    }, Ye.push(de);
                }
                W.set(Ft, ce);
                var hi = Ft.byteLength;
                ce += hi, de = {
                  size: hi,
                  cts: 0,
                  duration: 0,
                  flags: {
                    isLeading: 0,
                    isDependedOn: 0,
                    hasRedundancy: 0,
                    degradPrio: 0,
                    dependsOn: 1
                  }
                }, Ye.push(de), rt = Tt;
              }
              var mi = 0, Br = Ye.length;
              if (Br >= 2 && (mi = Ye[Br - 2].duration, de.duration = mi), Br) {
                this.nextAudioPts = Se = rt + H * mi, b.len = 0, b.samples = Ye, se ? Oe = new Uint8Array() : Oe = qe.moof(b.sequenceNumber++, tt / H, b), b.samples = [];
                var zr = tt / M, Ir = Se / M, Mi = {
                  data1: Oe,
                  data2: W,
                  startPTS: Hr,
                  endPTS: Ir,
                  startDTS: Hr,
                  endDTS: Ir,
                  type: "audio",
                  nb: Br
                };
                return this.observer.trigger(x.a.FRAG_PARSING_DATA, Mi), Mi;
              }
              return null;
            }, _.prototype.remuxEmptyAudio = function(b, L, k, U) {
              var M = b.inputTimeScale, Z = b.samplerate ? b.samplerate : M, H = M / Z, ee = this.nextAudioPts, re = (ee !== void 0 ? ee : U.startDTS * M) + this._initDTS, Q = U.endDTS * M + this._initDTS, oe = 1024, se = H * oe, ce = Math.ceil((Q - re) / se), de = lt.getSilentFrame(b.manifestCodec || b.codec, b.channelCount);
              if (m.b.warn("remux empty Audio"), !de) {
                m.b.trace("Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!");
                return;
              }
              for (var pe = [], W = 0; W < ce; W++) {
                var Ke = re + W * se;
                pe.push({ unit: de, pts: Ke, dts: Ke }), b.len += de.length;
              }
              b.samples = pe, this.remuxAudio(b, L, k);
            }, _.prototype.remuxID3 = function(b, L) {
              var k = b.samples.length, U, V = b.inputTimeScale, Z = this._initPTS, H = this._initDTS;
              if (k) {
                for (var ee = 0; ee < k; ee++)
                  U = b.samples[ee], U.pts = (U.pts - Z) / V, U.dts = (U.dts - H) / V;
                this.observer.trigger(x.a.FRAG_PARSING_METADATA, {
                  samples: b.samples
                });
              }
              b.samples = [];
            }, _.prototype.remuxText = function(b, L) {
              b.samples.sort(function(ee, re) {
                return ee.pts - re.pts;
              });
              var k = b.samples.length, U, V = b.inputTimeScale, Z = this._initPTS;
              if (k) {
                for (var H = 0; H < k; H++)
                  U = b.samples[H], U.pts = (U.pts - Z) / V;
                this.observer.trigger(x.a.FRAG_PARSING_USERDATA, {
                  samples: b.samples
                });
              }
              b.samples = [];
            }, _.prototype._PTSNormalize = function(b, L) {
              var k;
              if (L === void 0)
                return b;
              for (L < b ? k = -8589934592 : k = 8589934592; Math.abs(b - L) > 4294967296; )
                b += k;
              return b;
            }, _;
          }(), mr = At;
          function Mt(_, X) {
            if (!(_ instanceof X))
              throw new TypeError("Cannot call a class as a function");
          }
          var yr = function() {
            function _(X) {
              Mt(this, _), this.observer = X;
            }
            return _.prototype.destroy = function() {
            }, _.prototype.resetTimeStamp = function() {
            }, _.prototype.resetInitSegment = function() {
            }, _.prototype.remux = function(b, L, k, U, V, Z, H, ee) {
              var re = this.observer, Q = "";
              b && (Q += "audio"), L && (Q += "video"), re.trigger(x.a.FRAG_PARSING_DATA, {
                data1: ee,
                startPTS: V,
                startDTS: V,
                type: Q,
                nb: 1,
                dropped: 0
              }), re.trigger(x.a.FRAG_PARSED);
            }, _;
          }(), Nr = yr;
          function Ni(_, X) {
            if (!(_ instanceof X))
              throw new TypeError("Cannot call a class as a function");
          }
          var vr = function() {
            function _(X, b, L, k) {
              Ni(this, _), this.observer = X, this.typeSupported = b, this.config = L, this.vendor = k;
            }
            return _.prototype.destroy = function() {
              var b = this.demuxer;
              b && b.destroy();
            }, _.prototype.push = function(b, L, k, U, V, Z, H, ee, re, Q, oe, se) {
              if (b.byteLength > 0 && L != null && L.key != null && L.method === "AES-128") {
                var ce = this.decrypter;
                ce == null && (ce = this.decrypter = new p.a(this.observer, this.config));
                var de = this, pe;
                try {
                  pe = performance.now();
                } catch {
                  pe = Date.now();
                }
                ce.decrypt(b, L.key.buffer, L.iv.buffer, function(W) {
                  var Ke;
                  try {
                    Ke = performance.now();
                  } catch {
                    Ke = Date.now();
                  }
                  de.observer.trigger(x.a.FRAG_DECRYPTED, { stats: { tstart: pe, tdecrypt: Ke } }), de.pushDecrypted(new Uint8Array(W), L, new Uint8Array(k), U, V, Z, H, ee, re, Q, oe, se);
                });
              } else
                this.pushDecrypted(new Uint8Array(b), L, new Uint8Array(k), U, V, Z, H, ee, re, Q, oe, se);
            }, _.prototype.pushDecrypted = function(b, L, k, U, V, Z, H, ee, re, Q, oe, se) {
              var ce = this.demuxer;
              if (!ce || // in case of continuity change, we might switch from content type (AAC container to TS container for example)
              // so let's check that current demuxer is still valid
              H && !this.probe(b)) {
                for (var de = this.observer, pe = this.typeSupported, W = this.config, Oe = [{ demux: ht, remux: mr }, { demux: ve, remux: mr }, { demux: et, remux: mr }, { demux: Ve, remux: Nr }], tt = 0, rt = Oe.length; tt < rt; tt++) {
                  var Xe = Oe[tt], Ye = Xe.demux.probe;
                  if (Ye(b)) {
                    var Se = this.remuxer = new Xe.remux(de, W, pe, this.vendor);
                    ce = new Xe.demux(de, Se, W, pe), this.probe = Ye;
                    break;
                  }
                }
                if (!ce) {
                  de.trigger(x.a.ERROR, { type: y.b.MEDIA_ERROR, details: y.a.FRAG_PARSING_ERROR, fatal: !0, reason: "no demux matching with content found" });
                  return;
                }
                this.demuxer = ce;
              }
              var ut = this.remuxer;
              (H || ee) && (ce.resetInitSegment(k, U, M, Q), ut.resetInitSegment()), H && (ce.resetTimeStamp(se), ut.resetTimeStamp(se)), typeof ce.setDecryptData == "function" && ce.setDecryptData(L), ce.append(b, Z, re, oe);
            }, _;
          }();
          a.a = vr;
        },
        /* 8 */
        /***/
        function(r, a, u) {
          Object.defineProperty(a, "__esModule", { value: !0 });
          var x = {};
          u.d(x, "newCue", function() {
            return zp;
          });
          var y = u(6), p = /* @__PURE__ */ u.n(y), h = u(1), m = u(2), d = u(0), T = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(E) {
            return typeof E;
          } : function(E) {
            return E && typeof Symbol == "function" && E.constructor === Symbol && E !== Symbol.prototype ? "symbol" : typeof E;
          };
          function S(E, s) {
            if (!(E instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          var B = function() {
            function E(s) {
              S(this, E), this.hls = s, this.onEvent = this.onEvent.bind(this);
              for (var o = arguments.length, n = Array(o > 1 ? o - 1 : 0), l = 1; l < o; l++)
                n[l - 1] = arguments[l];
              this.handledEvents = n, this.useGenericHandler = !0, this.registerListeners();
            }
            return E.prototype.destroy = function() {
              this.unregisterListeners();
            }, E.prototype.isEventHandler = function() {
              return T(this.handledEvents) === "object" && this.handledEvents.length && typeof this.onEvent == "function";
            }, E.prototype.registerListeners = function() {
              this.isEventHandler() && this.handledEvents.forEach(function(o) {
                if (o === "hlsEventGeneric")
                  throw new Error("Forbidden event name: " + o);
                this.hls.on(o, this.onEvent);
              }, this);
            }, E.prototype.unregisterListeners = function() {
              this.isEventHandler() && this.handledEvents.forEach(function(o) {
                this.hls.off(o, this.onEvent);
              }, this);
            }, E.prototype.onEvent = function(o, n) {
              this.onEventGeneric(o, n);
            }, E.prototype.onEventGeneric = function(o, n) {
              var l = function(g, w) {
                var A = "on" + g.replace("hls", "");
                if (typeof this[A] != "function")
                  throw new Error("Event " + g + " has no generic handler in this " + this.constructor.name + " class (tried " + A + ")");
                return this[A].bind(this, w);
              };
              try {
                l.call(this, o, n).call();
              } catch (c) {
                d.b.error("internal error happened while processing " + o + ":" + c.message), this.hls.trigger(h.a.ERROR, { type: m.b.OTHER_ERROR, details: m.a.INTERNAL_EXCEPTION, fatal: !1, event: o, err: c });
              }
            }, E;
          }(), I = B;
          function O(E, s) {
            if (!(E instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          var j = /^(\d+)x(\d+)$/, $ = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g, z = function() {
            function E(s) {
              O(this, E), typeof s == "string" && (s = E.parseAttrList(s));
              for (var o in s)
                s.hasOwnProperty(o) && (this[o] = s[o]);
            }
            return E.prototype.decimalInteger = function(o) {
              var n = parseInt(this[o], 10);
              return n > Number.MAX_SAFE_INTEGER ? 1 / 0 : n;
            }, E.prototype.hexadecimalInteger = function(o) {
              if (this[o]) {
                var n = (this[o] || "0x").slice(2);
                n = (n.length & 1 ? "0" : "") + n;
                for (var l = new Uint8Array(n.length / 2), c = 0; c < n.length / 2; c++)
                  l[c] = parseInt(n.slice(c * 2, c * 2 + 2), 16);
                return l;
              } else
                return null;
            }, E.prototype.hexadecimalIntegerAsNumber = function(o) {
              var n = parseInt(this[o], 16);
              return n > Number.MAX_SAFE_INTEGER ? 1 / 0 : n;
            }, E.prototype.decimalFloatingPoint = function(o) {
              return parseFloat(this[o]);
            }, E.prototype.enumeratedString = function(o) {
              return this[o];
            }, E.prototype.decimalResolution = function(o) {
              var n = j.exec(this[o]);
              if (n !== null)
                return {
                  width: parseInt(n[1], 10),
                  height: parseInt(n[2], 10)
                };
            }, E.parseAttrList = function(o) {
              var n, l = {};
              for ($.lastIndex = 0; (n = $.exec(o)) !== null; ) {
                var c = n[2], g = '"';
                c.indexOf(g) === 0 && c.lastIndexOf(g) === c.length - 1 && (c = c.slice(1, -1)), l[n[1]] = c;
              }
              return l;
            }, E;
          }(), Y = z, ie = {
            audio: {
              a3ds: !0,
              "ac-3": !0,
              "ac-4": !0,
              alac: !0,
              alaw: !0,
              dra1: !0,
              "dts+": !0,
              "dts-": !0,
              dtsc: !0,
              dtse: !0,
              dtsh: !0,
              "ec-3": !0,
              enca: !0,
              g719: !0,
              g726: !0,
              m4ae: !0,
              mha1: !0,
              mha2: !0,
              mhm1: !0,
              mhm2: !0,
              mlpa: !0,
              mp4a: !0,
              "raw ": !0,
              Opus: !0,
              samr: !0,
              sawb: !0,
              sawp: !0,
              sevc: !0,
              sqcp: !0,
              ssmv: !0,
              twos: !0,
              ulaw: !0
            },
            video: {
              avc1: !0,
              avc2: !0,
              avc3: !0,
              avc4: !0,
              avcp: !0,
              drac: !0,
              dvav: !0,
              dvhe: !0,
              encv: !0,
              hev1: !0,
              hvc1: !0,
              mjp2: !0,
              mp4v: !0,
              mvc1: !0,
              mvc2: !0,
              mvc3: !0,
              mvc4: !0,
              resv: !0,
              rv60: !0,
              s263: !0,
              svc1: !0,
              svc2: !0,
              "vc-1": !0,
              vp08: !0,
              vp09: !0
            }
          };
          function ye(E, s) {
            var o = ie[s];
            return !!o && o[E.slice(0, 4)] === !0;
          }
          function ve(E) {
            return MediaSource.isTypeSupported('video/mp4;codecs="' + E + '"');
          }
          var Ae = /* @__PURE__ */ function() {
            function E(s, o) {
              for (var n = 0; n < o.length; n++) {
                var l = o[n];
                l.enumerable = l.enumerable || !1, l.configurable = !0, "value" in l && (l.writable = !0), Object.defineProperty(s, l.key, l);
              }
            }
            return function(s, o, n) {
              return o && E(s.prototype, o), n && E(s, n), s;
            };
          }();
          function Ee(E, s) {
            if (!E)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : E;
          }
          function Ce(E, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            E.prototype = Object.create(s && s.prototype, { constructor: { value: E, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(E, s) : E.__proto__ = s);
          }
          function Ve(E, s) {
            if (!(E instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          var Ue = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g, He = /#EXT-X-MEDIA:(.*)/g, dt = new RegExp([
            /#EXTINF:(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
            // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
            /|(?!#)(\S+)/.source,
            // segment URI, group 3 => the URI (note newline is not eaten)
            /|#EXT-X-BYTERANGE:*(.+)/.source,
            // next segment's byterange, group 4 => range spec (x@y)
            /|#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,
            // next segment's program date/time group 5 => the datetime spec
            /|#.*/.source
            // All other non-segment oriented tags will match with all groups empty
          ].join(""), "g"), Je = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)(.*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/, Nt = function() {
            function E() {
              Ve(this, E), this.method = null, this.key = null, this.iv = null, this._uri = null;
            }
            return Ae(E, [{
              key: "uri",
              get: function() {
                return !this._uri && this.reluri && (this._uri = p.a.buildAbsoluteURL(this.baseuri, this.reluri, { alwaysNormalize: !0 })), this._uri;
              }
            }]), E;
          }(), $e = function() {
            function E() {
              Ve(this, E), this._url = null, this._byteRange = null, this._decryptdata = null, this.tagList = [];
            }
            return E.prototype.createInitializationVector = function(o) {
              for (var n = new Uint8Array(16), l = 12; l < 16; l++)
                n[l] = o >> 8 * (15 - l) & 255;
              return n;
            }, E.prototype.fragmentDecryptdataFromLevelkey = function(o, n) {
              var l = o;
              return o && o.method && o.uri && !o.iv && (l = new Nt(), l.method = o.method, l.baseuri = o.baseuri, l.reluri = o.reluri, l.iv = this.createInitializationVector(n)), l;
            }, E.prototype.cloneObj = function(o) {
              return JSON.parse(JSON.stringify(o));
            }, Ae(E, [{
              key: "url",
              get: function() {
                return !this._url && this.relurl && (this._url = p.a.buildAbsoluteURL(this.baseurl, this.relurl, { alwaysNormalize: !0 })), this._url;
              },
              set: function(o) {
                this._url = o;
              }
            }, {
              key: "programDateTime",
              get: function() {
                return !this._programDateTime && this.rawProgramDateTime && (this._programDateTime = new Date(Date.parse(this.rawProgramDateTime))), this._programDateTime;
              }
            }, {
              key: "byteRange",
              get: function() {
                if (!this._byteRange) {
                  var o = this._byteRange = [];
                  if (this.rawByteRange) {
                    var n = this.rawByteRange.split("@", 2);
                    if (n.length === 1) {
                      var l = this.lastByteRangeEndOffset;
                      o[0] = l || 0;
                    } else
                      o[0] = parseInt(n[1]);
                    o[1] = parseInt(n[0]) + o[0];
                  }
                }
                return this._byteRange;
              }
            }, {
              key: "byteRangeStartOffset",
              get: function() {
                return this.byteRange[0];
              }
            }, {
              key: "byteRangeEndOffset",
              get: function() {
                return this.byteRange[1];
              }
            }, {
              key: "decryptdata",
              get: function() {
                return this._decryptdata || (this._decryptdata = this.fragmentDecryptdataFromLevelkey(this.levelkey, this.sn)), this._decryptdata;
              }
            }]), E;
          }(), vt = function(E) {
            Ce(s, E);
            function s(o) {
              Ve(this, s);
              var n = Ee(this, E.call(this, o, m.a.MANIFEST_LOADING, m.a.LEVEL_LOADING, m.a.AUDIO_TRACK_LOADING, m.a.SUBTITLE_TRACK_LOADING));
              return n.loaders = {}, n;
            }
            return s.prototype.destroy = function() {
              for (var n in this.loaders) {
                var l = this.loaders[n];
                l && l.destroy();
              }
              this.loaders = {}, I.prototype.destroy.call(this);
            }, s.prototype.onManifestLoading = function(n) {
              this.load(n.url, { type: "manifest" });
            }, s.prototype.onLevelLoading = function(n) {
              this.load(n.url, { type: "level", level: n.level, id: n.id });
            }, s.prototype.onAudioTrackLoading = function(n) {
              this.load(n.url, { type: "audioTrack", id: n.id });
            }, s.prototype.onSubtitleTrackLoading = function(n) {
              this.load(n.url, { type: "subtitleTrack", id: n.id });
            }, s.prototype.load = function(n, l) {
              var c = this.loaders[l.type];
              if (c) {
                var g = c.context;
                if (g && g.url === n) {
                  d.b.trace("playlist request ongoing");
                  return;
                } else
                  d.b.warn("abort previous loader for type:" + l.type), c.abort();
              }
              var w = this.hls.config, A = void 0, D = void 0, K = void 0, j = void 0;
              l.type === "manifest" ? (A = w.manifestLoadingMaxRetry, D = w.manifestLoadingTimeOut, K = w.manifestLoadingRetryDelay, j = w.manifestLoadingMaxRetryTimeout) : (A = w.levelLoadingMaxRetry, D = w.levelLoadingTimeOut, K = w.levelLoadingRetryDelay, j = w.levelLoadingMaxRetryTimeout, d.b.log("loading playlist for " + l.type + " " + (l.level || l.id))), c = this.loaders[l.type] = l.loader = typeof w.pLoader < "u" ? new w.pLoader(w) : new w.loader(w), l.url = n, l.responseType = "";
              var q = void 0, Y = void 0;
              q = { timeout: D, maxRetry: A, retryDelay: K, maxRetryDelay: j }, Y = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) }, c.load(l, q, Y);
            }, s.prototype.resolve = function(n, l) {
              return p.a.buildAbsoluteURL(l, n, { alwaysNormalize: !0 });
            }, s.prototype.parseMasterPlaylist = function(n, l) {
              var c = [], g = void 0;
              Ue.lastIndex = 0;
              function w(j, q) {
                ["video", "audio"].forEach(function(Y) {
                  var ue = j.filter(function(Re) {
                    return ye(Re, Y);
                  });
                  if (ue.length) {
                    var me = ue.filter(function(Re) {
                      return Re.lastIndexOf("avc1", 0) === 0 || Re.lastIndexOf("mp4a", 0) === 0;
                    });
                    q[Y + "Codec"] = me.length > 0 ? me[0] : ue[0], j = j.filter(function(Re) {
                      return ue.indexOf(Re) === -1;
                    });
                  }
                }), q.unknownCodecs = M;
              }
              for (; (g = Ue.exec(n)) != null; ) {
                var A = {}, D = A.attrs = new J(g[1]);
                A.url = this.resolve(g[2], l);
                var K = D.decimalResolution("RESOLUTION");
                K && (A.width = K.width, A.height = K.height), A.bitrate = D.decimalInteger("AVERAGE-BANDWIDTH") || D.decimalInteger("BANDWIDTH"), A.name = D.NAME, w([].concat((D.CODECS || "").split(/[ ,]+/)), A), A.videoCodec && A.videoCodec.indexOf("avc1") !== -1 && (A.videoCodec = this.avc1toavcoti(A.videoCodec)), c.push(A);
              }
              return c;
            }, s.prototype.parseMasterPlaylistMedia = function(n, l, c) {
              var g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, w = void 0, A = [], D = 0;
              for (He.lastIndex = 0; (w = He.exec(n)) != null; ) {
                var K = {}, j = new J(w[1]);
                j.TYPE === c && (K.groupId = j["GROUP-ID"], K.name = j.NAME, K.type = c, K.default = j.DEFAULT === "YES", K.autoselect = j.AUTOSELECT === "YES", K.forced = j.FORCED === "YES", j.URI && (K.url = this.resolve(j.URI, l)), K.lang = j.LANGUAGE, K.name || (K.name = K.lang), g && (K.audioCodec = g), K.id = D++, A.push(K));
              }
              return A;
            }, s.prototype.avc1toavcoti = function(n) {
              var l, c = n.split(".");
              return c.length > 2 ? (l = c.shift() + ".", l += parseInt(c.shift()).toString(16), l += ("000" + parseInt(c.shift()).toString(16)).substr(-4)) : l = n, l;
            }, s.prototype.parseLevelPlaylist = function(n, l, c, g) {
              var w = 0, A = 0, D = { type: null, version: null, url: l, fragments: [], live: !0, startSN: 0 }, K = new Nt(), j = 0, q = null, Y = new $e(), ue, me;
              for (dt.lastIndex = 0; (ue = dt.exec(n)) !== null; ) {
                var Re = ue[1];
                if (Re) {
                  Y.duration = parseFloat(Re);
                  var be = (" " + ue[2]).slice(1);
                  Y.title = be || null, Y.tagList.push(be ? ["INF", Re, be] : ["INF", Re]);
                } else if (ue[3]) {
                  if (!isNaN(Y.duration)) {
                    var Pe = w++;
                    Y.type = g, Y.start = A, Y.levelkey = K, Y.sn = Pe, Y.level = c, Y.cc = j, Y.baseurl = l, Y.relurl = (" " + ue[3]).slice(1), D.fragments.push(Y), q = Y, A += Y.duration, Y = new $e();
                  }
                } else if (ue[4]) {
                  if (Y.rawByteRange = (" " + ue[4]).slice(1), q) {
                    var ke = q.byteRangeEndOffset;
                    ke && (Y.lastByteRangeEndOffset = ke);
                  }
                } else if (ue[5])
                  J.rawProgramDateTime = (" " + ue[5]).slice(1), J.tagList.push(["PROGRAM-DATE-TIME", J.rawProgramDateTime]), D.programDateTime === void 0 && (D.programDateTime = new Date(new Date(Date.parse(ue[5])) - 1e3 * A));
                else {
                  for (ue = ue[0].match(Je), me = 1; me < ue.length && ue[me] === void 0; me++)
                    ;
                  var Ke = (" " + ue[me + 1]).slice(1), mt = (" " + ue[me + 2]).slice(1);
                  switch (ue[me]) {
                    case "#":
                      J.tagList.push(mt ? [Ne, mt] : [Ne]);
                      break;
                    case "PLAYLIST-TYPE":
                      D.type = Ne.toUpperCase();
                      break;
                    case "MEDIA-SEQUENCE":
                      w = D.startSN = parseInt(Ke);
                      break;
                    case "TARGETDURATION":
                      D.targetduration = parseFloat(Ne);
                      break;
                    case "VERSION":
                      D.version = parseInt(Ne);
                      break;
                    case "EXTM3U":
                      break;
                    case "ENDLIST":
                      D.live = !1;
                      break;
                    case "DIS":
                      M++, J.tagList.push(["DIS"]);
                      break;
                    case "DISCONTINUITY-SEQ":
                      M = parseInt(Ne);
                      break;
                    case "KEY":
                      var gt = Ne, Ce = new Y(gt), $t = Ce.enumeratedString("METHOD"), bt = Ce.URI, ji = Ce.hexadecimalInteger("IV");
                      $t && (K = new Nt(), bt && ["AES-128", "SAMPLE-AES"].indexOf($t) >= 0 && (K.method = $t, K.baseuri = l, K.reluri = bt, K.key = null, K.iv = ji));
                      break;
                    case "START":
                      var We = Ke, je = new J(We), er = je.decimalFloatingPoint("TIME-OFFSET");
                      isNaN(er) || (D.startTimeOffset = er);
                      break;
                    case "MAP":
                      var go = new Y(Ne);
                      J.relurl = go.URI, J.rawByteRange = go.BYTERANGE, J.baseurl = l, J.level = c, J.type = g, J.sn = "initSegment", D.initSegment = J, J = new $e();
                      break;
                    default:
                      d.b.warn("line parsed but not handled: " + ue);
                      break;
                  }
                }
              }
              return Y = q, Y && !Y.relurl && (D.fragments.pop(), A -= Y.duration), D.totalduration = A, D.averagetargetduration = A / D.fragments.length, D.endSN = w - 1, D.startCC = D.fragments[0] ? D.fragments[0].cc : 0, D.endCC = j, D;
            }, s.prototype.loadsuccess = function(n, l, c) {
              var g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, w = n.data, A = n.url, D = c.type, K = c.id, j = c.level, q = this.hls;
              if (this.loaders[D] = void 0, (A === void 0 || A.indexOf("data:") === 0) && (A = c.url), l.tload = performance.now(), w.indexOf("#EXTM3U") === 0)
                if (w.indexOf("#EXTINF:") > 0) {
                  var Y = D !== "audioTrack" && D !== "subtitleTrack", ue = isNaN(j) ? isNaN(K) ? 0 : K : j, me = this.parseLevelPlaylist(w, A, ue, D === "audioTrack" ? "audio" : D === "subtitleTrack" ? "subtitle" : "main");
                  me.tload = l.tload, D === "manifest" && q.trigger(m.a.MANIFEST_LOADED, { levels: [{ url: A, details: me }], audioTracks: [], url: A, stats: l, networkDetails: g }), l.tparsed = performance.now(), me.targetduration ? Y ? q.trigger(m.a.LEVEL_LOADED, { details: me, level: j || 0, id: K || 0, stats: l, networkDetails: g }) : D === "audioTrack" ? q.trigger(m.a.AUDIO_TRACK_LOADED, { details: me, id: K, stats: l, networkDetails: g }) : D === "subtitleTrack" && q.trigger(m.a.SUBTITLE_TRACK_LOADED, { details: me, id: K, stats: l, networkDetails: g }) : q.trigger(m.a.ERROR, { type: h.b.NETWORK_ERROR, details: h.a.MANIFEST_PARSING_ERROR, fatal: !0, url: A, reason: "invalid targetduration", networkDetails: g });
                } else {
                  var Re = this.parseMasterPlaylist(w, A);
                  if (Re.length) {
                    var be = this.parseMasterPlaylistMedia(w, A, "AUDIO", Re[0].audioCodec), Pe = this.parseMasterPlaylistMedia(w, A, "SUBTITLES");
                    if (be.length) {
                      var ke = !1;
                      be.forEach(function(Ke) {
                        Ke.url || (ke = !0);
                      }), ke === !1 && Re[0].audioCodec && !Re[0].attrs.AUDIO && (d.b.log("audio codec signaled in quality level, but no embedded audio track signaled, create one"), be.unshift({ type: "main", name: "main" }));
                    }
                    q.trigger(m.a.MANIFEST_LOADED, { levels: Re, audioTracks: be, subtitles: Pe, url: A, stats: l, networkDetails: g });
                  } else
                    q.trigger(h.a.ERROR, { type: m.b.NETWORK_ERROR, details: m.a.MANIFEST_PARSING_ERROR, fatal: !0, url: A, reason: "no level found in manifest", networkDetails: g });
                }
              else
                q.trigger(h.a.ERROR, { type: m.b.NETWORK_ERROR, details: m.a.MANIFEST_PARSING_ERROR, fatal: !0, url: A, reason: "no EXTM3U delimiter", networkDetails: g });
            }, s.prototype.loaderror = function(n, l) {
              var c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, g, w, A = l.loader;
              switch (l.type) {
                case "manifest":
                  g = h.a.MANIFEST_LOAD_ERROR, w = !0;
                  break;
                case "level":
                  g = h.a.LEVEL_LOAD_ERROR, w = !1;
                  break;
                case "audioTrack":
                  g = h.a.AUDIO_TRACK_LOAD_ERROR, w = !1;
                  break;
              }
              A && (A.abort(), this.loaders[l.type] = void 0), this.hls.trigger(m.a.ERROR, { type: h.b.NETWORK_ERROR, details: g, fatal: w, url: A.url, loader: A, response: n, context: l, networkDetails: c });
            }, s.prototype.loadtimeout = function(n, l) {
              var c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, g, w, A = l.loader;
              switch (l.type) {
                case "manifest":
                  g = h.a.MANIFEST_LOAD_TIMEOUT, w = !0;
                  break;
                case "level":
                  g = h.a.LEVEL_LOAD_TIMEOUT, w = !1;
                  break;
                case "audioTrack":
                  g = h.a.AUDIO_TRACK_LOAD_TIMEOUT, w = !1;
                  break;
              }
              A && (A.abort(), this.loaders[l.type] = void 0), this.hls.trigger(m.a.ERROR, { type: h.b.NETWORK_ERROR, details: g, fatal: w, url: A.url, loader: A, context: l, networkDetails: c });
            }, s;
          }(I), pt = vt;
          function st(E, s) {
            if (!(E instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function Qe(E, s) {
            if (!E)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : E;
          }
          function ht(E, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            E.prototype = Object.create(s && s.prototype, { constructor: { value: E, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(E, s) : E.__proto__ = s);
          }
          var Me = function(E) {
            ht(s, E);
            function s(o) {
              st(this, s);
              var n = Qe(this, E.call(this, o, m.a.FRAG_LOADING));
              return n.loaders = {}, n;
            }
            return s.prototype.destroy = function() {
              var n = this.loaders;
              for (var l in n) {
                var c = n[l];
                c && c.destroy();
              }
              this.loaders = {}, I.prototype.destroy.call(this);
            }, s.prototype.onFragLoading = function(n) {
              var l = n.frag, c = l.type, g = this.loaders[c], w = this.hls.config;
              l.loaded = 0, g && (d.b.warn("abort previous fragment loader for type:" + c), g.abort()), g = this.loaders[c] = l.loader = typeof w.fLoader < "u" ? new w.fLoader(w) : new w.loader(w);
              var A = void 0, D = void 0, K = void 0;
              A = { url: l.url, frag: l, responseType: "arraybuffer", progressData: !1 };
              var j = l.byteRangeStartOffset, q = l.byteRangeEndOffset;
              !isNaN(j) && !isNaN(q) && (A.rangeStart = j, A.rangeEnd = q), D = { timeout: w.fragLoadingTimeOut, maxRetry: 0, retryDelay: 0, maxRetryDelay: w.fragLoadingMaxRetryTimeout }, K = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this), onProgress: this.loadprogress.bind(this) }, g.load(A, D, K);
            }, s.prototype.loadsuccess = function(n, l, c) {
              var g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, w = n.data, A = c.frag;
              A.loader = void 0, this.loaders[A.type] = void 0, this.hls.trigger(m.a.FRAG_LOADED, { payload: w, frag: A, stats: l, networkDetails: g });
            }, s.prototype.loaderror = function(n, l) {
              var c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, g = l.loader;
              g && g.abort(), this.loaders[l.type] = void 0, this.hls.trigger(h.a.ERROR, { type: m.b.NETWORK_ERROR, details: m.a.FRAG_LOAD_ERROR, fatal: !1, frag: l.frag, response: n, networkDetails: c });
            }, s.prototype.loadtimeout = function(n, l) {
              var c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, g = l.loader;
              g && g.abort(), this.loaders[l.type] = void 0, this.hls.trigger(h.a.ERROR, { type: m.b.NETWORK_ERROR, details: m.a.FRAG_LOAD_TIMEOUT, fatal: !1, frag: l.frag, networkDetails: c });
            }, s.prototype.loadprogress = function(n, l, c) {
              var g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, w = l.frag;
              w.loaded = n.loaded, this.hls.trigger(m.a.FRAG_LOAD_PROGRESS, { frag: w, stats: n, networkDetails: g });
            }, s;
          }(I), Yt = Me;
          function et(E, s) {
            if (!(E instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function fr(E, s) {
            if (!E)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : E;
          }
          function Rt(E, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            E.prototype = Object.create(s && s.prototype, { constructor: { value: E, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(E, s) : E.__proto__ = s);
          }
          var lt = function(E) {
            Rt(s, E);
            function s(o) {
              et(this, s);
              var n = fr(this, E.call(this, o, m.a.KEY_LOADING));
              return n.loaders = {}, n.decryptkey = null, n.decrypturl = null, n;
            }
            return s.prototype.destroy = function() {
              for (var n in this.loaders) {
                var l = this.loaders[n];
                l && l.destroy();
              }
              this.loaders = {}, I.prototype.destroy.call(this);
            }, s.prototype.onKeyLoading = function(n) {
              var l = n.frag, c = l.type, g = this.loaders[c], w = l.decryptdata, A = w.uri;
              if (A !== this.decrypturl || this.decryptkey === null) {
                var D = this.hls.config;
                g && (d.b.warn("abort previous key loader for type:" + c), g.abort()), l.loader = this.loaders[c] = new D.loader(D), this.decrypturl = A, this.decryptkey = null;
                var K = void 0, j = void 0, q = void 0;
                K = { url: A, frag: l, responseType: "arraybuffer" }, j = { timeout: D.fragLoadingTimeOut, maxRetry: D.fragLoadingMaxRetry, retryDelay: D.fragLoadingRetryDelay, maxRetryDelay: D.fragLoadingMaxRetryTimeout }, q = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) }, l.loader.load(K, j, q);
              } else this.decryptkey && (w.key = this.decryptkey, this.hls.trigger(m.a.KEY_LOADED, { frag: l }));
            }, s.prototype.loadsuccess = function(n, l, c) {
              var g = c.frag;
              this.decryptkey = g.decryptdata.key = new Uint8Array(n.data), g.loader = void 0, this.loaders[g.type] = void 0, this.hls.trigger(h.a.KEY_LOADED, { frag: g });
            }, s.prototype.loaderror = function(n, l) {
              var c = l.frag, g = c.loader;
              g && g.abort(), this.loaders[l.type] = void 0, this.hls.trigger(h.a.ERROR, { type: m.b.NETWORK_ERROR, details: m.a.KEY_LOAD_ERROR, fatal: !1, frag: c, response: n });
            }, s.prototype.loadtimeout = function(n, l) {
              var c = l.frag, g = c.loader;
              g && g.abort(), this.loaders[l.type] = void 0, this.hls.trigger(h.a.ERROR, { type: m.b.NETWORK_ERROR, details: m.a.KEY_LOAD_TIMEOUT, fatal: !1, frag: c });
            }, s;
          }(I), It = lt, Ze = {
            /**
             * Searches for an item in an array which matches a certain condition.
             * This requires the condition to only match one item in the array,
             * and for the array to be ordered.
             *
             * @param {Array} list The array to search.
             * @param {Function} comparisonFunction
             *      Called and provided a candidate item as the first argument.
             *      Should return:
             *          > -1 if the item should be located at a lower index than the provided item.
             *          > 1 if the item should be located at a higher index than the provided item.
             *          > 0 if the item is the item you're looking for.
             *
             * @return {*} The object if it is found or null otherwise.
             */
            search: function(s, o) {
              for (var n = 0, l = s.length - 1, c = null, g = null; n <= l; ) {
                c = (n + l) / 2 | 0, g = s[c];
                var w = o(g);
                if (w > 0)
                  n = c + 1;
                else if (w < 0)
                  l = c - 1;
                else
                  return g;
              }
              return null;
            }
          }, Vt = Ze, qe = {
            isBuffered: function(s, o) {
              if (s) {
                for (var n = s.buffered, l = 0; l < n.length; l++)
                  if (o >= n.start(l) && o <= n.end(l))
                    return !0;
              }
              return !1;
            },
            bufferInfo: function(s, o, n) {
              if (s) {
                var l = s.buffered, c = [], g;
                for (g = 0; g < l.length; g++)
                  c.push({ start: l.start(g), end: l.end(g) });
                return this.bufferedInfo(c, o, n);
              } else
                return { len: 0, start: o, end: o, nextStart: void 0 };
            },
            bufferedInfo: function(s, o, n) {
              var l = [], c, g, w, A, D;
              for (s.sort(function(ue, me) {
                var Re = ue.start - me.start;
                return Re || me.end - ue.end;
              }), D = 0; D < s.length; D++) {
                var K = l.length;
                if (K) {
                  var M = l[K - 1].end;
                  s[D].start - M < n ? s[D].end > M && (l[K - 1].end = s[D].end) : l.push(s[D]);
                } else
                  l.push(s[D]);
              }
              for (D = 0, c = 0, g = w = o; D < l.length; D++) {
                var q = l[D].start, Y = l[D].end;
                if (o + n >= q && o < Y)
                  g = q, w = Y, c = w - o;
                else if (o + n < q) {
                  A = q;
                  break;
                }
              }
              return { len: c, start: g, end: w, nextStart: A };
            }
          }, ot = qe, Ut = u(7), At = u(5), mr = /* @__PURE__ */ u.n(At), Mt = u(9), yr = /* @__PURE__ */ u.n(Mt);
          function Nr() {
            if (typeof window < "u")
              return window.MediaSource || window.WebKitMediaSource;
          }
          function Ni(E, s) {
            if (!(E instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          var vr = Nr(), _ = function() {
            function E(s, o) {
              Ni(this, E), this.hls = s, this.id = o;
              var n = this.observer = new mr.a(), l = s.config;
              n.trigger = function(K) {
                for (var M = arguments.length, q = Array(M > 1 ? M - 1 : 0), J = 1; J < M; J++)
                  q[J - 1] = arguments[J];
                n.emit.apply(n, [K, K].concat(q));
              }, n.off = function(K) {
                for (var M = arguments.length, q = Array(M > 1 ? M - 1 : 0), J = 1; J < M; J++)
                  q[J - 1] = arguments[J];
                n.removeListener.apply(n, [K].concat(q));
              };
              var c = function(D, K) {
                K = K || {}, K.frag = this.frag, K.id = this.id, s.trigger(D, K);
              }.bind(this);
              n.on(h.a.FRAG_DECRYPTED, c), n.on(h.a.FRAG_PARSING_INIT_SEGMENT, c), n.on(h.a.FRAG_PARSING_DATA, c), n.on(h.a.FRAG_PARSED, c), n.on(h.a.ERROR, c), n.on(h.a.FRAG_PARSING_METADATA, c), n.on(h.a.FRAG_PARSING_USERDATA, c), n.on(h.a.INIT_PTS_FOUND, c);
              var g = {
                mp4: vr.isTypeSupported("video/mp4"),
                mpeg: vr.isTypeSupported("audio/mpeg"),
                mp3: vr.isTypeSupported('audio/mp4; codecs="mp3"')
              }, w = navigator.vendor;
              if (l.enableWorker && typeof Worker < "u") {
                d.b.log("demuxing in webworker");
                var A = void 0;
                try {
                  A = this.w = yr()(
                    /*require.resolve*/
                    10
                  ), this.onwmsg = this.onWorkerMessage.bind(this), A.addEventListener("message", this.onwmsg), A.onerror = function(D) {
                    s.trigger(m.a.ERROR, { type: h.b.OTHER_ERROR, details: h.a.INTERNAL_EXCEPTION, fatal: !0, event: "demuxerWorker", err: { message: D.message + " (" + D.filename + ":" + D.lineno + ")" } });
                  }, A.postMessage({ cmd: "init", typeSupported: g, vendor: w, id: o, config: JSON.stringify(l) });
                } catch {
                  d.b.error("error while initializing DemuxerWorker, fallback on DemuxerInline"), A && URL.revokeObjectURL(A.objectURL), this.demuxer = new Ut.a(n, g, l, w), this.w = void 0;
                }
              } else
                this.demuxer = new Ut.a(n, g, l, w);
            }
            return E.prototype.destroy = function() {
              var o = this.w;
              if (o)
                o.removeEventListener("message", this.onwmsg), o.terminate(), this.w = null;
              else {
                var n = this.demuxer;
                n && (n.destroy(), this.demuxer = null);
              }
              var l = this.observer;
              l && (l.removeAllListeners(), this.observer = null);
            }, E.prototype.push = function(o, n, l, c, g, w, A, D) {
              var K = this.w, j = isNaN(g.startDTS) ? g.start : g.startDTS, q = g.decryptdata, Y = this.frag, ue = !(Y && g.cc === Y.cc), me = !(Y && g.level === Y.level), Re = Y && g.sn === Y.sn + 1, be = !me && Re;
              if (ue && d.b.log(this.id + ":discontinuity detected"), me && d.b.log(this.id + ":switch detected"), this.frag = g, K)
                K.postMessage({ cmd: "demux", data: o, decryptdata: q, initSegment: n, audioCodec: l, videoCodec: c, timeOffset: j, discontinuity: ue, trackSwitch: me, contiguous: be, duration: w, accurateTimeOffset: A, defaultInitPTS: D }, o instanceof ArrayBuffer ? [o] : []);
              else {
                var Pe = this.demuxer;
                Pe && Pe.push(o, q, n, l, c, j, ue, me, be, w, A, D);
              }
            }, E.prototype.onWorkerMessage = function(o) {
              var n = o.data, l = this.hls;
              switch (n.event) {
                case "init":
                  URL.revokeObjectURL(this.w.objectURL);
                  break;
                case h.a.FRAG_PARSING_DATA:
                  n.data.data1 = new Uint8Array(n.data1), n.data2 && (n.data.data2 = new Uint8Array(n.data2));
                default:
                  n.data = n.data || {}, n.data.frag = this.frag, n.data.id = this.id, l.trigger(n.event, n.data);
                  break;
              }
            }, E;
          }(), X = _;
          function b(E, s, o) {
            var n = E[s], l = E[o], c = l.startPTS;
            isNaN(c) ? o > s ? l.start = n.start + n.duration : l.start = Math.max(n.start - l.duration, 0) : o > s ? (n.duration = c - n.start, n.duration < 0 && d.b.warn("negative duration computed for frag " + n.sn + ",level " + n.level + ", there should be some duration drift between playlist and fragment!")) : (l.duration = n.start - c, l.duration < 0 && d.b.warn("negative duration computed for frag " + l.sn + ",level " + l.level + ", there should be some duration drift between playlist and fragment!"));
          }
          function L(E, s, o, n, l, c) {
            var g = o;
            if (!isNaN(s.startPTS)) {
              var w = Math.abs(s.startPTS - o);
              isNaN(s.deltaPTS) ? s.deltaPTS = w : s.deltaPTS = Math.max(w, s.deltaPTS), g = Math.max(o, s.startPTS), o = Math.min(o, s.startPTS), n = Math.max(n, s.endPTS), l = Math.min(l, s.startDTS), c = Math.max(c, s.endDTS);
            }
            var A = o - s.start;
            s.start = s.startPTS = o, s.maxStartPTS = g, s.endPTS = n, s.startDTS = l, s.endDTS = c, s.duration = n - o;
            var D = s.sn;
            if (!E || D < E.startSN || D > E.endSN)
              return 0;
            var K, M, q;
            for (K = D - E.startSN, M = E.fragments, M[K] = s, q = K; q > 0; q--)
              b(M, q, q - 1);
            for (q = K; q < M.length - 1; q++)
              b(M, q, q + 1);
            return E.PTSKnown = !0, A;
          }
          function k(E, s) {
            var o = Math.max(E.startSN, s.startSN) - s.startSN, n = Math.min(E.endSN, s.endSN) - s.startSN, l = s.startSN - E.startSN, c = E.fragments, g = s.fragments, w = 0, A;
            if (n < o) {
              s.PTSKnown = !1;
              return;
            }
            for (var D = o; D <= n; D++) {
              var K = c[l + D], j = g[D];
              j && K && (w = K.cc - j.cc, isNaN(K.startPTS) || (j.start = j.startPTS = K.startPTS, j.endPTS = K.endPTS, j.duration = K.duration, j.backtracked = K.backtracked, j.dropped = K.dropped, A = j));
            }
            if (w)
              for (d.b.log("discontinuity sliding from playlist, take drift into account"), D = 0; D < g.length; D++)
                g[D].cc += w;
            if (A)
              L(s, A, A.startPTS, A.endPTS, A.startDTS, A.endDTS);
            else if (l >= 0 && l < c.length) {
              var q = c[l].start;
              for (D = 0; D < g.length; D++)
                g[D].start += q;
            }
            s.PTSKnown = E.PTSKnown;
          }
          var U = {
            toString: function(s) {
              for (var o = "", n = s.length, l = 0; l < n; l++)
                o += "[" + s.start(l).toFixed(3) + "," + s.end(l).toFixed(3) + "]";
              return o;
            }
          }, V = U;
          function Z(E, s) {
            for (var o = null, n = 0; n < E.length; n += 1) {
              var l = E[n];
              if (l && l.cc === s) {
                o = l;
                break;
              }
            }
            return o;
          }
          function H(E, s) {
            return Vt.search(E, function(o) {
              return o.cc < s ? 1 : o.cc > s ? -1 : 0;
            });
          }
          function ee(E, s, o) {
            var n = !1;
            return s && s.details && o && (o.endCC > o.startCC || E && E.cc < o.startCC) && (n = !0), n;
          }
          function re(E, s) {
            var o = E.fragments, n = s.fragments;
            if (!n.length || !o.length) {
              d.b.log("No fragments to align");
              return;
            }
            var l = Z(o, n[0].cc);
            if (!l || l && !l.startPTS) {
              d.b.log("No frag in previous level to align on");
              return;
            }
            return l;
          }
          function Q(E, s) {
            s.fragments.forEach(function(o) {
              if (o) {
                var n = o.start + E;
                o.start = o.startPTS = n, o.endPTS = n + o.duration;
              }
            }), s.PTSKnown = !0;
          }
          function oe(E, s, o) {
            if (ee(E, s, o)) {
              var n = re(s.details, o);
              n && (d.b.log("Adjusting PTS using last level due to CC increase within current level"), Q(n.start, o));
            }
            if (o.PTSKnown === !1 && s && s.details) {
              var l = s.details.programDateTime, c = o.programDateTime, g = (c - l) / 1e3 + s.details.fragments[0].start;
              isNaN(g) || (d.b.log("adjusting PTS using programDateTime delta, sliding:" + g.toFixed(3)), Q(g, o));
            }
          }
          var se = /* @__PURE__ */ function() {
            function E(s, o) {
              for (var n = 0; n < o.length; n++) {
                var l = o[n];
                l.enumerable = l.enumerable || !1, l.configurable = !0, "value" in l && (l.writable = !0), Object.defineProperty(s, l.key, l);
              }
            }
            return function(s, o, n) {
              return o && E(s.prototype, o), n && E(s, n), s;
            };
          }();
          function ce(E, s) {
            if (!(E instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function de(E, s) {
            if (!E)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : E;
          }
          function pe(E, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            E.prototype = Object.create(s && s.prototype, { constructor: { value: E, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(E, s) : E.__proto__ = s);
          }
          var W = {
            STOPPED: "STOPPED",
            IDLE: "IDLE",
            KEY_LOADING: "KEY_LOADING",
            FRAG_LOADING: "FRAG_LOADING",
            FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
            WAITING_LEVEL: "WAITING_LEVEL",
            PARSING: "PARSING",
            PARSED: "PARSED",
            BUFFER_FLUSHING: "BUFFER_FLUSHING",
            ENDED: "ENDED",
            ERROR: "ERROR"
          }, Ke = function(E) {
            pe(s, E);
            function s(o) {
              ce(this, s);
              var n = de(this, E.call(this, o, h.a.MEDIA_ATTACHED, h.a.MEDIA_DETACHING, h.a.MANIFEST_LOADING, h.a.MANIFEST_PARSED, h.a.LEVEL_LOADED, h.a.KEY_LOADED, h.a.FRAG_LOADED, h.a.FRAG_LOAD_EMERGENCY_ABORTED, h.a.FRAG_PARSING_INIT_SEGMENT, h.a.FRAG_PARSING_DATA, h.a.FRAG_PARSED, h.a.ERROR, h.a.AUDIO_TRACK_SWITCHING, h.a.AUDIO_TRACK_SWITCHED, h.a.BUFFER_CREATED, h.a.BUFFER_APPENDED, h.a.BUFFER_FLUSHED));
              return n.config = o.config, n.audioCodecSwap = !1, n.ticks = 0, n._state = W.STOPPED, n.ontick = n.tick.bind(n), n;
            }
            return s.prototype.destroy = function() {
              this.stopLoad(), this.timer && (clearInterval(this.timer), this.timer = null), I.prototype.destroy.call(this), this.state = W.STOPPED;
            }, s.prototype.startLoad = function(n) {
              if (this.levels) {
                var l = this.lastCurrentTime, c = this.hls;
                if (this.stopLoad(), this.timer || (this.timer = setInterval(this.ontick, 100)), this.level = -1, this.fragLoadError = 0, !this.startFragRequested) {
                  var g = c.startLevel;
                  g === -1 && (g = 0, this.bitrateTest = !0), this.level = c.nextLoadLevel = g, this.loadedmetadata = !1;
                }
                l > 0 && n === -1 && (d.b.log("override startPosition with lastCurrentTime @" + l.toFixed(3)), n = l), this.state = W.IDLE, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = n, this.tick();
              } else
                this.forceStartLoad = !0, this.state = W.STOPPED;
            }, s.prototype.stopLoad = function() {
              var n = this.fragCurrent;
              n && (n.loader && n.loader.abort(), this.fragCurrent = null), this.fragPrevious = null, this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.state = W.STOPPED, this.forceStartLoad = !1;
            }, s.prototype.tick = function() {
              this.ticks++, this.ticks === 1 && (this.doTick(), this.ticks > 1 && setTimeout(this.tick, 1), this.ticks = 0);
            }, s.prototype.doTick = function() {
              switch (this.state) {
                case W.ERROR:
                  break;
                case W.BUFFER_FLUSHING:
                  this.fragLoadError = 0;
                  break;
                case W.IDLE:
                  this._doTickIdle();
                  break;
                case W.WAITING_LEVEL:
                  var n = this.levels[this.level];
                  n && n.details && (this.state = W.IDLE);
                  break;
                case W.FRAG_LOADING_WAITING_RETRY:
                  var l = performance.now(), c = this.retryDate;
                  (!c || l >= c || this.media && this.media.seeking) && (d.b.log("mediaController: retryDate reached, switch back to IDLE state"), this.state = W.IDLE);
                  break;
              }
              this._checkBuffer(), this._checkFragmentChanged();
            }, s.prototype._doTickIdle = function() {
              var n = this.hls, l = n.config, c = this.media;
              if (!(this.levelLastLoaded === void 0 || !c && (this.startFragRequested || !l.startFragPrefetch))) {
                var g = void 0;
                this.loadedmetadata ? g = c.currentTime : g = this.nextLoadPosition;
                var w = n.nextLoadLevel, A = this.levels[w];
                if (A) {
                  var D = A.bitrate, K = void 0;
                  D ? K = Math.max(8 * l.maxBufferSize / D, l.maxBufferLength) : K = l.maxBufferLength, K = Math.min(K, l.maxMaxBufferLength);
                  var j = ot.bufferInfo(this.mediaBuffer ? this.mediaBuffer : c, g, l.maxBufferHole), q = j.len;
                  if (!(q >= K)) {
                    d.b.trace("buffer length of " + q.toFixed(3) + " is below max of " + K.toFixed(3) + ". checking for more payload ..."), this.level = n.nextLoadLevel = w;
                    var Y = A.details;
                    if (typeof Y > "u" || Y.live && this.levelLastLoaded !== w) {
                      this.state = W.WAITING_LEVEL;
                      return;
                    }
                    var ue = this.fragPrevious;
                    if (!Y.live && ue && !ue.backtracked && ue.sn === Y.endSN && !j.nextStart) {
                      var me = Math.min(c.duration, ue.start + ue.duration);
                      if (me - Math.max(j.end, ue.start) <= Math.max(0.2, ue.duration)) {
                        var Re = {};
                        this.altAudio && (Re.type = "video"), this.hls.trigger(m.a.BUFFER_EOS, Re), this.state = W.ENDED;
                        return;
                      }
                    }
                    this._fetchPayloadOrEos(g, M, J);
                  }
                }
              }
            }, s.prototype._fetchPayloadOrEos = function(n, l, c) {
              var g = this.fragPrevious, w = this.level, A = c.fragments, D = A.length;
              if (D !== 0) {
                var K = A[0].start, M = A[D - 1].start + A[D - 1].duration, q = l.end, J = void 0;
                if (c.initSegment && !c.initSegment.data)
                  J = c.initSegment;
                else if (c.live) {
                  var ue = this.config.initialLiveManifestSize;
                  if (D < ue) {
                    d.b.warn("Can not start playback of a level, reason: not enough fragments " + D + " < " + ue);
                    return;
                  }
                  if (J = this._ensureFragmentAtLivePoint(c, q, K, M, g, A, D), J === null)
                    return;
                } else
                  q < K && (Y = A[0]);
                Y || (Y = this._findFragment(K, g, D, A, q, j, c)), Y && this._loadFragmentOrKey(Y, w, c, n, q);
              }
            }, s.prototype._ensureFragmentAtLivePoint = function(n, l, c, g, w, A, D) {
              var K = this.hls.config, j = this.media, q = void 0, Y = K.liveMaxLatencyDuration !== void 0 ? K.liveMaxLatencyDuration : K.liveMaxLatencyDurationCount * n.targetduration;
              if (l < Math.max(c - K.maxFragLookUpTolerance, g - Y)) {
                var ue = this.liveSyncPosition = this.computeLivePosition(c, n);
                d.b.log("buffer end: " + l.toFixed(3) + " is located too far from the end of live sliding playlist, reset currentTime to : " + ue.toFixed(3)), l = ue, M && M.readyState && M.duration > ue && (M.currentTime = ue), this.nextLoadPosition = ue;
              }
              if (n.PTSKnown && l > g && M && M.readyState)
                return null;
              if (this.startFragRequested && !n.PTSKnown) {
                if (w) {
                  var me = w.sn + 1;
                  if (me >= n.startSN && me <= n.endSN) {
                    var Re = A[me - n.startSN];
                    w.cc === Re.cc && (q = Re, d.b.log("live playlist, switching playlist, load frag with next SN: " + q.sn));
                  }
                  q || (q = Vt.search(A, function(be) {
                    return w.cc - be.cc;
                  }), q && d.b.log("live playlist, switching playlist, load frag with same CC: " + q.sn));
                }
                q || (q = A[Math.min(D - 1, Math.round(D / 2))], d.b.log("live playlist, switching playlist, unknown, load middle frag : " + q.sn));
              }
              return q;
            }, s.prototype._findFragment = function(n, l, c, g, w, A, D) {
              var K = this.hls.config, j = void 0, q = void 0, Y = K.maxFragLookUpTolerance, ue = l ? g[l.sn - g[0].sn + 1] : void 0, me = function(gt) {
                var Le = Math.min(Y, gt.duration + (gt.deltaPTS ? gt.deltaPTS : 0));
                return gt.start + gt.duration - Le <= w ? 1 : gt.start - Le > w && gt.start ? -1 : 0;
              };
              if (w < A ? (w > A - Y && (Y = 0), ue && !me(ue) ? q = ue : q = Vt.search(g, me)) : q = g[c - 1], q) {
                j = q;
                var Re = j.sn - D.startSN, be = l && j.level === l.level, Pe = g[Re - 1], ke = g[Re + 1];
                if (l && j.sn === l.sn)
                  if (be && !j.backtracked)
                    if (j.sn < D.endSN) {
                      var Ke = l.deltaPTS;
                      Ke && Ke > K.maxBufferHole && l.dropped && Re ? (j = Pe, d.b.warn("SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this"), l.loadCounter--) : (j = ke, d.b.log("SN just loaded, load next one: " + j.sn));
                    } else
                      j = null;
                  else j.backtracked && (ke && ke.backtracked ? (d.b.warn("Already backtracked from fragment " + ke.sn + ", will not backtrack to fragment " + j.sn + ". Loading fragment " + ke.sn), j = ke) : (d.b.warn("Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe"), j.dropped = 0, Pe ? (Pe.loadCounter && Pe.loadCounter--, j = Pe, j.backtracked = !0) : Re && (j = null)));
              }
              return j;
            }, s.prototype._loadFragmentOrKey = function(n, l, c, g, w) {
              var A = this.hls, D = A.config;
              if (n.decryptdata && n.decryptdata.uri != null && n.decryptdata.key == null)
                d.b.log("Loading key for " + n.sn + " of [" + c.startSN + " ," + c.endSN + "],level " + l), this.state = W.KEY_LOADING, A.trigger(h.a.KEY_LOADING, { frag: n });
              else {
                if (d.b.log("Loading " + n.sn + " of [" + c.startSN + " ," + c.endSN + "],level " + l + ", currentTime:" + g.toFixed(3) + ",bufferEnd:" + w.toFixed(3)), this.fragLoadIdx !== void 0 ? this.fragLoadIdx++ : this.fragLoadIdx = 0, n.loadCounter) {
                  n.loadCounter++;
                  var K = D.fragLoadingLoopThreshold;
                  if (n.loadCounter > K && Math.abs(this.fragLoadIdx - n.loadIdx) < K) {
                    A.trigger(h.a.ERROR, { type: m.b.MEDIA_ERROR, details: m.a.FRAG_LOOP_LOADING_ERROR, fatal: !1, frag: n });
                    return;
                  }
                } else
                  n.loadCounter = 1;
                n.loadIdx = this.fragLoadIdx, n.autoLevel = A.autoLevelEnabled, n.bitrateTest = this.bitrateTest, this.fragCurrent = n, this.startFragRequested = !0, !isNaN(n.sn) && !n.bitrateTest && (this.nextLoadPosition = n.start + n.duration), A.trigger(h.a.FRAG_LOADING, { frag: n }), this.demuxer || (this.demuxer = new X(A, "main")), this.state = W.FRAG_LOADING;
                return;
              }
            }, s.prototype.getBufferedFrag = function(n) {
              return Vt.search(this._bufferedFrags, function(l) {
                return n < l.startPTS ? -1 : n > l.endPTS ? 1 : 0;
              });
            }, s.prototype.followingBufferedFrag = function(n) {
              return n ? this.getBufferedFrag(n.endPTS + 0.5) : null;
            }, s.prototype._checkFragmentChanged = function() {
              var n, l, c = this.media;
              if (c && c.readyState && c.seeking === !1 && (l = c.currentTime, l > c.playbackRate * this.lastCurrentTime && (this.lastCurrentTime = l), ot.isBuffered(c, l) ? n = this.getBufferedFrag(l) : ot.isBuffered(c, l + 0.1) && (n = this.getBufferedFrag(l + 0.1)), n)) {
                var g = n;
                if (g !== this.fragPlaying) {
                  this.hls.trigger(m.a.FRAG_CHANGED, { frag: g });
                  var w = g.level;
                  (!this.fragPlaying || this.fragPlaying.level !== w) && this.hls.trigger(m.a.LEVEL_SWITCHED, { level: w }), this.fragPlaying = g;
                }
              }
            }, s.prototype.immediateLevelSwitch = function() {
              if (d.b.log("immediateLevelSwitch"), !this.immediateSwitch) {
                this.immediateSwitch = !0;
                var n = this.media, l = void 0;
                n ? (l = n.paused, n.pause()) : l = !0, this.previouslyPaused = l;
              }
              var c = this.fragCurrent;
              c && c.loader && c.loader.abort(), this.fragCurrent = null, this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold), this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
            }, s.prototype.immediateLevelSwitchEnd = function() {
              var n = this.media;
              n && n.buffered.length && (this.immediateSwitch = !1, ot.isBuffered(n, n.currentTime) && (n.currentTime -= 1e-4), this.previouslyPaused || n.play());
            }, s.prototype.nextLevelSwitch = function() {
              var n = this.media;
              if (n && n.readyState) {
                var l = void 0, c = void 0, g = void 0;
                if (this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold), c = this.getBufferedFrag(n.currentTime), c && c.startPTS > 1 && this.flushMainBuffer(0, c.startPTS - 1), n.paused)
                  l = 0;
                else {
                  var w = this.hls.nextLoadLevel, A = this.levels[w], D = this.fragLastKbps;
                  D && this.fragCurrent ? l = this.fragCurrent.duration * A.bitrate / (1e3 * D) + 1 : l = 0;
                }
                if (g = this.getBufferedFrag(n.currentTime + l), g && (g = this.followingBufferedFrag(g), g)) {
                  var K = this.fragCurrent;
                  K && K.loader && K.loader.abort(), this.fragCurrent = null, this.flushMainBuffer(g.maxStartPTS, Number.POSITIVE_INFINITY);
                }
              }
            }, s.prototype.flushMainBuffer = function(n, l) {
              this.state = W.BUFFER_FLUSHING;
              var c = { startOffset: n, endOffset: l };
              this.altAudio && (c.type = "video"), this.hls.trigger(h.a.BUFFER_FLUSHING, c);
            }, s.prototype.onMediaAttached = function(n) {
              var l = this.media = this.mediaBuffer = n.media;
              this.onvseeking = this.onMediaSeeking.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), this.onvended = this.onMediaEnded.bind(this), l.addEventListener("seeking", this.onvseeking), l.addEventListener("seeked", this.onvseeked), l.addEventListener("ended", this.onvended);
              var c = this.config;
              this.levels && c.autoStartLoad && this.hls.startLoad(c.startPosition);
            }, s.prototype.onMediaDetaching = function() {
              var n = this.media;
              n && n.ended && (d.b.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0);
              var l = this.levels;
              l && l.forEach(function(c) {
                c.details && c.details.fragments.forEach(function(g) {
                  g.loadCounter = void 0, g.backtracked = void 0;
                });
              }), n && (n.removeEventListener("seeking", this.onvseeking), n.removeEventListener("seeked", this.onvseeked), n.removeEventListener("ended", this.onvended), this.onvseeking = this.onvseeked = this.onvended = null), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.stopLoad();
            }, s.prototype.onMediaSeeking = function() {
              var n = this.media, l = n ? n.currentTime : void 0, c = this.config;
              isNaN(l) || d.b.log("media seeking to " + l.toFixed(3));
              var g = this.mediaBuffer ? this.mediaBuffer : n, w = ot.bufferInfo(g, l, this.config.maxBufferHole);
              if (this.state === W.FRAG_LOADING) {
                var A = this.fragCurrent;
                if (w.len === 0 && A) {
                  var D = c.maxFragLookUpTolerance, K = A.start - D, j = A.start + A.duration + D;
                  l < K || l > j ? (A.loader && (d.b.log("seeking outside of buffer while fragment load in progress, cancel fragment load"), A.loader.abort()), this.fragCurrent = null, this.fragPrevious = null, this.state = W.IDLE) : d.b.log("seeking outside of buffer but within currently loaded fragment range");
                }
              } else this.state === W.ENDED && (w.len === 0 && (this.fragPrevious = 0), this.state = W.IDLE);
              n && (this.lastCurrentTime = l), this.state !== W.FRAG_LOADING && this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * c.fragLoadingLoopThreshold), this.loadedmetadata || (this.nextLoadPosition = this.startPosition = l), this.tick();
            }, s.prototype.onMediaSeeked = function() {
              var n = this.media, l = n ? n.currentTime : void 0;
              isNaN(l) || d.b.log("media seeked to " + l.toFixed(3)), this.tick();
            }, s.prototype.onMediaEnded = function() {
              d.b.log("media ended"), this.startPosition = this.lastCurrentTime = 0;
            }, s.prototype.onManifestLoading = function() {
              d.b.log("trigger BUFFER_RESET"), this.hls.trigger(h.a.BUFFER_RESET), this._bufferedFrags = [], this.stalled = !1, this.startPosition = this.lastCurrentTime = 0;
            }, s.prototype.onManifestParsed = function(n) {
              var l = !1, c = !1, g;
              n.levels.forEach(function(A) {
                g = A.audioCodec, g && (g.indexOf("mp4a.40.2") !== -1 && (l = !0), g.indexOf("mp4a.40.5") !== -1 && (c = !0));
              }), this.audioCodecSwitch = l && c, this.audioCodecSwitch && d.b.log("both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = n.levels, this.startFragRequested = !1;
              var w = this.config;
              (w.autoStartLoad || this.forceStartLoad) && this.hls.startLoad(w.startPosition);
            }, s.prototype.onLevelLoaded = function(n) {
              var l = n.details, c = n.level, g = this.levels[this.levelLastLoaded], w = this.levels[c], A = l.totalduration, D = 0;
              if (d.b.log("level " + c + " loaded [" + l.startSN + "," + l.endSN + "],duration:" + A), l.live) {
                var K = w.details;
                K && l.fragments.length > 0 ? (k(K, l), D = l.fragments[0].start, this.liveSyncPosition = this.computeLivePosition(D, K), l.PTSKnown && !isNaN(D) ? d.b.log("live playlist sliding:" + D.toFixed(3)) : (d.b.log("live playlist - outdated PTS, unknown sliding"), oe(this.fragPrevious, g, l))) : (d.b.log("live playlist - first load, unknown sliding"), l.PTSKnown = !1, oe(this.fragPrevious, g, l));
              } else
                l.PTSKnown = !1;
              if (w.details = l, this.levelLastLoaded = c, this.hls.trigger(m.a.LEVEL_UPDATED, { details: l, level: c }), this.startFragRequested === !1) {
                if (this.startPosition === -1 || this.lastCurrentTime === -1) {
                  var M = l.startTimeOffset;
                  isNaN(M) ? l.live ? (this.startPosition = this.computeLivePosition(D, l), d.b.log("configure startPosition to " + this.startPosition)) : this.startPosition = 0 : (M < 0 && (d.b.log("negative start time offset " + M + ", count from end of last fragment"), M = D + A + M), d.b.log("start time offset found in playlist, adjust startPosition to " + M), this.startPosition = M), this.lastCurrentTime = this.startPosition;
                }
                this.nextLoadPosition = this.startPosition;
              }
              this.state === W.WAITING_LEVEL && (this.state = W.IDLE), this.tick();
            }, s.prototype.onKeyLoaded = function() {
              this.state === W.KEY_LOADING && (this.state = W.IDLE, this.tick());
            }, s.prototype.onFragLoaded = function(n) {
              var l = this.fragCurrent, c = n.frag;
              if (this.state === W.FRAG_LOADING && l && c.type === "main" && c.level === l.level && c.sn === l.sn) {
                var g = n.stats, w = this.levels[l.level], A = w.details;
                if (d.b.log("Loaded  " + l.sn + " of [" + A.startSN + " ," + A.endSN + "],level " + l.level), this.bitrateTest = !1, this.stats = g, c.bitrateTest === !0 && this.hls.nextLoadLevel)
                  this.state = W.IDLE, this.startFragRequested = !1, g.tparsed = g.tbuffered = performance.now(), this.hls.trigger(h.a.FRAG_BUFFERED, { stats: g, frag: l, id: "main" }), this.tick();
                else if (c.sn === "initSegment")
                  this.state = W.IDLE, g.tparsed = g.tbuffered = performance.now(), A.initSegment.data = n.payload, this.hls.trigger(h.a.FRAG_BUFFERED, { stats: g, frag: l, id: "main" }), this.tick();
                else {
                  this.state = W.PARSING;
                  var D = A.totalduration, K = l.level, j = l.sn, q = this.config.defaultAudioCodec || w.audioCodec;
                  this.audioCodecSwap && (d.b.log("swapping playlist audio codec"), q === void 0 && (q = this.lastAudioCodec), q && (q.indexOf("mp4a.40.5") !== -1 ? q = "mp4a.40.2" : q = "mp4a.40.5")), this.pendingBuffering = !0, this.appended = !1, d.b.log("Parsing " + j + " of [" + A.startSN + " ," + A.endSN + "],level " + K + ", cc " + l.cc);
                  var Y = this.demuxer;
                  Y || (Y = this.demuxer = new X(this.hls, "main"));
                  var ue = this.media, me = ue && ue.seeking, Re = !me && (A.PTSKnown || !A.live), be = A.initSegment ? A.initSegment.data : [];
                  Y.push(n.payload, be, q, w.videoCodec, l, D, Re, void 0);
                }
              }
              this.fragLoadError = 0;
            }, s.prototype.onFragParsingInitSegment = function(n) {
              var l = this.fragCurrent, c = n.frag;
              if (l && n.id === "main" && c.sn === l.sn && c.level === l.level && this.state === W.PARSING) {
                var g = n.tracks, w, A;
                if (g.audio && this.altAudio && delete g.audio, A = g.audio, A) {
                  var D = this.levels[this.level].audioCodec, K = navigator.userAgent.toLowerCase();
                  D && this.audioCodecSwap && (d.b.log("swapping playlist audio codec"), D.indexOf("mp4a.40.5") !== -1 ? D = "mp4a.40.2" : D = "mp4a.40.5"), this.audioCodecSwitch && A.metadata.channelCount !== 1 && // don't force HE-AAC if firefox
                  K.indexOf("firefox") === -1 && (D = "mp4a.40.5"), K.indexOf("android") !== -1 && A.container !== "audio/mpeg" && (D = "mp4a.40.2", d.b.log("Android: force audio codec to " + D)), A.levelCodec = D, A.id = n.id;
                }
                A = g.video, A && (A.levelCodec = this.levels[this.level].videoCodec, A.id = n.id), this.hls.trigger(m.a.BUFFER_CODECS, g);
                for (w in g) {
                  A = g[w], d.b.log("main track:" + w + ",container:" + A.container + ",codecs[level/parsed]=[" + A.levelCodec + "/" + A.codec + "]");
                  var j = A.initSegment;
                  j && (this.appended = !0, this.pendingBuffering = !0, this.hls.trigger(m.a.BUFFER_APPENDING, { type: w, data: j, parent: "main", content: "initSegment" }));
                }
                this.tick();
              }
            }, s.prototype.onFragParsingData = function(n) {
              var l = this, c = this.fragCurrent, g = n.frag;
              if (c && n.id === "main" && g.sn === c.sn && g.level === c.level && !(n.type === "audio" && this.altAudio) && // filter out main audio if audio track is loaded through audio stream controller
              this.state === W.PARSING) {
                var w = this.levels[this.level], A = c;
                if (isNaN(n.endPTS) && (n.endPTS = n.startPTS + c.duration, n.endDTS = n.startDTS + c.duration), d.b.log("Parsed " + n.type + ",PTS:[" + n.startPTS.toFixed(3) + "," + n.endPTS.toFixed(3) + "],DTS:[" + n.startDTS.toFixed(3) + "/" + n.endDTS.toFixed(3) + "],nb:" + n.nb + ",dropped:" + (n.dropped || 0)), n.type === "video")
                  if (A.dropped = n.dropped, A.dropped)
                    if (A.backtracked)
                      d.b.warn("Already backtracked on this fragment, appending with the gap");
                    else {
                      var D = w.details;
                      if (D && A.sn === D.startSN)
                        d.b.warn("missing video frame(s) on first frag, appending with gap");
                      else {
                        d.b.warn("missing video frame(s), backtracking fragment"), A.backtracked = !0, this.nextLoadPosition = n.startPTS, this.state = W.IDLE, this.fragPrevious = A, this.tick();
                        return;
                      }
                    }
                  else
                    A.backtracked = !1;
                var K = L(w.details, A, n.startPTS, n.endPTS, n.startDTS, n.endDTS), j = this.hls;
                j.trigger(m.a.LEVEL_PTS_UPDATED, { details: w.details, level: this.level, drift: K, type: n.type, start: n.startPTS, end: n.endPTS }), [n.data1, n.data2].forEach(function(q) {
                  q && q.length && l.state === W.PARSING && (l.appended = !0, l.pendingBuffering = !0, j.trigger(m.a.BUFFER_APPENDING, { type: n.type, data: q, parent: "main", content: "data" }));
                }), this.tick();
              }
            }, s.prototype.onFragParsed = function(n) {
              var l = this.fragCurrent, c = n.frag;
              l && n.id === "main" && c.sn === l.sn && c.level === l.level && this.state === W.PARSING && (this.stats.tparsed = performance.now(), this.state = W.PARSED, this._checkAppendedParsed());
            }, s.prototype.onAudioTrackSwitching = function(n) {
              var l = !!n.url, c = n.id;
              if (!l) {
                if (this.mediaBuffer !== this.media) {
                  d.b.log("switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media;
                  var g = this.fragCurrent;
                  g.loader && (d.b.log("switching to main audio track, cancel main fragment load"), g.loader.abort()), this.fragCurrent = null, this.fragPrevious = null, this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.state = W.IDLE;
                }
                var w = this.hls;
                w.trigger(m.a.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: "audio" }), w.trigger(m.a.AUDIO_TRACK_SWITCHED, { id: c }), this.altAudio = !1;
              }
            }, s.prototype.onAudioTrackSwitched = function(n) {
              var l = n.id, c = !!this.hls.audioTracks[l].url;
              if (c) {
                var g = this.videoBuffer;
                g && this.mediaBuffer !== g && (d.b.log("switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = g);
              }
              this.altAudio = c, this.tick();
            }, s.prototype.onBufferCreated = function(n) {
              var l = n.tracks, c = void 0, g = void 0, w = !1;
              for (var A in l) {
                var D = l[A];
                D.id === "main" ? (g = A, c = D, A === "video" && (this.videoBuffer = l[A].buffer)) : w = !0;
              }
              w && c ? (d.b.log("alternate track found, use " + g + ".buffered to schedule main fragment loading"), this.mediaBuffer = c.buffer) : this.mediaBuffer = this.media;
            }, s.prototype.onBufferAppended = function(n) {
              if (n.parent === "main") {
                var l = this.state;
                (l === W.PARSING || l === W.PARSED) && (this.pendingBuffering = n.pending > 0, this._checkAppendedParsed());
              }
            }, s.prototype._checkAppendedParsed = function() {
              if (this.state === W.PARSED && (!this.appended || !this.pendingBuffering)) {
                var n = this.fragCurrent;
                if (n) {
                  var l = this.mediaBuffer ? this.mediaBuffer : this.media;
                  d.b.log("main buffered : " + M.toString(l.buffered));
                  var c = this._bufferedFrags.filter(function(w) {
                    return ot.isBuffered(l, (w.startPTS + w.endPTS) / 2);
                  });
                  c.push(n), this._bufferedFrags = c.sort(function(w, A) {
                    return w.startPTS - A.startPTS;
                  }), this.fragPrevious = n;
                  var g = this.stats;
                  g.tbuffered = performance.now(), this.fragLastKbps = Math.round(8 * g.total / (g.tbuffered - g.tfirst)), this.hls.trigger(h.a.FRAG_BUFFERED, { stats: g, frag: n, id: "main" }), this.state = W.IDLE;
                }
                this.tick();
              }
            }, s.prototype.onError = function(n) {
              var l = n.frag || this.fragCurrent;
              if (!(l && l.type !== "main")) {
                var c = !!this.media && ot.isBuffered(this.media, this.media.currentTime) && ot.isBuffered(this.media, this.media.currentTime + 0.5);
                switch (n.details) {
                  case m.a.FRAG_LOAD_ERROR:
                  case m.a.FRAG_LOAD_TIMEOUT:
                  case m.a.KEY_LOAD_ERROR:
                  case m.a.KEY_LOAD_TIMEOUT:
                    if (!n.fatal)
                      if (this.fragLoadError + 1 <= this.config.fragLoadingMaxRetry) {
                        var g = Math.min(Math.pow(2, this.fragLoadError) * this.config.fragLoadingRetryDelay, this.config.fragLoadingMaxRetryTimeout);
                        l.loadCounter = 0, d.b.warn("mediaController: frag loading failed, retry in " + g + " ms"), this.retryDate = performance.now() + g, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.fragLoadError++, this.state = W.FRAG_LOADING_WAITING_RETRY;
                      } else
                        d.b.error("mediaController: " + n.details + " reaches max retry, redispatch as fatal ..."), n.fatal = !0, this.state = W.ERROR;
                    break;
                  case m.a.FRAG_LOOP_LOADING_ERROR:
                    n.fatal || (c ? (this._reduceMaxBufferLength(l.duration), this.state = W.IDLE) : (!l.autoLevel || l.level === 0) && (n.fatal = !0, this.state = W.ERROR));
                    break;
                  case m.a.LEVEL_LOAD_ERROR:
                  case m.a.LEVEL_LOAD_TIMEOUT:
                    this.state !== W.ERROR && (n.fatal ? (this.state = W.ERROR, d.b.warn("streamController: " + n.details + ",switch to " + this.state + " state ...")) : !n.levelRetry && this.state === W.WAITING_LEVEL && (this.state = W.IDLE));
                    break;
                  case m.a.BUFFER_FULL_ERROR:
                    n.parent === "main" && (this.state === W.PARSING || this.state === W.PARSED) && (c ? (this._reduceMaxBufferLength(this.config.maxBufferLength), this.state = W.IDLE) : (d.b.warn("buffer full error also media.currentTime is not buffered, flush everything"), this.fragCurrent = null, this.flushMainBuffer(0, Number.POSITIVE_INFINITY)));
                    break;
                }
              }
            }, s.prototype._reduceMaxBufferLength = function(n) {
              var l = this.config;
              l.maxMaxBufferLength >= n && (l.maxMaxBufferLength /= 2, d.b.warn("main:reduce max buffer length to " + l.maxMaxBufferLength + "s"), this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * l.fragLoadingLoopThreshold));
            }, s.prototype._checkBuffer = function() {
              var n = this.media, l = this.config;
              if (n && n.readyState) {
                var c = n.currentTime, g = this.mediaBuffer ? this.mediaBuffer : n, w = g.buffered;
                if (!this.loadedmetadata && w.length) {
                  this.loadedmetadata = !0;
                  var A = n.seeking ? c : this.startPosition, D = ot.isBuffered(g, A), K = w.start(0), j = !D && Math.abs(A - K) < l.maxSeekHole;
                  (c !== A || j) && (d.b.log("target start position:" + A), j && (A = K, d.b.log("target start position not buffered, seek to buffered.start(0) " + A)), d.b.log("adjust currentTime from " + c + " to " + A), n.currentTime = A);
                } else if (this.immediateSwitch)
                  this.immediateLevelSwitchEnd();
                else {
                  var q = ot.bufferInfo(n, c, 0), Y = !(n.paused || // not playing when media is paused
                  n.ended || // not playing when media is ended
                  n.buffered.length === 0), ue = 0.5, me = c !== this.lastCurrentTime;
                  if (me)
                    this.stallReported && (d.b.warn("playback not stuck anymore @" + c + ", after " + Math.round(performance.now() - this.stalled) + "ms"), this.stallReported = !1), this.stalled = void 0, this.nudgeRetry = 0;
                  else if (Y) {
                    var Re = performance.now(), be = this.hls;
                    if (!this.stalled)
                      this.stalled = Re, this.stallReported = !1;
                    else {
                      var Pe = Re - this.stalled, ke = q.len, Ke = this.nudgeRetry || 0;
                      if (ke <= ue && Pe > l.lowBufferWatchdogPeriod * 1e3) {
                        this.stallReported || (this.stallReported = !0, d.b.warn("playback stalling in low buffer @" + c), be.trigger(m.a.ERROR, { type: h.b.MEDIA_ERROR, details: h.a.BUFFER_STALLED_ERROR, fatal: !1, buffer: ke }));
                        var mt = q.nextStart, gt = mt - c;
                        if (mt && gt < l.maxSeekHole && gt > 0) {
                          this.nudgeRetry = ++Ke;
                          var Le = Ke * l.nudgeOffset;
                          d.b.log("adjust currentTime from " + n.currentTime + " to next buffered @ " + mt + " + nudge " + Le), n.currentTime = mt + Le, this.stalled = void 0, be.trigger(m.a.ERROR, { type: h.b.MEDIA_ERROR, details: h.a.BUFFER_SEEK_OVER_HOLE, fatal: !1, hole: mt + Le - c });
                        }
                      } else if (ke > ue && Pe > l.highBufferWatchdogPeriod * 1e3)
                        if (this.stallReported || (this.stallReported = !0, d.b.warn("playback stalling in high buffer @" + c), be.trigger(m.a.ERROR, { type: h.b.MEDIA_ERROR, details: h.a.BUFFER_STALLED_ERROR, fatal: !1, buffer: ke })), this.stalled = void 0, this.nudgeRetry = ++Ke, Ke < l.nudgeMaxRetry) {
                          var $t = n.currentTime, bt = $t + Ke * l.nudgeOffset;
                          d.b.log("adjust currentTime from " + $t + " to " + bt), n.currentTime = bt, be.trigger(m.a.ERROR, { type: h.b.MEDIA_ERROR, details: h.a.BUFFER_NUDGE_ON_STALL, fatal: !1 });
                        } else
                          d.b.error("still stuck in high buffer @" + c + " after " + l.nudgeMaxRetry + ", raise fatal error"), be.trigger(m.a.ERROR, { type: h.b.MEDIA_ERROR, details: h.a.BUFFER_STALLED_ERROR, fatal: !0 });
                    }
                  }
                }
              }
            }, s.prototype.onFragLoadEmergencyAborted = function() {
              this.state = W.IDLE, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tick();
            }, s.prototype.onBufferFlushed = function() {
              var n = this.mediaBuffer ? this.mediaBuffer : this.media;
              this._bufferedFrags = this._bufferedFrags.filter(function(l) {
                return ot.isBuffered(n, (l.startPTS + l.endPTS) / 2);
              }), this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold), this.state = W.IDLE, this.fragPrevious = null;
            }, s.prototype.swapAudioCodec = function() {
              this.audioCodecSwap = !this.audioCodecSwap;
            }, s.prototype.computeLivePosition = function(n, l) {
              var c = this.config.liveSyncDuration !== void 0 ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * l.targetduration;
              return n + Math.max(0, l.totalduration - c);
            }, se(s, [{
              key: "state",
              set: function(n) {
                if (this.state !== n) {
                  var l = this.state;
                  this._state = n, d.b.log("main stream:" + l + "->" + n), this.hls.trigger(h.a.STREAM_STATE_TRANSITION, { previousState: l, nextState: n });
                }
              },
              get: function() {
                return this._state;
              }
            }, {
              key: "currentLevel",
              get: function() {
                var n = this.media;
                if (n) {
                  var l = this.getBufferedFrag(n.currentTime);
                  if (l)
                    return l.level;
                }
                return -1;
              }
            }, {
              key: "nextBufferedFrag",
              get: function() {
                var n = this.media;
                return n ? this.followingBufferedFrag(this.getBufferedFrag(n.currentTime)) : null;
              }
            }, {
              key: "nextLevel",
              get: function() {
                var n = this.nextBufferedFrag;
                return n ? n.level : -1;
              }
            }, {
              key: "liveSyncPosition",
              get: function() {
                return this._liveSyncPosition;
              },
              set: function(n) {
                this._liveSyncPosition = n;
              }
            }]), s;
          }(I), tt = Oe, rt = /* @__PURE__ */ function() {
            function E(s, o) {
              for (var n = 0; n < o.length; n++) {
                var l = o[n];
                l.enumerable = l.enumerable || !1, l.configurable = !0, "value" in l && (l.writable = !0), Object.defineProperty(s, l.key, l);
              }
            }
            return function(s, o, n) {
              return o && E(s.prototype, o), n && E(s, n), s;
            };
          }();
          function Xe(E, s) {
            if (!(E instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function Ye(E, s) {
            if (!E)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : E;
          }
          function Le(E, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            E.prototype = Object.create(s && s.prototype, { constructor: { value: E, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(E, s) : E.__proto__ = s);
          }
          var ut = function(E) {
            Se(s, E);
            function s(o) {
              Xe(this, s);
              var n = Ye(this, E.call(this, o, m.a.MANIFEST_LOADED, m.a.LEVEL_LOADED, m.a.FRAG_LOADED, m.a.ERROR));
              return n._manualLevel = -1, n.timer = null, n;
            }
            return s.prototype.destroy = function() {
              this.cleanTimer(), this._manualLevel = -1;
            }, s.prototype.cleanTimer = function() {
              this.timer !== null && (clearTimeout(this.timer), this.timer = null);
            }, s.prototype.startLoad = function() {
              var n = this._levels;
              this.canload = !0, this.levelRetryCount = 0, n && n.forEach(function(l) {
                l.loadError = 0;
                var c = l.details;
                c && c.live && (l.details = void 0);
              }), this.timer && this.tick();
            }, s.prototype.stopLoad = function() {
              this.canload = !1;
            }, s.prototype.onManifestLoaded = function(n) {
              var l = [], c = void 0, g = {}, w = null, A = !1, D = !1, K = /chrome|firefox/.test(navigator.userAgent.toLowerCase());
              if (n.levels.forEach(function(q) {
                q.loadError = 0, q.fragmentError = !1, A = A || !!q.videoCodec, D = D || !!q.audioCodec || !!(q.attrs && q.attrs.AUDIO), K === !0 && q.audioCodec && q.audioCodec.indexOf("mp4a.40.34") !== -1 && (q.audioCodec = void 0), w = g[q.bitrate], w === void 0 ? (q.url = [q.url], q.urlId = 0, g[q.bitrate] = q, l.push(q)) : w.url.push(q.url);
              }), A === !0 && D === !0 && (l = l.filter(function(q) {
                var J = q.videoCodec;
                return !!J;
              })), l = l.filter(function(q) {
                var Y = q.audioCodec, ue = q.videoCodec;
                return (!Y || ve(Y)) && (!ue || ve(ue));
              }), l.length > 0) {
                c = l[0].bitrate, l.sort(function(q, J) {
                  return q.bitrate - J.bitrate;
                }), this._levels = l;
                for (var M = 0; M < l.length; M++)
                  if (l[M].bitrate === c) {
                    this._firstLevel = M, d.b.log("manifest loaded," + l.length + " level(s) found, first bitrate:" + c);
                    break;
                  }
                this.hls.trigger(h.a.MANIFEST_PARSED, {
                  levels: l,
                  firstLevel: this._firstLevel,
                  stats: n.stats,
                  audio: D,
                  video: A,
                  altAudio: n.audioTracks.length > 0
                });
              } else
                this.hls.trigger(h.a.ERROR, {
                  type: m.b.MEDIA_ERROR,
                  details: m.a.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
                  fatal: !0,
                  url: this.hls.url,
                  reason: "no level with compatible codecs found in manifest"
                });
            }, s.prototype.setLevelInternal = function(n) {
              var l = this._levels, c = this.hls;
              if (n >= 0 && n < l.length) {
                if (this.cleanTimer(), this._level !== n) {
                  d.b.log("switching to level " + n), this._level = n;
                  var g = l[n];
                  g.level = n, c.trigger(h.a.LEVEL_SWITCH, g), c.trigger(h.a.LEVEL_SWITCHING, g);
                }
                var w = l[n], A = w.details;
                if (!A || A.live === !0) {
                  var D = w.urlId;
                  c.trigger(m.a.LEVEL_LOADING, { url: w.url[D], level: n, id: D });
                }
              } else
                c.trigger(h.a.ERROR, { type: m.b.OTHER_ERROR, details: m.a.LEVEL_SWITCH_ERROR, level: n, fatal: !1, reason: "invalid level idx" });
            }, s.prototype.onError = function(n) {
              var l = this;
              if (n.fatal === !0) {
                n.type === m.b.NETWORK_ERROR && this.cleanTimer();
                return;
              }
              var c = n.details, g = !1, w = !1, A = void 0, D = void 0, K = this.hls.config;
              switch (c) {
                case h.a.FRAG_LOAD_ERROR:
                case h.a.FRAG_LOAD_TIMEOUT:
                case h.a.FRAG_LOOP_LOADING_ERROR:
                case h.a.KEY_LOAD_ERROR:
                case h.a.KEY_LOAD_TIMEOUT:
                  A = n.frag.level, w = !0;
                  break;
                case m.a.LEVEL_LOAD_ERROR:
                case m.a.LEVEL_LOAD_TIMEOUT:
                  A = n.context.level, g = !0;
                  break;
                case m.a.REMUX_ALLOC_ERROR:
                  A = n.level;
                  break;
              }
              if (A !== void 0) {
                if (D = this._levels[A], D.loadError++, D.fragmentError = w, w === !0) {
                  var j = D.url.length;
                  j > 1 && D.loadError < j ? (D.urlId = (D.urlId + 1) % j, D.details = void 0, d.b.warn("level controller," + c + " for level " + A + ": switching to redundant stream id " + D.urlId)) : this._manualLevel === -1 && A !== 0 ? (d.b.warn("level controller," + c + ": switch-down for next fragment"), this.hls.nextAutoLevel = A - 1) : (d.b.warn("level controller, " + c + ": reload a fragment"), this._level = void 0);
                } else if (g === !0)
                  if (this.levelRetryCount + 1 <= K.levelLoadingMaxRetry) {
                    var q = Math.min(Math.pow(2, this.levelRetryCount) * K.levelLoadingRetryDelay, K.levelLoadingMaxRetryTimeout);
                    this.timer = setTimeout(function() {
                      return l.tick();
                    }, q), n.levelRetry = !0, this.levelRetryCount++, d.b.warn("level controller," + c + ", retry in " + q + " ms, current retry count is " + this.levelRetryCount);
                  } else
                    d.b.error("cannot recover " + c + " error"), this._level = void 0, this.cleanTimer(), n.fatal = !0;
              }
            }, s.prototype.onFragLoaded = function(n) {
              var l = n.frag;
              if (l !== void 0 && l.type === "main") {
                var c = this._levels[l.level];
                c !== void 0 && (c.fragmentError = !1, c.loadError = 0, this.levelRetryCount = 0);
              }
            }, s.prototype.onLevelLoaded = function(n) {
              var l = this, c = n.level;
              if (c === this._level) {
                var g = this._levels[c];
                g.fragmentError === !1 && (g.loadError = 0, this.levelRetryCount = 0);
                var w = n.details;
                if (w.live) {
                  var A = 1e3 * (w.averagetargetduration ? w.averagetargetduration : w.targetduration), D = g.details;
                  D && w.endSN === D.endSN && (A /= 2, d.b.log("same live playlist, reload twice faster")), A -= performance.now() - n.stats.trequest, A = Math.max(1e3, Math.round(A)), d.b.log("live playlist, reload in " + A + " ms"), this.timer = setTimeout(function() {
                    return l.tick();
                  }, A);
                } else
                  this.cleanTimer();
              }
            }, s.prototype.tick = function() {
              var n = this._level;
              if (n !== void 0 && this.canload) {
                var l = this._levels[n];
                if (l && l.url) {
                  var c = l.urlId;
                  this.hls.trigger(h.a.LEVEL_LOADING, { url: l.url[c], level: n, id: c });
                }
              }
            }, rt(s, [{
              key: "levels",
              get: function() {
                return this._levels;
              }
            }, {
              key: "level",
              get: function() {
                return this._level;
              },
              set: function(n) {
                var l = this._levels;
                l && (n = Math.min(n, l.length - 1), (this._level !== n || l[n].details === void 0) && this.setLevelInternal(n));
              }
            }, {
              key: "manualLevel",
              get: function() {
                return this._manualLevel;
              },
              set: function(n) {
                this._manualLevel = n, this._startLevel === void 0 && (this._startLevel = n), n !== -1 && (this.level = n);
              }
            }, {
              key: "firstLevel",
              get: function() {
                return this._firstLevel;
              },
              set: function(n) {
                this._firstLevel = n;
              }
            }, {
              key: "startLevel",
              get: function() {
                if (this._startLevel === void 0) {
                  var n = this.hls.config.startLevel;
                  return n !== void 0 ? n : this._firstLevel;
                } else
                  return this._startLevel;
              },
              set: function(n) {
                this._startLevel = n;
              }
            }, {
              key: "nextLoadLevel",
              get: function() {
                return this._manualLevel !== -1 ? this._manualLevel : this.hls.nextAutoLevel;
              },
              set: function(n) {
                this.level = n, this._manualLevel === -1 && (this.hls.nextAutoLevel = n);
              }
            }]), s;
          }(I), _t = ut, ft = u(4);
          function Et(E, s) {
            if (!(E instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function Dt(E, s) {
            if (!E)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : E;
          }
          function Jt(E, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            E.prototype = Object.create(s && s.prototype, { constructor: { value: E, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(E, s) : E.__proto__ = s);
          }
          var Pt = function(E) {
            Jt(s, E);
            function s(o) {
              Et(this, s);
              var n = Dt(this, E.call(this, o, h.a.MEDIA_ATTACHED, h.a.MEDIA_DETACHING, h.a.FRAG_PARSING_METADATA));
              return n.id3Track = void 0, n.media = void 0, n;
            }
            return s.prototype.destroy = function() {
              I.prototype.destroy.call(this);
            }, s.prototype.onMediaAttached = function(n) {
              this.media = n.media, this.media;
            }, s.prototype.onMediaDetaching = function() {
              this.media = void 0;
            }, s.prototype.onFragParsingMetadata = function(n) {
              var l = n.frag, c = n.samples;
              this.id3Track || (this.id3Track = this.media.addTextTrack("metadata", "id3"), this.id3Track.mode = "hidden");
              for (var g = window.WebKitDataCue || window.VTTCue || window.TextTrackCue, w = 0; w < c.length; w++) {
                var A = ft.a.getID3Frames(c[w].data);
                if (A) {
                  var D = c[w].pts, K = w < c.length - 1 ? c[w + 1].pts : l.endPTS;
                  D === K && (K += 1e-4);
                  for (var j = 0; j < A.length; j++) {
                    var q = A[j];
                    if (!ft.a.isTimeStampFrame(q)) {
                      var Y = new g(D, K, "");
                      Y.value = q, this.id3Track.addCue(Y);
                    }
                  }
                }
              }
            }, s;
          }(I), cr = Pt;
          function jt(E, s) {
            if (!(E instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          var Qt = function() {
            function E(s) {
              jt(this, E), this.alpha_ = s ? Math.exp(Math.log(0.5) / s) : 0, this.estimate_ = 0, this.totalWeight_ = 0;
            }
            return E.prototype.sample = function(o, n) {
              var l = Math.pow(this.alpha_, o);
              this.estimate_ = n * (1 - l) + l * this.estimate_, this.totalWeight_ += o;
            }, E.prototype.getTotalWeight = function() {
              return this.totalWeight_;
            }, E.prototype.getEstimate = function() {
              if (this.alpha_) {
                var o = 1 - Math.pow(this.alpha_, this.totalWeight_);
                return this.estimate_ / o;
              } else
                return this.estimate_;
            }, E;
          }(), kr = Qt;
          function zr(E, s) {
            if (!(E instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          var di = function() {
            function E(s, o, n, l) {
              zr(this, E), this.hls = s, this.defaultEstimate_ = l, this.minWeight_ = 1e-3, this.minDelayMs_ = 50, this.slow_ = new kr(o), this.fast_ = new kr(n);
            }
            return E.prototype.sample = function(o, n) {
              o = Math.max(o, this.minDelayMs_);
              var l = 8e3 * n / o, c = o / 1e3;
              this.fast_.sample(c, l), this.slow_.sample(c, l);
            }, E.prototype.canEstimate = function() {
              var o = this.fast_;
              return o && o.getTotalWeight() >= this.minWeight_;
            }, E.prototype.getEstimate = function() {
              return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_;
            }, E.prototype.destroy = function() {
            }, E;
          }(), Ft = di, Tt = /* @__PURE__ */ function() {
            function E(s, o) {
              for (var n = 0; n < o.length; n++) {
                var l = o[n];
                l.enumerable = l.enumerable || !1, l.configurable = !0, "value" in l && (l.writable = !0), Object.defineProperty(s, l.key, l);
              }
            }
            return function(s, o, n) {
              return o && E(s.prototype, o), n && E(s, n), s;
            };
          }();
          function Rr(E, s) {
            if (!(E instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function Vr(E, s) {
            if (!E)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : E;
          }
          function Pr(E, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            E.prototype = Object.create(s && s.prototype, { constructor: { value: E, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(E, s) : E.__proto__ = s);
          }
          var pi = function(E) {
            Pr(s, E);
            function s(o) {
              Rr(this, s);
              var n = Vr(this, E.call(this, o, h.a.FRAG_LOADING, h.a.FRAG_LOADED, h.a.FRAG_BUFFERED, h.a.ERROR));
              return n.lastLoadedFragLevel = 0, n._nextAutoLevel = -1, n.hls = o, n.timer = null, n._bwEstimator = null, n.onCheck = n._abandonRulesCheck.bind(n), n;
            }
            return s.prototype.destroy = function() {
              this.clearTimer(), I.prototype.destroy.call(this);
            }, s.prototype.onFragLoading = function(n) {
              var l = n.frag;
              if (l.type === "main") {
                if (this.timer || (this.timer = setInterval(this.onCheck, 100)), !this._bwEstimator) {
                  var c = this.hls, g = n.frag.level, w = c.levels[g].details.live, A = c.config, D = void 0, K = void 0;
                  w ? (D = A.abrEwmaFastLive, K = A.abrEwmaSlowLive) : (D = A.abrEwmaFastVoD, K = A.abrEwmaSlowVoD), this._bwEstimator = new Ft(c, K, D, A.abrEwmaDefaultEstimate);
                }
                this.fragCurrent = l;
              }
            }, s.prototype._abandonRulesCheck = function() {
              var n = this.hls, l = n.media, c = this.fragCurrent, g = c.loader, w = n.minAutoLevel;
              if (!g || g.stats && g.stats.aborted) {
                d.b.warn("frag loader destroy or aborted, disarm abandonRules"), this.clearTimer();
                return;
              }
              var A = g.stats;
              if (l && A && (!l.paused && l.playbackRate !== 0 || !l.readyState) && c.autoLevel && c.level) {
                var D = performance.now() - A.trequest, K = Math.abs(l.playbackRate);
                if (D > 500 * c.duration / K) {
                  var j = n.levels, q = Math.max(1, A.bw ? A.bw / 8 : A.loaded * 1e3 / D), Y = j[c.level], ue = Y.realBitrate ? Math.max(Y.realBitrate, Y.bitrate) : Y.bitrate, me = A.total ? A.total : Math.max(A.loaded, Math.round(c.duration * ue / 8)), Re = l.currentTime, be = (me - A.loaded) / q, Pe = (ot.bufferInfo(l, Re, n.config.maxBufferHole).end - Re) / K;
                  if (Pe < 2 * c.duration / K && be > Pe) {
                    var ke = void 0, Ke = void 0;
                    for (Ke = c.level - 1; Ke > w; Ke--) {
                      var mt = j[Ke].realBitrate ? Math.max(j[Ke].realBitrate, j[Ke].bitrate) : j[Ke].bitrate;
                      if (ke = c.duration * mt / (8 * 0.8 * q), ke < Pe)
                        break;
                    }
                    ke < be && (d.b.warn("loading too slow, abort fragment loading and switch to level " + Ke + ":fragLoadedDelay[" + Ke + "]<fragLoadedDelay[" + (c.level - 1) + "];bufferStarvationDelay:" + ke.toFixed(1) + "<" + be.toFixed(1) + ":" + Pe.toFixed(1)), n.nextLoadLevel = Ke, this._bwEstimator.sample(D, A.loaded), g.abort(), this.clearTimer(), n.trigger(m.a.FRAG_LOAD_EMERGENCY_ABORTED, { frag: c, stats: A }));
                  }
                }
              }
            }, s.prototype.onFragLoaded = function(n) {
              var l = n.frag;
              if (l.type === "main" && !isNaN(l.sn)) {
                if (this.clearTimer(), this.lastLoadedFragLevel = l.level, this._nextAutoLevel = -1, this.hls.config.abrMaxWithRealBitrate) {
                  var c = this.hls.levels[l.level], g = (c.loaded ? c.loaded.bytes : 0) + n.stats.loaded, w = (c.loaded ? c.loaded.duration : 0) + n.frag.duration;
                  c.loaded = { bytes: g, duration: w }, c.realBitrate = Math.round(8 * g / w);
                }
                if (n.frag.bitrateTest) {
                  var A = n.stats;
                  A.tparsed = A.tbuffered = A.tload, this.onFragBuffered(n);
                }
              }
            }, s.prototype.onFragBuffered = function(n) {
              var l = n.stats, c = n.frag;
              if (l.aborted !== !0 && c.loadCounter === 1 && c.type === "main" && !isNaN(c.sn) && (!c.bitrateTest || l.tload === l.tbuffered)) {
                var g = l.tparsed - l.trequest;
                d.b.log("latency/loading/parsing/append/kbps:" + Math.round(l.tfirst - l.trequest) + "/" + Math.round(l.tload - l.tfirst) + "/" + Math.round(l.tparsed - l.tload) + "/" + Math.round(l.tbuffered - l.tparsed) + "/" + Math.round(8 * l.loaded / (l.tbuffered - l.trequest))), this._bwEstimator.sample(g, l.loaded), l.bwEstimate = this._bwEstimator.getEstimate(), c.bitrateTest ? this.bitrateTestDelay = g / 1e3 : this.bitrateTestDelay = 0;
              }
            }, s.prototype.onError = function(n) {
              switch (n.details) {
                case m.a.FRAG_LOAD_ERROR:
                case m.a.FRAG_LOAD_TIMEOUT:
                  this.clearTimer();
                  break;
              }
            }, s.prototype.clearTimer = function() {
              clearInterval(this.timer), this.timer = null;
            }, s.prototype._findBestLevel = function(n, l, c, g, w, A, D, K, j) {
              for (var q = w; q >= g; q--) {
                var Y = j[q], ue = Y.details, me = ue ? ue.totalduration / ue.fragments.length : l, Re = ue ? ue.live : !1, be = void 0;
                q <= n ? be = D * c : be = K * c;
                var Pe = j[q].realBitrate ? Math.max(j[q].realBitrate, j[q].bitrate) : j[q].bitrate, ke = Pe * me / be;
                if (d.b.trace("level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: " + q + "/" + Math.round(be) + "/" + Pe + "/" + me + "/" + A + "/" + ke), be > Pe && // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
                // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
                // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that _findBestLevel will return -1
                (!ke || Re && !this.bitrateTestDelay || ke < A))
                  return q;
              }
              return -1;
            }, Tt(s, [{
              key: "nextAutoLevel",
              get: function() {
                var n = this._nextAutoLevel, l = this._bwEstimator;
                if (n !== -1 && (!l || !l.canEstimate()))
                  return n;
                var c = this._nextABRAutoLevel;
                return n !== -1 && (c = Math.min(n, c)), c;
              },
              set: function(n) {
                this._nextAutoLevel = n;
              }
            }, {
              key: "_nextABRAutoLevel",
              get: function() {
                var n = this.hls, l = n.maxAutoLevel, c = n.levels, g = n.config, w = n.minAutoLevel, A = n.media, D = this.lastLoadedFragLevel, K = this.fragCurrent ? this.fragCurrent.duration : 0, j = A ? A.currentTime : 0, q = A && A.playbackRate !== 0 ? Math.abs(A.playbackRate) : 1, Y = this._bwEstimator ? this._bwEstimator.getEstimate() : g.abrEwmaDefaultEstimate, ue = (ot.bufferInfo(A, j, g.maxBufferHole).end - j) / q, me = this._findBestLevel(D, K, Y, w, l, ue, g.abrBandWidthFactor, g.abrBandWidthUpFactor, c);
                if (me >= 0)
                  return me;
                d.b.trace("rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering");
                var Re = K ? Math.min(K, g.maxStarvationDelay) : g.maxStarvationDelay, be = g.abrBandWidthFactor, Pe = g.abrBandWidthUpFactor;
                if (ue === 0) {
                  var ke = this.bitrateTestDelay;
                  if (ke) {
                    var Ke = K ? Math.min(K, g.maxLoadingDelay) : g.maxLoadingDelay;
                    Re = Ke - ke, d.b.trace("bitrate test took " + Math.round(1e3 * ke) + "ms, set first fragment max fetchDuration to " + Math.round(1e3 * Re) + " ms"), be = Pe = 1;
                  }
                }
                return me = this._findBestLevel(D, K, Y, w, l, ue + Re, be, Pe, c), Math.max(me, 0);
              }
            }]), s;
          }(I), Vi = pi;
          function hi(E, s) {
            if (!(E instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function mi(E, s) {
            if (!E)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : E;
          }
          function Br(E, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            E.prototype = Object.create(s && s.prototype, { constructor: { value: E, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(E, s) : E.__proto__ = s);
          }
          var Hr = Nr(), Ir = function(E) {
            Br(s, E);
            function s(o) {
              hi(this, s);
              var n = mi(this, E.call(this, o, h.a.MEDIA_ATTACHING, h.a.MEDIA_DETACHING, h.a.MANIFEST_PARSED, h.a.BUFFER_RESET, h.a.BUFFER_APPENDING, h.a.BUFFER_CODECS, h.a.BUFFER_EOS, h.a.BUFFER_FLUSHING, h.a.LEVEL_PTS_UPDATED, h.a.LEVEL_UPDATED));
              return n._msDuration = null, n._levelDuration = null, n.onsbue = n.onSBUpdateEnd.bind(n), n.onsbe = n.onSBUpdateError.bind(n), n.pendingTracks = {}, n.tracks = {}, n;
            }
            return s.prototype.destroy = function() {
              I.prototype.destroy.call(this);
            }, s.prototype.onLevelPtsUpdated = function(n) {
              var l = n.type, c = this.tracks.audio;
              if (l === "audio" && c && c.container === "audio/mpeg") {
                var g = this.sourceBuffer.audio, w = Math.abs(g.timestampOffset - n.start);
                if (w > 0.1) {
                  var A = g.updating;
                  try {
                    g.abort();
                  } catch (D) {
                    A = !0, d.b.warn("can not abort audio buffer: " + D);
                  }
                  A ? this.audioTimestampOffset = n.start : (d.b.warn("change mpeg audio timestamp offset from " + g.timestampOffset + " to " + n.start), g.timestampOffset = n.start);
                }
              }
            }, s.prototype.onManifestParsed = function(n) {
              var l = n.audio, c = n.video || n.levels.length && n.audio, g = 0;
              n.altAudio && (l || c) && (g = (l ? 1 : 0) + (c ? 1 : 0), d.b.log(g + " sourceBuffer(s) expected")), this.sourceBufferNb = g;
            }, s.prototype.onMediaAttaching = function(n) {
              var l = this.media = n.media;
              if (l) {
                var c = this.mediaSource = new Hr();
                this.onmso = this.onMediaSourceOpen.bind(this), this.onmse = this.onMediaSourceEnded.bind(this), this.onmsc = this.onMediaSourceClose.bind(this), c.addEventListener("sourceopen", this.onmso), c.addEventListener("sourceended", this.onmse), c.addEventListener("sourceclose", this.onmsc), l.src = URL.createObjectURL(c);
              }
            }, s.prototype.onMediaDetaching = function() {
              d.b.log("media source detaching");
              var n = this.mediaSource;
              if (n) {
                if (n.readyState === "open")
                  try {
                    n.endOfStream();
                  } catch (l) {
                    d.b.warn("onMediaDetaching:" + l.message + " while calling endOfStream");
                  }
                n.removeEventListener("sourceopen", this.onmso), n.removeEventListener("sourceended", this.onmse), n.removeEventListener("sourceclose", this.onmsc), this.media && (URL.revokeObjectURL(this.media.src), this.media.removeAttribute("src"), this.media.load()), this.mediaSource = null, this.media = null, this.pendingTracks = {}, this.tracks = {}, this.sourceBuffer = {}, this.flushRange = [], this.segments = [], this.appended = 0;
              }
              this.onmso = this.onmse = this.onmsc = null, this.hls.trigger(h.a.MEDIA_DETACHED);
            }, s.prototype.onMediaSourceOpen = function() {
              d.b.log("media source opened"), this.hls.trigger(h.a.MEDIA_ATTACHED, { media: this.media });
              var n = this.mediaSource;
              n && n.removeEventListener("sourceopen", this.onmso), this.checkPendingTracks();
            }, s.prototype.checkPendingTracks = function() {
              var n = this.pendingTracks, l = Object.keys(n).length;
              l && (this.sourceBufferNb <= l || this.sourceBufferNb === 0) && (this.createSourceBuffers(n), this.pendingTracks = {}, this.doAppending());
            }, s.prototype.onMediaSourceClose = function() {
              d.b.log("media source closed");
            }, s.prototype.onMediaSourceEnded = function() {
              d.b.log("media source ended");
            }, s.prototype.onSBUpdateEnd = function() {
              if (this.audioTimestampOffset) {
                var n = this.sourceBuffer.audio;
                d.b.warn("change mpeg audio timestamp offset from " + n.timestampOffset + " to " + this.audioTimestampOffset), n.timestampOffset = this.audioTimestampOffset, delete this.audioTimestampOffset;
              }
              this._needsFlush && this.doFlush(), this._needsEos && this.checkEos(), this.appending = !1;
              var l = this.parent, c = this.segments.reduce(function(g, w) {
                return w.parent === l ? g + 1 : g;
              }, 0);
              this.hls.trigger(h.a.BUFFER_APPENDED, { parent: l, pending: c }), this._needsFlush || this.doAppending(), this.updateMediaElementDuration();
            }, s.prototype.onSBUpdateError = function(n) {
              d.b.error("sourceBuffer error:", n), this.hls.trigger(h.a.ERROR, { type: m.b.MEDIA_ERROR, details: m.a.BUFFER_APPENDING_ERROR, fatal: !1 });
            }, s.prototype.onBufferReset = function() {
              var n = this.sourceBuffer;
              for (var l in n) {
                var c = n[l];
                try {
                  this.mediaSource.removeSourceBuffer(c), c.removeEventListener("updateend", this.onsbue), c.removeEventListener("error", this.onsbe);
                } catch {
                }
              }
              this.sourceBuffer = {}, this.flushRange = [], this.segments = [], this.appended = 0;
            }, s.prototype.onBufferCodecs = function(n) {
              if (Object.keys(this.sourceBuffer).length === 0) {
                for (var l in n)
                  this.pendingTracks[l] = n[l];
                var c = this.mediaSource;
                c && c.readyState === "open" && this.checkPendingTracks();
              }
            }, s.prototype.createSourceBuffers = function(n) {
              var l = this.sourceBuffer, c = this.mediaSource;
              for (var g in n)
                if (!l[g]) {
                  var w = n[g], A = w.levelCodec || w.codec, D = w.container + ";codecs=" + A;
                  d.b.log("creating sourceBuffer(" + D + ")");
                  try {
                    var K = l[g] = c.addSourceBuffer(D);
                    K.addEventListener("updateend", this.onsbue), K.addEventListener("error", this.onsbe), this.tracks[g] = { codec: A, container: w.container }, w.buffer = K;
                  } catch (j) {
                    d.b.error("error while trying to add sourceBuffer:" + j.message), this.hls.trigger(m.a.ERROR, { type: h.b.MEDIA_ERROR, details: h.a.BUFFER_ADD_CODEC_ERROR, fatal: !1, err: j, mimeType: D });
                  }
                }
              this.hls.trigger(h.a.BUFFER_CREATED, { tracks: n });
            }, s.prototype.onBufferAppending = function(n) {
              this._needsFlush || (this.segments ? this.segments.push(n) : this.segments = [n], this.doAppending());
            }, s.prototype.onBufferAppendFail = function(n) {
              d.b.error("sourceBuffer error:", n.event), this.hls.trigger(h.a.ERROR, { type: m.b.MEDIA_ERROR, details: m.a.BUFFER_APPENDING_ERROR, fatal: !1 });
            }, s.prototype.onBufferEos = function(n) {
              var l = this.sourceBuffer, c = n.type;
              for (var g in l)
                (!c || g === c) && (l[g].ended || (l[g].ended = !0, d.b.log(g + " sourceBuffer now EOS")));
              this.checkEos();
            }, s.prototype.checkEos = function() {
              var n = this.sourceBuffer, l = this.mediaSource;
              if (!l || l.readyState !== "open") {
                this._needsEos = !1;
                return;
              }
              for (var c in n) {
                var g = n[c];
                if (!g.ended)
                  return;
                if (g.updating) {
                  this._needsEos = !0;
                  return;
                }
              }
              d.b.log("all media data available, signal endOfStream() to MediaSource and stop loading fragment");
              try {
                l.endOfStream();
              } catch {
                d.b.warn("exception while calling mediaSource.endOfStream()");
              }
              this._needsEos = !1;
            }, s.prototype.onBufferFlushing = function(n) {
              this.flushRange.push({ start: n.startOffset, end: n.endOffset, type: n.type }), this.flushBufferCounter = 0, this.doFlush();
            }, s.prototype.onLevelUpdated = function(n) {
              var l = n.details;
              l.fragments.length !== 0 && (this._levelDuration = l.totalduration + l.fragments[0].start, this.updateMediaElementDuration());
            }, s.prototype.updateMediaElementDuration = function() {
              var n = this.media, l = this.mediaSource, c = this.sourceBuffer, g = this._levelDuration;
              if (!(g === null || !n || !l || !c || n.readyState === 0 || l.readyState !== "open")) {
                for (var w in c)
                  if (c[w].updating)
                    return;
                this._msDuration === null && (this._msDuration = l.duration);
                var A = n.duration;
                (g > this._msDuration && g > A || A === 1 / 0 || isNaN(A)) && (d.b.log("Updating mediasource duration to " + g.toFixed(3)), this._msDuration = l.duration = g);
              }
            }, s.prototype.doFlush = function() {
              for (; this.flushRange.length; ) {
                var n = this.flushRange[0];
                if (this.flushBuffer(n.start, n.end, n.type))
                  this.flushRange.shift(), this.flushBufferCounter = 0;
                else {
                  this._needsFlush = !0;
                  return;
                }
              }
              if (this.flushRange.length === 0) {
                this._needsFlush = !1;
                var l = 0, c = this.sourceBuffer;
                try {
                  for (var g in c)
                    l += c[g].buffered.length;
                } catch {
                  d.b.error("error while accessing sourceBuffer.buffered");
                }
                this.appended = l, this.hls.trigger(h.a.BUFFER_FLUSHED);
              }
            }, s.prototype.doAppending = function() {
              var n = this.hls, l = this.sourceBuffer, c = this.segments;
              if (Object.keys(l).length) {
                if (this.media.error) {
                  this.segments = [], d.b.error("trying to append although a media error occured, flush segment and abort");
                  return;
                }
                if (this.appending)
                  return;
                if (c && c.length) {
                  var g = c.shift();
                  try {
                    var w = g.type, A = l[w];
                    A ? A.updating ? c.unshift(g) : (A.ended = !1, this.parent = g.parent, A.appendBuffer(g.data), this.appendError = 0, this.appended++, this.appending = !0) : this.onSBUpdateEnd();
                  } catch (K) {
                    d.b.error("error while trying to append buffer:" + K.message), c.unshift(g);
                    var D = { type: m.b.MEDIA_ERROR, parent: g.parent };
                    if (K.code !== 22)
                      if (this.appendError ? this.appendError++ : this.appendError = 1, D.details = m.a.BUFFER_APPEND_ERROR, this.appendError > n.config.appendErrorMaxRetry) {
                        d.b.log("fail " + n.config.appendErrorMaxRetry + " times to append segment in sourceBuffer"), c = [], D.fatal = !0, n.trigger(h.a.ERROR, D);
                        return;
                      } else
                        D.fatal = !1, n.trigger(h.a.ERROR, D);
                    else {
                      this.segments = [], D.details = m.a.BUFFER_FULL_ERROR, D.fatal = !1, n.trigger(h.a.ERROR, D);
                      return;
                    }
                  }
                }
              }
            }, s.prototype.flushBuffer = function(n, l, c) {
              var g, w, A, D, K, j, q = this.sourceBuffer;
              if (Object.keys(q).length) {
                if (d.b.log("flushBuffer,pos/start/end: " + this.media.currentTime.toFixed(3) + "/" + n + "/" + l), this.flushBufferCounter < this.appended) {
                  for (var J in q)
                    if (!(c && J !== c)) {
                      if (g = q[J], g.ended = !1, g.updating)
                        return d.b.warn("cannot flush, sb updating in progress"), !1;
                      try {
                        for (w = 0; w < g.buffered.length; w++)
                          if (A = g.buffered.start(w), D = g.buffered.end(w), navigator.userAgent.toLowerCase().indexOf("firefox") !== -1 && l === Number.POSITIVE_INFINITY ? (K = n, j = l) : (K = Math.max(A, n), j = Math.min(D, l)), Math.min(j, D) - K > 0.5)
                            return this.flushBufferCounter++, d.b.log("flush " + Y + " [" + K + "," + j + "], of [" + A + "," + D + "], pos:" + this.media.currentTime), g.remove(K, j), !1;
                      } catch {
                        d.b.warn("exception while accessing sourcebuffer, it might have been removed from MediaSource");
                      }
                    }
                } else
                  d.b.warn("abort flushing too many retries");
                d.b.log("buffer flushed");
              }
              return !0;
            }, s;
          }(I), Mi = Ir, Ur = /* @__PURE__ */ function() {
            function E(s, o) {
              for (var n = 0; n < o.length; n++) {
                var l = o[n];
                l.enumerable = l.enumerable || !1, l.configurable = !0, "value" in l && (l.writable = !0), Object.defineProperty(s, l.key, l);
              }
            }
            return function(s, o, n) {
              return o && E(s.prototype, o), n && E(s, n), s;
            };
          }();
          function tn(E, s) {
            if (!(E instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function rn(E, s) {
            if (!E)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : E;
          }
          function na(E, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            E.prototype = Object.create(s && s.prototype, { constructor: { value: E, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(E, s) : E.__proto__ = s);
          }
          var Ln = function(E) {
            na(s, E);
            function s(o) {
              return tn(this, s), rn(this, E.call(this, o, h.a.FPS_DROP_LEVEL_CAPPING, h.a.MEDIA_ATTACHING, h.a.MANIFEST_PARSED));
            }
            return s.prototype.destroy = function() {
              this.hls.config.capLevelToPlayerSize && (this.media = this.restrictedLevels = null, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (this.timer = clearInterval(this.timer)));
            }, s.prototype.onFpsDropLevelCapping = function(n) {
              s.isLevelAllowed(n.droppedLevel, this.restrictedLevels) && this.restrictedLevels.push(n.droppedLevel);
            }, s.prototype.onMediaAttaching = function(n) {
              this.media = n.media instanceof HTMLVideoElement ? n.media : null;
            }, s.prototype.onManifestParsed = function(n) {
              var l = this.hls;
              this.restrictedLevels = [], l.config.capLevelToPlayerSize && (this.autoLevelCapping = Number.POSITIVE_INFINITY, this.levels = n.levels, l.firstLevel = this.getMaxLevel(n.firstLevel), clearInterval(this.timer), this.timer = setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize());
            }, s.prototype.detectPlayerSize = function() {
              if (this.media) {
                var n = this.levels ? this.levels.length : 0;
                if (n) {
                  var l = this.hls;
                  l.autoLevelCapping = this.getMaxLevel(n - 1), l.autoLevelCapping > this.autoLevelCapping && l.streamController.nextLevelSwitch(), this.autoLevelCapping = l.autoLevelCapping;
                }
              }
            }, s.prototype.getMaxLevel = function(n) {
              var l = this;
              if (!this.levels)
                return -1;
              var c = this.levels.filter(function(g, w) {
                return s.isLevelAllowed(w, l.restrictedLevels) && w <= n;
              });
              return s.getMaxLevelByMediaSize(c, this.mediaWidth, this.mediaHeight);
            }, s.isLevelAllowed = function(n) {
              var l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
              return l.indexOf(n) === -1;
            }, s.getMaxLevelByMediaSize = function(n, l, c) {
              if (!n || n && !n.length)
                return -1;
              for (var g = function(j, q) {
                return q ? j.width !== q.width || j.height !== q.height : !0;
              }, w = n.length - 1, A = 0; A < n.length; A += 1) {
                var D = n[A];
                if ((D.width >= l || D.height >= c) && g(D, n[A + 1])) {
                  w = A;
                  break;
                }
              }
              return w;
            }, Ur(s, [{
              key: "mediaWidth",
              get: function() {
                var n = void 0, l = this.media;
                return l && (n = l.width || l.clientWidth || l.offsetWidth, n *= s.contentScaleFactor), n;
              }
            }, {
              key: "mediaHeight",
              get: function() {
                var n = void 0, l = this.media;
                return l && (n = l.height || l.clientHeight || l.offsetHeight, n *= s.contentScaleFactor), n;
              }
            }], [{
              key: "contentScaleFactor",
              get: function() {
                var n = 1;
                try {
                  n = window.devicePixelRatio;
                } catch {
                }
                return n;
              }
            }]), s;
          }(I), Cn = Ln;
          function N(E, s) {
            if (!(E instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function f(E, s) {
            if (!E)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : E;
          }
          function R(E, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            E.prototype = Object.create(s && s.prototype, { constructor: { value: E, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(E, s) : E.__proto__ = s);
          }
          var C = function(E) {
            R(s, E);
            function s(o) {
              return N(this, s), f(this, E.call(this, o, h.a.MEDIA_ATTACHING));
            }
            return s.prototype.destroy = function() {
              this.timer && clearInterval(this.timer), this.isVideoPlaybackQualityAvailable = !1;
            }, s.prototype.onMediaAttaching = function(n) {
              var l = this.hls.config;
              if (l.capLevelOnFPSDrop) {
                var c = this.video = n.media instanceof HTMLVideoElement ? n.media : null;
                typeof c.getVideoPlaybackQuality == "function" && (this.isVideoPlaybackQualityAvailable = !0), clearInterval(this.timer), this.timer = setInterval(this.checkFPSInterval.bind(this), l.fpsDroppedMonitoringPeriod);
              }
            }, s.prototype.checkFPS = function(n, l, c) {
              var g = performance.now();
              if (l) {
                if (this.lastTime) {
                  var w = g - this.lastTime, A = c - this.lastDroppedFrames, D = l - this.lastDecodedFrames, K = 1e3 * A / w, j = this.hls;
                  if (j.trigger(m.a.FPS_DROP, { currentDropped: A, currentDecoded: D, totalDroppedFrames: c }), K > 0 && A > j.config.fpsDroppedMonitoringThreshold * D) {
                    var q = j.currentLevel;
                    d.b.warn("drop FPS ratio greater than max allowed value for currentLevel: " + q), q > 0 && (j.autoLevelCapping === -1 || j.autoLevelCapping >= q) && (q = q - 1, j.trigger(m.a.FPS_DROP_LEVEL_CAPPING, { level: q, droppedLevel: j.currentLevel }), j.autoLevelCapping = q, j.streamController.nextLevelSwitch());
                  }
                }
                this.lastTime = g, this.lastDroppedFrames = c, this.lastDecodedFrames = l;
              }
            }, s.prototype.checkFPSInterval = function() {
              var n = this.video;
              if (n)
                if (this.isVideoPlaybackQualityAvailable) {
                  var l = n.getVideoPlaybackQuality();
                  this.checkFPS(n, l.totalVideoFrames, l.droppedVideoFrames);
                } else
                  this.checkFPS(n, n.webkitDecodedFrameCount, n.webkitDroppedFrameCount);
            }, s;
          }(I), G = C;
          function F(E, s) {
            if (!(E instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          var fe = function() {
            function E(s) {
              F(this, E), s && s.xhrSetup && (this.xhrSetup = s.xhrSetup);
            }
            return E.prototype.destroy = function() {
              this.abort(), this.loader = null;
            }, E.prototype.abort = function() {
              var o = this.loader;
              o && o.readyState !== 4 && (this.stats.aborted = !0, o.abort()), window.clearTimeout(this.requestTimeout), this.requestTimeout = null, window.clearTimeout(this.retryTimeout), this.retryTimeout = null;
            }, E.prototype.load = function(o, n, l) {
              this.context = o, this.config = n, this.callbacks = l, this.stats = { trequest: performance.now(), retry: 0 }, this.retryDelay = n.retryDelay, this.loadInternal();
            }, E.prototype.loadInternal = function() {
              var o, n = this.context;
              o = this.loader = new XMLHttpRequest();
              var l = this.stats;
              l.tfirst = 0, l.loaded = 0;
              var c = this.xhrSetup;
              try {
                if (c)
                  try {
                    c(o, n.url);
                  } catch {
                    o.open("GET", n.url, !0), c(o, n.url);
                  }
                o.readyState || o.open("GET", n.url, !0);
              } catch (g) {
                this.callbacks.onError({ code: o.status, text: g.message }, n, o);
                return;
              }
              n.rangeEnd && o.setRequestHeader("Range", "bytes=" + n.rangeStart + "-" + (n.rangeEnd - 1)), o.onreadystatechange = this.readystatechange.bind(this), o.onprogress = this.loadprogress.bind(this), o.responseType = n.responseType, this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout), o.send();
            }, E.prototype.readystatechange = function(o) {
              var n = o.currentTarget, l = n.readyState, c = this.stats, g = this.context, w = this.config;
              if (!c.aborted && l >= 2)
                if (window.clearTimeout(this.requestTimeout), c.tfirst === 0 && (c.tfirst = Math.max(performance.now(), c.trequest)), l === 4) {
                  var A = n.status;
                  if (A >= 200 && A < 300) {
                    c.tload = Math.max(c.tfirst, performance.now());
                    var D = void 0, K = void 0;
                    g.responseType === "arraybuffer" ? (D = n.response, K = D.byteLength) : (D = n.responseText, K = D.length), c.loaded = c.total = K;
                    var M = { url: n.responseURL, data: D };
                    this.callbacks.onSuccess(M, c, g, n);
                  } else
                    c.retry >= w.maxRetry || A >= 400 && A < 499 ? (d.b.error(A + " while loading " + g.url), this.callbacks.onError({ code: A, text: n.statusText }, g, n)) : (d.b.warn(A + " while loading " + g.url + ", retrying in " + this.retryDelay + "..."), this.destroy(), this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay), this.retryDelay = Math.min(2 * this.retryDelay, w.maxRetryDelay), c.retry++);
                } else
                  this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), w.timeout);
            }, E.prototype.loadtimeout = function() {
              d.b.warn("timeout while loading " + this.context.url), this.callbacks.onTimeout(this.stats, this.context, null);
            }, E.prototype.loadprogress = function(o) {
              var n = o.currentTarget, l = this.stats;
              l.loaded = o.loaded, o.lengthComputable && (l.total = o.total);
              var c = this.callbacks.onProgress;
              c && c(l, this.context, null, n);
            }, E;
          }(), ae = fe, _e = /* @__PURE__ */ function() {
            function E(s, o) {
              for (var n = 0; n < o.length; n++) {
                var l = o[n];
                l.enumerable = l.enumerable || !1, l.configurable = !0, "value" in l && (l.writable = !0), Object.defineProperty(s, l.key, l);
              }
            }
            return function(s, o, n) {
              return o && E(s.prototype, o), n && E(s, n), s;
            };
          }();
          function Te(E, s) {
            if (!(E instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function Be(E, s) {
            if (!E)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : E;
          }
          function br(E, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            E.prototype = Object.create(s && s.prototype, { constructor: { value: E, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(E, s) : E.__proto__ = s);
          }
          var xo = function(E) {
            br(s, E);
            function s(o) {
              Te(this, s);
              var n = Be(this, E.call(this, o, m.a.MANIFEST_LOADING, m.a.MANIFEST_LOADED, m.a.AUDIO_TRACK_LOADED, m.a.ERROR));
              return n.ticks = 0, n.ontick = n.tick.bind(n), n;
            }
            return s.prototype.destroy = function() {
              this.cleanTimer(), I.prototype.destroy.call(this);
            }, s.prototype.cleanTimer = function() {
              this.timer && (clearTimeout(this.timer), this.timer = null);
            }, s.prototype.tick = function() {
              this.ticks++, this.ticks === 1 && (this.doTick(), this.ticks > 1 && setTimeout(this.tick, 1), this.ticks = 0);
            }, s.prototype.doTick = function() {
              this.updateTrack(this.trackId);
            }, s.prototype.onError = function(n) {
              n.fatal && n.type === m.b.NETWORK_ERROR && this.cleanTimer();
            }, s.prototype.onManifestLoading = function() {
              this.tracks = [], this.trackId = -1;
            }, s.prototype.onManifestLoaded = function(n) {
              var l = this, c = n.audioTracks || [], g = !1;
              this.tracks = c, this.hls.trigger(m.a.AUDIO_TRACKS_UPDATED, { audioTracks: c });
              var w = 0;
              c.forEach(function(A) {
                if (A.default && !g) {
                  l.audioTrack = w, g = !0;
                  return;
                }
                w++;
              }), g === !1 && c.length && (d.b.log("no default audio track defined, use first audio track as default"), this.audioTrack = 0);
            }, s.prototype.onAudioTrackLoaded = function(n) {
              n.id < this.tracks.length && (d.b.log("audioTrack " + n.id + " loaded"), this.tracks[n.id].details = n.details, n.details.live && !this.timer && (this.timer = setInterval(this.ontick, 1e3 * n.details.targetduration)), !n.details.live && this.timer && this.cleanTimer());
            }, s.prototype.setAudioTrackInternal = function(n) {
              if (n >= 0 && n < this.tracks.length) {
                this.cleanTimer(), this.trackId = n, d.b.log("switching to audioTrack " + n);
                var l = this.tracks[n], c = this.hls, g = l.type, w = l.url, A = { id: n, type: g, url: w };
                c.trigger(m.a.AUDIO_TRACK_SWITCH, A), c.trigger(m.a.AUDIO_TRACK_SWITCHING, A);
                var D = l.details;
                w && (D === void 0 || D.live === !0) && (d.b.log("(re)loading playlist for audioTrack " + n), c.trigger(m.a.AUDIO_TRACK_LOADING, { url: w, id: n }));
              }
            }, s.prototype.updateTrack = function(n) {
              if (n >= 0 && n < this.tracks.length) {
                this.cleanTimer(), this.trackId = n, d.b.log("updating audioTrack " + n);
                var l = this.tracks[n], c = l.url, g = l.details;
                c && (g === void 0 || g.live === !0) && (d.b.log("(re)loading playlist for audioTrack " + n), this.hls.trigger(h.a.AUDIO_TRACK_LOADING, { url: c, id: n }));
              }
            }, _e(s, [{
              key: "audioTracks",
              get: function() {
                return this.tracks;
              }
              /** get index of the selected audio track (index in audio track lists) **/
            }, {
              key: "audioTrack",
              get: function() {
                return this.trackId;
              },
              set: function(n) {
                (this.trackId !== n || this.tracks[n].details === void 0) && this.setAudioTrackInternal(n);
              }
            }]), s;
          }(I), aa = xo, Kp = /* @__PURE__ */ function() {
            function E(s, o) {
              for (var n = 0; n < o.length; n++) {
                var l = o[n];
                l.enumerable = l.enumerable || !1, l.configurable = !0, "value" in l && (l.writable = !0), Object.defineProperty(s, l.key, l);
              }
            }
            return function(s, o, n) {
              return o && E(s.prototype, o), n && E(s, n), s;
            };
          }();
          function Np(E, s) {
            if (!(E instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function Vp(E, s) {
            if (!E)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : E;
          }
          function Mp(E, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            E.prototype = Object.create(s && s.prototype, { constructor: { value: E, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(E, s) : E.__proto__ = s);
          }
          var Se = {
            STOPPED: "STOPPED",
            STARTING: "STARTING",
            IDLE: "IDLE",
            PAUSED: "PAUSED",
            KEY_LOADING: "KEY_LOADING",
            FRAG_LOADING: "FRAG_LOADING",
            FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
            WAITING_TRACK: "WAITING_TRACK",
            PARSING: "PARSING",
            PARSED: "PARSED",
            BUFFER_FLUSHING: "BUFFER_FLUSHING",
            ENDED: "ENDED",
            ERROR: "ERROR",
            WAITING_INIT_PTS: "WAITING_INIT_PTS"
          }, jp = function(E) {
            Mp(s, E);
            function s(o) {
              Np(this, s);
              var n = Vp(this, E.call(this, o, m.a.MEDIA_ATTACHED, m.a.MEDIA_DETACHING, m.a.AUDIO_TRACKS_UPDATED, m.a.AUDIO_TRACK_SWITCHING, m.a.AUDIO_TRACK_LOADED, m.a.KEY_LOADED, m.a.FRAG_LOADED, m.a.FRAG_PARSING_INIT_SEGMENT, m.a.FRAG_PARSING_DATA, m.a.FRAG_PARSED, m.a.ERROR, m.a.BUFFER_CREATED, m.a.BUFFER_APPENDED, m.a.BUFFER_FLUSHED, m.a.INIT_PTS_FOUND));
              return n.config = o.config, n.audioCodecSwap = !1, n.ticks = 0, n._state = we.STOPPED, n.ontick = n.tick.bind(n), n.initPTS = [], n.waitingFragment = null, n.videoTrackCC = null, n;
            }
            return s.prototype.destroy = function() {
              this.stopLoad(), this.timer && (clearInterval(this.timer), this.timer = null), I.prototype.destroy.call(this), this.state = Se.STOPPED;
            }, s.prototype.onInitPtsFound = function(n) {
              var l = n.id, c = n.frag.cc, g = n.initPTS;
              l === "main" && (this.initPTS[c] = g, this.videoTrackCC = c, d.b.log("InitPTS for cc:" + c + " found from video track:" + g), this.state === Se.WAITING_INIT_PTS && this.tick());
            }, s.prototype.startLoad = function(n) {
              if (this.tracks) {
                var l = this.lastCurrentTime;
                this.stopLoad(), this.timer || (this.timer = setInterval(this.ontick, 100)), this.fragLoadError = 0, l > 0 && n === -1 ? (d.b.log("audio:override startPosition with lastCurrentTime @" + l.toFixed(3)), this.state = Se.IDLE) : (this.lastCurrentTime = this.startPosition ? this.startPosition : n, this.state = Se.STARTING), this.nextLoadPosition = this.startPosition = this.lastCurrentTime, this.tick();
              } else
                this.startPosition = n, this.state = Se.STOPPED;
            }, s.prototype.stopLoad = function() {
              var n = this.fragCurrent;
              n && (n.loader && n.loader.abort(), this.fragCurrent = null), this.fragPrevious = null, this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.state = Se.STOPPED;
            }, s.prototype.tick = function() {
              this.ticks++, this.ticks === 1 && (this.doTick(), this.ticks > 1 && setTimeout(this.tick, 1), this.ticks = 0);
            }, s.prototype.doTick = function() {
              var n, l, c, g = this.hls, w = g.config;
              switch (this.state) {
                case Se.ERROR:
                case Se.PAUSED:
                case Se.BUFFER_FLUSHING:
                  break;
                case Se.STARTING:
                  this.state = Se.WAITING_TRACK, this.loadedmetadata = !1;
                  break;
                case Se.IDLE:
                  var A = this.tracks;
                  if (!A || !this.media && (this.startFragRequested || !w.startFragPrefetch))
                    break;
                  if (this.loadedmetadata)
                    n = this.media.currentTime;
                  else if (n = this.nextLoadPosition, n === void 0)
                    break;
                  var D = this.mediaBuffer ? this.mediaBuffer : this.media, K = this.videoBuffer ? this.videoBuffer : this.media, j = ot.bufferInfo(D, n, w.maxBufferHole), q = ot.bufferInfo(K, n, w.maxBufferHole), Y = j.len, ue = j.end, me = this.fragPrevious, Re = Math.max(w.maxBufferLength, q.len), be = this.audioSwitch, Pe = this.trackId;
                  if ((Y < Re || be) && Pe < A.length) {
                    if (c = A[Pe].details, typeof c > "u") {
                      this.state = we.WAITING_TRACK;
                      break;
                    }
                    if (!be && !c.live && me && me.sn === c.endSN && (!this.media.seeking || this.media.duration - ue < me.duration / 2)) {
                      this.hls.trigger(m.a.BUFFER_EOS, { type: "audio" }), this.state = we.ENDED;
                      break;
                    }
                    var ke = c.fragments, Ke = ke.length, mt = ke[0].start, gt = ke[Ke - 1].start + ke[Ke - 1].duration, Le = void 0;
                    if (be) {
                      if (c.live && !c.PTSKnown)
                        d.b.log("switching audiotrack, live stream, unknown PTS,load first fragment"), ue = 0;
                      else if (ue = n, c.PTSKnown && n < mt)
                        if (M.end > mt || M.nextStart)
                          d.b.log("alt audio track ahead of main track, seek to start of alt audio track"), this.media.currentTime = mt + 0.05;
                        else
                          return;
                    }
                    if (c.initSegment && !c.initSegment.data)
                      Ce = c.initSegment;
                    else if (ue <= mt) {
                      if (Le = ke[0], this.videoTrackCC !== null && Le.cc !== this.videoTrackCC && (Le = H(ke, this.videoTrackCC)), c.live && Le.loadIdx && Le.loadIdx === this.fragLoadIdx) {
                        var $t = j.nextStart ? j.nextStart : mt;
                        d.b.log("no alt audio available @currentTime:" + this.media.currentTime + ", seeking @" + ($t + 0.05)), this.media.currentTime = $t + 0.05;
                        return;
                      }
                    } else {
                      var bt = void 0, ji = w.maxFragLookUpTolerance, We = me ? ke[me.sn - ke[0].sn + 1] : void 0, je = function(oa) {
                        var Ru = Math.min(ji, oa.duration);
                        return oa.start + oa.duration - Ru <= ue ? 1 : oa.start - Ru > ue && oa.start ? -1 : 0;
                      };
                      ue < gt ? (ue > gt - ji && (ji = 0), We && !je(We) ? bt = We : bt = Vt.search(ke, je)) : bt = ke[Ke - 1], bt && (Le = bt, mt = bt.start, me && Le.level === me.level && Le.sn === me.sn && (Le.sn < c.endSN ? (Le = ke[Le.sn + 1 - c.startSN], d.b.log("SN just loaded, load next one: " + Le.sn)) : Le = null));
                    }
                    if (Le)
                      if (Le.decryptdata && Le.decryptdata.uri != null && Le.decryptdata.key == null)
                        d.b.log("Loading key for " + Le.sn + " of [" + c.startSN + " ," + c.endSN + "],track " + Pe), this.state = we.KEY_LOADING, g.trigger(m.a.KEY_LOADING, { frag: Le });
                      else {
                        if (d.b.log("Loading " + Le.sn + ", cc: " + Le.cc + " of [" + c.startSN + " ," + c.endSN + "],track " + Pe + ", currentTime:" + n + ",bufferEnd:" + ue.toFixed(3)), this.fragLoadIdx !== void 0 ? this.fragLoadIdx++ : this.fragLoadIdx = 0, Le.loadCounter) {
                          Le.loadCounter++;
                          var er = w.fragLoadingLoopThreshold;
                          if (Le.loadCounter > er && Math.abs(this.fragLoadIdx - Le.loadIdx) < er) {
                            g.trigger(m.a.ERROR, { type: h.b.MEDIA_ERROR, details: h.a.FRAG_LOOP_LOADING_ERROR, fatal: !1, frag: Le });
                            return;
                          }
                        } else
                          Ce.loadCounter = 1;
                        Ce.loadIdx = this.fragLoadIdx, this.fragCurrent = Ce, this.startFragRequested = !0, isNaN(Ce.sn) || (this.nextLoadPosition = Ce.start + Ce.duration), g.trigger(h.a.FRAG_LOADING, { frag: Ce }), this.state = Se.FRAG_LOADING;
                      }
                  }
                  break;
                case Se.WAITING_TRACK:
                  l = this.tracks[this.trackId], l && l.details && (this.state = Se.IDLE);
                  break;
                case Se.FRAG_LOADING_WAITING_RETRY:
                  var go = performance.now(), Eu = this.retryDate;
                  D = this.media;
                  var Lh = D && D.seeking;
                  (!Eu || go >= Eu || Lh) && (d.b.log("audioStreamController: retryDate reached, switch back to IDLE state"), this.state = we.IDLE);
                  break;
                case Se.WAITING_INIT_PTS:
                  var bl = this.videoTrackCC;
                  if (this.initPTS[bl] === void 0)
                    break;
                  var gu = this.waitingFragment;
                  if (gu) {
                    var vu = gu.frag.cc;
                    bl !== vu ? (l = this.tracks[this.trackId], l.details && l.details.live && (d.b.warn("Waiting fragment CC (" + vu + ") does not match video track CC (" + bl + ")"), this.waitingFragment = null, this.state = Se.IDLE)) : (this.state = Se.FRAG_LOADING, this.onFragLoaded(this.waitingFragment), this.waitingFragment = null);
                  } else
                    this.state = Se.IDLE;
                  break;
              }
            }, s.prototype.onMediaAttached = function(n) {
              var l = this.media = this.mediaBuffer = n.media;
              this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), l.addEventListener("seeking", this.onvseeking), l.addEventListener("ended", this.onvended);
              var c = this.config;
              this.tracks && c.autoStartLoad && this.startLoad(c.startPosition);
            }, s.prototype.onMediaDetaching = function() {
              var n = this.media;
              n && n.ended && (d.b.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0);
              var l = this.tracks;
              l && l.forEach(function(c) {
                c.details && c.details.fragments.forEach(function(g) {
                  g.loadCounter = void 0;
                });
              }), n && (n.removeEventListener("seeking", this.onvseeking), n.removeEventListener("ended", this.onvended), this.onvseeking = this.onvseeked = this.onvended = null), this.media = this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1, this.stopLoad();
            }, s.prototype.onMediaSeeking = function() {
              this.state === Se.ENDED && (this.state = Se.IDLE), this.media && (this.lastCurrentTime = this.media.currentTime), this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold), this.tick();
            }, s.prototype.onMediaEnded = function() {
              this.startPosition = this.lastCurrentTime = 0;
            }, s.prototype.onAudioTracksUpdated = function(n) {
              d.b.log("audio tracks updated"), this.tracks = n.audioTracks;
            }, s.prototype.onAudioTrackSwitching = function(n) {
              var l = !!n.url;
              this.trackId = n.id, this.fragCurrent = null, this.state = Se.PAUSED, this.waitingFragment = null, l ? this.timer || (this.timer = setInterval(this.ontick, 100)) : this.demuxer && (this.demuxer.destroy(), this.demuxer = null), l && (this.audioSwitch = !0, this.state = Se.IDLE, this.fragLoadIdx !== void 0 && (this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold)), this.tick();
            }, s.prototype.onAudioTrackLoaded = function(n) {
              var l = n.details, c = n.id, g = this.tracks[c], w = l.totalduration, A = 0;
              if (d.b.log("track " + c + " loaded [" + l.startSN + "," + l.endSN + "],duration:" + w), l.live) {
                var D = g.details;
                D && l.fragments.length > 0 ? (k(D, l), A = l.fragments[0].start, l.PTSKnown ? d.b.log("live audio playlist sliding:" + A.toFixed(3)) : d.b.log("live audio playlist - outdated PTS, unknown sliding")) : (l.PTSKnown = !1, d.b.log("live audio playlist - first load, unknown sliding"));
              } else
                l.PTSKnown = !1;
              if (g.details = l, !this.startFragRequested) {
                if (this.startPosition === -1) {
                  var K = l.startTimeOffset;
                  isNaN(K) ? this.startPosition = 0 : (d.b.log("start time offset found in playlist, adjust startPosition to " + K), this.startPosition = K);
                }
                this.nextLoadPosition = this.startPosition;
              }
              this.state === Se.WAITING_TRACK && (this.state = Se.IDLE), this.tick();
            }, s.prototype.onKeyLoaded = function() {
              this.state === Se.KEY_LOADING && (this.state = Se.IDLE, this.tick());
            }, s.prototype.onFragLoaded = function(n) {
              var l = this.fragCurrent, c = n.frag;
              if (this.state === we.FRAG_LOADING && l && c.type === "audio" && c.level === l.level && c.sn === l.sn) {
                var g = this.tracks[this.trackId], w = g.details, A = w.totalduration, D = l.level, K = l.sn, j = l.cc, q = this.config.defaultAudioCodec || g.audioCodec || "mp4a.40.2", Y = this.stats = n.stats;
                if (K === "initSegment")
                  this.state = we.IDLE, Y.tparsed = Y.tbuffered = performance.now(), w.initSegment.data = n.payload, this.hls.trigger(m.a.FRAG_BUFFERED, { stats: Y, frag: l, id: "audio" }), this.tick();
                else {
                  this.state = we.PARSING, this.appended = !1, this.demuxer || (this.demuxer = new X(this.hls, "audio"));
                  var ue = this.initPTS[j], me = w.initSegment ? w.initSegment.data : [];
                  if (w.initSegment || ue !== void 0) {
                    this.pendingBuffering = !0, d.b.log("Demuxing " + K + " of [" + w.startSN + " ," + w.endSN + "],track " + D);
                    var Re = !1;
                    this.demuxer.push(n.payload, me, q, null, l, A, Re, ue);
                  } else
                    d.b.log("unknown video PTS for continuity counter " + j + ", waiting for video PTS before demuxing audio frag " + K + " of [" + w.startSN + " ," + w.endSN + "],track " + D), this.waitingFragment = n, this.state = we.WAITING_INIT_PTS;
                }
              }
              this.fragLoadError = 0;
            }, s.prototype.onFragParsingInitSegment = function(n) {
              var l = this.fragCurrent, c = n.frag;
              if (l && n.id === "audio" && c.sn === l.sn && c.level === l.level && this.state === we.PARSING) {
                var g = n.tracks, w = void 0;
                if (g.video && delete g.video, w = g.audio, w) {
                  w.levelCodec = w.codec, w.id = n.id, this.hls.trigger(m.a.BUFFER_CODECS, g), d.b.log("audio track:audio,container:" + w.container + ",codecs[level/parsed]=[" + w.levelCodec + "/" + w.codec + "]");
                  var A = w.initSegment;
                  if (A) {
                    var D = { type: "audio", data: A, parent: "audio", content: "initSegment" };
                    this.audioSwitch ? this.pendingData = [D] : (this.appended = !0, this.pendingBuffering = !0, this.hls.trigger(h.a.BUFFER_APPENDING, D));
                  }
                  this.tick();
                }
              }
            }, s.prototype.onFragParsingData = function(n) {
              var l = this, c = this.fragCurrent, g = n.frag;
              if (c && n.id === "audio" && n.type === "audio" && g.sn === c.sn && g.level === c.level && this.state === we.PARSING) {
                var w = this.trackId, A = this.tracks[w], D = this.hls;
                isNaN(n.endPTS) && (n.endPTS = n.startPTS + c.duration, n.endDTS = n.startDTS + c.duration), d.b.log("parsed " + n.type + ",PTS:[" + n.startPTS.toFixed(3) + "," + n.endPTS.toFixed(3) + "],DTS:[" + n.startDTS.toFixed(3) + "/" + n.endDTS.toFixed(3) + "],nb:" + n.nb), L(A.details, c, n.startPTS, n.endPTS);
                var K = this.audioSwitch, j = this.media, q = !1;
                if (K && j)
                  if (j.readyState) {
                    var Y = j.currentTime;
                    d.b.log("switching audio track : currentTime:" + Y), Y >= n.startPTS && (d.b.log("switching audio track : flushing all audio"), this.state = we.BUFFER_FLUSHING, D.trigger(m.a.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: "audio" }), q = !0, this.audioSwitch = !1, D.trigger(m.a.AUDIO_TRACK_SWITCHED, { id: w }));
                  } else
                    this.audioSwitch = !1, D.trigger(m.a.AUDIO_TRACK_SWITCHED, { id: w });
                var ue = this.pendingData;
                this.audioSwitch || ([n.data1, n.data2].forEach(function(me) {
                  me && me.length && ue.push({ type: n.type, data: me, parent: "audio", content: "data" });
                }), !q && ue.length && (ue.forEach(function(me) {
                  l.state === we.PARSING && (l.pendingBuffering = !0, l.hls.trigger(m.a.BUFFER_APPENDING, me));
                }), this.pendingData = [], this.appended = !0)), this.tick();
              }
            }, s.prototype.onFragParsed = function(n) {
              var l = this.fragCurrent, c = n.frag;
              l && n.id === "audio" && c.sn === l.sn && c.level === l.level && this.state === Se.PARSING && (this.stats.tparsed = performance.now(), this.state = Se.PARSED, this._checkAppendedParsed());
            }, s.prototype.onBufferCreated = function(n) {
              var l = n.tracks.audio;
              l && (this.mediaBuffer = l.buffer, this.loadedmetadata = !0), n.tracks.video && (this.videoBuffer = n.tracks.video.buffer);
            }, s.prototype.onBufferAppended = function(n) {
              if (n.parent === "audio") {
                var l = this.state;
                (l === Se.PARSING || l === Se.PARSED) && (this.pendingBuffering = n.pending > 0, this._checkAppendedParsed());
              }
            }, s.prototype._checkAppendedParsed = function() {
              if (this.state === Se.PARSED && (!this.appended || !this.pendingBuffering)) {
                var n = this.fragCurrent, l = this.stats, c = this.hls;
                if (n) {
                  this.fragPrevious = n, l.tbuffered = performance.now(), c.trigger(h.a.FRAG_BUFFERED, { stats: l, frag: n, id: "audio" });
                  var g = this.mediaBuffer ? this.mediaBuffer : this.media;
                  d.b.log("audio buffered : " + V.toString(g.buffered)), this.audioSwitch && this.appended && (this.audioSwitch = !1, c.trigger(h.a.AUDIO_TRACK_SWITCHED, { id: this.trackId })), this.state = Se.IDLE;
                }
                this.tick();
              }
            }, s.prototype.onError = function(n) {
              var l = n.frag;
              if (!(l && l.type !== "audio"))
                switch (n.details) {
                  case m.a.FRAG_LOAD_ERROR:
                  case m.a.FRAG_LOAD_TIMEOUT:
                    if (!n.fatal) {
                      var c = this.fragLoadError;
                      c ? c++ : c = 1;
                      var g = this.config;
                      if (c <= g.fragLoadingMaxRetry) {
                        this.fragLoadError = c, l.loadCounter = 0;
                        var w = Math.min(Math.pow(2, c - 1) * g.fragLoadingRetryDelay, g.fragLoadingMaxRetryTimeout);
                        d.b.warn("audioStreamController: frag loading failed, retry in " + w + " ms"), this.retryDate = performance.now() + w, this.state = we.FRAG_LOADING_WAITING_RETRY;
                      } else
                        d.b.error("audioStreamController: " + n.details + " reaches max retry, redispatch as fatal ..."), n.fatal = !0, this.state = Se.ERROR;
                    }
                    break;
                  case m.a.FRAG_LOOP_LOADING_ERROR:
                  case m.a.AUDIO_TRACK_LOAD_ERROR:
                  case m.a.AUDIO_TRACK_LOAD_TIMEOUT:
                  case m.a.KEY_LOAD_ERROR:
                  case m.a.KEY_LOAD_TIMEOUT:
                    this.state !== Se.ERROR && (this.state = n.fatal ? Se.ERROR : Se.IDLE, d.b.warn("audioStreamController: " + n.details + " while loading frag,switch to " + this.state + " state ..."));
                    break;
                  case h.a.BUFFER_FULL_ERROR:
                    if (n.parent === "audio" && (this.state === we.PARSING || this.state === we.PARSED)) {
                      var A = this.mediaBuffer, D = this.media.currentTime, K = A && ot.isBuffered(A, D) && ot.isBuffered(A, D + 0.5);
                      if (K) {
                        var M = this.config;
                        M.maxMaxBufferLength >= M.maxBufferLength && (M.maxMaxBufferLength /= 2, d.b.warn("audio:reduce max buffer length to " + M.maxMaxBufferLength + "s"), this.fragLoadIdx += 2 * M.fragLoadingLoopThreshold), this.state = Se.IDLE;
                      } else
                        d.b.warn("buffer full error also media.currentTime is not buffered, flush audio buffer"), this.fragCurrent = null, this.state = Se.BUFFER_FLUSHING, this.hls.trigger(h.a.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: "audio" });
                    }
                    break;
                }
            }, s.prototype.onBufferFlushed = function() {
              var n = this, l = this.pendingData;
              l && l.length ? (d.b.log("appending pending audio data on Buffer Flushed"), l.forEach(function(c) {
                n.hls.trigger(m.a.BUFFER_APPENDING, c);
              }), this.appended = !0, this.pendingData = [], this.state = we.PARSED) : (this.state = we.IDLE, this.fragPrevious = null, this.tick());
            }, Kp(s, [{
              key: "state",
              set: function(n) {
                if (this.state !== n) {
                  var l = this.state;
                  this._state = n, d.b.log("audio stream:" + l + "->" + n);
                }
              },
              get: function() {
                return this._state;
              }
            }]), s;
          }(I), Fp = jp, lu = function() {
            if (typeof window < "u" && window.VTTCue)
              return window.VTTCue;
            var E = "auto", s = {
              "": !0,
              lr: !0,
              rl: !0
            }, o = {
              start: !0,
              middle: !0,
              end: !0,
              left: !0,
              right: !0
            };
            function n(w) {
              if (typeof w != "string")
                return !1;
              var A = s[w.toLowerCase()];
              return A ? w.toLowerCase() : !1;
            }
            function l(w) {
              if (typeof w != "string")
                return !1;
              var A = o[w.toLowerCase()];
              return A ? w.toLowerCase() : !1;
            }
            function c(w) {
              for (var A = 1; A < arguments.length; A++) {
                var D = arguments[A];
                for (var K in D)
                  w[K] = D[K];
              }
              return w;
            }
            function g(w, A, D) {
              var K = this, j = function() {
                if (!(typeof navigator > "u"))
                  return /MSIE\s8\.0/.test(navigator.userAgent);
              }(), q = {};
              j ? K = document.createElement("custom") : q.enumerable = !0, K.hasBeenReset = !1;
              var Y = "", ue = !1, me = w, Re = A, be = D, Pe = null, ke = "", Ke = !0, mt = "auto", gt = "start", Le = 50, $t = "middle", bt = 50, ji = "middle";
              if (Object.defineProperty(K, "id", c({}, q, {
                get: function() {
                  return J;
                },
                set: function(je) {
                  J = "" + je;
                }
              })), Object.defineProperty(K, "pauseOnExit", c({}, q, {
                get: function() {
                  return ue;
                },
                set: function(je) {
                  ue = !!je;
                }
              })), Object.defineProperty(K, "startTime", c({}, q, {
                get: function() {
                  return me;
                },
                set: function(je) {
                  if (typeof je != "number")
                    throw new TypeError("Start time must be set to a number.");
                  me = je, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(K, "endTime", c({}, q, {
                get: function() {
                  return Re;
                },
                set: function(je) {
                  if (typeof je != "number")
                    throw new TypeError("End time must be set to a number.");
                  Re = je, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(K, "text", c({}, q, {
                get: function() {
                  return be;
                },
                set: function(je) {
                  be = "" + je, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(K, "region", c({}, q, {
                get: function() {
                  return Pe;
                },
                set: function(je) {
                  Pe = je, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(K, "vertical", c({}, q, {
                get: function() {
                  return ke;
                },
                set: function(je) {
                  var er = n(je);
                  if (er === !1)
                    throw new SyntaxError("An invalid or illegal string was specified.");
                  ke = er, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(K, "snapToLines", c({}, q, {
                get: function() {
                  return Ne;
                },
                set: function(je) {
                  Ne = !!je, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(K, "line", c({}, q, {
                get: function() {
                  return mt;
                },
                set: function(je) {
                  if (typeof je != "number" && je !== E)
                    throw new SyntaxError("An invalid number or illegal string was specified.");
                  mt = je, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(K, "lineAlign", c({}, q, {
                get: function() {
                  return gt;
                },
                set: function(je) {
                  var er = l(je);
                  if (!er)
                    throw new SyntaxError("An invalid or illegal string was specified.");
                  gt = er, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(K, "position", c({}, q, {
                get: function() {
                  return Ce;
                },
                set: function(je) {
                  if (je < 0 || je > 100)
                    throw new Error("Position must be between 0 and 100.");
                  Ce = je, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(K, "positionAlign", c({}, q, {
                get: function() {
                  return $t;
                },
                set: function(je) {
                  var er = l(je);
                  if (!er)
                    throw new SyntaxError("An invalid or illegal string was specified.");
                  $t = er, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(K, "size", c({}, q, {
                get: function() {
                  return bt;
                },
                set: function(je) {
                  if (je < 0 || je > 100)
                    throw new Error("Size must be between 0 and 100.");
                  bt = je, this.hasBeenReset = !0;
                }
              })), Object.defineProperty(K, "align", c({}, q, {
                get: function() {
                  return ji;
                },
                set: function(je) {
                  var er = l(je);
                  if (!er)
                    throw new SyntaxError("An invalid or illegal string was specified.");
                  ji = er, this.hasBeenReset = !0;
                }
              })), K.displayState = void 0, M)
                return K;
            }
            return g.prototype.getCueAsHTML = function() {
              var w = window.WebVTT;
              return w.convertCueToDOMTree(window, this.text);
            }, g;
          }(), $p = function() {
            return {
              decode: function(o) {
                if (!o)
                  return "";
                if (typeof o != "string")
                  throw new Error("Error - expected string data.");
                return decodeURIComponent(encodeURIComponent(o));
              }
            };
          };
          function uu() {
            this.window = window, this.state = "INITIAL", this.buffer = "", this.decoder = new $p(), this.regionList = [];
          }
          function Gp(E) {
            function s(n, l, c, g) {
              return (n | 0) * 3600 + (l | 0) * 60 + (c | 0) + (g | 0) / 1e3;
            }
            var o = E.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
            return o ? o[3] ? s(o[1], o[2], o[3].replace(":", ""), o[4]) : o[1] > 59 ? s(o[1], o[2], 0, o[4]) : s(0, o[1], o[2], o[4]) : null;
          }
          function fu() {
            this.values = /* @__PURE__ */ Object.create(null);
          }
          fu.prototype = {
            // Only accept the first assignment to any key.
            set: function(s, o) {
              !this.get(s) && o !== "" && (this.values[s] = o);
            },
            // Return the value for a key, or a default value.
            // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
            // a number of possible default values as properties where 'defaultKey' is
            // the key of the property that will be chosen; otherwise it's assumed to be
            // a single value.
            get: function(s, o, n) {
              return n ? this.has(s) ? this.values[s] : o[n] : this.has(s) ? this.values[s] : o;
            },
            // Check whether we have a value for a key.
            has: function(s) {
              return s in this.values;
            },
            // Accept a setting if its one of the given alternatives.
            alt: function(s, o, n) {
              for (var l = 0; l < n.length; ++l)
                if (o === n[l]) {
                  this.set(s, o);
                  break;
                }
            },
            // Accept a setting if its a valid (signed) integer.
            integer: function(s, o) {
              /^-?\d+$/.test(o) && this.set(s, parseInt(o, 10));
            },
            // Accept a setting if its a valid percentage.
            percent: function(s, o) {
              return o.match(/^([\d]{1,3})(\.[\d]*)?%$/) && (o = parseFloat(o), o >= 0 && o <= 100) ? (this.set(s, o), !0) : !1;
            }
          };
          function cu(E, s, o, n) {
            var l = n ? E.split(n) : [E];
            for (var c in l)
              if (typeof l[c] == "string") {
                var g = l[c].split(o);
                if (g.length === 2) {
                  var w = g[0], A = g[1];
                  s(w, A);
                }
              }
          }
          var pl = new lu(0, 0, 0), Eo = pl.align === "middle" ? "middle" : "center";
          function qp(E, s, o) {
            var n = E;
            function l() {
              var w = Gp(E);
              if (w === null)
                throw new Error("Malformed timestamp: " + n);
              return E = E.replace(/^[^\sa-zA-Z-]+/, ""), w;
            }
            function c(w, A) {
              var D = new fu();
              cu(w, function(q, Y) {
                switch (q) {
                  case "region":
                    for (var ue = o.length - 1; ue >= 0; ue--)
                      if (o[ue].id === J) {
                        D.set(q, o[ue].region);
                        break;
                      }
                    break;
                  case "vertical":
                    D.alt(q, J, ["rl", "lr"]);
                    break;
                  case "line":
                    var me = Y.split(","), Re = me[0];
                    D.integer(q, Re), D.percent(q, Re) && D.set("snapToLines", !1), D.alt(q, Re, ["auto"]), me.length === 2 && D.alt("lineAlign", me[1], ["start", Eo, "end"]);
                    break;
                  case "position":
                    me = Y.split(","), D.percent(q, me[0]), me.length === 2 && D.alt("positionAlign", me[1], ["start", Eo, "end", "line-left", "line-right", "auto"]);
                    break;
                  case "size":
                    D.percent(q, J);
                    break;
                  case "align":
                    D.alt(q, J, ["start", Eo, "end", "left", "right"]);
                    break;
                }
              }, /:/, /\s/), A.region = D.get("region", null), A.vertical = D.get("vertical", "");
              var K = D.get("line", "auto");
              K === "auto" && pl.line === -1 && (K = -1), A.line = K, A.lineAlign = D.get("lineAlign", "start"), A.snapToLines = D.get("snapToLines", !0), A.size = D.get("size", 100), A.align = D.get("align", Eo);
              var M = D.get("position", "auto");
              M === "auto" && pl.position === 50 && (M = A.align === "start" || A.align === "left" ? 0 : A.align === "end" || A.align === "right" ? 100 : 50), A.position = M;
            }
            function g() {
              E = E.replace(/^\s+/, "");
            }
            if (g(), s.startTime = l(), g(), E.substr(0, 3) !== "-->")
              throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + n);
            E = E.substr(3), g(), s.endTime = l(), g(), c(E, s);
          }
          function du(E) {
            return E.replace(/<br(?: \/)?>/gi, `
`);
          }
          uu.prototype = {
            parse: function(s) {
              var o = this;
              s && (o.buffer += o.decoder.decode(s, { stream: !0 }));
              function n() {
                var D = o.buffer, K = 0;
                for (D = du(D); K < D.length && D[K] !== "\r" && D[K] !== `
`; )
                  ++K;
                var M = D.substr(0, K);
                return D[K] === "\r" && ++K, D[K] === `
` && ++K, o.buffer = D.substr(K), M;
              }
              function l(D) {
                cu(D, function(K, M) {
                  switch (K) {
                    case "Region":
                      console.log("parse region", M);
                      break;
                  }
                }, /:/);
              }
              try {
                var c;
                if (o.state === "INITIAL") {
                  if (!/\r\n|\n/.test(o.buffer))
                    return this;
                  c = n();
                  var g = c.match(/^()?WEBVTT([ \t].*)?$/);
                  if (!g || !g[0])
                    throw new Error("Malformed WebVTT signature.");
                  o.state = "HEADER";
                }
                for (var w = !1; o.buffer; ) {
                  if (!/\r\n|\n/.test(o.buffer))
                    return this;
                  switch (w ? w = !1 : c = n(), o.state) {
                    case "HEADER":
                      /:/.test(c) ? l(c) : c || (o.state = "ID");
                      continue;
                    case "NOTE":
                      c || (o.state = "ID");
                      continue;
                    case "ID":
                      if (/^NOTE($|[ \t])/.test(c)) {
                        o.state = "NOTE";
                        break;
                      }
                      if (!c)
                        continue;
                      if (o.cue = new lu(0, 0, ""), o.state = "CUE", c.indexOf("-->") === -1) {
                        o.cue.id = c;
                        continue;
                      }
                    case "CUE":
                      try {
                        qp(c, o.cue, o.regionList);
                      } catch {
                        o.cue = null, o.state = "BADCUE";
                        continue;
                      }
                      o.state = "CUETEXT";
                      continue;
                    case "CUETEXT":
                      var A = c.indexOf("-->") !== -1;
                      if (!c || A && (w = !0)) {
                        o.oncue && o.oncue(o.cue), o.cue = null, o.state = "ID";
                        continue;
                      }
                      o.cue.text && (o.cue.text += `
`), o.cue.text += c;
                      continue;
                    case "BADCUE":
                      c || (o.state = "ID");
                      continue;
                  }
                }
              } catch {
                o.state === "CUETEXT" && o.cue && o.oncue && o.oncue(o.cue), o.cue = null, o.state = o.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
              }
              return this;
            },
            flush: function() {
              var s = this;
              try {
                if (s.buffer += s.decoder.decode(), (s.cue || s.state === "HEADER") && (s.buffer += `

`, s.parse()), s.state === "INITIAL")
                  throw new Error("Malformed WebVTT signature.");
              } catch (o) {
                throw o;
              }
              return s.onflush && s.onflush(), this;
            }
          };
          var Xp = uu;
          function zp(E, s, o, n) {
            for (var l, c, g, w, A, D = window.VTTCue || window.TextTrackCue, K = 0; K < n.rows.length; K++)
              if (l = n.rows[K], g = !0, w = 0, A = "", !l.isEmpty()) {
                for (var j = 0; j < l.chars.length; j++)
                  l.chars[j].uchar.match(/\s/) && g ? w++ : (A += l.chars[j].uchar, g = !1);
                l.cueStartTime = s, s === o && (o += 1e-4), c = new D(s, o, du(A.trim())), w >= 16 ? w-- : w++, navigator.userAgent.match(/Firefox\//) ? c.line = K + 1 : c.line = K > 7 ? K - 2 : K + 1, c.align = "left", c.position = Math.max(0, Math.min(100, 100 * (w / 32) + (navigator.userAgent.match(/Firefox\//) ? 50 : 0))), E.addCue(c);
              }
          }
          function Dn(E, s) {
            if (!(E instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          var pu = {
            42: 225,
            // lowercase a, acute accent
            92: 233,
            // lowercase e, acute accent
            94: 237,
            // lowercase i, acute accent
            95: 243,
            // lowercase o, acute accent
            96: 250,
            // lowercase u, acute accent
            123: 231,
            // lowercase c with cedilla
            124: 247,
            // division symbol
            125: 209,
            // uppercase N tilde
            126: 241,
            // lowercase n tilde
            127: 9608,
            // Full block
            // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
            // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
            // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
            128: 174,
            // Registered symbol (R)
            129: 176,
            // degree sign
            130: 189,
            // 1/2 symbol
            131: 191,
            // Inverted (open) question mark
            132: 8482,
            // Trademark symbol (TM)
            133: 162,
            // Cents symbol
            134: 163,
            // Pounds sterling
            135: 9834,
            // Music 8'th note
            136: 224,
            // lowercase a, grave accent
            137: 32,
            // transparent space (regular)
            138: 232,
            // lowercase e, grave accent
            139: 226,
            // lowercase a, circumflex accent
            140: 234,
            // lowercase e, circumflex accent
            141: 238,
            // lowercase i, circumflex accent
            142: 244,
            // lowercase o, circumflex accent
            143: 251,
            // lowercase u, circumflex accent
            // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
            // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
            144: 193,
            // capital letter A with acute
            145: 201,
            // capital letter E with acute
            146: 211,
            // capital letter O with acute
            147: 218,
            // capital letter U with acute
            148: 220,
            // capital letter U with diaresis
            149: 252,
            // lowercase letter U with diaeresis
            150: 8216,
            // opening single quote
            151: 161,
            // inverted exclamation mark
            152: 42,
            // asterisk
            153: 8217,
            // closing single quote
            154: 9473,
            // box drawings heavy horizontal
            155: 169,
            // copyright sign
            156: 8480,
            // Service mark
            157: 8226,
            // (round) bullet
            158: 8220,
            // Left double quotation mark
            159: 8221,
            // Right double quotation mark
            160: 192,
            // uppercase A, grave accent
            161: 194,
            // uppercase A, circumflex
            162: 199,
            // uppercase C with cedilla
            163: 200,
            // uppercase E, grave accent
            164: 202,
            // uppercase E, circumflex
            165: 203,
            // capital letter E with diaresis
            166: 235,
            // lowercase letter e with diaresis
            167: 206,
            // uppercase I, circumflex
            168: 207,
            // uppercase I, with diaresis
            169: 239,
            // lowercase i, with diaresis
            170: 212,
            // uppercase O, circumflex
            171: 217,
            // uppercase U, grave accent
            172: 249,
            // lowercase u, grave accent
            173: 219,
            // uppercase U, circumflex
            174: 171,
            // left-pointing double angle quotation mark
            175: 187,
            // right-pointing double angle quotation mark
            // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
            // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
            176: 195,
            // Uppercase A, tilde
            177: 227,
            // Lowercase a, tilde
            178: 205,
            // Uppercase I, acute accent
            179: 204,
            // Uppercase I, grave accent
            180: 236,
            // Lowercase i, grave accent
            181: 210,
            // Uppercase O, grave accent
            182: 242,
            // Lowercase o, grave accent
            183: 213,
            // Uppercase O, tilde
            184: 245,
            // Lowercase o, tilde
            185: 123,
            // Open curly brace
            186: 125,
            // Closing curly brace
            187: 92,
            // Backslash
            188: 94,
            // Caret
            189: 95,
            // Underscore
            190: 124,
            // Pipe (vertical line)
            191: 8764,
            // Tilde operator
            192: 196,
            // Uppercase A, umlaut
            193: 228,
            // Lowercase A, umlaut
            194: 214,
            // Uppercase O, umlaut
            195: 246,
            // Lowercase o, umlaut
            196: 223,
            // Esszett (sharp S)
            197: 165,
            // Yen symbol
            198: 164,
            // Generic currency sign
            199: 9475,
            // Box drawings heavy vertical
            200: 197,
            // Uppercase A, ring
            201: 229,
            // Lowercase A, ring
            202: 216,
            // Uppercase O, stroke
            203: 248,
            // Lowercase o, strok
            204: 9487,
            // Box drawings heavy down and right
            205: 9491,
            // Box drawings heavy down and left
            206: 9495,
            // Box drawings heavy up and right
            207: 9499
            // Box drawings heavy up and left
          }, hu = function(s) {
            var o = s;
            return pu.hasOwnProperty(s) && (o = pu[s]), String.fromCharCode(o);
          }, Mr = 15, yi = 100, Hp = { 17: 1, 18: 3, 21: 5, 22: 7, 23: 9, 16: 11, 19: 12, 20: 14 }, Zp = { 17: 2, 18: 4, 21: 6, 22: 8, 23: 10, 19: 13, 20: 15 }, Wp = { 25: 1, 26: 3, 29: 5, 30: 7, 31: 9, 24: 11, 27: 12, 28: 14 }, Yp = { 25: 2, 26: 4, 29: 6, 30: 8, 31: 10, 27: 13, 28: 15 }, Jp = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"], Fe = {
            verboseFilter: { DATA: 3, DEBUG: 3, INFO: 2, WARNING: 2, TEXT: 1, ERROR: 0 },
            time: null,
            verboseLevel: 0,
            // Only write errors
            setTime: function(s) {
              this.time = s;
            },
            log: function(s, o) {
              var n = this.verboseFilter[s];
              this.verboseLevel >= n && console.log(this.time + " [" + s + "] " + o);
            }
          }, nn = function(s) {
            for (var o = [], n = 0; n < s.length; n++)
              o.push(s[n].toString(16));
            return o;
          }, mu = function() {
            function E(s, o, n, l, c) {
              Dn(this, E), this.foreground = s || "white", this.underline = o || !1, this.italics = n || !1, this.background = l || "black", this.flash = c || !1;
            }
            return E.prototype.reset = function() {
              this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1;
            }, E.prototype.setStyles = function(o) {
              for (var n = ["foreground", "underline", "italics", "background", "flash"], l = 0; l < n.length; l++) {
                var c = n[l];
                o.hasOwnProperty(c) && (this[c] = o[c]);
              }
            }, E.prototype.isDefault = function() {
              return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash;
            }, E.prototype.equals = function(o) {
              return this.foreground === o.foreground && this.underline === o.underline && this.italics === o.italics && this.background === o.background && this.flash === o.flash;
            }, E.prototype.copy = function(o) {
              this.foreground = o.foreground, this.underline = o.underline, this.italics = o.italics, this.background = o.background, this.flash = o.flash;
            }, E.prototype.toString = function() {
              return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash;
            }, E;
          }(), Qp = function() {
            function E(s, o, n, l, c, g) {
              Dn(this, E), this.uchar = s || " ", this.penState = new mu(o, n, l, c, g);
            }
            return E.prototype.reset = function() {
              this.uchar = " ", this.penState.reset();
            }, E.prototype.setChar = function(o, n) {
              this.uchar = o, this.penState.copy(n);
            }, E.prototype.setPenState = function(o) {
              this.penState.copy(o);
            }, E.prototype.equals = function(o) {
              return this.uchar === o.uchar && this.penState.equals(o.penState);
            }, E.prototype.copy = function(o) {
              this.uchar = o.uchar, this.penState.copy(o.penState);
            }, E.prototype.isEmpty = function() {
              return this.uchar === " " && this.penState.isDefault();
            }, E;
          }(), eh = function() {
            function E() {
              Dn(this, E), this.chars = [];
              for (var s = 0; s < yi; s++)
                this.chars.push(new Qp());
              this.pos = 0, this.currPenState = new mu();
            }
            return E.prototype.equals = function(o) {
              for (var n = !0, l = 0; l < yi; l++)
                if (!this.chars[l].equals(o.chars[l])) {
                  n = !1;
                  break;
                }
              return n;
            }, E.prototype.copy = function(o) {
              for (var n = 0; n < yi; n++)
                this.chars[n].copy(o.chars[n]);
            }, E.prototype.isEmpty = function() {
              for (var o = !0, n = 0; n < yi; n++)
                if (!this.chars[n].isEmpty()) {
                  o = !1;
                  break;
                }
              return o;
            }, E.prototype.setCursor = function(o) {
              this.pos !== o && (this.pos = o), this.pos < 0 ? (Fe.log("ERROR", "Negative cursor position " + this.pos), this.pos = 0) : this.pos > yi && (Fe.log("ERROR", "Too large cursor position " + this.pos), this.pos = yi);
            }, E.prototype.moveCursor = function(o) {
              var n = this.pos + o;
              if (o > 1)
                for (var l = this.pos + 1; l < n + 1; l++)
                  this.chars[l].setPenState(this.currPenState);
              this.setCursor(n);
            }, E.prototype.backSpace = function() {
              this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState);
            }, E.prototype.insertChar = function(o) {
              o >= 144 && this.backSpace();
              var n = hu(o);
              if (this.pos >= yi) {
                Fe.log("ERROR", "Cannot insert " + o.toString(16) + " (" + n + ") at position " + this.pos + ". Skipping it!");
                return;
              }
              this.chars[this.pos].setChar(n, this.currPenState), this.moveCursor(1);
            }, E.prototype.clearFromPos = function(o) {
              var n;
              for (n = o; n < yi; n++)
                this.chars[n].reset();
            }, E.prototype.clear = function() {
              this.clearFromPos(0), this.pos = 0, this.currPenState.reset();
            }, E.prototype.clearToEndOfRow = function() {
              this.clearFromPos(this.pos);
            }, E.prototype.getTextString = function() {
              for (var o = [], n = !0, l = 0; l < yi; l++) {
                var c = this.chars[l].uchar;
                c !== " " && (n = !1), o.push(c);
              }
              return n ? "" : o.join("");
            }, E.prototype.setPenStyles = function(o) {
              this.currPenState.setStyles(o);
              var n = this.chars[this.pos];
              n.setPenState(this.currPenState);
            }, E;
          }(), hl = function() {
            function E() {
              Dn(this, E), this.rows = [];
              for (var s = 0; s < Mr; s++)
                this.rows.push(new eh());
              this.currRow = Mr - 1, this.nrRollUpRows = null, this.reset();
            }
            return E.prototype.reset = function() {
              for (var o = 0; o < Mr; o++)
                this.rows[o].clear();
              this.currRow = Mr - 1;
            }, E.prototype.equals = function(o) {
              for (var n = !0, l = 0; l < Mr; l++)
                if (!this.rows[l].equals(o.rows[l])) {
                  n = !1;
                  break;
                }
              return n;
            }, E.prototype.copy = function(o) {
              for (var n = 0; n < Mr; n++)
                this.rows[n].copy(o.rows[n]);
            }, E.prototype.isEmpty = function() {
              for (var o = !0, n = 0; n < Mr; n++)
                if (!this.rows[n].isEmpty()) {
                  o = !1;
                  break;
                }
              return o;
            }, E.prototype.backSpace = function() {
              var o = this.rows[this.currRow];
              o.backSpace();
            }, E.prototype.clearToEndOfRow = function() {
              var o = this.rows[this.currRow];
              o.clearToEndOfRow();
            }, E.prototype.insertChar = function(o) {
              var n = this.rows[this.currRow];
              n.insertChar(o);
            }, E.prototype.setPen = function(o) {
              var n = this.rows[this.currRow];
              n.setPenStyles(o);
            }, E.prototype.moveCursor = function(o) {
              var n = this.rows[this.currRow];
              n.moveCursor(o);
            }, E.prototype.setCursor = function(o) {
              Fe.log("INFO", "setCursor: " + o);
              var n = this.rows[this.currRow];
              n.setCursor(o);
            }, E.prototype.setPAC = function(o) {
              Fe.log("INFO", "pacData = " + JSON.stringify(o));
              var n = o.row - 1;
              if (this.nrRollUpRows && n < this.nrRollUpRows - 1 && (n = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== n) {
                for (var l = 0; l < Mr; l++)
                  this.rows[l].clear();
                var c = this.currRow + 1 - this.nrRollUpRows, g = this.lastOutputScreen;
                if (g) {
                  var w = g.rows[c].cueStartTime;
                  if (w && w < Fe.time)
                    for (var A = 0; A < this.nrRollUpRows; A++)
                      this.rows[n - this.nrRollUpRows + A + 1].copy(g.rows[c + A]);
                }
              }
              this.currRow = n;
              var D = this.rows[this.currRow];
              if (o.indent !== null) {
                var K = o.indent, M = Math.max(K - 1, 0);
                D.setCursor(o.indent), o.color = D.chars[M].penState.foreground;
              }
              var q = { foreground: o.color, underline: o.underline, italics: o.italics, background: "black", flash: !1 };
              this.setPen(q);
            }, E.prototype.setBkgData = function(o) {
              Fe.log("INFO", "bkgData = " + JSON.stringify(o)), this.backSpace(), this.setPen(o), this.insertChar(32);
            }, E.prototype.setRollUpRows = function(o) {
              this.nrRollUpRows = o;
            }, E.prototype.rollUp = function() {
              if (this.nrRollUpRows === null) {
                Fe.log("DEBUG", "roll_up but nrRollUpRows not set yet");
                return;
              }
              Fe.log("TEXT", this.getDisplayText());
              var o = this.currRow + 1 - this.nrRollUpRows, n = this.rows.splice(o, 1)[0];
              n.clear(), this.rows.splice(this.currRow, 0, n), Fe.log("INFO", "Rolling up");
            }, E.prototype.getDisplayText = function(o) {
              o = o || !1;
              for (var n = [], l = "", c = -1, g = 0; g < Mr; g++) {
                var w = this.rows[g].getTextString();
                w && (c = g + 1, o ? n.push("Row " + c + ": '" + w + "'") : n.push(w.trim()));
              }
              return n.length > 0 && (o ? l = "[" + n.join(" | ") + "]" : l = n.join(`
`)), l;
            }, E.prototype.getTextAndFormat = function() {
              return this.rows;
            }, E;
          }(), yu = function() {
            function E(s, o) {
              Dn(this, E), this.chNr = s, this.outputFilter = o, this.mode = null, this.verbose = 0, this.displayedMemory = new hl(), this.nonDisplayedMemory = new hl(), this.lastOutputScreen = new hl(), this.currRollUpRow = this.displayedMemory.rows[Mr - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null;
            }
            return E.prototype.reset = function() {
              this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.currRollUpRow = this.displayedMemory.rows[Mr - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.lastCueEndTime = null;
            }, E.prototype.getHandler = function() {
              return this.outputFilter;
            }, E.prototype.setHandler = function(o) {
              this.outputFilter = o;
            }, E.prototype.setPAC = function(o) {
              this.writeScreen.setPAC(o);
            }, E.prototype.setBkgData = function(o) {
              this.writeScreen.setBkgData(o);
            }, E.prototype.setMode = function(o) {
              o !== this.mode && (this.mode = o, Fe.log("INFO", "MODE=" + o), this.mode === "MODE_POP-ON" ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), this.mode !== "MODE_ROLL-UP" && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = o);
            }, E.prototype.insertChars = function(o) {
              for (var n = 0; n < o.length; n++)
                this.writeScreen.insertChar(o[n]);
              var l = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
              Fe.log("INFO", l + ": " + this.writeScreen.getDisplayText(!0)), (this.mode === "MODE_PAINT-ON" || this.mode === "MODE_ROLL-UP") && (Fe.log("TEXT", "DISPLAYED: " + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate());
            }, E.prototype.ccRCL = function() {
              Fe.log("INFO", "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON");
            }, E.prototype.ccBS = function() {
              Fe.log("INFO", "BS - BackSpace"), this.mode !== "MODE_TEXT" && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate());
            }, E.prototype.ccAOF = function() {
            }, E.prototype.ccAON = function() {
            }, E.prototype.ccDER = function() {
              Fe.log("INFO", "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate();
            }, E.prototype.ccRU = function(o) {
              Fe.log("INFO", "RU(" + o + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(o);
            }, E.prototype.ccFON = function() {
              Fe.log("INFO", "FON - Flash On"), this.writeScreen.setPen({ flash: !0 });
            }, E.prototype.ccRDC = function() {
              Fe.log("INFO", "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON");
            }, E.prototype.ccTR = function() {
              Fe.log("INFO", "TR"), this.setMode("MODE_TEXT");
            }, E.prototype.ccRTD = function() {
              Fe.log("INFO", "RTD"), this.setMode("MODE_TEXT");
            }, E.prototype.ccEDM = function() {
              Fe.log("INFO", "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate();
            }, E.prototype.ccCR = function() {
              Fe.log("CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate();
            }, E.prototype.ccENM = function() {
              Fe.log("INFO", "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset();
            }, E.prototype.ccEOC = function() {
              if (Fe.log("INFO", "EOC - End Of Caption"), this.mode === "MODE_POP-ON") {
                var o = this.displayedMemory;
                this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = o, this.writeScreen = this.nonDisplayedMemory, Fe.log("TEXT", "DISP: " + this.displayedMemory.getDisplayText());
              }
              this.outputDataUpdate();
            }, E.prototype.ccTO = function(o) {
              Fe.log("INFO", "TO(" + o + ") - Tab Offset"), this.writeScreen.moveCursor(o);
            }, E.prototype.ccMIDROW = function(o) {
              var n = { flash: !1 };
              if (n.underline = o % 2 === 1, n.italics = o >= 46, n.italics)
                n.foreground = "white";
              else {
                var l = Math.floor(o / 2) - 16, c = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
                n.foreground = c[l];
              }
              Fe.log("INFO", "MIDROW: " + JSON.stringify(n)), this.writeScreen.setPen(n);
            }, E.prototype.outputDataUpdate = function() {
              var o = Fe.time;
              o !== null && this.outputFilter && (this.outputFilter.updateData && this.outputFilter.updateData(o, this.displayedMemory), this.cueStartTime === null && !this.displayedMemory.isEmpty() ? this.cueStartTime = o : this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, o, this.lastOutputScreen), this.cueStartTime = this.displayedMemory.isEmpty() ? null : o), this.lastOutputScreen.copy(this.displayedMemory));
            }, E.prototype.cueSplitAtTime = function(o) {
              this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, o, this.displayedMemory), this.cueStartTime = o));
            }, E;
          }(), th = function() {
            function E(s, o, n) {
              Dn(this, E), this.field = s || 1, this.outputs = [o, n], this.channels = [new yu(1, o), new yu(2, n)], this.currChNr = -1, this.lastCmdA = null, this.lastCmdB = null, this.bufferedData = [], this.startTime = null, this.lastTime = null, this.dataCounters = { padding: 0, char: 0, cmd: 0, other: 0 };
            }
            return E.prototype.getHandler = function(o) {
              return this.channels[o].getHandler();
            }, E.prototype.setHandler = function(o, n) {
              this.channels[o].setHandler(n);
            }, E.prototype.addData = function(o, n) {
              var l, c, g, w = !1;
              this.lastTime = o, Fe.setTime(o);
              for (var A = 0; A < n.length; A += 2) {
                if (c = n[A] & 127, g = n[A + 1] & 127, c === 0 && g === 0) {
                  this.dataCounters.padding += 2;
                  continue;
                } else
                  Fe.log("DATA", "[" + nn([n[A], n[A + 1]]) + "] -> (" + nn([c, g]) + ")");
                if (l = this.parseCmd(c, g), l || (l = this.parseMidrow(c, g)), l || (l = this.parsePAC(c, g)), l || (l = this.parseBackgroundAttributes(c, g)), !l && (w = this.parseChars(c, g), w))
                  if (this.currChNr && this.currChNr >= 0) {
                    var D = this.channels[this.currChNr - 1];
                    D.insertChars(w);
                  } else
                    Fe.log("WARNING", "No channel found yet. TEXT-MODE?");
                l ? this.dataCounters.cmd += 2 : w ? this.dataCounters.char += 2 : (this.dataCounters.other += 2, Fe.log("WARNING", "Couldn't parse cleaned data " + nn([c, g]) + " orig: " + nn([n[A], n[A + 1]])));
              }
            }, E.prototype.parseCmd = function(o, n) {
              var l = null, c = (o === 20 || o === 28) && 32 <= n && n <= 47, g = (o === 23 || o === 31) && 33 <= n && n <= 35;
              if (!(c || g))
                return !1;
              if (o === this.lastCmdA && n === this.lastCmdB)
                return this.lastCmdA = null, this.lastCmdB = null, Fe.log("DEBUG", "Repeated command (" + nn([o, n]) + ") is dropped"), !0;
              o === 20 || o === 23 ? l = 1 : l = 2;
              var w = this.channels[l - 1];
              return o === 20 || o === 28 ? n === 32 ? w.ccRCL() : n === 33 ? w.ccBS() : n === 34 ? w.ccAOF() : n === 35 ? w.ccAON() : n === 36 ? w.ccDER() : n === 37 ? w.ccRU(2) : n === 38 ? w.ccRU(3) : n === 39 ? w.ccRU(4) : n === 40 ? w.ccFON() : n === 41 ? w.ccRDC() : n === 42 ? w.ccTR() : n === 43 ? w.ccRTD() : n === 44 ? w.ccEDM() : n === 45 ? w.ccCR() : n === 46 ? w.ccENM() : n === 47 && w.ccEOC() : w.ccTO(n - 32), this.lastCmdA = o, this.lastCmdB = n, this.currChNr = l, !0;
            }, E.prototype.parseMidrow = function(o, n) {
              var l = null;
              if ((o === 17 || o === 25) && 32 <= n && n <= 47) {
                if (o === 17 ? l = 1 : l = 2, l !== this.currChNr)
                  return Fe.log("ERROR", "Mismatch channel in midrow parsing"), !1;
                var c = this.channels[l - 1];
                return c.ccMIDROW(n), Fe.log("DEBUG", "MIDROW (" + nn([o, n]) + ")"), !0;
              }
              return !1;
            }, E.prototype.parsePAC = function(o, n) {
              var l = null, c = null, g = (17 <= o && o <= 23 || 25 <= o && o <= 31) && 64 <= n && n <= 127, w = (o === 16 || o === 24) && 64 <= n && n <= 95;
              if (!(g || w))
                return !1;
              if (o === this.lastCmdA && n === this.lastCmdB)
                return this.lastCmdA = null, this.lastCmdB = null, !0;
              l = o <= 23 ? 1 : 2, 64 <= n && n <= 95 ? c = l === 1 ? Hp[o] : Wp[o] : c = l === 1 ? Zp[o] : Yp[o];
              var A = this.interpretPAC(c, n), D = this.channels[l - 1];
              return D.setPAC(A), this.lastCmdA = o, this.lastCmdB = n, this.currChNr = l, !0;
            }, E.prototype.interpretPAC = function(o, n) {
              var l = n, c = { color: null, italics: !1, indent: null, underline: !1, row: o };
              return n > 95 ? l = n - 96 : l = n - 64, c.underline = (l & 1) === 1, l <= 13 ? c.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(l / 2)] : l <= 15 ? (c.italics = !0, c.color = "white") : c.indent = Math.floor((l - 16) / 2) * 4, c;
            }, E.prototype.parseChars = function(o, n) {
              var l = null, c = null, g = null;
              if (o >= 25 ? (l = 2, g = o - 8) : (l = 1, g = o), 17 <= g && g <= 19) {
                var w = n;
                g === 17 ? w = n + 80 : g === 18 ? w = n + 112 : w = n + 144, Fe.log("INFO", "Special char '" + hu(w) + "' in channel " + l), c = [w];
              } else 32 <= o && o <= 127 && (c = n === 0 ? [o] : [o, n]);
              if (c) {
                var A = nn(c);
                Fe.log("DEBUG", "Char codes =  " + A.join(",")), this.lastCmdA = null, this.lastCmdB = null;
              }
              return c;
            }, E.prototype.parseBackgroundAttributes = function(o, n) {
              var l, c, g, w, A = (o === 16 || o === 24) && 32 <= n && n <= 47, D = (o === 23 || o === 31) && 45 <= n && n <= 47;
              return A || D ? (l = {}, o === 16 || o === 24 ? (c = Math.floor((n - 32) / 2), l.background = Jp[c], n % 2 === 1 && (l.background = l.background + "_semi")) : n === 45 ? l.background = "transparent" : (l.foreground = "black", n === 47 && (l.underline = !0)), g = o < 24 ? 1 : 2, w = this.channels[g - 1], w.setBkgData(l), this.lastCmdA = null, this.lastCmdB = null, !0) : !1;
            }, E.prototype.reset = function() {
              for (var o = 0; o < this.channels.length; o++)
                this.channels[o] && this.channels[o].reset();
              this.lastCmdA = null, this.lastCmdB = null;
            }, E.prototype.cueSplitAtTime = function(o) {
              for (var n = 0; n < this.channels.length; n++)
                this.channels[n] && this.channels[n].cueSplitAtTime(o);
            }, E;
          }(), rh = th, ml = function(s, o, n) {
            return s.substr(0, o.length) === o;
          }, ih = function(s) {
            var o = parseInt(s.substr(-3)), n = parseInt(s.substr(-6, 2)), l = parseInt(s.substr(-9, 2)), c = s.length > 9 ? parseInt(s.substr(0, s.indexOf(":"))) : 0;
            return isNaN(o) || isNaN(n) || isNaN(l) || isNaN(c) ? -1 : (o += 1e3 * n, o += 60 * 1e3 * l, o += 60 * 60 * 1e3 * c, o);
          }, yl = function(s) {
            for (var o = 5381, n = s.length; n; )
              o = o * 33 ^ s.charCodeAt(--n);
            return (o >>> 0).toString();
          }, nh = function(s, o, n) {
            var l = s[o], c = s[l.prevCC];
            if (!c || !c.new && l.new) {
              s.ccOffset = s.presentationOffset = l.start, l.new = !1;
              return;
            }
            for (; c && c.new; )
              s.ccOffset += l.start - c.start, l.new = !1, l = c, c = s[l.prevCC];
            s.presentationOffset = n;
          }, ah = {
            parse: function(s, o, n, l, c, g) {
              var w = /\r\n|\n\r|\n|\r/g, A = new Uint8Array(s).reduce(function(be, Pe) {
                return be + String.fromCharCode(Pe);
              }, "").trim().replace(w, `
`).split(`
`), D = "00:00.000", K = 0, j = 0, q = 0, Y = [], ue = void 0, me = !0, Re = new Xp();
              Re.oncue = function(be) {
                var Pe = n[l], ke = n.ccOffset;
                Pe && Pe.new && (j !== void 0 ? ke = n.ccOffset = Pe.start : nh(n, l, q)), q && (ke = q + n.ccOffset - n.presentationOffset), be.startTime += ke - j, be.endTime += ke - j, be.id = yl(be.startTime) + yl(be.endTime) + yl(be.text), be.text = decodeURIComponent(escape(be.text)), be.endTime > 0 && Y.push(be);
              }, Re.onparsingerror = function(be) {
                ue = be;
              }, Re.onflush = function() {
                if (ue && g) {
                  g(ue);
                  return;
                }
                c(Y);
              }, A.forEach(function(be) {
                if (me)
                  if (ml(be, "X-TIMESTAMP-MAP=")) {
                    me = !1, be.substr(16).split(",").forEach(function(Pe) {
                      ml(Pe, "LOCAL:") ? D = Pe.substr(6) : ml(Pe, "MPEGTS:") && (K = parseInt(Pe.substr(7)));
                    });
                    try {
                      o = o < 0 ? o + 8589934592 : o, K -= o, j = ih(D) / 1e3, q = K / 9e4, j === -1 && (ue = new Error("Malformed X-TIMESTAMP-MAP: " + be));
                    } catch {
                      ue = new Error("Malformed X-TIMESTAMP-MAP: " + be);
                    }
                    return;
                  } else be === "" && (me = !1);
                Re.parse(be + `
`);
              }), Re.flush();
            }
          }, sh = ah;
          function oh(E, s) {
            if (!(E instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function lh(E, s) {
            if (!E)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : E;
          }
          function uh(E, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            E.prototype = Object.create(s && s.prototype, { constructor: { value: E, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(E, s) : E.__proto__ = s);
          }
          function sa(E) {
            if (E && E.cues)
              for (; E.cues.length > 0; )
                E.removeCue(E.cues[0]);
          }
          function fh(E, s) {
            return E && E.label === s.name && !(E.textTrack1 || E.textTrack2);
          }
          function ch(E, s, o, n) {
            return Math.min(s, n) - Math.max(E, o);
          }
          var dh = function(E) {
            uh(s, E);
            function s(o) {
              oh(this, s);
              var n = lh(this, E.call(this, o, m.a.MEDIA_ATTACHING, m.a.MEDIA_DETACHING, m.a.FRAG_PARSING_USERDATA, m.a.FRAG_DECRYPTED, m.a.MANIFEST_LOADING, m.a.MANIFEST_LOADED, m.a.FRAG_LOADED, m.a.LEVEL_SWITCHING, m.a.INIT_PTS_FOUND));
              if (n.hls = o, n.config = o.config, n.enabled = !0, n.Cues = o.config.cueHandler, n.textTracks = [], n.tracks = [], n.unparsedVttFrags = [], n.initPTS = void 0, n.cueRanges = [], n.config.enableCEA708Captions) {
                var l = n, c = function(D, K) {
                  var M = null;
                  try {
                    M = new window.Event("addtrack");
                  } catch {
                    M = document.createEvent("Event"), M.initEvent("addtrack", !1, !1);
                  }
                  M.track = D, K.dispatchEvent(M);
                }, g = {
                  newCue: function(D, K, M) {
                    if (!l.textTrack1) {
                      var q = l.getExistingTrack("1");
                      if (q)
                        l.textTrack1 = q, sa(l.textTrack1), c(l.textTrack1, l.media);
                      else {
                        var J = l.createTextTrack("captions", l.config.captionsTextTrack1Label, l.config.captionsTextTrack1LanguageCode);
                        J && (J.textTrack1 = !0, l.textTrack1 = J);
                      }
                    }
                    l.addCues("textTrack1", D, K, M);
                  }
                }, w = {
                  newCue: function(D, K, j) {
                    if (!l.textTrack2) {
                      var q = l.getExistingTrack("2");
                      if (q)
                        l.textTrack2 = q, sa(l.textTrack2), c(l.textTrack2, l.media);
                      else {
                        var J = l.createTextTrack("captions", l.config.captionsTextTrack2Label, l.config.captionsTextTrack1LanguageCode);
                        J && (J.textTrack2 = !0, l.textTrack2 = J);
                      }
                    }
                    l.addCues("textTrack2", D, K, M);
                  }
                };
                n.cea608Parser = new rh(0, g, w);
              }
              return n;
            }
            return s.prototype.addCues = function(n, l, c, g) {
              for (var w = this.cueRanges, A = !1, D = w.length; D--; ) {
                var K = w[D], j = ch(K[0], K[1], l, c);
                if (j >= 0 && (K[0] = Math.min(K[0], l), K[1] = Math.max(K[1], c), A = !0, j / (c - l) > 0.5))
                  return;
              }
              A || w.push([l, c]), this.Cues.newCue(this[n], l, c, g);
            }, s.prototype.onInitPtsFound = function(n) {
              var l = this;
              typeof this.initPTS > "u" && (this.initPTS = n.initPTS), this.unparsedVttFrags.length && (this.unparsedVttFrags.forEach(function(c) {
                l.onFragLoaded(c);
              }), this.unparsedVttFrags = []);
            }, s.prototype.getExistingTrack = function(n) {
              var l = this.media;
              if (l)
                for (var c = 0; c < l.textTracks.length; c++) {
                  var g = l.textTracks[c], w = "textTrack" + n;
                  if (g[w] === !0)
                    return g;
                }
              return null;
            }, s.prototype.createTextTrack = function(n, l, c) {
              var g = this.media;
              if (g)
                return g.addTextTrack(n, l, c);
            }, s.prototype.destroy = function() {
              I.prototype.destroy.call(this);
            }, s.prototype.onMediaAttaching = function(n) {
              this.media = n.media;
            }, s.prototype.onMediaDetaching = function() {
              sa(this.textTrack1), sa(this.textTrack2);
            }, s.prototype.onManifestLoading = function() {
              this.lastSn = -1, this.prevCC = -1, this.vttCCs = { ccOffset: 0, presentationOffset: 0 };
              var n = this.media;
              if (n) {
                var l = n.textTracks;
                if (l)
                  for (var c = 0; c < l.length; c++)
                    sa(l[c]);
              }
            }, s.prototype.onManifestLoaded = function(n) {
              var l = this;
              if (this.textTracks = [], this.unparsedVttFrags = this.unparsedVttFrags || [], this.initPTS = void 0, this.cueRanges = [], this.config.enableWebVTT) {
                this.tracks = n.subtitles || [];
                var c = this.media ? this.media.textTracks : [];
                this.tracks.forEach(function(g, w) {
                  var A = void 0;
                  if (w < c.length) {
                    var D = c[w];
                    fh(D, g) && (A = D);
                  }
                  A || (A = l.createTextTrack("subtitles", g.name, g.lang)), A.mode = g.default ? "showing" : "hidden", l.textTracks.push(A);
                });
              }
            }, s.prototype.onLevelSwitching = function() {
              this.enabled = this.hls.currentLevel.closedCaptions !== "NONE";
            }, s.prototype.onFragLoaded = function(n) {
              var l = n.frag, c = n.payload;
              if (l.type === "main") {
                var g = l.sn;
                if (g !== this.lastSn + 1) {
                  var w = this.cea608Parser;
                  w && w.reset();
                }
                this.lastSn = g;
              } else if (l.type === "subtitle")
                if (c.byteLength) {
                  if (typeof this.initPTS > "u") {
                    this.unparsedVttFrags.push(n);
                    return;
                  }
                  var A = l.decryptdata;
                  (A == null || A.key == null || A.method !== "AES-128") && this._parseVTTs(l, c);
                } else
                  this.hls.trigger(h.a.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: l });
            }, s.prototype._parseVTTs = function(n, l) {
              var c = this.vttCCs;
              c[n.cc] || (c[n.cc] = { start: n.start, prevCC: this.prevCC, new: !0 }, this.prevCC = n.cc);
              var g = this.textTracks, w = this.hls;
              sh.parse(l, this.initPTS, c, n.cc, function(A) {
                var D = g[n.trackId];
                A.forEach(function(K) {
                  if (!D.cues.getCueById(K.id))
                    try {
                      D.addCue(K);
                    } catch {
                      var M = new window.TextTrackCue(K.startTime, K.endTime, K.text);
                      M.id = K.id, D.addCue(M);
                    }
                }), w.trigger(m.a.SUBTITLE_FRAG_PROCESSED, { success: !0, frag: n });
              }, function(A) {
                d.b.log("Failed to parse VTT cue: " + A), w.trigger(m.a.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: n });
              });
            }, s.prototype.onFragDecrypted = function(n) {
              var l = n.payload, c = n.frag;
              if (c.type === "subtitle") {
                if (typeof this.initPTS > "u") {
                  this.unparsedVttFrags.push(n);
                  return;
                }
                this._parseVTTs(c, l);
              }
            }, s.prototype.onFragParsingUserdata = function(n) {
              if (this.enabled && this.config.enableCEA708Captions)
                for (var l = 0; l < n.samples.length; l++) {
                  var c = this.extractCea608Data(n.samples[l].bytes);
                  this.cea608Parser.addData(n.samples[l].pts, c);
                }
            }, s.prototype.extractCea608Data = function(n) {
              for (var l = n[0] & 31, c = 2, g, w, A, D, K, j = [], q = 0; q < l; q++)
                g = n[c++], w = 127 & n[c++], A = 127 & n[c++], D = (4 & g) !== 0, K = 3 & g, !(w === 0 && A === 0) && D && K === 0 && (j.push(w), j.push(A));
              return j;
            }, s;
          }(I), ph = dh, hh = /* @__PURE__ */ function() {
            function E(s, o) {
              for (var n = 0; n < o.length; n++) {
                var l = o[n];
                l.enumerable = l.enumerable || !1, l.configurable = !0, "value" in l && (l.writable = !0), Object.defineProperty(s, l.key, l);
              }
            }
            return function(s, o, n) {
              return o && E(s.prototype, o), n && E(s, n), s;
            };
          }();
          function mh(E, s) {
            if (!(E instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function yh(E, s) {
            if (!E)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : E;
          }
          function bh(E, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            E.prototype = Object.create(s && s.prototype, { constructor: { value: E, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(E, s) : E.__proto__ = s);
          }
          function bu(E) {
            for (var s = [], o = 0; o < E.length; o++)
              E[o].kind === "subtitles" && s.push(E[o]);
            return s;
          }
          var xh = function(E) {
            bh(s, E);
            function s(o) {
              mh(this, s);
              var n = yh(this, E.call(this, o, m.a.MEDIA_ATTACHED, m.a.MEDIA_DETACHING, m.a.MANIFEST_LOADING, m.a.MANIFEST_LOADED, m.a.SUBTITLE_TRACK_LOADED));
              return n.tracks = [], n.trackId = -1, n.media = void 0, n.subtitleDisplay = !1, n;
            }
            return s.prototype._onTextTracksChanged = function() {
              if (this.media) {
                for (var n = -1, l = bu(this.media.textTracks), c = 0; c < l.length; c++)
                  l[c].mode === "showing" && (n = c);
                this.subtitleTrack = n;
              }
            }, s.prototype.destroy = function() {
              I.prototype.destroy.call(this);
            }, s.prototype.onMediaAttached = function(n) {
              var l = this;
              this.media = n.media, this.media && (this.trackChangeListener = this._onTextTracksChanged.bind(this), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.subtitlePollingInterval = setInterval(function() {
                l.trackChangeListener();
              }, 500) : this.media.textTracks.addEventListener("change", this.trackChangeListener));
            }, s.prototype.onMediaDetaching = function() {
              this.media && (this.useTextTrackPolling ? clearInterval(this.subtitlePollingInterval) : this.media.textTracks.removeEventListener("change", this.trackChangeListener), this.media = void 0);
            }, s.prototype.onManifestLoading = function() {
              this.tracks = [], this.trackId = -1;
            }, s.prototype.onManifestLoaded = function(n) {
              var l = this, c = n.subtitles || [];
              this.tracks = c, this.trackId = -1, this.hls.trigger(h.a.SUBTITLE_TRACKS_UPDATED, { subtitleTracks: c }), c.forEach(function(g) {
                g.default && (l.subtitleTrack = g.id);
              });
            }, s.prototype.onTick = function() {
              var n = this.trackId, l = this.tracks[n];
              if (l) {
                var c = l.details;
                (c === void 0 || c.live === !0) && (d.b.log("(re)loading playlist for subtitle track " + n), this.hls.trigger(h.a.SUBTITLE_TRACK_LOADING, { url: l.url, id: n }));
              }
            }, s.prototype.onSubtitleTrackLoaded = function(n) {
              var l = this;
              n.id < this.tracks.length && (d.b.log("subtitle track " + n.id + " loaded"), this.tracks[n.id].details = n.details, n.details.live && !this.timer && (this.timer = setInterval(function() {
                l.onTick();
              }, 1e3 * n.details.targetduration, this)), !n.details.live && this.timer && (clearInterval(this.timer), this.timer = null));
            }, s.prototype.setSubtitleTrackInternal = function(n) {
              if (!(n < -1 || n >= this.tracks.length)) {
                this.timer && (clearInterval(this.timer), this.timer = null);
                var l = bu(this.media.textTracks);
                if (this.trackId !== -1 && this.subtitleDisplay && (l[this.trackId].mode = "hidden"), this.trackId = n, d.b.log("switching to subtitle track " + n), this.hls.trigger(h.a.SUBTITLE_TRACK_SWITCH, { id: n }), n !== -1) {
                  var c = this.tracks[n];
                  this.subtitleDisplay && (l[n].mode = "showing");
                  var g = c.details;
                  (g === void 0 || g.live === !0) && (d.b.log("(re)loading playlist for subtitle track " + n), this.hls.trigger(h.a.SUBTITLE_TRACK_LOADING, { url: c.url, id: n }));
                }
              }
            }, hh(s, [{
              key: "subtitleTracks",
              get: function() {
                return this.tracks;
              }
              /** get index of the selected subtitle track (index in subtitle track lists) **/
            }, {
              key: "subtitleTrack",
              get: function() {
                return this.trackId;
              },
              set: function(n) {
                this.trackId !== n && this.setSubtitleTrackInternal(n);
              }
            }]), s;
          }(I), Eh = xh, gh = u(3);
          function vh(E, s) {
            if (!(E instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          function Rh(E, s) {
            if (!E)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return s && (typeof s == "object" || typeof s == "function") ? s : E;
          }
          function Ah(E, s) {
            if (typeof s != "function" && s !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof s);
            E.prototype = Object.create(s && s.prototype, { constructor: { value: E, enumerable: !1, writable: !0, configurable: !0 } }), s && (Object.setPrototypeOf ? Object.setPrototypeOf(E, s) : E.__proto__ = s);
          }
          var Zr = {
            STOPPED: "STOPPED",
            IDLE: "IDLE",
            KEY_LOADING: "KEY_LOADING",
            FRAG_LOADING: "FRAG_LOADING"
          }, _h = function(E) {
            Ah(s, E);
            function s(o) {
              vh(this, s);
              var n = Rh(this, E.call(this, o, m.a.MEDIA_ATTACHED, m.a.ERROR, m.a.KEY_LOADED, m.a.FRAG_LOADED, m.a.SUBTITLE_TRACKS_UPDATED, m.a.SUBTITLE_TRACK_SWITCH, m.a.SUBTITLE_TRACK_LOADED, m.a.SUBTITLE_FRAG_PROCESSED));
              return n.config = o.config, n.vttFragSNsProcessed = {}, n.vttFragQueues = void 0, n.currentlyProcessing = null, n.state = Hr.STOPPED, n.currentTrackId = -1, n.ticks = 0, n.decrypter = new gh.a(o.observer, o.config), n;
            }
            return s.prototype.destroy = function() {
              I.prototype.destroy.call(this), this.state = Zr.STOPPED;
            }, s.prototype.clearVttFragQueues = function() {
              var n = this;
              this.vttFragQueues = {}, this.tracks.forEach(function(l) {
                n.vttFragQueues[l.id] = [];
              });
            }, s.prototype.nextFrag = function() {
              if (this.currentlyProcessing === null && this.currentTrackId > -1 && this.vttFragQueues[this.currentTrackId].length) {
                var n = this.currentlyProcessing = this.vttFragQueues[this.currentTrackId].shift();
                this.fragCurrent = n, this.hls.trigger(h.a.FRAG_LOADING, { frag: n }), this.state = Zr.FRAG_LOADING;
              }
            }, s.prototype.onSubtitleFragProcessed = function(n) {
              n.success && this.vttFragSNsProcessed[n.frag.trackId].push(n.frag.sn), this.currentlyProcessing = null, this.state = Zr.IDLE, this.nextFrag();
            }, s.prototype.onMediaAttached = function() {
              this.state = Zr.IDLE;
            }, s.prototype.onError = function(n) {
              var l = n.frag;
              l && l.type !== "subtitle" || this.currentlyProcessing && (this.currentlyProcessing = null, this.nextFrag());
            }, s.prototype.tick = function() {
              var n = this;
              this.ticks++, this.ticks === 1 && (this.doTick(), this.ticks > 1 && setTimeout(function() {
                n.tick();
              }, 1), this.ticks = 0);
            }, s.prototype.doTick = function() {
              var n = this;
              switch (this.state) {
                case Hr.IDLE:
                  var l = this.tracks, c = this.currentTrackId, g = this.vttFragSNsProcessed[c], w = this.vttFragQueues[c], A = this.currentlyProcessing ? this.currentlyProcessing.sn : -1, D = function(Y) {
                    return g.indexOf(Y.sn) > -1;
                  }, K = function(Y) {
                    return w.some(function(ue) {
                      return ue.sn === Y.sn;
                    });
                  };
                  if (!l)
                    break;
                  var M;
                  if (c < l.length && (M = l[c].details), typeof M > "u")
                    break;
                  j.fragments.forEach(function(q) {
                    D(q) || q.sn === A || K(q) || (q.decryptdata && q.decryptdata.uri != null && q.decryptdata.key == null ? (d.b.log("Loading key for " + q.sn), n.state = Hr.KEY_LOADING, n.hls.trigger(m.a.KEY_LOADING, { frag: q })) : (q.trackId = c, w.push(q), n.nextFrag()));
                  });
              }
            }, s.prototype.onSubtitleTracksUpdated = function(n) {
              var l = this;
              d.b.log("subtitle tracks updated"), this.tracks = n.subtitleTracks, this.clearVttFragQueues(), this.vttFragSNsProcessed = {}, this.tracks.forEach(function(c) {
                l.vttFragSNsProcessed[c.id] = [];
              });
            }, s.prototype.onSubtitleTrackSwitch = function(n) {
              this.currentTrackId = n.id, this.clearVttFragQueues();
            }, s.prototype.onSubtitleTrackLoaded = function() {
              this.tick();
            }, s.prototype.onKeyLoaded = function() {
              this.state === Zr.KEY_LOADING && (this.state = Zr.IDLE, this.tick());
            }, s.prototype.onFragLoaded = function(n) {
              var l = this.fragCurrent, c = n.frag.decryptdata, g = n.frag, w = this.hls;
              if (this.state === Hr.FRAG_LOADING && l && n.frag.type === "subtitle" && l.sn === n.frag.sn && n.payload.byteLength > 0 && c != null && c.key != null && c.method === "AES-128") {
                var A;
                try {
                  A = performance.now();
                } catch {
                  A = Date.now();
                }
                this.decrypter.decrypt(n.payload, c.key.buffer, c.iv.buffer, function(D) {
                  var K;
                  try {
                    K = performance.now();
                  } catch {
                    K = Date.now();
                  }
                  w.trigger(m.a.FRAG_DECRYPTED, { frag: g, payload: D, stats: { tstart: A, tdecrypt: K } });
                });
              }
            }, s;
          }(I), Th = _h, Ar = {
            autoStartLoad: !0,
            // used by stream-controller
            startPosition: -1,
            // used by stream-controller
            defaultAudioCodec: void 0,
            // used by stream-controller
            debug: !1,
            // used by logger
            capLevelOnFPSDrop: !1,
            // used by fps-controller
            capLevelToPlayerSize: !1,
            // used by cap-level-controller
            initialLiveManifestSize: 1,
            // used by stream-controller
            maxBufferLength: 30,
            // used by stream-controller
            maxBufferSize: 60 * 1e3 * 1e3,
            // used by stream-controller
            maxBufferHole: 0.5,
            // used by stream-controller
            maxSeekHole: 2,
            // used by stream-controller
            lowBufferWatchdogPeriod: 0.5,
            // used by stream-controller
            highBufferWatchdogPeriod: 3,
            // used by stream-controller
            nudgeOffset: 0.1,
            // used by stream-controller
            nudgeMaxRetry: 3,
            // used by stream-controller
            maxFragLookUpTolerance: 0.25,
            // used by stream-controller
            liveSyncDurationCount: 3,
            // used by stream-controller
            liveMaxLatencyDurationCount: 1 / 0,
            // used by stream-controller
            liveSyncDuration: void 0,
            // used by stream-controller
            liveMaxLatencyDuration: void 0,
            // used by stream-controller
            maxMaxBufferLength: 600,
            // used by stream-controller
            enableWorker: !0,
            // used by demuxer
            enableSoftwareAES: !0,
            // used by decrypter
            manifestLoadingTimeOut: 1e4,
            // used by playlist-loader
            manifestLoadingMaxRetry: 1,
            // used by playlist-loader
            manifestLoadingRetryDelay: 1e3,
            // used by playlist-loader
            manifestLoadingMaxRetryTimeout: 64e3,
            // used by playlist-loader
            startLevel: void 0,
            // used by level-controller
            levelLoadingTimeOut: 1e4,
            // used by playlist-loader
            levelLoadingMaxRetry: 4,
            // used by playlist-loader
            levelLoadingRetryDelay: 1e3,
            // used by playlist-loader
            levelLoadingMaxRetryTimeout: 64e3,
            // used by playlist-loader
            fragLoadingTimeOut: 2e4,
            // used by fragment-loader
            fragLoadingMaxRetry: 6,
            // used by fragment-loader
            fragLoadingRetryDelay: 1e3,
            // used by fragment-loader
            fragLoadingMaxRetryTimeout: 64e3,
            // used by fragment-loader
            fragLoadingLoopThreshold: 3,
            // used by stream-controller
            startFragPrefetch: !1,
            // used by stream-controller
            fpsDroppedMonitoringPeriod: 5e3,
            // used by fps-controller
            fpsDroppedMonitoringThreshold: 0.2,
            // used by fps-controller
            appendErrorMaxRetry: 3,
            // used by buffer-controller
            loader: ae,
            //loader: FetchLoader,
            fLoader: void 0,
            pLoader: void 0,
            xhrSetup: void 0,
            fetchSetup: void 0,
            abrController: Vi,
            bufferController: Mi,
            capLevelController: Cn,
            fpsController: G,
            stretchShortVideoTrack: !1,
            // used by mp4-remuxer
            maxAudioFramesDrift: 1,
            // used by mp4-remuxer
            forceKeyFrameOnDiscontinuity: !0,
            // used by ts-demuxer
            abrEwmaFastLive: 3,
            // used by abr-controller
            abrEwmaSlowLive: 9,
            // used by abr-controller
            abrEwmaFastVoD: 3,
            // used by abr-controller
            abrEwmaSlowVoD: 9,
            // used by abr-controller
            abrEwmaDefaultEstimate: 5e5,
            // 500 kbps  // used by abr-controller
            abrBandWidthFactor: 0.95,
            // used by abr-controller
            abrBandWidthUpFactor: 0.7,
            // used by abr-controller
            abrMaxWithRealBitrate: !1,
            // used by abr-controller
            maxStarvationDelay: 4,
            // used by abr-controller
            maxLoadingDelay: 4,
            // used by abr-controller
            minAutoBitrate: 0
            // used by hls
          };
          Ar.subtitleStreamController = Th, Ar.subtitleTrackController = Eh, Ar.timelineController = ph, Ar.cueHandler = x, Ar.enableCEA708Captions = !0, Ar.enableWebVTT = !0, Ar.captionsTextTrack1Label = "English", Ar.captionsTextTrack1LanguageCode = "en", Ar.captionsTextTrack2Label = "Spanish", Ar.captionsTextTrack2LanguageCode = "es", Ar.audioStreamController = Fp, Ar.audioTrackController = aa;
          var xu = /* @__PURE__ */ function() {
            function E(s, o) {
              for (var n = 0; n < o.length; n++) {
                var l = o[n];
                l.enumerable = l.enumerable || !1, l.configurable = !0, "value" in l && (l.writable = !0), Object.defineProperty(s, l.key, l);
              }
            }
            return function(s, o, n) {
              return o && E(s.prototype, o), n && E(s, n), s;
            };
          }();
          function wh(E, s) {
            if (!(E instanceof s))
              throw new TypeError("Cannot call a class as a function");
          }
          var Sh = function() {
            E.isSupported = function() {
              var o = Nr(), n = window.SourceBuffer || window.WebKitSourceBuffer, l = o && typeof o.isTypeSupported == "function" && o.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"'), c = !n || n.prototype && typeof n.prototype.appendBuffer == "function" && typeof n.prototype.remove == "function";
              return l && c;
            }, xu(E, null, [{
              key: "version",
              get: function() {
                return "0.8.5";
              }
            }, {
              key: "Events",
              get: function() {
                return h.a;
              }
            }, {
              key: "ErrorTypes",
              get: function() {
                return m.b;
              }
            }, {
              key: "ErrorDetails",
              get: function() {
                return m.a;
              }
            }, {
              key: "DefaultConfig",
              get: function() {
                return E.defaultConfig ? E.defaultConfig : Ar;
              },
              set: function(o) {
                E.defaultConfig = o;
              }
            }]);
            function E() {
              var s = this, o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              wh(this, E);
              var n = E.DefaultConfig;
              if ((o.liveSyncDurationCount || o.liveMaxLatencyDurationCount) && (o.liveSyncDuration || o.liveMaxLatencyDuration))
                throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
              for (var l in n)
                l in o || (o[l] = n[l]);
              if (o.liveMaxLatencyDurationCount !== void 0 && o.liveMaxLatencyDurationCount <= o.liveSyncDurationCount)
                throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');
              if (o.liveMaxLatencyDuration !== void 0 && (o.liveMaxLatencyDuration <= o.liveSyncDuration || o.liveSyncDuration === void 0))
                throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');
              Object(d.a)(o.debug), this.config = o, this._autoLevelCapping = -1;
              var c = this.observer = new mr.a();
              c.trigger = function(gt) {
                for (var Ce = arguments.length, $t = Array(Ce > 1 ? Ce - 1 : 0), bt = 1; bt < Ce; bt++)
                  $t[bt - 1] = arguments[bt];
                c.emit.apply(c, [gt, gt].concat($t));
              }, c.off = function(gt) {
                for (var Ce = arguments.length, $t = Array(Ce > 1 ? Ce - 1 : 0), bt = 1; bt < Ce; bt++)
                  $t[bt - 1] = arguments[bt];
                c.removeListener.apply(c, [gt].concat($t));
              }, this.on = c.on.bind(c), this.off = c.off.bind(c), this.trigger = c.trigger.bind(c);
              var g = this.abrController = new o.abrController(this), w = new o.bufferController(this), A = new o.capLevelController(this), D = new o.fpsController(this), K = new pt(this), j = new Yt(this), q = new It(this), Y = new cr(this), ue = this.levelController = new _t(this), me = this.streamController = new tt(this), Re = [ue, me], be = o.audioStreamController;
              be && Re.push(new be(this)), this.networkControllers = Re;
              var Pe = [K, j, q, g, w, A, D, Y];
              if (be = o.audioTrackController, be) {
                var ke = new be(this);
                this.audioTrackController = ke, Pe.push(ke);
              }
              if (be = o.subtitleTrackController, be) {
                var Ke = new be(this);
                this.subtitleTrackController = Ke, Pe.push(Ke);
              }
              [o.subtitleStreamController, o.timelineController].forEach(function(mt) {
                mt && Pe.push(new mt(s));
              }), this.coreComponents = Pe;
            }
            return E.prototype.destroy = function() {
              d.b.log("destroy"), this.trigger(h.a.DESTROYING), this.detachMedia(), this.coreComponents.concat(this.networkControllers).forEach(function(o) {
                o.destroy();
              }), this.url = null, this.observer.removeAllListeners(), this._autoLevelCapping = -1;
            }, E.prototype.attachMedia = function(o) {
              d.b.log("attachMedia"), this.media = o, this.trigger(h.a.MEDIA_ATTACHING, { media: o });
            }, E.prototype.detachMedia = function() {
              d.b.log("detachMedia"), this.trigger(h.a.MEDIA_DETACHING), this.media = null;
            }, E.prototype.loadSource = function(o) {
              o = p.a.buildAbsoluteURL(window.location.href, o, { alwaysNormalize: !0 }), d.b.log("loadSource:" + o), this.url = o, this.trigger(h.a.MANIFEST_LOADING, { url: o });
            }, E.prototype.startLoad = function() {
              var o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
              d.b.log("startLoad(" + o + ")"), this.networkControllers.forEach(function(n) {
                n.startLoad(o);
              });
            }, E.prototype.stopLoad = function() {
              d.b.log("stopLoad"), this.networkControllers.forEach(function(o) {
                o.stopLoad();
              });
            }, E.prototype.swapAudioCodec = function() {
              d.b.log("swapAudioCodec"), this.streamController.swapAudioCodec();
            }, E.prototype.recoverMediaError = function() {
              d.b.log("recoverMediaError");
              var o = this.media;
              this.detachMedia(), this.attachMedia(o);
            }, xu(E, [{
              key: "levels",
              get: function() {
                return this.levelController.levels;
              }
              /** Return current playback quality level **/
            }, {
              key: "currentLevel",
              get: function() {
                return this.streamController.currentLevel;
              },
              set: function(o) {
                d.b.log("set currentLevel:" + o), this.loadLevel = o, this.streamController.immediateLevelSwitch();
              }
              /** Return next playback quality level (quality level of next fragment) **/
            }, {
              key: "nextLevel",
              get: function() {
                return this.streamController.nextLevel;
              },
              set: function(o) {
                d.b.log("set nextLevel:" + o), this.levelController.manualLevel = o, this.streamController.nextLevelSwitch();
              }
              /** Return the quality level of current/last loaded fragment **/
            }, {
              key: "loadLevel",
              get: function() {
                return this.levelController.level;
              },
              set: function(o) {
                d.b.log("set loadLevel:" + o), this.levelController.manualLevel = o;
              }
              /** Return the quality level of next loaded fragment **/
            }, {
              key: "nextLoadLevel",
              get: function() {
                return this.levelController.nextLoadLevel;
              },
              set: function(o) {
                this.levelController.nextLoadLevel = o;
              }
              /** Return first level (index of first level referenced in manifest)
              **/
            }, {
              key: "firstLevel",
              get: function() {
                return Math.max(this.levelController.firstLevel, this.minAutoLevel);
              },
              set: function(o) {
                d.b.log("set firstLevel:" + o), this.levelController.firstLevel = o;
              }
              /** Return start level (level of first fragment that will be played back)
                  if not overrided by user, first level appearing in manifest will be used as start level
                  if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
              **/
            }, {
              key: "startLevel",
              get: function() {
                return this.levelController.startLevel;
              },
              set: function(o) {
                d.b.log("set startLevel:" + o);
                var n = this;
                o !== -1 && (o = Math.max(o, n.minAutoLevel)), n.levelController.startLevel = o;
              }
              /** Return the capping/max level value that could be used by automatic level selection algorithm **/
            }, {
              key: "autoLevelCapping",
              get: function() {
                return this._autoLevelCapping;
              },
              set: function(o) {
                d.b.log("set autoLevelCapping:" + o), this._autoLevelCapping = o;
              }
              /* check if we are in automatic level selection mode */
            }, {
              key: "autoLevelEnabled",
              get: function() {
                return this.levelController.manualLevel === -1;
              }
              /* return manual level */
            }, {
              key: "manualLevel",
              get: function() {
                return this.levelController.manualLevel;
              }
              /* return min level selectable in auto mode according to config.minAutoBitrate */
            }, {
              key: "minAutoLevel",
              get: function() {
                for (var o = this, n = o.levels, l = o.config.minAutoBitrate, c = n ? n.length : 0, g = 0; g < c; g++) {
                  var w = n[g].realBitrate ? Math.max(n[g].realBitrate, n[g].bitrate) : n[g].bitrate;
                  if (w > l)
                    return g;
                }
                return 0;
              }
              /* return max level selectable in auto mode according to autoLevelCapping */
            }, {
              key: "maxAutoLevel",
              get: function() {
                var o = this, n = o.levels, l = o.autoLevelCapping, c = void 0;
                return l === -1 && n && n.length ? c = n.length - 1 : c = l, c;
              }
              // return next auto level
            }, {
              key: "nextAutoLevel",
              get: function() {
                var o = this;
                return Math.min(Math.max(o.abrController.nextAutoLevel, o.minAutoLevel), o.maxAutoLevel);
              },
              set: function(o) {
                var n = this;
                n.abrController.nextAutoLevel = Math.max(n.minAutoLevel, o);
              }
              /** get alternate audio tracks list from playlist **/
            }, {
              key: "audioTracks",
              get: function() {
                var o = this.audioTrackController;
                return o ? o.audioTracks : [];
              }
              /** get index of the selected audio track (index in audio track lists) **/
            }, {
              key: "audioTrack",
              get: function() {
                var o = this.audioTrackController;
                return o ? o.audioTrack : -1;
              },
              set: function(o) {
                var n = this.audioTrackController;
                n && (n.audioTrack = o);
              }
            }, {
              key: "liveSyncPosition",
              get: function() {
                return this.streamController.liveSyncPosition;
              }
              /** get alternate subtitle tracks list from playlist **/
            }, {
              key: "subtitleTracks",
              get: function() {
                var o = this.subtitleTrackController;
                return o ? o.subtitleTracks : [];
              }
              /** get index of the selected subtitle track (index in subtitle track lists) **/
            }, {
              key: "subtitleTrack",
              get: function() {
                var o = this.subtitleTrackController;
                return o ? o.subtitleTrack : -1;
              },
              set: function(o) {
                var n = this.subtitleTrackController;
                n && (n.subtitleTrack = o);
              }
            }, {
              key: "subtitleDisplay",
              get: function() {
                var o = this.subtitleTrackController;
                return o ? o.subtitleDisplay : !1;
              },
              set: function(o) {
                var n = this.subtitleTrackController;
                n && (n.subtitleDisplay = o);
              }
            }]), E;
          }();
          a.default = Sh;
        },
        /* 9 */
        /***/
        function(r, a, u) {
          function x(m) {
            var d = {};
            function T(B) {
              if (d[B])
                return d[B].exports;
              var I = d[B] = {
                /******/
                i: B,
                /******/
                l: !1,
                /******/
                exports: {}
                /******/
              };
              return m[B].call(I.exports, I, I.exports, T), I.l = !0, I.exports;
            }
            T.m = m, T.c = d, T.i = function(B) {
              return B;
            }, T.d = function(B, I, O) {
              T.o(B, I) || Object.defineProperty(B, I, {
                /******/
                configurable: !1,
                /******/
                enumerable: !0,
                /******/
                get: O
                /******/
              });
            }, T.n = function(B) {
              var I = B && B.__esModule ? (
                /******/
                function() {
                  return B.default;
                }
              ) : (
                /******/
                function() {
                  return B;
                }
              );
              return T.d(I, "a", I), I;
            }, T.o = function(B, I) {
              return Object.prototype.hasOwnProperty.call(B, I);
            }, T.p = "/", T.oe = function(B) {
              throw console.error(B), B;
            };
            var S = T(T.s = ENTRY_MODULE);
            return S.default || S;
          }
          function y(m) {
            return (m + "").replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
          }
          function p(h) {
            var d = [], T = h.toString(), S = T.match(/^function\s?\(\w+,\s*\w+,\s*(\w+)\)/);
            if (!S) return d;
            for (var B = S[1], I = new RegExp("(\\\\n|\\W)" + y(B) + "\\((/\\*.*?\\*/)?s?.*?([\\.|\\-|\\w|/|@]+).*?\\)", "g"), O; O = I.exec(T); )
              d.push(O[3]);
            return d;
          }
          function m(h, d) {
            for (var T = [d], S = [], B = {}; T.length; ) {
              var I = T.pop();
              if (!(B[I] || !h[I])) {
                B[I] = !0, S.push(I);
                var O = p(h[I]);
                T = T.concat(O);
              }
            }
            return S;
          }
          r.exports = function(m, d) {
            d = d || {};
            var T = u.m, S = d.all ? Object.keys(T) : m(T, h), B = "(" + x.toString().replace("ENTRY_MODULE", JSON.stringify(h)) + ")({" + S.map(function(z) {
              return "" + JSON.stringify(z) + ": " + T[z].toString();
            }).join(",") + "})(self);", I = new window.Blob([B], { type: "text/javascript" });
            if (d.bare)
              return I;
            var O = window.URL || window.webkitURL || window.mozURL || window.msURL, j = O.createObjectURL(I), $ = new window.Worker(j);
            return $.objectURL = j, $;
          };
        },
        /* 10 */
        /***/
        function(r, a, u) {
          Object.defineProperty(a, "__esModule", { value: !0 });
          var x = u(7), y = u(1), p = u(0), m = u(5), h = u.n(m), d = function(S) {
            var B = new h.a();
            B.trigger = function(F) {
              for (var V = arguments.length, z = Array(V > 1 ? V - 1 : 0), J = 1; J < V; J++)
                z[J - 1] = arguments[J];
              B.emit.apply(B, [F, F].concat(z));
            }, B.off = function(F) {
              for (var V = arguments.length, z = Array(V > 1 ? V - 1 : 0), J = 1; J < V; J++)
                z[J - 1] = arguments[J];
              B.removeListener.apply(B, [F].concat(z));
            };
            var I = function(F, V) {
              S.postMessage({ event: F, data: V });
            };
            S.addEventListener("message", function(O) {
              var F = O.data;
              switch (F.cmd) {
                case "init":
                  var V = JSON.parse(F.config);
                  S.demuxer = new x.a(B, F.typeSupported, V, F.vendor);
                  try {
                    Object(p.a)($.debug === !0);
                  } catch {
                    console.warn("demuxerWorker: unable to enable logs");
                  }
                  I("init", null);
                  break;
                case "demux":
                  S.demuxer.push(F.data, F.decryptdata, F.initSegment, F.audioCodec, F.videoCodec, F.timeOffset, F.discontinuity, F.trackSwitch, F.contiguous, F.duration, F.accurateTimeOffset, F.defaultInitPTS);
                  break;
              }
            }), B.on(y.a.FRAG_DECRYPTED, I), B.on(y.a.FRAG_PARSING_INIT_SEGMENT, I), B.on(y.a.FRAG_PARSED, I), B.on(y.a.ERROR, I), B.on(y.a.FRAG_PARSING_METADATA, I), B.on(y.a.FRAG_PARSING_USERDATA, I), B.on(y.a.INIT_PTS_FOUND, I), B.on(y.a.FRAG_PARSING_DATA, function(O, F) {
              var V = [], z = { event: O, data: F };
              F.data1 && (z.data1 = F.data1.buffer, V.push(F.data1.buffer), delete F.data1), F.data2 && (z.data2 = F.data2.buffer, V.push(F.data2.buffer), delete F.data2), S.postMessage(z, V);
            });
          };
          a.default = d;
        }
        /******/
      ]).default
    );
  });
})(Ip);
var LC = Ip.exports;
const Cl = /* @__PURE__ */ r0(LC), Up = ({
  post: t,
  reason: e,
  isRoot: r
}) => {
  if (t.$type === "app.bsky.graph.defs#listView")
    return {
      username: t.creator.displayName,
      handle: t.creator.handle,
      avatar: t.creator.avatar,
      text: [{
        val: t.description,
        setInnerHtml: !1
      }],
      createdAt: t.indexedAt,
      uri: t.uri,
      images: [],
      card: null,
      replyPost: null,
      isRepost: !1,
      repostBy: null
    };
  const a = t.record.facets || [], u = t.record.text, x = new Ml.RichText({
    text: u,
    facets: a
  }), y = [];
  for (const d of x.segments())
    d.isLink() ? y.push({
      val: `<a href="${d.link?.uri}" target="_blank" rel="noopener" class="text-blue-500 underline">${d.text}</a>`,
      setInnerHtml: !0
    }) : d.isMention() ? y.push({
      val: `<a href="https://bsky.app/profile/${d.mention?.did}" target="_blank" rel="noopener" class="text-blue-500 underline">${d.text}</a>`,
      setInnerHtml: !0
    }) : d.isTag() ? y.push({
      val: `<a href="https://bsky.app/hashtag/${d.tag?.tag}" target="_blank" rel="noopener" class="text-blue-500 underline">${d.text}</a>`,
      setInnerHtml: !0
    }) : y.push({
      val: d.text,
      setInnerHtml: !1
    });
  const p = t.embed?.$type === "app.bsky.embed.record#view" ? t.embed.record : t.embed?.record?.record?.$type === "app.bsky.embed.record#viewRecord" && t.embed.record.record, h = p && {
    ...p,
    record: p.value || p.record,
    embed: (p?.embeds || [])[0]
  }, m = t.author || t.creator;
  return {
    username: m.displayName,
    handle: m.handle,
    avatar: m.avatar,
    // todo fallback
    text: y,
    createdAt: t.record.createdAt,
    uri: t.uri,
    images: [...t.embed?.images || [], ...t.embed?.media?.images || [], ...[t.embed?.media?.external].filter(Boolean).map((d) => ({
      ...d,
      alt: d.title,
      thumb: d.uri
    }))],
    video: t.embed?.$type === "app.bsky.embed.video#view" && t.embed,
    card: t.embed?.$type === "app.bsky.embed.external#view" && t.embed?.external,
    replyPost: r && m && Up({
      post: m,
      reason: {
        $type: "",
        by: {
          displayName: ""
        }
      },
      isRoot: !1
    }),
    isRepost: e?.$type === "app.bsky.feed.defs#reasonRepost",
    repostBy: e?.by?.displayName
  };
}, Dl = (t) => (t.feed || []).map((e) => Up({
  ...e,
  isRoot: !0
})), Lf = (t) => {
  const e = t.lastIndexOf("/");
  return e !== -1 ? t.substring(e + 1) : t;
}, CC = (t) => {
  const e = /* @__PURE__ */ new Date(), r = 60 * 1e3, a = r * 60, u = a * 24, x = u * 30, y = u * 365, p = e.getTime() - t.getTime();
  return p < r ? Math.floor(p / 1e3) + "s" : p < a ? Math.floor(p / r) + "m" : p < u ? Math.floor(p / a) + "h" : p < x ? Math.floor(p / u) + "d" : p < y ? Math.floor(p / x) + " mo" : Math.floor(p / y) + " yr";
}, DC = async (t, e) => {
  if (!("IntersectionObserver" in window)) {
    console.error("IntersectionObserver not supported");
    return;
  }
  if (!e) {
    console.error("Video element not found");
    return;
  }
  const r = {
    root: null,
    // Viewport is the root by default
    threshold: 0.5
    // 50% of the video must be visible to trigger playback
  }, a = async (x, y) => {
    x.forEach((p) => {
      if (p.isIntersecting) {
        if (Cl.isSupported()) {
          var h = new Cl();
          h.loadSource(t.playlist), h.attachMedia(e), h.on(Cl.Events.MANIFEST_PARSED, () => {
            e.play();
          });
        } else e.canPlayType("application/vnd.apple.mpegurl") && (e.src = t.playlist, e.addEventListener("loadedmetadata", () => {
          e.play();
        }));
        y.unobserve(e);
      }
    });
  };
  new IntersectionObserver(a, r).observe(e);
};
var kC = /* @__PURE__ */ ur('<article class="p-4 border-b border-slate-300 dark:border-slate-800"><div class="flex gap-2"><div class=w-full><div class="flex max-w-[calc(100vw-96px)] items-center"><a class="text-ellipsis overflow-hidden whitespace-nowrap hover:underline dark:text-white"><span class="font-bold dark:text-white"></span><span> </span><span class="text-slate-500 dark:text-slate-400 text-sm">@</span></a><span class="text-slate-500 dark:text-slate-400 text-sm"><span class=mx-1></span><a class=hover:underline></a></span></div><p class="whitespace-pre-wrap dark:text-white">'), PC = /* @__PURE__ */ ur('<p class="flex gap-1 items-center ml-10 text-slate-600 dark:text-slate-400"><svg viewBox="0 0 576 512"height=16 width=16 tabindex=-1 class=mr-1><path fill=currentColor d="M272 416c17.7 0 32-14.3 32-32s-14.3-32-32-32H160c-17.7 0-32-14.3-32-32V192h32c12.9 0 24.6-7.8 29.6-19.8s2.2-25.7-6.9-34.9l-64-64c-12.5-12.5-32.8-12.5-45.3 0l-64 64c-9.2 9.2-11.9 22.9-6.9 34.9s16.6 19.8 29.6 19.8l32 0 0 128c0 53 43 96 96 96H272zM304 96c-17.7 0-32 14.3-32 32s14.3 32 32 32l112 0c17.7 0 32 14.3 32 32l0 128H416c-12.9 0-24.6 7.8-29.6 19.8s-2.2 25.7 6.9 34.9l64 64c12.5 12.5 32.8 12.5 45.3 0l64-64c9.2-9.2 11.9-22.9 6.9-34.9s-16.6-19.8-29.6-19.8l-32 0V192c0-53-43-96-96-96L304 96z"></path></svg><span class="text-sm text-slate-500 font-semibold">Reposted by '), BC = /* @__PURE__ */ ur('<img alt="profile picture"class="w-14 h-14 rounded-full">'), IC = /* @__PURE__ */ ur('<img alt="profile picture"class="w-4 h-4 mr-1 rounded-full">'), Cf = /* @__PURE__ */ ur("<span>"), UC = /* @__PURE__ */ ur("<div>"), OC = /* @__PURE__ */ ur("<a><img class=rounded-md>"), KC = /* @__PURE__ */ ur('<div class="mt-4 w-full"><video width=100% class="rounded-md w-full h-full object-cover"preload=none>'), NC = /* @__PURE__ */ ur('<a target=_blank rel=noopener class="mt-4 rounded-md border border-slate-300 block"><div class=p-3><p class="text-slate-500 dark:text-slate-400 text-sm"></p><p class="font-bold dark:text-white mb-1"></p><p class="whitespace-pre-wrap dark:text-white">'), VC = /* @__PURE__ */ ur('<img class=rounded-t-md alt="Post Thumbnail">'), MC = /* @__PURE__ */ ur('<a target=_blank rel=noopener class="mt-4 rounded-md border border-slate-300 block">');
const Op = ({
  linkTarget: t = "_self",
  post: e,
  handleModalContent: r,
  isCard: a = !1,
  dateFormat: u
}) => {
  let u;
  return jh(() => {
    e.video && e.video.cid && DC(e.video, u);
  }), (() => {
    var x = kC(), y = x.firstChild, p = y.firstChild, m = p.firstChild, h = m.firstChild, d = h.firstChild, T = d.nextSibling, S = T.nextSibling;
    S.firstChild;
    var B = h.nextSibling, I = B.firstChild, O = I.nextSibling, F = m.nextSibling;
    return yt(x, (() => {
      var V = Yr(() => !!e.isRepost);
      return () => V() && (() => {
        var z = PC(), J = z.firstChild, ie = J.nextSibling;
        return ie.firstChild, yt(ie, () => e.repostBy, null), z;
      })();
    })(), y), yt(y, !a && (() => {
      var V = BC();
      return wr(() => Gt(V, "src", e.avatar)), V;
    })(), p), yt(m, a && (() => {
      var V = IC();
      return wr(() => Gt(V, "src", e.avatar)), V;
    })(), h), Gt(h, "target", t), Gt(h, "rel", t === "_blank" ? "noopeener" : ""), yt(d, () => e.username), yt(S, () => e.handle, null), Gt(O, "target", t), Gt(O, "rel", t === "_blank" ? "noopeener" : ""), yt(O, () => CC(new Date(e.createdAt))), yt(F, () => e.text.map((V) => V.setInnerHtml ? (() => {
      var z = Cf();
      return wr(() => z.innerHTML = V.val), z;
    })() : (() => {
      var z = Cf();
      return yt(z, () => V.val), z;
    })())), yt(p, (() => {
      var V = Yr(() => e.images.length > 0);
      return () => V() && (() => {
        var z = UC();
        return yt(z, () => e.images.map((J) => (() => {
          var ie = OC(), ye = ie.firstChild;
          return ie.$$click = (ve) => r(ve, J), Gt(ie, "target", t), Gt(ie, "rel", t === "_blank" ? "noopeener" : ""), wr((ve) => {
            var Ae = `https://bsky.app/profile/${e.handle}/post/${Lf(e.uri)}`, Ee = J.thumb, Ce = J.alt;
            return Ae !== ve.e && Gt(ie, "href", ve.e = Ae), Ee !== ve.t && Gt(ye, "src", ve.t = Ee), Ce !== ve.a && Gt(ye, "alt", ve.a = Ce), ve;
          }, {
            e: void 0,
            t: void 0,
            a: void 0
          }), ie;
        })())), wr(() => $f(z, e.images.length > 1 ? "mt-4 grid grid-cols-2 gap-2" : "mt-4")), z;
      })();
    })(), null), yt(p, (() => {
      var V = Yr(() => !!e.video);
      return () => V() && (() => {
        var z = KC(), J = z.firstChild, ie = u;
        return typeof ie == "function" ? Pl(ie, J) : u = J, J.autoplay = !1, J.controls = !0, J.muted = !0, wr(() => Gt(J, "poster", e.video.thumbnail)), z;
      })();
    })(), null), yt(p, (() => {
      var V = Yr(() => !!e.card);
      return () => V() && (() => {
        var z = NC(), J = z.firstChild, ie = J.firstChild, ye = ie.nextSibling, ve = ye.nextSibling;
        return yt(z, (() => {
          var Ae = Yr(() => !!e.card.thumb);
          return () => Ae() && (() => {
            var Ee = VC();
            return wr(() => Gt(Ee, "src", e.card.thumb)), Ee;
          })();
        })(), J), yt(ie, () => new URL(e.card.uri).hostname), yt(ye, () => e.card.title), yt(ve, () => e.card.description), wr(() => Gt(z, "href", e.card.uri)), z;
      })();
    })(), null), yt(p, (() => {
      var V = Yr(() => !!e.replyPost);
      return () => V() && (() => {
        var z = MC();
        return yt(z, jf(Op, Hh({
          linkTarget: t,
          handleModalContent: r
        }, {
          get post() {
            return e.replyPost;
          },
          isCard: !0
        }))), wr(() => Gt(Y, "href", e.card.uri)), Y;
      })();
    })(), null), wr((z) => {
      var Y = `https://bsky.app/profile/${e.handle}`, ie = `https://bsky.app/profile/${e.handle}/post/${Lf(e.uri)}`;
      return Y !== z.e && Gt(d, "href", z.e = Y), ie !== z.t && Gt(j, "href", z.t = ie), z;
    }, {
      e: void 0,
      t: void 0
    }), y;
  })();
};
Ff(["click"]);
var jC = /* @__PURE__ */ ur('<section><dialog class="backdrop:bg-gray-800 backdrop:opacity-90"><form class="fixed top-5 right-5"><button type=submit aria-label=close formmethod=dialog formnovalidate class="bg-gray-900 rounded-full w-10 h-10 text-white flex items-center justify-center">X</button></form><img src=""alt=""class=max-h-[90vh]>'), Df = /* @__PURE__ */ ur("<style>"), FC = /* @__PURE__ */ ur("<div class=w-full>"), $C = /* @__PURE__ */ ur('<article class="w-full flex gap-2 p-4 border-b border-slate-300 dark:border-slate-800 animate-pulse"><div class="bg-slate-200 w-14 h-14 rounded-full dark:bg-slate-800"></div><div class="flex-1 space-y-2 py-1"><div class="grid grid-cols-4 gap-4"><div class="h-2 bg-slate-200 rounded col-span-2 dark:bg-slate-800"></div></div><div class="h-2 bg-slate-200 rounded dark:bg-slate-800"></div><div class="h-2 bg-slate-200 rounded dark:bg-slate-800"></div><div class="h-2 bg-slate-200 rounded dark:bg-slate-800">'), GC = /* @__PURE__ */ ur('<div class="mt-8 mb-16"><button id=bsky-load-more class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Load More Posts');
const qC = ({
  username: t,
  feed: e,
  limit: r = 10,
  mode: a = "",
  linkTarget: u = "_self",
  linkImage: x = !1,
  customStyles: y = "",
  disableStyles: p = !1,
  search: m,
  loadMore: h = !1
}) => {
  let d = null, T = null;
  const [S, B] = pa(!1), [I, O] = pa([]), [F] = pa(r), [V, z] = pa(void 0);
  Uf(() => {
    B(!0), J();
  }, [t, e, m, F]);
  const J = async (Ae) => {
    t ? Ll.app.bsky.feed.getAuthorFeed({
      limit: F(),
      actor: t,
      filter: "posts_no_replies",
      cursor: Ae
    }).then(({
      success: Ee,
      data: Ce
    }) => {
      if (Ee) {
        const Ve = Dl(Ce);
        ve(Ve), B(!1), z(Ce.cursor);
      }
    }) : e ? Ll.app.bsky.feed.getFeed({
      limit: F(),
      feed: e,
      cursor: Ae
    }).then(({
      success: Ee,
      data: Ce
    }) => {
      if (Ee) {
        const Ve = Dl(Ce);
        ve(Ve), B(!1), z(Ce.cursor);
      }
    }) : m && Ll.app.bsky.feed.searchPosts({
      limit: F(),
      q: m,
      cursor: Ae
    }).then(({
      success: Ee,
      data: Ce
    }) => {
      if (Ee) {
        const Ve = {
          ...Ce,
          feed: Ce.posts.map((He) => ({
            post: He
          }))
        }, Ue = Dl(Ve);
        ve(Ue), B(!1), z(Ce.cursor);
      }
    });
  }, ie = (Ae, Ee) => {
    !x && d && T && (Ae.preventDefault(), T.src = Ee.fullsize, T.alt = Ee.alt, d.showModal());
  }, ye = () => {
    B(!0), J(V());
  }, ve = (Ae) => {
    const Ee = [...I(), ...Ae];
    O(Ee);
  };
  return [!p && (() => {
    var Ae = Df();
    return yt(Ae, t0), Ae;
  })(), y && (() => {
    var Ae = Df();
    return yt(Ae, y), Ae;
  })(), (() => {
    var Ae = jC(), Ee = Ae.firstChild, Ce = Ee.firstChild, Ve = Ce.nextSibling;
    return $f(Ae, `${a} max-w-screen-sm mx-auto flex flex-col items-center`), yt(Ae, (() => {
      var Ue = Yr(() => I().length > 0);
      return () => Ue() && I().map((He, dt) => (() => {
        var Je = FC();
        return Gt(Je, "id", `post-${dt}`), yt(Je, jf(Op, {
          post: He,
          handleModalContent: ie,
          linkTarget: u
        })), Je;
      })());
    })(), Ee), yt(Ae, (() => {
      var Ue = Yr(() => !!S());
      return () => Ue() && Array.from(Array(r)).map(() => $C());
    })(), Ee), Pl((Ue) => d = Ue, Ee), Pl((Ue) => T = Ue, Ve), yt(Ae, (() => {
      var Ue = Yr(() => !!(h && V()));
      return () => Ue() && (() => {
        var He = GC(), dt = He.firstChild;
        return dt.$$click = ye, He;
      })();
    })(), null), Ae;
  })()];
};
Ff(["click"]);
e0("bsky-embed", {
  username: "",
  feed: "",
  limit: 10,
  mode: "",
  linkTarget: "_self",
  linkImage: !1,
  customStyles: "",
  disableStyles: !1,
  search: "",
  loadMore: !1,
  dateFormat: {}
}, qC);
